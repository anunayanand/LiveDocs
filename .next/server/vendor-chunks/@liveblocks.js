"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   addReaction: () => (/* binding */ addReaction),\n/* harmony export */   applyOptimisticUpdates: () => (/* binding */ applyOptimisticUpdates),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   deleteComment: () => (/* binding */ deleteComment),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   removeReaction: () => (/* binding */ removeReaction),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   upsertComment: () => (/* binding */ upsertComment),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.3.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function clear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    clear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options.size ?? DEFAULT_SIZE;\n    this.delay = options.delay;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.input) === stringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(callback, options) {\n  const batch = new Batch(callback, options);\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    cache.set(cacheKey, state);\n    eventSource2.notify();\n  }\n  async function get(input) {\n    const cacheKey = getCacheKey(input);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(input);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(input) {\n    const cacheKey = getCacheKey(input);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2.observable,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const newState = callback(state);\n    if (state === newState) {\n      return;\n    }\n    state = newState;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    callback(state);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    subscribe\n  };\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url.toString();\n}\n\n// src/notifications.ts\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url = urljoin(baseUrl, `/v2/c${endpoint}`, params);\n    const response = await fetcher(url.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const json = await fetchJson(\"/inbox-notifications\", void 0, {\n      limit: options?.limit,\n      since: options?.since?.toISOString()\n    });\n    return {\n      threads: json.threads.map((thread) => convertToThreadData(thread)),\n      inboxNotifications: json.inboxNotifications.map(\n        (notification) => convertToInboxNotificationData(notification)\n      ),\n      deletedThreads: json.deletedThreads.map(\n        (info) => convertToThreadDeleteInfo(info)\n      ),\n      deletedInboxNotifications: json.deletedInboxNotifications.map(\n        (info) => convertToInboxNotificationDeleteInfo(info)\n      ),\n      meta: {\n        requestedAt: new Date(json.meta.requestedAt)\n      }\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(\"/inbox-notifications/count\");\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await fetchJson(\"/inbox-notifications\", {\n      method: \"DELETE\"\n    });\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await fetchJson(\n      `/inbox-notifications/${encodeURIComponent(inboxNotificationId)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n  const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n  const len = alphabet.length;\n  return Array.from(\n    { length },\n    () => alphabet.charAt(Math.floor(Math.random() * len))\n  ).join(\"\");\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isValueWithOperator(value)) {\n      keyValuePairsWithOperator.push([key, value]);\n    } else if (typeof value === \"object\" && !(\"startsWith\" in value)) {\n      indexedKeys.push([key, value]);\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isValueWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(\n    ({ key, operator, value }) => formatFilter(key, operator, formatFilterValue(value))\n  ).join(\" AND \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  return false;\n};\nvar isValueWithOperator = (value) => {\n  if (typeof value === \"object\" && value !== null && \"startsWith\" in value) {\n    return true;\n  }\n  return false;\n};\nvar formatFilter = (key, operator, value) => {\n  return `${key}${operator}${value}`;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${JSON.stringify(nestedKey)}]`;\n  }\n  return key;\n};\nvar formatFilterValue = (value) => {\n  if (typeof value === \"string\") {\n    if (isStringEmpty(value)) {\n      throw new Error(\"Value cannot be empty\");\n    }\n    return JSON.stringify(value);\n  }\n  return value.toString();\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createCommentsApi(roomId, getAuthValue, fetchClientApi) {\n  async function fetchCommentsApi(endpoint, params, options) {\n    const authValue = await getAuthValue();\n    return fetchClientApi(roomId, endpoint, authValue, options, params);\n  }\n  async function fetchJson(endpoint, options, params) {\n    const response = await fetchCommentsApi(endpoint, params, options);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreads(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const response = await fetchCommentsApi(\n      \"/threads\",\n      {\n        since: options?.since?.toISOString(),\n        query\n      },\n      {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map((thread) => convertToThreadData(thread)),\n        inboxNotifications: json.inboxNotifications.map(\n          (notification) => convertToInboxNotificationData(notification)\n        ),\n        deletedThreads: json.deletedThreads.map(\n          (info) => convertToThreadDeleteInfo(info)\n        ),\n        deletedInboxNotifications: json.deletedInboxNotifications.map(\n          (info) => convertToInboxNotificationDeleteInfo(info)\n        ),\n        meta: {\n          requestedAt: new Date(json.meta.requestedAt)\n        }\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        meta: {\n          requestedAt: /* @__PURE__ */ new Date()\n        }\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread({ threadId }) {\n    const response = await fetchCommentsApi(\n      `/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return;\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId,\n    threadId\n  }) {\n    const thread = await fetchJson(\"/threads\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        id: threadId,\n        comment: {\n          id: commentId,\n          body\n        },\n        metadata\n      })\n    });\n    return convertToThreadData(thread);\n  }\n  async function deleteThread({ threadId }) {\n    await fetchJson(`/threads/${encodeURIComponent(threadId)}`, {\n      method: \"DELETE\"\n    });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function markThreadAsResolved({ threadId }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/mark-as-resolved`,\n      {\n        method: \"POST\"\n      }\n    );\n  }\n  async function markThreadAsUnresolved({ threadId }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/mark-as-unresolved`,\n      {\n        method: \"POST\"\n      }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment2({\n    threadId,\n    commentId\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function addReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions/${encodeURIComponent(emoji)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getThreads,\n    getThread,\n    createThread,\n    deleteThread,\n    editThreadMetadata,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    createComment,\n    editComment,\n    deleteComment: deleteComment2,\n    addReaction: addReaction2,\n    removeReaction: removeReaction2\n  };\n}\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 = 50;\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getAuthBearerHeaderFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(roomId, endpoint, authValue, options2, params) {\n    const url = urljoin(\n      config.baseUrl,\n      `/v2/c/rooms/${encodeURIComponent(roomId)}${endpoint}`,\n      params\n    );\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(roomId, \"/storage\", authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(config.roomId, endpoint, managedSocket.authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    });\n  }\n  async function createTextMention(userId, mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      config.roomId,\n      \"/text-mentions\",\n      managedSocket.authValue,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          userId,\n          mentionId\n        })\n      }\n    );\n  }\n  async function deleteTextMention(mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      config.roomId,\n      `/text-mentions/${mentionId}`,\n      managedSocket.authValue,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function reportTextEditor(type, rootKey) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(config.roomId, \"/text-metadata\", authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        type,\n        rootKey\n      })\n    });\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = self.current?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storageBatch.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (true) {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 407 /* THREAD_DELETED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 408 /* THREAD_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  function isPresenceReady() {\n    return self.current !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  const commentsApi = createCommentsApi(\n    config.roomId,\n    delegates.authenticate,\n    fetchClientApi\n  );\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(\n      config.roomId,\n      endpoint,\n      authValue,\n      options2\n    );\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getRoomNotificationSettings() {\n    return fetchNotificationsJson(\n      \"/notification-settings\"\n    );\n  }\n  function updateRoomNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      \"/notification-settings\",\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        comments: {\n          ...commentsApi\n        },\n        notifications: {\n          getRoomNotificationSettings,\n          updateRoomNotificationSettings,\n          markInboxNotificationAsRead\n        }\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n\n// src/store.ts\nfunction createClientStore() {\n  const store = createStore({\n    threads: {},\n    queries: {},\n    optimisticUpdates: [],\n    inboxNotifications: {},\n    notificationSettings: {}\n  });\n  const optimisticUpdatesEventSource = makeEventSource();\n  return {\n    ...store,\n    deleteThread(threadId) {\n      store.set((state) => {\n        return {\n          ...state,\n          threads: deleteKeyImmutable(state.threads, threadId),\n          inboxNotifications: Object.fromEntries(\n            Object.entries(state.inboxNotifications).filter(\n              ([_id, notification]) => notification.kind === \"thread\" && notification.threadId === threadId\n            )\n          )\n        };\n      });\n    },\n    updateThreadAndNotification(thread, inboxNotification) {\n      store.set((state) => {\n        const existingThread = state.threads[thread.id];\n        return {\n          ...state,\n          threads: existingThread === void 0 || compareThreads(thread, existingThread) === 1 ? { ...state.threads, [thread.id]: thread } : state.threads,\n          inboxNotifications: inboxNotification === void 0 ? state.inboxNotifications : {\n            ...state.inboxNotifications,\n            [inboxNotification.id]: inboxNotification\n          }\n        };\n      });\n    },\n    updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads, deletedInboxNotifications, queryKey) {\n      store.set((state) => ({\n        ...state,\n        threads: applyThreadUpdates(state.threads, {\n          newThreads: threads,\n          deletedThreads\n        }),\n        inboxNotifications: applyNotificationsUpdates(\n          state.inboxNotifications,\n          {\n            newInboxNotifications: inboxNotifications,\n            deletedNotifications: deletedInboxNotifications\n          }\n        ),\n        queries: queryKey !== void 0 ? {\n          ...state.queries,\n          [queryKey]: { isLoading: false, data: void 0 }\n        } : state.queries\n      }));\n    },\n    updateRoomInboxNotificationSettings(roomId, settings, queryKey) {\n      store.set((state) => ({\n        ...state,\n        notificationSettings: {\n          ...state.notificationSettings,\n          [roomId]: settings\n        },\n        queries: {\n          ...state.queries,\n          [queryKey]: { isLoading: false, data: void 0 }\n        }\n      }));\n    },\n    pushOptimisticUpdate(optimisticUpdate) {\n      optimisticUpdatesEventSource.notify(optimisticUpdate);\n      store.set((state) => ({\n        ...state,\n        optimisticUpdates: [...state.optimisticUpdates, optimisticUpdate]\n      }));\n    },\n    setQueryState(queryKey, queryState) {\n      store.set((state) => ({\n        ...state,\n        queries: {\n          ...state.queries,\n          [queryKey]: queryState\n        }\n      }));\n    },\n    optimisticUpdatesEventSource\n  };\n}\nfunction deleteKeyImmutable(record, key) {\n  if (Object.prototype.hasOwnProperty.call(record, key)) {\n    const { [key]: _toDelete, ...rest } = record;\n    return rest;\n  }\n  return record;\n}\nfunction compareThreads(thread1, thread2) {\n  if (thread1.updatedAt && thread2.updatedAt) {\n    return thread1.updatedAt > thread2.updatedAt ? 1 : thread1.updatedAt < thread2.updatedAt ? -1 : 0;\n  } else if (thread1.updatedAt || thread2.updatedAt) {\n    return thread1.updatedAt ? 1 : -1;\n  }\n  if (thread1.createdAt > thread2.createdAt) {\n    return 1;\n  } else if (thread1.createdAt < thread2.createdAt) {\n    return -1;\n  }\n  return 0;\n}\nfunction applyOptimisticUpdates(state) {\n  const result = {\n    threads: {\n      ...state.threads\n    },\n    inboxNotifications: {\n      ...state.inboxNotifications\n    },\n    notificationSettings: {\n      ...state.notificationSettings\n    }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        result.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        };\n        break;\n      }\n      case \"mark-thread-as-resolved\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          resolved: true\n        };\n        break;\n      }\n      case \"mark-thread-as-unresolved\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          resolved: false\n        };\n        break;\n      }\n      case \"create-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        const inboxNotification = Object.values(result.inboxNotifications).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        result.inboxNotifications[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = deleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[optimisticUpdate.threadId] = {\n          ...result.threads[optimisticUpdate.threadId],\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        };\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = addReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = removeReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        result.inboxNotifications[optimisticUpdate.inboxNotificationId] = {\n          ...state.inboxNotifications[optimisticUpdate.inboxNotificationId],\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in result.inboxNotifications) {\n          result.inboxNotifications[id] = {\n            ...result.inboxNotifications[id],\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        const {\n          [optimisticUpdate.inboxNotificationId]: _,\n          ...inboxNotifications\n        } = result.inboxNotifications;\n        result.inboxNotifications = inboxNotifications;\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        result.inboxNotifications = {};\n        break;\n      }\n      case \"update-notification-settings\": {\n        result.notificationSettings[optimisticUpdate.roomId] = {\n          ...result.notificationSettings[optimisticUpdate.roomId],\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return result;\n}\nfunction applyThreadUpdates(existingThreads, updates) {\n  const updatedThreads = { ...existingThreads };\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n    if (existingThread) {\n      const result = compareThreads(existingThread, thread);\n      if (result === 1) return;\n    }\n    updatedThreads[thread.id] = thread;\n  });\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === void 0) return;\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n  return updatedThreads;\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1) return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction upsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction deleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      body: void 0\n    } : comment\n  );\n  if (!updatedComments.some((comment) => comment.deletedAt === void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n      comments: []\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction addReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction removeReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification\n  } = createNotificationsApi({\n    baseUrl,\n    fetcher: clientOptions.polyfills?.fetch || /* istanbul ignore next */\n    fetch,\n    authManager,\n    currentUserIdStore\n  });\n  const cacheStore = createClientStore();\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const usersStore = createBatchStore(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const roomsInfoStore = createBatchStore(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  return Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Internal\n      [kInternal]: {\n        notifications: {\n          getInboxNotifications,\n          getUnreadInboxNotificationsCount,\n          markAllInboxNotificationsAsRead,\n          markInboxNotificationAsRead,\n          deleteAllInboxNotifications,\n          deleteInboxNotification\n        },\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        cacheStore,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    return \"https://\" + url;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ?? element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n  let context = {\n    state: \"stopped\",\n    timeoutHandle: null,\n    interval: null,\n    lastScheduledAt: null,\n    remainingInterval: null\n  };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule(context.interval);\n    }\n    void callback();\n  }\n  function schedule(interval) {\n    context = {\n      state: \"running\",\n      interval: context.state !== \"stopped\" ? context.interval : interval,\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval),\n      remainingInterval: null\n    };\n  }\n  function scheduleRemaining(remaining) {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    context = {\n      state: \"running\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: setTimeout(poll, remaining),\n      remainingInterval: null\n    };\n  }\n  function start(interval) {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule(interval);\n  }\n  function restart(interval) {\n    stop();\n    start(interval);\n  }\n  function pause() {\n    if (context.state !== \"running\") {\n      return;\n    }\n    clearTimeout(context.timeoutHandle);\n    context = {\n      state: \"paused\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: null,\n      remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n    };\n  }\n  function resume() {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    scheduleRemaining(context.remainingInterval);\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = {\n      state: \"stopped\",\n      interval: null,\n      lastScheduledAt: null,\n      timeoutHandle: null,\n      remainingInterval: null\n    };\n  }\n  return {\n    start,\n    restart,\n    pause,\n    resume,\n    stop\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQixHQUFHLFVBQVU7QUFDeEU7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxxR0FBcUcsa0JBQWtCO0FBQ3ZIO0FBQ0E7QUFDQSxXQUFXLFNBQVMsRUFBRSxVQUFVO0FBQ2hDLFdBQVcsU0FBUyxFQUFFLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHdCQUF3QjtBQUMzRztBQUNBO0FBQ0EsYUFBYSxVQUFVLFFBQVEsWUFBWTtBQUMzQyxhQUFhLFNBQVMsUUFBUSxXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0MscUJBQXFCLFdBQVcsZ0JBQWdCLHVCQUF1QixnQkFBZ0I7QUFDdkg7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssUUFBUSxTQUFTLFVBQVUsY0FBYztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQSwwQ0FBMEMsK0JBQStCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1EQUFtRCw0RkFBNEY7QUFDL0k7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJLGNBQWM7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0JBQXNCLHFFQUFxRSxHQUFHLFlBQVksbUJBQW1CLFNBQVM7QUFDdEk7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCxNQUFNO0FBQ04saURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdFQUFnRSxTQUFTLEtBQUs7QUFDOUU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYyxtQ0FBbUMsU0FBUyxhQUFhO0FBQ3ZIO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQkFBZ0IseUJBQXlCLElBQUksYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVMsR0FBRyxlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQXdEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDRHQUE0RyxhQUFhLFlBQVksZUFBZTtBQUNwSjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQSxvQ0FBb0MsZ0NBQWdDO0FBQ3BFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2Qiw2QkFBNkI7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTSxtQ0FBbUMsbUJBQW1CO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLG1DQUFtQyx1QkFBdUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNLG1DQUFtQyx1QkFBdUI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBcUMsR0FBRyxDQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsYUFBYSxNQUFxQztBQUNsRDtBQUNBLEVBQUUsQ0FBUTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELCtCQUErQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxxQkFBcUIsT0FBTyxHQUFHLEtBQUs7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sc0JBQXNCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJLEdBQUcsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3Q0FBd0M7QUFDeEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxnQ0FBZ0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EseURBQXlELGVBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4Q0FBOEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QixzQkFBc0I7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYyw0Q0FBNEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQixZQUFZO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBNkRFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcz8wNzgxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4zLjBcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL2R1cGUtZGV0ZWN0aW9uLnRzXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge307XG52YXIgY3Jvc3NMaW5rZWREb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvY3Jvc3MtbGlua2VkXCI7XG52YXIgZHVwZXNEb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvZHVwZXNcIjtcbnZhciBTUEFDRSA9IFwiIFwiO1xuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVjdER1cGVzKHBrZ05hbWUsIHBrZ1ZlcnNpb24sIHBrZ0Zvcm1hdCkge1xuICBjb25zdCBwa2dJZCA9IFN5bWJvbC5mb3IocGtnTmFtZSk7XG4gIGNvbnN0IHBrZ0J1aWxkSW5mbyA9IHBrZ0Zvcm1hdCA/IGAke3BrZ1ZlcnNpb24gfHwgXCJkZXZcIn0gKCR7cGtnRm9ybWF0fSlgIDogcGtnVmVyc2lvbiB8fCBcImRldlwiO1xuICBpZiAoIWdbcGtnSWRdKSB7XG4gICAgZ1twa2dJZF0gPSBwa2dCdWlsZEluZm87XG4gIH0gZWxzZSBpZiAoZ1twa2dJZF0gPT09IHBrZ0J1aWxkSW5mbykge1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IFtcbiAgICAgIGBNdWx0aXBsZSBjb3BpZXMgb2YgTGl2ZWJsb2NrcyBhcmUgYmVpbmcgbG9hZGVkIGluIHlvdXIgcHJvamVjdC4gVGhpcyB3aWxsIGNhdXNlIGlzc3VlcyEgU2VlICR7ZHVwZXNEb2NzICsgU1BBQ0V9YCxcbiAgICAgIFwiXCIsXG4gICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgIGAtICR7cGtnTmFtZX0gJHtnW3BrZ0lkXX0gKGFscmVhZHkgbG9hZGVkKWAsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7cGtnQnVpbGRJbmZvfSAodHJ5aW5nIHRvIGxvYWQgdGhpcyBub3cpYFxuICAgIF0uam9pbihcIlxcblwiKTtcbiAgICBlcnJvcihtc2cpO1xuICB9XG4gIGlmIChwa2dWZXJzaW9uICYmIFBLR19WRVJTSU9OICYmIHBrZ1ZlcnNpb24gIT09IFBLR19WRVJTSU9OKSB7XG4gICAgZXJyb3IoXG4gICAgICBbXG4gICAgICAgIGBDcm9zcy1saW5rZWQgdmVyc2lvbnMgb2YgTGl2ZWJsb2NrcyBmb3VuZCwgd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2Nyb3NzTGlua2VkRG9jcyArIFNQQUNFfWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQ29uZmxpY3RzOlwiLFxuICAgICAgICBgLSAke1BLR19OQU1FfSBpcyBhdCAke1BLR19WRVJTSU9OfWAsXG4gICAgICAgIGAtICR7cGtnTmFtZX0gaXMgYXQgJHtwa2dWZXJzaW9ufWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQWx3YXlzIHVwZ3JhZGUgYWxsIExpdmVibG9ja3MgcGFja2FnZXMgdG8gdGhlIHNhbWUgdmVyc2lvbiBudW1iZXIuXCJcbiAgICAgIF0uam9pbihcIlxcblwiKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSwgZXJybXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgZXJybXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICBlcnIubmFtZSA9IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKHZhbHVlLCBlcnJtc2cgPSBcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG5vbi1udWxsYWJsZVwiKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwLCBlcnJtc2cpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9saWIvY29udHJvbGxlZFByb21pc2UudHNcbmZ1bmN0aW9uIGNvbnRyb2xsZWRQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIFtwcm9taXNlLCByZXNvbHZlLCByZWplY3RdO1xufVxuZnVuY3Rpb24gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCkge1xuICBjb25zdCBbcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0XSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vLyBzcmMvbGliL0V2ZW50U291cmNlLnRzXG5mdW5jdGlvbiBtYWtlRXZlbnRTb3VyY2UoKSB7XG4gIGNvbnN0IF9vbmV0aW1lT2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBfYnVmZmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgX2J1ZmZlciA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKF9idWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBfYnVmZmVyKSB7XG4gICAgICBub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgICBfYnVmZmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBfb2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVPbmNlKGNhbGxiYWNrKSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29uZXRpbWVPYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWwocHJlZGljYXRlKSB7XG4gICAgbGV0IHVuc3ViO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB1bnN1YiA9IHN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSA9PT0gdm9pZCAwIHx8IHByZWRpY2F0ZShldmVudCkpIHtcbiAgICAgICAgICByZXMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHVuc3ViPy4oKSk7XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5T3JCdWZmZXIoZXZlbnQpIHtcbiAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgX2J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBfb2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgX29ic2VydmVycy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGNvdW50KCkge1xuICAgIHJldHVybiBfb25ldGltZU9ic2VydmVycy5zaXplICsgX29ic2VydmVycy5zaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUHJpdmF0ZS9pbnRlcm5hbCBjb250cm9sIG92ZXIgZXZlbnQgZW1pc3Npb25cbiAgICBub3RpZnk6IG5vdGlmeU9yQnVmZmVyLFxuICAgIHN1YnNjcmliZSxcbiAgICBzdWJzY3JpYmVPbmNlLFxuICAgIGNsZWFyLFxuICAgIGNvdW50LFxuICAgIHdhaXRVbnRpbCxcbiAgICBwYXVzZSxcbiAgICB1bnBhdXNlLFxuICAgIC8vIFB1YmxpY2x5IGV4cG9zYWJsZSBzdWJzY3JpcHRpb24gQVBJXG4gICAgb2JzZXJ2YWJsZToge1xuICAgICAgc3Vic2NyaWJlLFxuICAgICAgc3Vic2NyaWJlT25jZSxcbiAgICAgIHdhaXRVbnRpbFxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9mYW5jeS1jb25zb2xlLnRzXG52YXIgZmFuY3lfY29uc29sZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChmYW5jeV9jb25zb2xlX2V4cG9ydHMsIHtcbiAgZXJyb3I6ICgpID0+IGVycm9yMixcbiAgZXJyb3JXaXRoVGl0bGU6ICgpID0+IGVycm9yV2l0aFRpdGxlLFxuICB3YXJuOiAoKSA9PiB3YXJuLFxuICB3YXJuV2l0aFRpdGxlOiAoKSA9PiB3YXJuV2l0aFRpdGxlXG59KTtcbnZhciBiYWRnZSA9IFwiYmFja2dyb3VuZDojMGUwZDEyO2JvcmRlci1yYWRpdXM6OTk5OXB4O2NvbG9yOiNmZmY7cGFkZGluZzozcHggN3B4O2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NjAwO1wiO1xudmFyIGJvbGQgPSBcImZvbnQtd2VpZ2h0OjYwMFwiO1xuZnVuY3Rpb24gd3JhcChtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IGNvbnNvbGVbbWV0aG9kXShcIiVjTGl2ZWJsb2Nrc1wiLCBiYWRnZSwgbWVzc2FnZSwgLi4uYXJncylcbiAgKTtcbn1cbnZhciB3YXJuID0gd3JhcChcIndhcm5cIik7XG52YXIgZXJyb3IyID0gd3JhcChcImVycm9yXCIpO1xuZnVuY3Rpb24gd3JhcFdpdGhUaXRsZShtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKHRpdGxlLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXG4gICAgICBgJWNMaXZlYmxvY2tzJWMgJHt0aXRsZX1gLFxuICAgICAgYmFkZ2UsXG4gICAgICBib2xkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIC4uLmFyZ3NcbiAgICApXG4gICk7XG59XG52YXIgd2FybldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJ3YXJuXCIpO1xudmFyIGVycm9yV2l0aFRpdGxlID0gd3JhcFdpdGhUaXRsZShcImVycm9yXCIpO1xuXG4vLyBzcmMvbGliL2ZzbS50c1xuZnVuY3Rpb24gZGlzdGFuY2Uoc3RhdGUxLCBzdGF0ZTIpIHtcbiAgaWYgKHN0YXRlMSA9PT0gc3RhdGUyKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBjb25zdCBjaHVua3MxID0gc3RhdGUxLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgY2h1bmtzMiA9IHN0YXRlMi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IG1pbkxlbiA9IE1hdGgubWluKGNodW5rczEubGVuZ3RoLCBjaHVua3MyLmxlbmd0aCk7XG4gIGxldCBzaGFyZWQgPSAwO1xuICBmb3IgKDsgc2hhcmVkIDwgbWluTGVuOyBzaGFyZWQrKykge1xuICAgIGlmIChjaHVua3MxW3NoYXJlZF0gIT09IGNodW5rczJbc2hhcmVkXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVwID0gY2h1bmtzMS5sZW5ndGggLSBzaGFyZWQ7XG4gIGNvbnN0IGRvd24gPSBjaHVua3MyLmxlbmd0aCAtIHNoYXJlZDtcbiAgcmV0dXJuIFt1cCwgZG93bl07XG59XG5mdW5jdGlvbiBwYXR0ZXJucyh0YXJnZXRTdGF0ZSwgbGV2ZWxzKSB7XG4gIGNvbnN0IHBhcnRzID0gdGFyZ2V0U3RhdGUuc3BsaXQoXCIuXCIpO1xuICBpZiAobGV2ZWxzIDwgMSB8fCBsZXZlbHMgPiBwYXJ0cy5sZW5ndGggKyAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgbGV2ZWxzXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAobGV2ZWxzID4gcGFydHMubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goXCIqXCIpO1xuICB9XG4gIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSBsZXZlbHMgKyAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbGljZSA9IHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5qb2luKFwiLlwiKSArIFwiLipcIik7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKHRhcmdldFN0YXRlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBTYWZlQ29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmN1cnIgPSBpbml0aWFsQ29udGV4dDtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhbGxvd3MgcGF0Y2hpbmcgb2YgdGhlIGNvbnRleHQsIGJ5XG4gICAqIGNhbGxpbmcgYGNvbnRleHQucGF0Y2goKWAuIFBhdGNoaW5nIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIGR1cmF0aW9uXG4gICAqIG9mIHRoaXMgd2luZG93LlxuICAgKi9cbiAgYWxsb3dQYXRjaGluZyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBhbGxvd2VkID0gdHJ1ZTtcbiAgICBjb25zdCBwYXRjaGFibGVDb250ZXh0ID0ge1xuICAgICAgLi4udGhpcy5jdXJyLFxuICAgICAgcGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICBzZWxmLmN1cnIgPSBPYmplY3QuYXNzaWduKHt9LCBzZWxmLmN1cnIsIHBhdGNoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMocGF0Y2gpKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJwYXRjaFwiKSB7XG4gICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm8gbG9uZ2VyIHBhdGNoIHN0YWxlIGNvbnRleHRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNhbGxiYWNrKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgIGFsbG93ZWQgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cbn07XG52YXIgbmV4dElkID0gMTtcbnZhciBGU00gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlLCB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoZSBmaXJzdCBjYWxsIG1hZGUgdG9cbiAgICogLmFkZFN0YXRlKCkuXG4gICAqL1xuICBnZXQgaW5pdGlhbFN0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RhdGVzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGF0ZXMgZGVmaW5lZCB5ZXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgPT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdGFydGVkIHlldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RvcHBlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIG1hY2hpbmUgYnkgZW50ZXJpbmcgdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtYWNoaW5lIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMSAvKiBTVEFSVEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gdGhpcy5pbml0aWFsU3RhdGU7XG4gICAgdGhpcy5lbnRlcihudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHN0YXRlIG1hY2hpbmUuIFN0b3BwaW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHdpbGwgY2FsbCBleGl0XG4gICAqIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgYnV0IG5vdCBlbnRlciBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAxIC8qIFNUQVJURUQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdG9wIGEgc3RhdGUgbWFjaGluZSB0aGF0IGhhc24ndCBzdGFydGVkIHlldFwiKTtcbiAgICB9XG4gICAgdGhpcy5leGl0KG51bGwpO1xuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMiAvKiBTVE9QUEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuaWQgPSBuZXh0SWQrKztcbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDAgLyogTk9UX1NUQVJURURfWUVUICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5lbnRlckZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jbGVhbnVwU3RhY2sgPSBbXTtcbiAgICB0aGlzLmtub3duRXZlbnRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBuZXcgU2FmZUNvbnRleHQoaW5pdGlhbENvbnRleHQpO1xuICAgIHRoaXMuZXZlbnRIdWIgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbFRyYW5zaXRpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRFbnRlclN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKVxuICAgIH07XG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsVHJhbnNpdGlvbjogdGhpcy5ldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5vYnNlcnZhYmxlLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogdGhpcy5ldmVudEh1Yi5kaWRFbnRlclN0YXRlLm9ic2VydmFibGVcbiAgICB9O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbiBleHBsaWNpdCBmaW5pdGUgc3RhdGUgaW4gdGhlIHN0YXRlIG1hY2hpbmUuXG4gICAqL1xuICBhZGRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyKG5hbWVPclBhdHRlcm4sIGVudGVyRm4pIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVudGVyRm5zLmhhcyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPIFdlIF9jdXJyZW50bHlfIGRvbid0IHN1cHBvcnQgbXVsdGlwbGUgLm9uRW50ZXJzKCkgZm9yIHRoZSBzYW1lXG4gICAgICAgIC8vIHN0YXRlLCBidXQgdGhpcyBpcyBub3QgYSBmdW5kYW1lbnRhbCBsaW1pdGF0aW9uLiBKdXN0IG5vdFxuICAgICAgICAvLyBpbXBsZW1lbnRlZCB5ZXQuIElmIHdlIHdhbnRlZCB0bywgd2UgY291bGQgbWFrZSB0aGlzIGFuIGFycmF5LlxuICAgICAgICBgZW50ZXIvZXhpdCBmdW5jdGlvbiBmb3IgJHtuYW1lT3JQYXR0ZXJufSBhbHJlYWR5IGV4aXN0c2BcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW50ZXJGbnMuc2V0KG5hbWVPclBhdHRlcm4sIGVudGVyRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uRW50ZXJBc3luYyhuYW1lT3JQYXR0ZXJuLCBwcm9taXNlRm4sIG9uT0ssIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKG5hbWVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdm9pZCBwcm9taXNlRm4odGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50LCBzaWduYWwpLnRoZW4oXG4gICAgICAgIC8vIE9uIE9LXG4gICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX09LXCIsIGRhdGEgfSwgb25PSyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBPbiBFcnJvclxuICAgICAgICAocmVhc29uKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX0VSUk9SXCIsIHJlYXNvbiB9LCBvbkVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGlmIChuYW1lT3JQYXR0ZXJuID09PSBcIipcIikge1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZU9yUGF0dGVybi5lbmRzV2l0aChcIi4qXCIpKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuYW1lT3JQYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy5zdGF0ZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YXRlcyBtYXRjaCAke0pTT04uc3RyaW5naWZ5KG5hbWVPclBhdHRlcm4pfWApO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFsbCBhbGxvd2VkIG91dGdvaW5nIHRyYW5zaXRpb25zIGZvciBhIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0cyBmb3IgZWFjaCBldmVudCBjYW4gYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gICAqIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by4gVGhlc2UgZnVuY3Rpb25zIGNhbiBsb29rIGF0IHRoZSBgZXZlbnRgIG9yXG4gICAqIGBjb250ZXh0YCBwYXJhbXMgdG8gY29uZGl0aW9uYWxseSBkZWNpZGUgd2hpY2ggbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uXG4gICAqIHRvLlxuICAgKlxuICAgKiBJZiB5b3Ugc2V0IGl0IHRvIGBudWxsYCwgdGhlbiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIGV4cGxpY2l0bHkgZm9yYmlkZGVuXG4gICAqIGFuZCB0aHJvdyBhbiBlcnJvci4gSWYgeW91IGRvbid0IGRlZmluZSBhIHRhcmdldCBmb3IgYSB0cmFuc2l0aW9uLCB0aGVuXG4gICAqIHN1Y2ggZXZlbnRzIHdpbGwgZ2V0IGlnbm9yZWQuXG4gICAqL1xuICBhZGRUcmFuc2l0aW9ucyhuYW1lT3JQYXR0ZXJuLCBtYXBwaW5nKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyY1N0YXRlIG9mIHRoaXMuZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5nZXQoc3JjU3RhdGUpO1xuICAgICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLnNldChzcmNTdGF0ZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHRhcmdldF9dIG9mIE9iamVjdC5lbnRyaWVzKG1hcHBpbmcpKSB7XG4gICAgICAgIGlmIChtYXAuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzZXQgdHJhbnNpdGlvbiBcIiR7dHlwZX1cIiBvbiBcIiR7c3JjU3RhdGV9XCIgKHZpYSBcIiR7bmFtZU9yUGF0dGVybn1cIiksIGJ1dCBhIHRyYW5zaXRpb24gYWxyZWFkeSBleGlzdHMgdGhlcmUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0XztcbiAgICAgICAgdGhpcy5rbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuIFRoZSBzdGF0ZSBuYW1lLCBvciBzdGF0ZSBncm91cCBwYXR0ZXJuIG5hbWUuXG4gICAqIEBwYXJhbSBhZnRlciAgICAgICAgICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRvIHRha2UgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgIGlzIHRha2VuLCB0aGUgdGltZXIgd2lsbCBnZXQgY2FuY2VsbGVkLlxuICAgKiBAcGFyYW0gdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCkgOiBhZnRlcjI7XG4gICAgICBjb25zdCB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJUSU1FUlwiIH0sIHRhcmdldCk7XG4gICAgICB9LCBtcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldCh0aGlzLmN1cnJlbnRTdGF0ZSk/LmdldChldmVudE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGl0cyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuXG4gICAqIENhbGwgdGhpcyBiZWZvcmUgY2hhbmdpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBsZXZlbHMgRGVmaW5lcyBob3cgbWFueSBcImxldmVsc1wiIG9mIG5lc3Rpbmcgd2lsbCBiZVxuICAgKiBleGl0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tIGBmb28uYmFyLnF1eGAgdG9cbiAgICogYGZvby5iYXIuYmF6YCwgdGhlbiB0aGUgbGV2ZWwgaXMgMS4gQnV0IGlmIHlvdSB0cmFuc2l0aW9uIGZyb21cbiAgICogYGZvby5iYXIucXV4YCB0byBgYmxhLmJsYWAsIHRoZW4gdGhlIGxldmVsIGlzIDMuXG4gICAqIElmIGBudWxsYCwgaXQgd2lsbCBleGl0IGFsbCBsZXZlbHMuXG4gICAqL1xuICBleGl0KGxldmVscykge1xuICAgIHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzID8/IHRoaXMuY2xlYW51cFN0YWNrLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgZW50ZXIobGV2ZWxzKSB7XG4gICAgY29uc3QgZW50ZXJQYXR0ZXJucyA9IHBhdHRlcm5zKFxuICAgICAgdGhpcy5jdXJyZW50U3RhdGUsXG4gICAgICBsZXZlbHMgPz8gdGhpcy5jdXJyZW50U3RhdGUuc3BsaXQoXCIuXCIpLmxlbmd0aCArIDFcbiAgICApO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVudGVyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgZW50ZXJGbiA9IHRoaXMuZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKGNsZWFudXBGbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMua25vd25FdmVudFR5cGVzLmhhcyhldmVudC50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV2ZW50ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQudHlwZSl9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMiAvKiBTVE9QUEVEICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZuID0gdGhpcy5nZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbihldmVudCwgdGFyZ2V0Rm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRTdGF0ZTtcbiAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICBjb25zdCBuZXh0VGFyZ2V0ID0gdGFyZ2V0Rm4oZXZlbnQsIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCk7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgZWZmZWN0cyA9IHZvaWQgMDtcbiAgICBpZiAobmV4dFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGVzLmhhcyhuZXh0U3RhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV4dCBzdGF0ZSBuYW1lOiAke0pTT04uc3RyaW5naWZ5KG5leHRTdGF0ZSl9YCk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ubm90aWZ5KHsgZnJvbTogb2xkU3RhdGUsIHRvOiBuZXh0U3RhdGUgfSk7XG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpc3RhbmNlKHRoaXMuY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIGlmICh1cCA+IDApIHtcbiAgICAgIHRoaXMuZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbmV4dFN0YXRlO1xuICAgIGlmIChlZmZlY3RzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGVmZmVjdHNUb1J1biA9IGVmZmVjdHM7XG4gICAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0c1RvUnVuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWZmZWN0KHBhdGNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hhYmxlQ29udGV4dC5wYXRjaChlZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb3duID4gMCkge1xuICAgICAgdGhpcy5lbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKTtcbn1cbmZ1bmN0aW9uIHRyeVBhcnNlSnNvbihyYXdNZXNzYWdlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmF3TWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGI2NGRlY29kZShiNjR2YWx1ZSkge1xuICB0cnkge1xuICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gYjY0dmFsdWUucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gICAgY29uc3QgZGVjb2RlZFZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgYXRvYihmb3JtYXR0ZWRWYWx1ZSkuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiJVwiICsgKFwiMDBcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgIH0pLmpvaW4oXCJcIilcbiAgICApO1xuICAgIHJldHVybiBkZWNvZGVkVmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBhdG9iKGI2NHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcGFjdChpdGVtcykge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKFxuICAgIChpdGVtKSA9PiBpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHZvaWQgMFxuICApO1xufVxuZnVuY3Rpb24gY29tcGFjdE9iamVjdChvYmopIHtcbiAgY29uc3QgbmV3T2JqID0geyAuLi5vYmogfTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBpZiAobmV3T2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIG5ld09ialtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdPYmo7XG59XG5mdW5jdGlvbiB3YWl0KG1pbGxpcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIG1pbGxpcykpO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aFRpbWVvdXQocHJvbWlzZSwgbWlsbGlzLCBlcnJtc2cpIHtcbiAgbGV0IHRpbWVySUQ7XG4gIGNvbnN0IHRpbWVyJCA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICB0aW1lcklEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKGVycm1zZykpO1xuICAgIH0sIG1pbGxpcyk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCB0aW1lciRdKS5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aW1lcklEKSk7XG59XG5mdW5jdGlvbiBtZW1vaXplT25TdWNjZXNzKGZhY3RvcnlGbikge1xuICBsZXQgY2FjaGVkID0gbnVsbDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoY2FjaGVkID09PSBudWxsKSB7XG4gICAgICBjYWNoZWQgPSBmYWN0b3J5Rm4oKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNhY2hlZCA9IG51bGw7XG4gICAgICAgIH0sIDVlMyk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkO1xuICB9O1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvU2VydmVyTXNnLnRzXG52YXIgU2VydmVyTXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcnZlck1zZ0NvZGUyKSA9PiB7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9KT0lORURcIl0gPSAxMDFdID0gXCJVU0VSX0pPSU5FRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfTEVGVFwiXSA9IDEwMl0gPSBcIlVTRVJfTEVGVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkJST0FEQ0FTVEVEX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNURURfRVZFTlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJST09NX1NUQVRFXCJdID0gMTA0XSA9IFwiUk9PTV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiXSA9IDIwMF0gPSBcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJSRUpFQ1RfU1RPUkFHRV9PUFwiXSA9IDI5OV0gPSBcIlJFSkVDVF9TVE9SQUdFX09QXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDBdID0gXCJVUERBVEVfWURPQ1wiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9DUkVBVEVEXCJdID0gNDAwXSA9IFwiVEhSRUFEX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfREVMRVRFRFwiXSA9IDQwN10gPSBcIlRIUkVBRF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIl0gPSA0MDFdID0gXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9VUERBVEVEXCJdID0gNDA4XSA9IFwiVEhSRUFEX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0NSRUFURURcIl0gPSA0MDJdID0gXCJDT01NRU5UX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0VESVRFRFwiXSA9IDQwM10gPSBcIkNPTU1FTlRfRURJVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9ERUxFVEVEXCJdID0gNDA0XSA9IFwiQ09NTUVOVF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiXSA9IDQwNV0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIl0gPSA0MDZdID0gXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIjtcbiAgcmV0dXJuIFNlcnZlck1zZ0NvZGUyO1xufSkoU2VydmVyTXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9JV2ViU29ja2V0LnRzXG52YXIgV2Vic29ja2V0Q2xvc2VDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFdlYnNvY2tldENsb3NlQ29kZXMyKSA9PiB7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfTk9STUFMXCJdID0gMWUzXSA9IFwiQ0xPU0VfTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfQUJOT1JNQUxcIl0gPSAxMDA2XSA9IFwiQ0xPU0VfQUJOT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiXSA9IDEwMTFdID0gXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRSWV9BR0FJTl9MQVRFUlwiXSA9IDEwMTNdID0gXCJUUllfQUdBSU5fTEFURVJcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCJdID0gNGUzXSA9IFwiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk5PVF9BTExPV0VEXCJdID0gNDAwMV0gPSBcIk5PVF9BTExPV0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiXSA9IDQwMDJdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCJdID0gNDAwM10gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCJdID0gNDAwNF0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCJdID0gNDAwNV0gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlJPT01fSURfVVBEQVRFRFwiXSA9IDQwMDZdID0gXCJST09NX0lEX1VQREFURURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJLSUNLRURcIl0gPSA0MTAwXSA9IFwiS0lDS0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVE9LRU5fRVhQSVJFRFwiXSA9IDQxMDldID0gXCJUT0tFTl9FWFBJUkVEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiXSA9IDQ5OTldID0gXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCI7XG4gIHJldHVybiBXZWJzb2NrZXRDbG9zZUNvZGVzMjtcbn0pKFdlYnNvY2tldENsb3NlQ29kZXMgfHwge30pO1xuZnVuY3Rpb24gc2hvdWxkRGlzY29ubmVjdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSA0OTk5IC8qIENMT1NFX1dJVEhPVVRfUkVUUlkgKi8gfHwgY29kZSA+PSA0ZTMgJiYgY29kZSA8IDQxMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA0MTAwICYmIGNvZGUgPCA0MjAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMTMgLyogVFJZX0FHQUlOX0xBVEVSICovIHx8IGNvZGUgPj0gNDIwMCAmJiBjb2RlIDwgNDMwMDtcbn1cblxuLy8gc3JjL2Nvbm5lY3Rpb24udHNcbmZ1bmN0aW9uIGlzSWRsZShzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gXCJpbml0aWFsXCIgfHwgc3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiO1xufVxuZnVuY3Rpb24gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdGUgPSBtYWNoaW5lLmN1cnJlbnRTdGF0ZTtcbiAgc3dpdGNoIChzdGF0ZSkge1xuICAgIGNhc2UgXCJAb2suY29ubmVjdGVkXCI6XG4gICAgY2FzZSBcIkBvay5hd2FpdGluZy1wb25nXCI6XG4gICAgICByZXR1cm4gXCJjb25uZWN0ZWRcIjtcbiAgICBjYXNlIFwiQGlkbGUuaW5pdGlhbFwiOlxuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIGNhc2UgXCJAYXV0aC5idXN5XCI6XG4gICAgY2FzZSBcIkBhdXRoLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYnVzeVwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBpZGxlLnpvbWJpZVwiOlxuICAgICAgcmV0dXJuIG1hY2hpbmUuY29udGV4dC5zdWNjZXNzQ291bnQgPiAwID8gXCJyZWNvbm5lY3RpbmdcIiA6IFwiY29ubmVjdGluZ1wiO1xuICAgIGNhc2UgXCJAaWRsZS5mYWlsZWRcIjpcbiAgICAgIHJldHVybiBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoc3RhdGUsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgfVxufVxudmFyIEJBQ0tPRkZfREVMQVlTID0gWzI1MCwgNTAwLCAxZTMsIDJlMywgNGUzLCA4ZTMsIDFlNF07XG52YXIgUkVTRVRfREVMQVkgPSBCQUNLT0ZGX0RFTEFZU1swXSAtIDE7XG52YXIgQkFDS09GRl9ERUxBWVNfU0xPVyA9IFsyZTMsIDNlNCwgNmU0LCAzZTVdO1xudmFyIEhFQVJUQkVBVF9JTlRFUlZBTCA9IDNlNDtcbnZhciBQT05HX1RJTUVPVVQgPSAyZTM7XG52YXIgQVVUSF9USU1FT1VUID0gMWU0O1xudmFyIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQgPSAxZTQ7XG52YXIgU3RvcFJldHJ5aW5nID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKHJlYXNvbik7XG4gIH1cbn07XG52YXIgTGl2ZWJsb2Nrc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn07XG5mdW5jdGlvbiBuZXh0QmFja29mZkRlbGF5KGN1cnJlbnREZWxheSwgZGVsYXlzKSB7XG4gIHJldHVybiBkZWxheXMuZmluZCgoZGVsYXkpID0+IGRlbGF5ID4gY3VycmVudERlbGF5KSA/PyBkZWxheXNbZGVsYXlzLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gaW5jcmVhc2VCYWNrb2ZmRGVsYXkoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHtcbiAgICBiYWNrb2ZmRGVsYXk6IG5leHRCYWNrb2ZmRGVsYXkoY29udGV4dC5iYWNrb2ZmRGVsYXksIEJBQ0tPRkZfREVMQVlTKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZU19TTE9XKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U3VjY2Vzc0NvdW50KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7IHN1Y2Nlc3NDb3VudDogMCB9KTtcbn1cbmZ1bmN0aW9uIGxvZyhsZXZlbCwgbWVzc2FnZSkge1xuICBjb25zdCBsb2dnZXIgPSBsZXZlbCA9PT0gMiAvKiBFUlJPUiAqLyA/IGVycm9yMiA6IGxldmVsID09PSAxIC8qIFdBUk4gKi8gPyB3YXJuIDogKFxuICAgIC8qIGJsYWNrIGhvbGUgKi9cbiAgICAoKSA9PiB7XG4gICAgfVxuICApO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxvZ2dlcihtZXNzYWdlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGUpIHtcbiAgY29uc3QgY29ubiA9IFwiQ29ubmVjdGlvbiB0byBMaXZlYmxvY2tzIHdlYnNvY2tldCBzZXJ2ZXJcIjtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB3YXJuKGAke2Nvbm59IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZC4gJHtTdHJpbmcoZSl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGlzQ2xvc2VFdmVudChlKSA/IGAke2Nvbm59IGNsb3NlZCBwcmVtYXR1cmVseSAoY29kZTogJHtlLmNvZGV9KS4gUmV0cnlpbmcgaW4gJHtjdHguYmFja29mZkRlbGF5fW1zLmAgOiBgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBsb2dDbG9zZUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGRldGFpbHMgPSBbYGNvZGU6ICR7ZXZlbnQuY29kZX1gXTtcbiAgaWYgKGV2ZW50LnJlYXNvbikge1xuICAgIGRldGFpbHMucHVzaChgcmVhc29uOiAke2V2ZW50LnJlYXNvbn1gKTtcbiAgfVxuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgQ29ubmVjdGlvbiB0byBMaXZlYmxvY2tzIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkICgke2RldGFpbHMuam9pbihcIiwgXCIpfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gXG4gICAgKTtcbiAgfTtcbn1cbnZhciBsb2dQZXJtYW5lbnRDbG9zZSA9IGxvZyhcbiAgMSAvKiBXQVJOICovLFxuICBcIkNvbm5lY3Rpb24gdG8gV2ViU29ja2V0IGNsb3NlZCBwZXJtYW5lbnRseS4gV29uJ3QgcmV0cnkuXCJcbik7XG5mdW5jdGlvbiBpc0Nsb3NlRXZlbnQoZXJyb3IzKSB7XG4gIHJldHVybiAhKGVycm9yMyBpbnN0YW5jZW9mIEVycm9yKSAmJiBlcnJvcjMudHlwZSA9PT0gXCJjbG9zZVwiO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2luZyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXJ0ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIGZ1bmN0aW9uIGxvZzIoLi4uYXJncykge1xuICAgIHdhcm4oXG4gICAgICBgJHsoKCgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gMWUzKS50b0ZpeGVkKDIpfSBbRlNNICMke21hY2hpbmUuaWR9XWAsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfVxuICBjb25zdCB1bnN1YnMgPSBbXG4gICAgbWFjaGluZS5ldmVudHMuZGlkUmVjZWl2ZUV2ZW50LnN1YnNjcmliZSgoZSkgPT4gbG9nMihgRXZlbnQgJHtlLnR5cGV9YCkpLFxuICAgIG1hY2hpbmUuZXZlbnRzLndpbGxUcmFuc2l0aW9uLnN1YnNjcmliZShcbiAgICAgICh7IGZyb20sIHRvIH0pID0+IGxvZzIoXCJUcmFuc2l0aW9uaW5nXCIsIGZyb20sIFwiXFx1MjE5MlwiLCB0bylcbiAgICApLFxuICAgIG1hY2hpbmUuZXZlbnRzLmRpZElnbm9yZUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChlKSA9PiBsb2cyKFwiSWdub3JlZCBldmVudFwiLCBlLnR5cGUsIGUsIFwiKGN1cnJlbnQgc3RhdGUgd29uJ3QgaGFuZGxlIGl0KVwiKVxuICAgIClcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy53aWxsRXhpdFN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRXhpdGluZyBzdGF0ZVwiLCBzKSksXG4gICAgLy8gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkVudGVyaW5nIHN0YXRlXCIsIHMpKSxcbiAgXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgICAgdW5zdWIoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSkge1xuICBjb25zdCBzdGF0dXNEaWRDaGFuZ2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkQ29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWREaXNjb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGxldCBsYXN0U3RhdHVzID0gbnVsbDtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3QgY3VyclN0YXR1cyA9IHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKTtcbiAgICBpZiAoY3VyclN0YXR1cyAhPT0gbGFzdFN0YXR1cykge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLm5vdGlmeShjdXJyU3RhdHVzKTtcbiAgICB9XG4gICAgaWYgKGxhc3RTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIgJiYgY3VyclN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgZGlkRGlzY29ubmVjdC5ub3RpZnkoKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIgJiYgY3VyclN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgZGlkQ29ubmVjdC5ub3RpZnkoKTtcbiAgICB9XG4gICAgbGFzdFN0YXR1cyA9IGN1cnJTdGF0dXM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN0YXR1c0RpZENoYW5nZTogc3RhdHVzRGlkQ2hhbmdlLm9ic2VydmFibGUsXG4gICAgZGlkQ29ubmVjdDogZGlkQ29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIGRpZERpc2Nvbm5lY3Q6IGRpZERpc2Nvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICB1bnN1YnNjcmliZVxuICB9O1xufVxudmFyIGFzc2lnbiA9IChwYXRjaCkgPT4gKGN0eCkgPT4gY3R4LnBhdGNoKHBhdGNoKTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoZGVsZWdhdGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9uTWVzc2FnZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgY29uc3Qgb25MaXZlYmxvY2tzRXJyb3IgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZmlyZUVycm9yRXZlbnQoZXJybXNnLCBlcnJjb2RlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBMaXZlYmxvY2tzRXJyb3IoZXJybXNnLCBlcnJjb2RlKTtcbiAgICAgIG9uTGl2ZWJsb2Nrc0Vycm9yLm5vdGlmeShlcnIpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW5pdGlhbENvbnRleHQgPSB7XG4gICAgc3VjY2Vzc0NvdW50OiAwLFxuICAgIGF1dGhWYWx1ZTogbnVsbCxcbiAgICBzb2NrZXQ6IG51bGwsXG4gICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICB9O1xuICBjb25zdCBtYWNoaW5lID0gbmV3IEZTTShpbml0aWFsQ29udGV4dCkuYWRkU3RhdGUoXCJAaWRsZS5pbml0aWFsXCIpLmFkZFN0YXRlKFwiQGlkbGUuZmFpbGVkXCIpLmFkZFN0YXRlKFwiQGlkbGUuem9tYmllXCIpLmFkZFN0YXRlKFwiQGF1dGguYnVzeVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5idXN5XCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiKS5hZGRTdGF0ZShcIkBvay5jb25uZWN0ZWRcIikuYWRkU3RhdGUoXCJAb2suYXdhaXRpbmctcG9uZ1wiKTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIipcIiwge1xuICAgIFJFQ09OTkVDVDoge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCByZXNldFN1Y2Nlc3NDb3VudF1cbiAgICB9LFxuICAgIERJU0NPTk5FQ1Q6IFwiQGlkbGUuaW5pdGlhbFwiXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAaWRsZS4qXCIsIHJlc2V0U3VjY2Vzc0NvdW50KS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLipcIiwge1xuICAgIENPTk5FQ1Q6IChfLCBjdHgpID0+IChcbiAgICAgIC8vIElmIHdlIHN0aWxsIGhhdmUgYSBrbm93biBhdXRoVmFsdWUsIHRyeSB0byByZWNvbm5lY3QgdG8gdGhlIHNvY2tldCBkaXJlY3RseSxcbiAgICAgIC8vIG90aGVyd2lzZSwgdHJ5IHRvIG9idGFpbiBhIG5ldyBhdXRoVmFsdWVcbiAgICAgIGN0eC5hdXRoVmFsdWUgIT09IG51bGwgPyBcIkBjb25uZWN0aW5nLmJ1c3lcIiA6IFwiQGF1dGguYnVzeVwiXG4gICAgKVxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBhdXRoLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGF1dGguYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGF1dGguYnVzeVwiLFxuICAgICgpID0+IHdpdGhUaW1lb3V0KFxuICAgICAgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpLFxuICAgICAgQVVUSF9USU1FT1VULFxuICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIGF1dGhcIlxuICAgICksXG4gICAgLy8gT24gc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgYXV0aFZhbHVlOiBva0V2ZW50LmRhdGFcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gQXV0aCBmYWlsZWRcbiAgICAoZmFpbGVkRXZlbnQpID0+IHtcbiAgICAgIGlmIChmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5LFxuICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgIDIgLyogRVJST1IgKi8sXG4gICAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2ZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIEVycm9yID8gZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UgOiBTdHJpbmcoZmFpbGVkRXZlbnQucmVhc29uKX1gXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgb25Tb2NrZXRFcnJvciA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfRVJST1JcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldE1lc3NhZ2UgPSAoZXZlbnQpID0+IGV2ZW50LmRhdGEgPT09IFwicG9uZ1wiID8gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJQT05HXCIgfSkgOiBvbk1lc3NhZ2Uubm90aWZ5KGV2ZW50KTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Tb2NrZXQoc29ja2V0KSB7XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy9cbiAgICAvLyBVc2UgdGhlIFwiY3JlYXRlU29ja2V0XCIgZGVsZWdhdGUgZnVuY3Rpb24gKHByb3ZpZGVkIHRvIHRoZVxuICAgIC8vIE1hbmFnZWRTb2NrZXQpIHRvIGNyZWF0ZSB0aGUgYWN0dWFsIFdlYlNvY2tldCBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgIC8vIFRoZW4sIHNldCB1cCBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMsIGFuZCB3YWl0IGZvciB0aGVcbiAgICAvLyBcIm9wZW5cIiBldmVudCB0byBvY2N1ci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIFwib3BlblwiIGV2ZW50IGhhcHBlbnMsIHdlJ3JlIHJlYWR5IHRvIHRyYW5zaXRpb24gdG8gdGhlXG4gICAgLy8gT0sgc3RhdGUuIFRoaXMgaXMgZG9uZSBieSByZXNvbHZpbmcgdGhlIFByb21pc2UuXG4gICAgLy9cbiAgICBhc3luYyAoY3R4LCBzaWduYWwpID0+IHtcbiAgICAgIGxldCBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gbnVsbDtcbiAgICAgIGxldCB1bmNvbmZpcm1lZFNvY2tldCA9IG51bGw7XG4gICAgICBjb25zdCBjb25uZWN0JCA9IG5ldyBQcm9taXNlKFxuICAgICAgICAocmVzb2x2ZSwgcmVqKSA9PiB7XG4gICAgICAgICAgaWYgKGN0eC5hdXRoVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggYXV0aFZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzb2NrZXQgPSBkZWxlZ2F0ZXMuY3JlYXRlU29ja2V0KGN0eC5hdXRoVmFsdWUpO1xuICAgICAgICAgIHVuY29uZmlybWVkU29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdChldmVudCkge1xuICAgICAgICAgICAgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgICByZWooZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBbYWN0b3IkLCBkaWRSZWNlaXZlQWN0b3JdID0gY29udHJvbGxlZFByb21pc2UoKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yQWN0b3JJZChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyTXNnID0gdHJ5UGFyc2VKc29uKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKHNlcnZlck1zZz8udHlwZSA9PT0gMTA0IC8qIFJPT01fU1RBVEUgKi8pIHtcbiAgICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2b2lkIGFjdG9yJC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShbc29ja2V0LCB1bnN1Yl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gd2l0aFRpbWVvdXQoXG4gICAgICAgIGNvbm5lY3QkLFxuICAgICAgICBTT0NLRVRfQ09OTkVDVF9USU1FT1VULFxuICAgICAgICBcIlRpbWVkIG91dCBkdXJpbmcgd2Vic29ja2V0IGNvbm5lY3Rpb25cIlxuICAgICAgKS50aGVuKFxuICAgICAgICAvL1xuICAgICAgICAvLyBQYXJ0IDM6XG4gICAgICAgIC8vIEJ5IG5vdywgb3VyIFwib3BlblwiIGV2ZW50IGhhcyBmaXJlZCwgYW5kIHRoZSBwcm9taXNlIGhhcyBiZWVuXG4gICAgICAgIC8vIHJlc29sdmVkLiBUd28gcG9zc2libGUgc2NlbmFyaW9zOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBUaGUgaGFwcHkgcGF0aC4gTW9zdCBsaWtlbHkuXG4gICAgICAgIC8vIDIuIFVoLW9oLiBBIHByZW1hdHVyZSBjbG9zZS9lcnJvciBldmVudCBoYXMgYmVlbiBvYnNlcnZlZC4gTGV0J3NcbiAgICAgICAgLy8gICAgcmVqZWN0IHRoZSBwcm9taXNlIGFmdGVyIGFsbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQW55IGNsb3NlL2Vycm9yIGV2ZW50IHRoYXQgd2lsbCBnZXQgc2NoZWR1bGVkIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gb253YXJkcywgd2lsbCBiZSBjYXVnaHQgaW4gdGhlIE9LIHN0YXRlLCBhbmQgZGVhbHQgd2l0aFxuICAgICAgICAvLyBhY2NvcmRpbmdseS5cbiAgICAgICAgLy9cbiAgICAgICAgKFtzb2NrZXQsIHVuc3ViXSkgPT4ge1xuICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydGVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FwdHVyZWRQcmVtYXR1cmVFdmVudCkge1xuICAgICAgICAgICAgdGhyb3cgY2FwdHVyZWRQcmVtYXR1cmVFdmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgfVxuICAgICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB0ZWFyZG93blNvY2tldCh1bmNvbmZpcm1lZFNvY2tldCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIE9ubHkgdHJhbnNpdGlvbiB0byBPSyBzdGF0ZSBhZnRlciBhIHN1Y2Nlc3NmdWxseSBvcGVuZWQgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAb2suY29ubmVjdGVkXCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIHNvY2tldDogb2tFdmVudC5kYXRhLFxuICAgICAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWRcbiAgICAoZmFpbHVyZSkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gZmFpbHVyZS5yZWFzb247XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNDbG9zZUV2ZW50KGVycikpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSxcbiAgICAgICAgICAgICAgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLnJlYXNvbiksXG4gICAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5yZWFzb24sIGVyci5jb2RlKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IHNlbmRIZWFydGJlYXQgPSB7XG4gICAgdGFyZ2V0OiBcIkBvay5hd2FpdGluZy1wb25nXCIsXG4gICAgZWZmZWN0OiAoY3R4KSA9PiB7XG4gICAgICBjdHguc29ja2V0Py5zZW5kKFwicGluZ1wiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1heWJlSGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IGNhblpvbWJpZSA9IGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiICYmIGRlbGVnYXRlcy5jYW5ab21iaWUoKTtcbiAgICByZXR1cm4gY2FuWm9tYmllID8gXCJAaWRsZS56b21iaWVcIiA6IHNlbmRIZWFydGJlYXQ7XG4gIH07XG4gIG1hY2hpbmUuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmNvbm5lY3RlZFwiLCBIRUFSVEJFQVRfSU5URVJWQUwsIG1heWJlSGVhcnRiZWF0KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5jb25uZWN0ZWRcIiwge1xuICAgIE5BVklHQVRPUl9PRkZMSU5FOiBtYXliZUhlYXJ0YmVhdCxcbiAgICAvLyBEb24ndCB0YWtlIHRoZSBicm93c2VyJ3Mgd29yZCBmb3IgaXQgd2hlbiBpdCBzYXlzIGl0J3Mgb2ZmbGluZS4gRG8gYSBwaW5nL3BvbmcgdG8gbWFrZSBzdXJlLlxuICAgIFdJTkRPV19HT1RfRk9DVVM6IHNlbmRIZWFydGJlYXRcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS56b21iaWVcIiwge1xuICAgIFdJTkRPV19HT1RfRk9DVVM6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiXG4gICAgLy8gV2hlbiBpbiB6b21iaWUgc3RhdGUsIHRoZSBjbGllbnQgd2lsbCB0cnkgdG8gd2FrZSB1cCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHdpbmRvdyByZWdhaW5zIGZvY3VzXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAb2suKlwiLCAoY3R4KSA9PiB7XG4gICAgY3R4LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiBjdHguc3VjY2Vzc0NvdW50ICsgMSB9KTtcbiAgICBjb25zdCB0aW1lcklEID0gc2V0VGltZW91dChcbiAgICAgIC8vIE9uIHRoZSBuZXh0IHRpY2ssIHN0YXJ0IGRlbGl2ZXJpbmcgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBhbHJlYWR5XG4gICAgICAvLyBiZWVuIHJlY2VpdmVkLCBhbmQgY29udGludWUgc3luY2hyb25vdXMgZGVsaXZlcnkgb2YgYWxsIGZ1dHVyZVxuICAgICAgLy8gaW5jb21pbmcgbWVzc2FnZXMuXG4gICAgICBvbk1lc3NhZ2UudW5wYXVzZSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiAoY3R4MikgPT4ge1xuICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4Mi5zb2NrZXQpO1xuICAgICAgY3R4Mi5wYXRjaCh7IHNvY2tldDogbnVsbCB9KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTtcbiAgICAgIG9uTWVzc2FnZS5wYXVzZSgpO1xuICAgIH07XG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgeyBQT05HOiBcIkBvay5jb25uZWN0ZWRcIiB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suYXdhaXRpbmctcG9uZ1wiLCBQT05HX1RJTUVPVVQsIHtcbiAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vIExvZyBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MgYW5kIGRyb3AgdGhlIGN1cnJlbnQgb3BlbiBzb2NrZXRcbiAgICBlZmZlY3Q6IGxvZyhcbiAgICAgIDEgLyogV0FSTiAqLyxcbiAgICAgIFwiUmVjZWl2ZWQgbm8gcG9uZyBmcm9tIHNlcnZlciwgYXNzdW1lIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcy5cIlxuICAgIClcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suKlwiLCB7XG4gICAgLy8gV2hlbiBhIHNvY2tldCByZWNlaXZlcyBhbiBlcnJvciwgdGhpcyBjYW4gY2F1c2UgdGhlIGNsb3Npbmcgb2YgdGhlXG4gICAgLy8gc29ja2V0LCBvciBub3QuIFNvIGFsd2F5cyBjaGVjayB0byBzZWUgaWYgdGhlIHNvY2tldCBpcyBzdGlsbCBPUEVOIG9yXG4gICAgLy8gbm90LiBXaGVuIHN0aWxsIE9QRU4sIGRvbid0IHRyYW5zaXRpb24uXG4gICAgRVhQTElDSVRfU09DS0VUX0VSUk9SOiAoXywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQuc29ja2V0Py5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBpbmNyZWFzZUJhY2tvZmZEZWxheVxuICAgICAgfTtcbiAgICB9LFxuICAgIEVYUExJQ0lUX1NPQ0tFVF9DTE9TRTogKGUpID0+IHtcbiAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2dQZXJtYW5lbnRDbG9zZSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGUuZXZlbnQucmVhc29uLCBlLmV2ZW50LmNvZGUpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIGlmIChlLmV2ZW50LmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gICAgY29uc3Qgcm9vdCA9IHdpbiA/PyBkb2M7XG4gICAgbWFjaGluZS5vbkVudGVyKFwiKlwiLCAoY3R4KSA9PiB7XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtPZmZsaW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PRkZMSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtCYWNrT25saW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PTkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiV0lORE9XX0dPVF9GT0NVU1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgcm9vdD8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJvb3Q/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4LnNvY2tldCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGNsZWFudXBzID0gW107XG4gIGNvbnN0IHsgc3RhdHVzRGlkQ2hhbmdlLCBkaWRDb25uZWN0LCBkaWREaXNjb25uZWN0LCB1bnN1YnNjcmliZSB9ID0gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpO1xuICBjbGVhbnVwcy5wdXNoKHVuc3Vic2NyaWJlKTtcbiAgaWYgKG9wdGlvbnMuZW5hYmxlRGVidWdMb2dnaW5nKSB7XG4gICAgY2xlYW51cHMucHVzaChlbmFibGVUcmFjaW5nKG1hY2hpbmUpKTtcbiAgfVxuICBtYWNoaW5lLnN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgbWFjaGluZSxcbiAgICBjbGVhbnVwcyxcbiAgICAvLyBPYnNlcnZhYmxlIGV2ZW50cyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGlzIG1hY2hpbmVcbiAgICBldmVudHM6IHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZSxcbiAgICAgIGRpZENvbm5lY3QsXG4gICAgICBkaWREaXNjb25uZWN0LFxuICAgICAgb25NZXNzYWdlOiBvbk1lc3NhZ2Uub2JzZXJ2YWJsZSxcbiAgICAgIG9uTGl2ZWJsb2Nrc0Vycm9yOiBvbkxpdmVibG9ja3NFcnJvci5vYnNlcnZhYmxlXG4gICAgfVxuICB9O1xufVxudmFyIE1hbmFnZWRTb2NrZXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlcywgZW5hYmxlRGVidWdMb2dnaW5nID0gZmFsc2UsIHdhaXRGb3JBY3RvcklkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgbWFjaGluZSwgZXZlbnRzLCBjbGVhbnVwcyB9ID0gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShcbiAgICAgIGRlbGVnYXRlcyxcbiAgICAgIHsgd2FpdEZvckFjdG9ySWQsIGVuYWJsZURlYnVnTG9nZ2luZyB9XG4gICAgKTtcbiAgICB0aGlzLm1hY2hpbmUgPSBtYWNoaW5lO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuY2xlYW51cHMgPSBjbGVhbnVwcztcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b05ld0Nvbm5lY3Rpb25TdGF0dXModGhpcy5tYWNoaW5lKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXV0aCBhdXRoVmFsdWUuXG4gICAqL1xuICBnZXQgYXV0aFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLm1hY2hpbmUuY29udGV4dC5hdXRoVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgdG8gdHJ5IHRvIGNvbm5lY3QgdG8gYSBXZWJTb2NrZXQuIFRoaXMgb25seSBoYXMgYW4gZWZmZWN0XG4gICAqIGlmIHRoZSBtYWNoaW5lIGlzIGlkbGUgYXQgdGhlIG1vbWVudCwgb3RoZXJ3aXNlIHRoaXMgaXMgYSBuby1vcC5cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogSWYgaWRsZSwgd2lsbCB0cnkgdG8gY29ubmVjdC4gT3RoZXJ3aXNlLCBpdCB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IHRvXG4gICAqIHRoZSBzb2NrZXQsIHBvdGVudGlhbGx5IG9idGFpbmluZyBhIG5ldyBhdXRoVmFsdWUgZmlyc3QsIGlmIG5lZWRlZC5cbiAgICovXG4gIHJlY29ubmVjdCgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiUkVDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgdG8gZGlzY29ubmVjdCBmcm9tIHRoZSBjdXJyZW50IFdlYlNvY2tldC4gSXMgZ29pbmcgdG8gYmVcbiAgICogYSBuby1vcCBpZiB0aGVyZSBpcyBubyBhY3RpdmUgY29ubmVjdGlvbi5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkRJU0NPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIHN0b3AgdGhlIG1hY2hpbmUgYW5kIHJ1biBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuIEFmdGVyXG4gICAqIGNhbGxpbmcgZGVzdHJveSgpLCB5b3UgY2FuIG5vIGxvbmdlciB1c2UgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzIGJlZm9yZVxuICAgKiBsZXR0aW5nIHRoZSBpbnN0YW5jZSBnZXQgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWFjaGluZS5zdG9wKCk7XG4gICAgbGV0IGNsZWFudXA7XG4gICAgd2hpbGUgKGNsZWFudXAgPSB0aGlzLmNsZWFudXBzLnBvcCgpKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTYWZlbHkgc2VuZCBhIG1lc3NhZ2UgdG8gdGhlIGN1cnJlbnQgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFdpbGwgZW1pdCBhIGxvZ1xuICAgKiBtZXNzYWdlIGlmIHRoaXMgaXMgc29tZWhvdyBpbXBvc3NpYmxlLlxuICAgKi9cbiAgc2VuZChkYXRhKSB7XG4gICAgY29uc3Qgc29ja2V0ID0gdGhpcy5tYWNoaW5lLmNvbnRleHQ/LnNvY2tldDtcbiAgICBpZiAoc29ja2V0ID09PSBudWxsKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IG5vdCBjb25uZWN0ZWQgeWV0XCIsIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IDEpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogV2ViU29ja2V0IG5vIGxvbmdlciBvcGVuXCIsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQuc2VuZChkYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5PVEU6IFVzZWQgYnkgdGhlIEUyRSBhcHAgb25seSwgdG8gc2ltdWxhdGUgZXhwbGljaXQgZXZlbnRzLlxuICAgKiBOb3QgaWRlYWwgdG8ga2VlcCBleHBvc2VkIDooXG4gICAqL1xuICBfcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZChldmVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9BdXRoVG9rZW4udHNcbmZ1bmN0aW9uIGNhbldyaXRlU3RvcmFnZShzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG59XG5mdW5jdGlvbiBjYW5Db21tZW50KHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gaXNWYWxpZEF1dGhUb2tlblBheWxvYWQoZGF0YSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChkYXRhKSAmJiAoZGF0YS5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pO1xufVxuZnVuY3Rpb24gcGFyc2VBdXRoVG9rZW4ocmF3VG9rZW5TdHJpbmcpIHtcbiAgY29uc3QgdG9rZW5QYXJ0cyA9IHJhd1Rva2VuU3RyaW5nLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHRva2VuUGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aGVudGljYXRpb24gZXJyb3I6IGludmFsaWQgSldUIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IHBheWxvYWQgPSB0cnlQYXJzZUpzb24oYjY0ZGVjb2RlKHRva2VuUGFydHNbMV0pKTtcbiAgaWYgKCEocGF5bG9hZCAmJiBpc1ZhbGlkQXV0aFRva2VuUGF5bG9hZChwYXlsb2FkKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBleHBlY3RlZCBhIHZhbGlkIHRva2VuIGJ1dCBkaWQgbm90IGdldCBvbmUuIEhpbnQ6IGlmIHlvdSBhcmUgdXNpbmcgYSBjYWxsYmFjaywgZW5zdXJlIHRoZSByb29tIGlzIHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSB0b2tlbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50Q2FsbGJhY2tcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByYXc6IHJhd1Rva2VuU3RyaW5nLFxuICAgIHBhcnNlZDogcGF5bG9hZFxuICB9O1xufVxuXG4vLyBzcmMvYXV0aC1tYW5hZ2VyLnRzXG5mdW5jdGlvbiBjcmVhdGVBdXRoTWFuYWdlcihhdXRoT3B0aW9ucykge1xuICBjb25zdCBhdXRoZW50aWNhdGlvbiA9IHByZXBhcmVBdXRoZW50aWNhdGlvbihhdXRoT3B0aW9ucyk7XG4gIGNvbnN0IHNlZW5Ub2tlbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgZXhwaXJ5VGltZXMgPSBbXTtcbiAgY29uc3QgcmVxdWVzdFByb21pc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgc2VlblRva2Vucy5jbGVhcigpO1xuICAgIHRva2Vucy5sZW5ndGggPSAwO1xuICAgIGV4cGlyeVRpbWVzLmxlbmd0aCA9IDA7XG4gICAgcmVxdWVzdFByb21pc2VzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSB7XG4gICAgaWYgKHJlcXVlc3RlZFNjb3BlID09PSBcImNvbW1lbnRzOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOnJlYWRcIiAvKiBDb21tZW50c1JlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTpyZWFkXCIgLyogUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3RlZFNjb3BlID09PSBcInJvb206cmVhZFwiKSB7XG4gICAgICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwicm9vbTpyZWFkXCIgLyogUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGdldENhY2hlZFRva2VuKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgY29uc3Qgbm93ID0gTWF0aC5jZWlsKERhdGUubm93KCkgLyAxZTMpO1xuICAgIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gZXhwaXJ5VGltZXNbaV07XG4gICAgICBpZiAoZXhwaXJlc0F0IDw9IG5vdykge1xuICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBleHBpcnlUaW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSBlbHNlIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8pIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0T3B0aW9ucy5yb29tSWQgJiYgT2JqZWN0LmVudHJpZXModG9rZW4ucGFyc2VkLnBlcm1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbcmVzb3VyY2UsIHNjb3Blc10gb2YgT2JqZWN0LmVudHJpZXModG9rZW4ucGFyc2VkLnBlcm1zKSkge1xuICAgICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2UuaW5jbHVkZXMoXCIqXCIpICYmIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdE9wdGlvbnMucmVxdWVzdGVkU2NvcGUsIHNjb3BlcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UuaW5jbHVkZXMoXCIqXCIpICYmIHJlcXVlc3RPcHRpb25zLnJvb21JZC5zdGFydHNXaXRoKHJlc291cmNlLnJlcGxhY2UoXCIqXCIsIFwiXCIpKSB8fCByZXF1ZXN0T3B0aW9ucy5yb29tSWQgPT09IHJlc291cmNlICYmIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdE9wdGlvbnMucmVxdWVzdGVkU2NvcGUsIHNjb3BlcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYWtlQXV0aFJlcXVlc3Qob3B0aW9ucykge1xuICAgIGNvbnN0IGZldGNoZXIgPSBhdXRoT3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoID8/ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDogd2luZG93LmZldGNoKTtcbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJwcml2YXRlXCIpIHtcbiAgICAgIGlmIChmZXRjaGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRvIHVzZSBMaXZlYmxvY2tzIGNsaWVudCBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQgd2l0aCBhIHVybCBhcyBhdXRoIGVuZHBvaW50LCB5b3UgbmVlZCB0byBwcm92aWRlIGEgZmV0Y2ggcG9seWZpbGwuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2hlciwgYXV0aGVudGljYXRpb24udXJsLCB7XG4gICAgICAgIHJvb206IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXV0aFRva2VuKHJlc3BvbnNlLnRva2VuKTtcbiAgICAgIGlmIChzZWVuVG9rZW5zLmhhcyhwYXJzZWQucmF3KSkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiVGhlIHNhbWUgTGl2ZWJsb2NrcyBhdXRoIHRva2VuIHdhcyBpc3N1ZWQgZnJvbSB0aGUgYmFja2VuZCBiZWZvcmUuIENhY2hpbmcgTGl2ZWJsb2NrcyB0b2tlbnMgaXMgbm90IHN1cHBvcnRlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRpb24uY2FsbGJhY2sob3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlLmVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtcInJlYXNvblwiIGluIHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZS5yZWFzb24gPT09IFwic3RyaW5nXCIgPyByZXNwb25zZS5yZWFzb24gOiBcIkZvcmJpZGRlblwifWA7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yID09PSBcImZvcmJpZGRlblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKHJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91ciBhdXRoZW50aWNhdGlvbiBjYWxsYmFjayBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgdG9rZW4sIGJ1dCBpdCBkaWQgbm90LiBIaW50OiB0aGUgcmV0dXJuIHZhbHVlIHNob3VsZCBsb29rIGxpa2U6IHsgdG9rZW46IFwiLi4uXCIgfSdcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVW5leHBlY3RlZCBhdXRoZW50aWNhdGlvbiB0eXBlLiBNdXN0IGJlIHByaXZhdGUgb3IgY3VzdG9tLlwiXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRBdXRoVmFsdWUocmVxdWVzdE9wdGlvbnMpIHtcbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJwdWJsaWNcIiwgcHVibGljQXBpS2V5OiBhdXRoZW50aWNhdGlvbi5wdWJsaWNBcGlLZXkgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkVG9rZW4gPSBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucyk7XG4gICAgaWYgKGNhY2hlZFRva2VuICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuOiBjYWNoZWRUb2tlbiB9O1xuICAgIH1cbiAgICBsZXQgY3VycmVudFByb21pc2U7XG4gICAgaWYgKHJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZXMuZ2V0KHJlcXVlc3RPcHRpb25zLnJvb21JZCk7XG4gICAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQocmVxdWVzdE9wdGlvbnMucm9vbUlkLCBjdXJyZW50UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChcImxpdmVibG9ja3MtdXNlci10b2tlblwiKTtcbiAgICAgIGlmIChjdXJyZW50UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlID0gbWFrZUF1dGhSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLnNldChcImxpdmVibG9ja3MtdXNlci10b2tlblwiLCBjdXJyZW50UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGN1cnJlbnRQcm9taXNlO1xuICAgICAgY29uc3QgQlVGRkVSID0gMzA7XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpICsgKHRva2VuLnBhcnNlZC5leHAgLSB0b2tlbi5wYXJzZWQuaWF0KSAtIEJVRkZFUjtcbiAgICAgIHNlZW5Ub2tlbnMuYWRkKHRva2VuLnJhdyk7XG4gICAgICBpZiAodG9rZW4ucGFyc2VkLmsgIT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBleHBpcnlUaW1lcy5wdXNoKGV4cGlyZXNBdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbiB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAocmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5kZWxldGUocmVxdWVzdE9wdGlvbnMucm9vbUlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5kZWxldGUoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVzZXQsXG4gICAgZ2V0QXV0aFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwdWJsaWNBcGlLZXksIGF1dGhFbmRwb2ludCB9ID0gYXV0aE9wdGlvbnM7XG4gIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCAmJiBwdWJsaWNBcGlLZXkgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCBzaW11bHRhbmVvdXNseSB1c2UgYHB1YmxpY0FwaUtleWAgYW5kIGBhdXRoRW5kcG9pbnRgIG9wdGlvbnMuIFBsZWFzZSBwaWNrIG9uZSBhbmQgbGVhdmUgdGhlIG90aGVyIG9wdGlvbiB1bnNwZWNpZmllZC4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2YgcHVibGljQXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwic2tfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBgcHVibGljQXBpS2V5YCBvcHRpb24uIFRoZSB2YWx1ZSB5b3UgcGFzc2VkIGlzIGEgc2VjcmV0IGtleSwgd2hpY2ggc2hvdWxkIG5vdCBiZSB1c2VkIGZyb20gdGhlIGNsaWVudC4gUGxlYXNlIG9ubHkgZXZlciBwYXNzIGEgcHVibGljIGtleSBoZXJlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRQdWJsaWNLZXlcIlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInBrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQga2V5LiBQbGVhc2UgdXNlIHRoZSBwdWJsaWMga2V5IGZvcm1hdDogcGtfPHB1YmxpYyBrZXk+LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRQdWJsaWNLZXlcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHVibGljXCIsXG4gICAgICBwdWJsaWNBcGlLZXlcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHJpdmF0ZVwiLFxuICAgICAgdXJsOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgICAgY2FsbGJhY2s6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBgYXV0aEVuZHBvaW50YCBvcHRpb24gbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRBdXRoRW5kcG9pbnRcIlxuICAgICk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIFwiSW52YWxpZCBMaXZlYmxvY2tzIGNsaWVudCBvcHRpb25zLiBQbGVhc2UgcHJvdmlkZSBlaXRoZXIgYSBgcHVibGljQXBpS2V5YCBvciBgYXV0aEVuZHBvaW50YCBvcHRpb24uIFRoZXkgY2Fubm90IGJvdGggYmUgZW1wdHkuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEF1dGhFbmRwb2ludChmZXRjaDIsIGVuZHBvaW50LCBib2R5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoMihlbmRwb2ludCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGAkeyhhd2FpdCByZXMudGV4dCgpKS50cmltKCkgfHwgXCJyZWFzb24gbm90IHByb3ZpZGVkIGluIGF1dGggcmVzcG9uc2VcIn0gKCR7cmVzLnN0YXR1c30gcmV0dXJuZWQgYnkgUE9TVCAke2VuZHBvaW50fSlgO1xuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEgfHwgcmVzLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKGBVbmF1dGhvcml6ZWQ6ICR7cmVhc29ufWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhdXRoZW50aWNhdGU6ICR7cmVhc29ufWApO1xuICAgIH1cbiAgfVxuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIHdoZW4gZG9pbmcgYSBQT1NUIHJlcXVlc3Qgb24gXCIke2VuZHBvaW50fVwiLiAke1N0cmluZyhcbiAgICAgICAgZXJcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpIHx8IHR5cGVvZiBkYXRhLnRva2VuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgSlNPTiByZXNwb25zZSBvZiB0aGUgZm9ybSBcXGB7IHRva2VuOiBcIi4uLlwiIH1cXGAgd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgZGF0YVxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7IHRva2VuIH0gPSBkYXRhO1xuICByZXR1cm4geyB0b2tlbiB9O1xufVxuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgREVGQVVMVF9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9hcGkubGl2ZWJsb2Nrcy5pb1wiO1xuXG4vLyBzcmMvaW50ZXJuYWwudHNcbnZhciBrSW50ZXJuYWwgPSBTeW1ib2woKTtcblxuLy8gc3JjL2RldnRvb2xzL2JyaWRnZS50c1xudmFyIF9icmlkZ2VBY3RpdmUgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdGl2YXRlQnJpZGdlKGFsbG93ZWQpIHtcbiAgX2JyaWRnZUFjdGl2ZSA9IGFsbG93ZWQ7XG59XG5mdW5jdGlvbiBzZW5kVG9QYW5lbChtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmdWxsTXNnID0ge1xuICAgIC4uLm1lc3NhZ2UsXG4gICAgc291cmNlOiBcImxpdmVibG9ja3MtZGV2dG9vbHMtY2xpZW50XCJcbiAgfTtcbiAgaWYgKCEob3B0aW9ucz8uZm9yY2UgfHwgX2JyaWRnZUFjdGl2ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LnBvc3RNZXNzYWdlKGZ1bGxNc2csIFwiKlwiKTtcbn1cbnZhciBldmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YT8uc291cmNlID09PSBcImxpdmVibG9ja3MtZGV2dG9vbHMtcGFuZWxcIikge1xuICAgICAgZXZlbnRTb3VyY2Uubm90aWZ5KGV2ZW50LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuICB9KTtcbn1cbnZhciBvbk1lc3NhZ2VGcm9tUGFuZWwgPSBldmVudFNvdXJjZS5vYnNlcnZhYmxlO1xuXG4vLyBzcmMvZGV2dG9vbHMvaW5kZXgudHNcbnZhciBWRVJTSU9OID0gUEtHX1ZFUlNJT04gfHwgXCJkZXZcIjtcbnZhciBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBEZXZUb29scyhnZXRBbGxSb29tcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9kZXZ0b29sc1NldHVwSGFzUnVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gdHJ1ZTtcbiAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdFwiOiB7XG4gICAgICAgIGFjdGl2YXRlQnJpZGdlKHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHJvb21JZCBvZiBnZXRBbGxSb29tcygpKSB7XG4gICAgICAgICAgc2VuZFRvUGFuZWwoe1xuICAgICAgICAgICAgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgY2xpZW50VmVyc2lvbjogVkVSU0lPTlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcIndha2UtdXAtZGV2dG9vbHNcIiB9LCB7IGZvcmNlOiB0cnVlIH0pO1xufVxudmFyIHVuc3Vic0J5Um9vbUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHN0b3BTeW5jU3RyZWFtKHJvb21JZCkge1xuICBjb25zdCB1bnN1YnMgPSB1bnN1YnNCeVJvb21JZC5nZXQocm9vbUlkKSA/PyBbXTtcbiAgdW5zdWJzQnlSb29tSWQuZGVsZXRlKHJvb21JZCk7XG4gIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgdW5zdWIoKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RhcnRTeW5jU3RyZWFtKHJvb20pIHtcbiAgc3RvcFN5bmNTdHJlYW0ocm9vbS5pZCk7XG4gIGZ1bGxTeW5jKHJvb20pO1xuICB1bnN1YnNCeVJvb21JZC5zZXQocm9vbS5pZCwgW1xuICAgIC8vIFdoZW4gdGhlIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZXNcbiAgICByb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSksXG4gICAgLy8gV2hlbiBzdG9yYWdlIGluaXRpYWxpemVzLCBzZW5kIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlRGlkTG9hZC5zdWJzY3JpYmVPbmNlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgc3RvcmFnZSB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgc3RvcmFnZSByb290XG4gICAgcm9vbS5ldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIFwibWVcIiBvciBcIm90aGVyc1wiIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyB2YWx1ZXMgYWNjb3JkaW5nbHlcbiAgICByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY01lKHJvb20pKSxcbiAgICByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSB5ZG9jIGlzIHVwZGF0ZWQsIGZvcndhcmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnlkb2Muc3Vic2NyaWJlKCh1cGRhdGUpID0+IHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkpLFxuICAgIC8vIEFueSB0aW1lIGEgY3VzdG9tIHJvb20gZXZlbnQgaXMgcmVjZWl2ZWQsIGZvcndhcmQgaXRcbiAgICByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZXZlbnREYXRhKSA9PiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKVxuICAgIClcbiAgXSk7XG59XG5mdW5jdGlvbiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjp5ZG9jXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHVwZGF0ZVxuICB9KTtcbn1cbnZhciBsb2FkZWRBdCA9IERhdGUubm93KCk7XG52YXIgZXZlbnRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5leHRFdmVudElkKCkge1xuICByZXR1cm4gYGV2ZW50LSR7bG9hZGVkQXR9LSR7ZXZlbnRDb3VudGVyKyt9YDtcbn1cbmZ1bmN0aW9uIGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpldmVudHM6OmN1c3RvbS1ldmVudFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogXCJDdXN0b21FdmVudFwiLFxuICAgICAgaWQ6IG5leHRFdmVudElkKCksXG4gICAgICBrZXk6IFwiRXZlbnRcIixcbiAgICAgIGNvbm5lY3Rpb25JZDogZXZlbnREYXRhLmNvbm5lY3Rpb25JZCxcbiAgICAgIHBheWxvYWQ6IGV2ZW50RGF0YS5ldmVudFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGlmIChyb290KSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIHN0b3JhZ2U6IHJvb3QudG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY01lKHJvb20pIHtcbiAgY29uc3QgbWUgPSByb29tW2tJbnRlcm5hbF0uZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBpZiAobWUpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgbWVcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkge1xuICBjb25zdCBvdGhlcnMgPSByb29tW2tJbnRlcm5hbF0uZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIGlmIChvdGhlcnMpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgb3RoZXJzXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ1bGxTeW5jKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGNvbnN0IG1lID0gcm9vbVtrSW50ZXJuYWxdLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbVtrSW50ZXJuYWxdLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICByb29tLmZldGNoWURvYyhcIlwiKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpmdWxsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKSxcbiAgICBzdG9yYWdlOiByb290Py50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkID8/IG51bGwsXG4gICAgbWUsXG4gICAgb3RoZXJzXG4gIH0pO1xufVxudmFyIHJvb21DaGFubmVsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCkge1xuICBjb25zdCBsaXN0ZW5lciA9IHJvb21DaGFubmVsTGlzdGVuZXJzLmdldChyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5kZWxldGUocm9vbUlkKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbGlua0RldlRvb2xzKHJvb21JZCwgcm9vbSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsIHJvb21JZCwgY2xpZW50VmVyc2lvbjogVkVSU0lPTiB9KTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuc2V0KFxuICAgIHJvb21JZCxcbiAgICAvLyBSZXR1cm5zIHRoZSB1bnN1YnNjcmliZSBjYWxsYmFjaywgdGhhdCB3ZSBzdG9yZSBpbiB0aGVcbiAgICAvLyByb29tQ2hhbm5lbExpc3RlbmVycyByZWdpc3RyeVxuICAgIG9uTWVzc2FnZUZyb21QYW5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xuICAgICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICAgIGNhc2UgXCJyb29tOjpzdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0YXJ0U3luY1N0cmVhbShyb29tKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJvb206OnVuc3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB1bmxpbmtEZXZUb29scyhyb29tSWQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6dW5hdmFpbGFibGVcIixcbiAgICByb29tSWRcbiAgfSk7XG59XG5cbi8vIHNyYy9saWIvc3RyaW5naWZ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiIHx8IG9iamVjdCA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKTtcbiAgfVxuICBjb25zdCBzb3J0ZWRPYmplY3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLnNvcnQoKS5yZWR1Y2UoXG4gICAgKHNvcnRlZE9iamVjdDIsIGtleSkgPT4ge1xuICAgICAgc29ydGVkT2JqZWN0MltrZXldID0gb2JqZWN0W2tleV07XG4gICAgICByZXR1cm4gc29ydGVkT2JqZWN0MjtcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3J0ZWRPYmplY3QsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvbGliL2JhdGNoLnRzXG52YXIgREVGQVVMVF9TSVpFID0gNTA7XG52YXIgQmF0Y2hDYWxsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICB9XG59O1xudmFyIEJhdGNoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZSA/PyBERUZBVUxUX1NJWkU7XG4gICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gIH1cbiAgY2xlYXJEZWxheVRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQgIT09IHZvaWQgMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc2NoZWR1bGUoKSB7XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSB0aGlzLnNpemUpIHtcbiAgICAgIHZvaWQgdGhpcy5mbHVzaCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY2xlYXJEZWxheVRpbWVvdXQoKTtcbiAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHZvaWQgdGhpcy5mbHVzaCgpLCB0aGlzLmRlbGF5KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmx1c2goKSB7XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbGxzID0gdGhpcy5xdWV1ZS5zcGxpY2UoMCk7XG4gICAgY29uc3QgaW5wdXRzID0gY2FsbHMubWFwKChjYWxsKSA9PiBjYWxsLmlucHV0KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuY2FsbGJhY2soaW5wdXRzKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHM/LltpbmRleF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgIGNhbGwucmVqZWN0KG5ldyBFcnJvcihcIkNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5LlwiKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbHMubGVuZ3RoICE9PSByZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGwucmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQ2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBudW1iZXIgb2YgcHJvdmlkZWQgaXRlbXMuIEV4cGVjdGVkICR7Y2FsbHMubGVuZ3RofSwgYnV0IGdvdCAke3Jlc3VsdHMubGVuZ3RofS5gXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGNhbGwucmVqZWN0KHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgdGhpcy5lcnJvciA9IHRydWU7XG4gICAgICBjYWxscy5mb3JFYWNoKChjYWxsKSA9PiB7XG4gICAgICAgIGNhbGwucmVqZWN0KGVycm9yMyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0KGlucHV0KSB7XG4gICAgY29uc3QgZXhpc3RpbmdDYWxsID0gdGhpcy5xdWV1ZS5maW5kKFxuICAgICAgKGNhbGwyKSA9PiBzdHJpbmdpZnkoY2FsbDIuaW5wdXQpID09PSBzdHJpbmdpZnkoaW5wdXQpXG4gICAgKTtcbiAgICBpZiAoZXhpc3RpbmdDYWxsKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdDYWxsLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGNhbGwgPSBuZXcgQmF0Y2hDYWxsKGlucHV0KTtcbiAgICB0aGlzLnF1ZXVlLnB1c2goY2FsbCk7XG4gICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgIHJldHVybiBjYWxsLnByb21pc2U7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyRGVsYXlUaW1lb3V0KCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVCYXRjaFN0b3JlKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGNvbnN0IGJhdGNoID0gbmV3IEJhdGNoKGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBldmVudFNvdXJjZTIgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoYXJncykge1xuICAgIHJldHVybiBzdHJpbmdpZnkoYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHN0YXRlKSB7XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzdGF0ZSk7XG4gICAgZXZlbnRTb3VyY2UyLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldChpbnB1dCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoaW5wdXQpO1xuICAgIGlmIChjYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBiYXRjaC5nZXQoaW5wdXQpO1xuICAgICAgc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHsgaXNMb2FkaW5nOiBmYWxzZSwgZGF0YTogcmVzdWx0IH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yM1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXRlKGlucHV0KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShpbnB1dCk7XG4gICAgcmV0dXJuIGNhY2hlLmdldChjYWNoZUtleSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5ldmVudFNvdXJjZTIub2JzZXJ2YWJsZSxcbiAgICBnZXQsXG4gICAgZ2V0U3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9jcmVhdGUtc3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZSkge1xuICBsZXQgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNhbGxiYWNrKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT09IG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgZm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVyKHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICBjYWxsYmFjayhzdGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgc3Vic2NyaWJlXG4gIH07XG59XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgdXBkYXRlZEF0ID0gZGF0YS51cGRhdGVkQXQgPyBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgY29tbWVudHMgPSBkYXRhLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdCxcbiAgICB1cGRhdGVkQXQsXG4gICAgY29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24oZGF0YSkge1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdClcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShkYXRhKSB7XG4gIGNvbnN0IG5vdGlmaWVkQXQgPSBuZXcgRGF0ZShkYXRhLm5vdGlmaWVkQXQpO1xuICBjb25zdCByZWFkQXQgPSBkYXRhLnJlYWRBdCA/IG5ldyBEYXRlKGRhdGEucmVhZEF0KSA6IG51bGw7XG4gIGlmIChcImFjdGl2aXRpZXNcIiBpbiBkYXRhKSB7XG4gICAgY29uc3QgYWN0aXZpdGllcyA9IGRhdGEuYWN0aXZpdGllcy5tYXAoKGFjdGl2aXR5KSA9PiAoe1xuICAgICAgLi4uYWN0aXZpdHksXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGFjdGl2aXR5LmNyZWF0ZWRBdClcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBub3RpZmllZEF0LFxuICAgICAgcmVhZEF0LFxuICAgICAgYWN0aXZpdGllc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIG5vdGlmaWVkQXQsXG4gICAgcmVhZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oZGF0YSkge1xuICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBkZWxldGVkQXRcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi91cmwudHNcbmZ1bmN0aW9uIHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXJsam9pbihiYXNlVXJsLCBwYXRoLCBwYXJhbXMpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKTtcbiAgaWYgKHBhcmFtcyAhPT0gdm9pZCAwKSB7XG4gICAgdXJsLnNlYXJjaCA9IChwYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBwYXJhbXMgOiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuLy8gc3JjL25vdGlmaWNhdGlvbnMudHNcbnZhciBNQVJLX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9CQVRDSF9ERUxBWSA9IDUwO1xuZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uc0FwaSh7XG4gIGJhc2VVcmwsXG4gIGF1dGhNYW5hZ2VyLFxuICBjdXJyZW50VXNlcklkU3RvcmUsXG4gIGZldGNoZXJcbn0pIHtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hKc29uKGVuZHBvaW50LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiXG4gICAgfSk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiICYmIGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8pIHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQudWlkO1xuICAgICAgY3VycmVudFVzZXJJZFN0b3JlLnNldCgoKSA9PiB1c2VySWQpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB1cmxqb2luKGJhc2VVcmwsIGAvdjIvYyR7ZW5kcG9pbnR9YCwgcGFyYW1zKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoZXIodXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpfWBcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGZldGNoSnNvbihcIi9pbmJveC1ub3RpZmljYXRpb25zXCIsIHZvaWQgMCwge1xuICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0LFxuICAgICAgc2luY2U6IG9wdGlvbnM/LnNpbmNlPy50b0lTT1N0cmluZygpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IGpzb24udGhyZWFkcy5tYXAoKHRocmVhZCkgPT4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpKSxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEobm90aWZpY2F0aW9uKVxuICAgICAgKSxcbiAgICAgIGRlbGV0ZWRUaHJlYWRzOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChcbiAgICAgICAgKGluZm8pID0+IGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8oaW5mbylcbiAgICAgICksXG4gICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAoaW5mbykgPT4gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGluZm8pXG4gICAgICApLFxuICAgICAgbWV0YToge1xuICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvY291bnRcIik7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5ib3hOb3RpZmljYXRpb25JZHM6IFwiYWxsXCIgfSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5ib3hOb3RpZmljYXRpb25JZHMgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZCA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICBhd2FpdCBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICB9LFxuICAgIHsgZGVsYXk6IE1BUktfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICAgIGF3YWl0IGZldGNoSnNvbihcIi9pbmJveC1ub3RpZmljYXRpb25zXCIsIHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL2luYm94LW5vdGlmaWNhdGlvbnMvJHtlbmNvZGVVUklDb21wb25lbnQoaW5ib3hOb3RpZmljYXRpb25JZCl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb25cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wb3NpdGlvbi50c1xudmFyIE1JTl9DT0RFID0gMzI7XG52YXIgTUFYX0NPREUgPSAxMjY7XG52YXIgTlVNX0RJR0lUUyA9IE1BWF9DT0RFIC0gTUlOX0NPREUgKyAxO1xudmFyIFpFUk8gPSBudGhEaWdpdCgwKTtcbnZhciBPTkUgPSBudGhEaWdpdCgxKTtcbnZhciBaRVJPX05JTkUgPSBaRVJPICsgbnRoRGlnaXQoLTEpO1xuZnVuY3Rpb24gbnRoRGlnaXQobikge1xuICBjb25zdCBjb2RlID0gTUlOX0NPREUgKyAobiA8IDAgPyBOVU1fRElHSVRTICsgbiA6IG4pO1xuICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuIHZhbHVlOiAke259YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBtYWtlUG9zaXRpb24oeCwgeSkge1xuICBpZiAoeCAhPT0gdm9pZCAwICYmIHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZXR3ZWVuKHgsIHkpO1xuICB9IGVsc2UgaWYgKHggIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhZnRlcih4KTtcbiAgfSBlbHNlIGlmICh5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmVmb3JlKHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPTkU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJlZm9yZShwb3MpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcG9zLmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDw9IE1JTl9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgaWYgKGNvZGUgPT09IE1JTl9DT0RFICsgMSkge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFpFUk9fTklORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9ORTtcbn1cbmZ1bmN0aW9uIGFmdGVyKHBvcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwb3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IE1BWF9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAxKTtcbiAgfVxuICByZXR1cm4gcG9zICsgT05FO1xufVxuZnVuY3Rpb24gYmV0d2VlbihsbywgaGkpIHtcbiAgaWYgKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4obG8sIGhpKTtcbiAgfSBlbHNlIGlmIChsbyA+IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGhpLCBsbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmFsdWUgYmV0d2VlbiB0d28gZXF1YWwgcG9zaXRpb25zXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfYmV0d2VlbihsbywgaGkpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbG9MZW4gPSBsby5sZW5ndGg7XG4gIGNvbnN0IGhpTGVuID0gaGkubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvQ29kZSA9IGluZGV4IDwgbG9MZW4gPyBsby5jaGFyQ29kZUF0KGluZGV4KSA6IE1JTl9DT0RFO1xuICAgIGNvbnN0IGhpQ29kZSA9IGluZGV4IDwgaGlMZW4gPyBoaS5jaGFyQ29kZUF0KGluZGV4KSA6IE1BWF9DT0RFO1xuICAgIGlmIChsb0NvZGUgPT09IGhpQ29kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaGlDb2RlIC0gbG9Db2RlID09PSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gaW5kZXggKyAxO1xuICAgICAgbGV0IHByZWZpeCA9IGxvLnN1YnN0cmluZygwLCBzaXplKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBwcmVmaXggKz0gWkVSTy5yZXBlYXQoc2l6ZSAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gbG8uc3Vic3RyaW5nKHNpemUpO1xuICAgICAgY29uc3QgbmluZXMgPSBcIlwiO1xuICAgICAgcmV0dXJuIHByZWZpeCArIF9iZXR3ZWVuKHN1ZmZpeCwgbmluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFrZU4obG8sIGluZGV4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlDb2RlICsgbG9Db2RlID4+IDEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFrZU4ocG9zLCBuKSB7XG4gIHJldHVybiBuIDwgcG9zLmxlbmd0aCA/IHBvcy5zdWJzdHJpbmcoMCwgbikgOiBwb3MgKyBaRVJPLnJlcGVhdChuIC0gcG9zLmxlbmd0aCk7XG59XG52YXIgTUlOX05PTl9aRVJPX0NPREUgPSBNSU5fQ09ERSArIDE7XG5mdW5jdGlvbiBpc1BvcyhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0SWR4ID0gc3RyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGxhc3QgPSBzdHIuY2hhckNvZGVBdChsYXN0SWR4KTtcbiAgaWYgKGxhc3QgPCBNSU5fTk9OX1pFUk9fQ09ERSB8fCBsYXN0ID4gTUFYX0NPREUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3Moc3RyKSB7XG4gIGNvbnN0IGNvZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGVzLnB1c2goY29kZSA8IE1JTl9DT0RFID8gTUlOX0NPREUgOiBjb2RlID4gTUFYX0NPREUgPyBNQVhfQ09ERSA6IGNvZGUpO1xuICB9XG4gIHdoaWxlIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID09PSBNSU5fQ09ERSkge1xuICAgIGNvZGVzLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBjb2Rlcy5sZW5ndGggPiAwID8gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2RlcykgOiAoXG4gICAgLy8gRWRnZSBjYXNlOiB0aGUgc3RyIHdhcyBhIDAtb25seSBzdHJpbmcsIHdoaWNoIGlzIGludmFsaWQuIERlZmF1bHQgYmFjayB0byAuMVxuICAgIE9ORVxuICApO1xufVxuZnVuY3Rpb24gYXNQb3Moc3RyKSB7XG4gIHJldHVybiBpc1BvcyhzdHIpID8gc3RyIDogY29udmVydFRvUG9zKHN0cik7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9PcC50c1xudmFyIE9wQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE9wQ29kZTIpID0+IHtcbiAgT3BDb2RlMltPcENvZGUyW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlNFVF9QQVJFTlRfS0VZXCJdID0gMV0gPSBcIlNFVF9QQVJFTlRfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9MSVNUXCJdID0gMl0gPSBcIkNSRUFURV9MSVNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlVQREFURV9PQkpFQ1RcIl0gPSAzXSA9IFwiVVBEQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfT0JKRUNUXCJdID0gNF0gPSBcIkNSRUFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX0NSRFRcIl0gPSA1XSA9IFwiREVMRVRFX0NSRFRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX09CSkVDVF9LRVlcIl0gPSA2XSA9IFwiREVMRVRFX09CSkVDVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX01BUFwiXSA9IDddID0gXCJDUkVBVEVfTUFQXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9SRUdJU1RFUlwiXSA9IDhdID0gXCJDUkVBVEVfUkVHSVNURVJcIjtcbiAgcmV0dXJuIE9wQ29kZTI7XG59KShPcENvZGUgfHwge30pO1xuZnVuY3Rpb24gYWNrT3Aob3BJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgaWQ6IFwiQUNLXCIsXG4gICAgLy8gKEgpQUNLXG4gICAgb3BJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNBY2tPcChvcCkge1xuICByZXR1cm4gb3AudHlwZSA9PT0gNSAvKiBERUxFVEVfQ1JEVCAqLyAmJiBvcC5pZCA9PT0gXCJBQ0tcIjtcbn1cblxuLy8gc3JjL2NyZHRzL0Fic3RyYWN0Q3JkdC50c1xuZnVuY3Rpb24gY3JkdEFzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gSGFzUGFyZW50KG5vZGUsIGtleSwgcG9zID0gYXNQb3Moa2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiSGFzUGFyZW50XCIsIG5vZGUsIGtleSwgcG9zIH0pO1xufVxudmFyIE5vUGFyZW50ID0gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiTm9QYXJlbnRcIiB9KTtcbmZ1bmN0aW9uIE9ycGhhbmVkKG9sZEtleSwgb2xkUG9zID0gYXNQb3Mob2xkS2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiT3JwaGFuZWRcIiwgb2xkS2V5LCBvbGRQb3MgfSk7XG59XG52YXIgQWJzdHJhY3RDcmR0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0UGFyZW50S2V5T3JUaHJvdygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50UG9zKCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zO1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkUG9zO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wb29sKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbDtcbiAgfVxuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbCA/IHRoaXMuX19wb29sLnJvb21JZCA6IG51bGw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX2lkKCkge1xuICAgIHJldHVybiB0aGlzLl9faWQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3BhcmVudEtleSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBfaXNMb2NhbCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGUuX2RldGFjaENoaWxkKGNyZHRBc0xpdmVOb2RlKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2V0UGFyZW50TGluayhuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Lm5vZGUgIT09IG5ld1BhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHBhcmVudDogbm9kZSBhbHJlYWR5IGhhcyBhIHBhcmVudFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBpZiAodGhpcy5fX2lkIHx8IHRoaXMuX19wb29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXR0YWNoIG5vZGU6IGFscmVhZHkgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIHBvb2wuYWRkTm9kZShpZCwgY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgIHRoaXMuX19pZCA9IGlkO1xuICAgIHRoaXMuX19wb29sID0gcG9vbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgaWYgKHRoaXMuX19wb29sICYmIHRoaXMuX19pZCkge1xuICAgICAgdGhpcy5fX3Bvb2wuZGVsZXRlTm9kZSh0aGlzLl9faWQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBPcnBoYW5lZCh0aGlzLnBhcmVudC5rZXksIHRoaXMucGFyZW50LnBvcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9fcG9vbCA9IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIENsZWFyIHRoZSBJbW11dGFibGUgY2FjaGUsIHNvIHRoYXQgdGhlIG5leHQgY2FsbCB0byBgLnRvSW1tdXRhYmxlKClgIHdpbGxcbiAgICogcmVjb21wdXRlIHRoZSBlcXVpdmFsZW50IEltbXV0YWJsZSB2YWx1ZSBhZ2Fpbi4gIENhbGwgdGhpcyBhZnRlciBldmVyeVxuICAgKiBtdXRhdGlvbiB0byB0aGUgTGl2ZSBub2RlLlxuICAgKi9cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlICE9PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBSZXR1cm4gYW4gc25hcHNob3Qgb2YgdGhpcyBMaXZlIHRyZWUgZm9yIHVzZSBpbiBEZXZUb29scy5cbiAgICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFRyZWVOb2RlID09PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgIT09IGtleSkge1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgPSBrZXk7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHRoaXMuX3RvVHJlZU5vZGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFRyZWVOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaW1tdXRhYmxlIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuICB0b0ltbXV0YWJsZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlZEltbXV0YWJsZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbW11dGFibGU7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJpYWxpemVkQ3JkdC50c1xudmFyIENyZHRUeXBlID0gLyogQF9fUFVSRV9fICovICgoQ3JkdFR5cGUyKSA9PiB7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJPQkpFQ1RcIl0gPSAwXSA9IFwiT0JKRUNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJMSVNUXCJdID0gMV0gPSBcIkxJU1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk1BUFwiXSA9IDJdID0gXCJNQVBcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIlJFR0lTVEVSXCJdID0gM10gPSBcIlJFR0lTVEVSXCI7XG4gIHJldHVybiBDcmR0VHlwZTI7XG59KShDcmR0VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1Jvb3RDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8gJiYgIWlzQ2hpbGRDcmR0KGNyZHQpO1xufVxuZnVuY3Rpb24gaXNDaGlsZENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC5wYXJlbnRJZCAhPT0gdm9pZCAwICYmIGNyZHQucGFyZW50S2V5ICE9PSB2b2lkIDA7XG59XG5cbi8vIHNyYy9saWIvbmFub2lkLnRzXG5mdW5jdGlvbiBuYW5vaWQobGVuZ3RoID0gNykge1xuICBjb25zdCBhbHBoYWJldCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODksLi87W11+IUAjJCUmKigpXys9LVwiO1xuICBjb25zdCBsZW4gPSBhbHBoYWJldC5sZW5ndGg7XG4gIHJldHVybiBBcnJheS5mcm9tKFxuICAgIHsgbGVuZ3RoIH0sXG4gICAgKCkgPT4gYWxwaGFiZXQuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbikpXG4gICkuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL2NyZHRzL0xpdmVSZWdpc3Rlci50c1xudmFyIExpdmVSZWdpc3RlciA9IGNsYXNzIF9MaXZlUmVnaXN0ZXIgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgX3BhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCByZWdpc3RlciA9IG5ldyBfTGl2ZVJlZ2lzdGVyKGl0ZW0uZGF0YSk7XG4gICAgcmVnaXN0ZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBzZXJpYWxpemUgcmVnaXN0ZXIgaWYgcGFyZW50SWQgb3IgcGFyZW50S2V5IGlzIHVuZGVmaW5lZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgcGFyZW50SWQsXG4gICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZVJlZ2lzdGVyIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMyAvKiBSRUdJU1RFUiAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKF9vcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKF9jcmR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkpzb25cIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2RhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5kYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVMaXN0LnRzXG5mdW5jdGlvbiBjb21wYXJlTm9kZVBvc2l0aW9uKGl0ZW1BLCBpdGVtQikge1xuICBjb25zdCBwb3NBID0gaXRlbUEuX3BhcmVudFBvcztcbiAgY29uc3QgcG9zQiA9IGl0ZW1CLl9wYXJlbnRQb3M7XG4gIHJldHVybiBwb3NBID09PSBwb3NCID8gMCA6IHBvc0EgPCBwb3NCID8gLTEgOiAxO1xufVxudmFyIExpdmVMaXN0ID0gY2xhc3MgX0xpdmVMaXN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHBvc2l0aW9uID0gdm9pZCAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBtYWtlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdQb3NpdGlvbik7XG4gICAgICB0aGlzLl9pdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBsaXN0ID0gbmV3IF9MaXZlTGlzdChbXSk7XG4gICAgbGlzdC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGlzdCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbGlzdC5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdGluZyBvcHMgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgaWYgdGhleSBoYXZlIGFuICdvcElkJ1xuICAgKiBzbyB3ZSBtdXRhdGUgX3VuYWNrbm93bGVkZ2VkU2V0cyB0byBhdm9pZCBwb3RlbnRpYWwgZmxpY2tlcmluZ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL3B1bGwvMTE3N1xuICAgKlxuICAgKiBUaGlzIGlzIHF1aXRlIHVuaW50dWl0aXZlIGFuZCBzaG91bGQgZGlzYXBwZWFyIGFzIHNvb24gYXNcbiAgICogd2UgaW50cm9kdWNlIGFuIGV4cGxpY2l0IExpdmVMaXN0LlNldCBvcGVyYXRpb25cbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleTIgPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgICBjb25zdCBjaGlsZE9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwYXJlbnRLZXkyLCBwb29sKSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY29uc3QgY2hpbGRPcElkID0gY2hpbGRPcHNbMF0ub3BJZDtcbiAgICAgIGlmIChjaGlsZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KHBhcmVudEtleTIsIGNoaWxkT3BJZCk7XG4gICAgICB9XG4gICAgICBvcHMucHVzaCguLi5jaGlsZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gaW50byB0aGUgc29ydGVkIGxpc3QsIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgKi9cbiAgX2luc2VydEFuZFNvcnQoaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc29ydEl0ZW1zKCkge1xuICAgIHRoaXMuX2l0ZW1zLnNvcnQoY29tcGFyZU5vZGVQb3NpdGlvbik7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5kZXhPZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkgPT09IHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRSZW1vdGUob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBkZWxldGVkSWQgPSBvcC5kZWxldGVkSWQ7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXTtcbiAgICAgIGlmIChpdGVtV2l0aFNhbWVQb3NpdGlvbi5faWQgPT09IGRlbGV0ZWRJZCkge1xuICAgICAgICBpdGVtV2l0aFNhbWVQb3NpdGlvbi5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChpdGVtV2l0aFNhbWVQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB1cGRhdGVzLnB1c2goaW5zZXJ0RGVsdGEodGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSksIGNoaWxkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbXSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgdXBkYXRlcylcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0QWNrKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgIH1cbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wSWQgPSB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZ2V0KG9wLnBhcmVudEtleSk7XG4gICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSBvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5sZW5ndGggPT09IDAgPyB7IG1vZGlmaWVkOiBmYWxzZSB9IDogeyBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksIHJldmVyc2U6IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZGVsZXRlKG9wLnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IG9wLnBhcmVudEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoXG4gICAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgZGVsdGEucHVzaChtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gdGhpcy5fcG9vbC5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCByZWNyZWF0ZWRJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKG9ycGhhbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbikgOiBzZXREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbiksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KFxuICAgICAgICAgIG9wLFxuICAgICAgICAgIG9wLnBhcmVudEtleVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pIDogc2V0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIGRlbHRhIG9mIHRoZSBkZWxldGlvbiBvciBudWxsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oZGVsZXRlZElkKSB7XG4gICAgaWYgKGRlbGV0ZWRJZCA9PT0gdm9pZCAwIHx8IHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtID0gdGhpcy5fcG9vbC5nZXROb2RlKGRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWRJdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZXRhY2hDaGlsZChkZWxldGVkSXRlbSk7XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lm1vZGlmaWVkLnVwZGF0ZXNbMF07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlSZW1vdGVJbnNlcnQob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oZXhpc3RpbmdJdGVtSW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICByZXZlcnNlOiBbXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlJbnNlcnRBY2sob3ApIHtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgaXRlbUluZGV4QXRQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0pIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbkluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSBvbGRQb3NpdGlvbkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEob2xkUG9zaXRpb25JbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSBubih0aGlzLl9wb29sKS5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgb3JwaGFuKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBsZXQgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0/Ll9wYXJlbnRQb3M7XG4gICAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zO1xuICAgICAgbmV3S2V5ID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XSA9IGNoaWxkO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvcC5pZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gW3NldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXksIGNoaWxkKV07XG4gICAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvcC5pbnRlbnQgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0UmVtb3RlKG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlSZW1vdGVJbnNlcnQob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhubih0aGlzLl9pZCksIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXhUb0RlbGV0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUpXSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCkge1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBjaGlsZC5fcGFyZW50S2V5O1xuICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQ6IG5uKGNoaWxkLl9pZCksXG4gICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c0tleVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRDaGlsZEtleShuZXdLZXksIGNoaWxkLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZUxpc3QgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzLlxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9uZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHJldHVybiB0aGlzLmluc2VydChlbGVtZW50LCB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgb25lIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB5b3Ugd2FudCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqL1xuICBpbnNlcnQoZWxlbWVudCwgaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnNlcnQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0gPyB0aGlzLl9pdGVtc1tpbmRleCAtIDFdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgYWZ0ZXIyID0gdGhpcy5faXRlbXNbaW5kZXhdID8gdGhpcy5faXRlbXNbaW5kZXhdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGVsZW1lbnQpO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShpbmRleCwgdmFsdWUpXSldXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSBvbmUgZWxlbWVudCBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHRhcmdldEluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgZWxlbWVudCBzaG91bGQgYmUgYWZ0ZXIgbW92aW5nLlxuICAgKi9cbiAgbW92ZShpbmRleCwgdGFyZ2V0SW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInRhcmdldEluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGxldCBiZWZvcmVQb3NpdGlvbiA9IG51bGw7XG4gICAgbGV0IGFmdGVyUG9zaXRpb24gPSBudWxsO1xuICAgIGlmIChpbmRleCA8IHRhcmdldEluZGV4KSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCArIDFdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSAwID8gdm9pZCAwIDogdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXggLSAxXS5fcGFyZW50UG9zO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmVQb3NpdGlvbiwgYWZ0ZXJQb3NpdGlvbik7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEoaW5kZXgsIHRhcmdldEluZGV4LCBpdGVtKV0pXVxuICAgICAgXSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGVsZXRlIGxpc3QgaXRlbSBhdCBpbmRleCBcIiR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IGNoaWxkUmVjb3JkSWQgPSBpdGVtLl9pZDtcbiAgICAgIGlmIChjaGlsZFJlY29yZElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIG5uKHRoaXMuX2lkKSxcbiAgICAgICAgICBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleCldKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IGNoaWxkUmVjb3JkSWQsXG4gICAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGl0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKSxcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICAgIGNvbnN0IHVwZGF0ZURlbHRhID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICAgIGNvbnN0IGNoaWxkSWQgPSBpdGVtLl9pZDtcbiAgICAgICAgaWYgKGNoaWxkSWQpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKFxuICAgICAgICAgICAgLi4uaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1cGRhdGVEZWx0YS5wdXNoKGRlbGV0ZURlbHRhKDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KG5uKHRoaXMuX2lkKSwgbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVEZWx0YSkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQoaW5kZXgsIGl0ZW0pIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgY29uc3QgcG9zaXRpb24gPSBleGlzdGluZ0l0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBjb25zdCBleGlzdGluZ0lkID0gZXhpc3RpbmdJdGVtLl9pZDtcbiAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XSA9IHZhbHVlO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW3NldERlbHRhKGluZGV4LCB2YWx1ZSldKSk7XG4gICAgICBjb25zdCBvcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgZXhpc3RpbmdJZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocG9zaXRpb24sIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHZvaWQgMCksXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgb2YgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnkpID0+IGxpdmVOb2RlVG9Mc29uKGVudHJ5KVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhbGwgZWxlbWVudHMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LCB0YWtpbmcgdHdvIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCkuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBldmVyeSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBvZiB0aGUgTGl2ZUxpc3QuIFJldHVybiBhIHZhbHVlIHRoYXQgY29lcmNlcyB0byB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIG9yIHRvIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0LlxuICAgKi9cbiAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maWx0ZXIocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUuXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uIE90aGVyd2lzZSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZmluZChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHBhc3NlcyB0aGUgdGVzdC4gT3RoZXJ3aXNlLCAtMS5cbiAgICovXG4gIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvbiB0aGUgZWxlbWVudCB0byBnZXQuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih0aGlzLl9pdGVtc1tpbmRleF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0OyAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBpbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LiBUaGUgTGl2ZUxzaXQgaXMgc2VhcmNoZWQgYmFja3dhcmRzLCBzdGFydGluZyBhdCBmcm9tSW5kZXguXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgYmFja3dhcmRzLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZXZlcnkgZWxlbWVudC5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBtYXAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubWFwKFxuICAgICAgKGVudHJ5LCBpKSA9PiBjYWxsYmFjayhcbiAgICAgICAgbGl2ZU5vZGVUb0xzb24oZW50cnkpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgICAgIGlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCBwYXNzZXMgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBzb21lKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5zb21lKHByZWRpY2F0ZSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdEl0ZXJhdG9yKHRoaXMuX2l0ZW1zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KSB7XG4gICAgY29uc3QgbmV3SXRlbSA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBuZXdJdGVtLl9hdHRhY2gob3AuaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBuZXdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChuZXdJdGVtKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIHJldHVybiB7IG5ld0l0ZW0sIG5ld0luZGV4IH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2hpZnRJdGVtUG9zaXRpb24oaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMuX2l0ZW1zW2luZGV4ICsgMV0/Ll9wYXJlbnRQb3MgOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XS5fc2V0UGFyZW50TGluayh0aGlzLCBzaGlmdGVkUG9zaXRpb24pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpdGVtLnRvVHJlZU5vZGUoaW5kZXgudG9TdHJpbmcoKSlcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2l0ZW1zLm1hcCgobm9kZSkgPT4gbm9kZS50b0ltbXV0YWJsZSgpKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVMaXN0KHRoaXMuX2l0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5jbG9uZSgpKSk7XG4gIH1cbn07XG52YXIgTGl2ZUxpc3RJdGVyYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICB0aGlzLl9pbm5lckl0ZXJhdG9yID0gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5leHQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1ha2VVcGRhdGUobGl2ZUxpc3QsIGRlbHRhVXBkYXRlcykge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGxpdmVMaXN0LFxuICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICB1cGRhdGVzOiBkZWx0YVVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlRGVsdGEoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImRlbGV0ZVwiXG4gIH07XG59XG5mdW5jdGlvbiBpbnNlcnREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24ob3BzLCBkZWxldGVkSWQpIHtcbiAgcmV0dXJuIG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlyc3RPcCA9IG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlyc3RPcCxcbiAgICAgICAgaW50ZW50OiBcInNldFwiLFxuICAgICAgICBkZWxldGVkSWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL2ZyZWV6ZS50c1xudmFyIGZyZWV6ZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IChcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKHgpID0+IHhcbikgOiBPYmplY3QuZnJlZXplO1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU1hcC50c1xudmFyIExpdmVNYXAgPSBjbGFzcyBfTGl2ZU1hcCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZW50cmllczIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbWFwcGVkRW50cmllcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAobWFwcGVkRW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgX2l0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IF9MaXZlTWFwKCk7XG4gICAgbWFwLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKG1hcCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbWFwLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBtYXAuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5LCBvcElkIH0gPSBvcDtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXk7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICBjb25zdCBsYXN0VXBkYXRlT3BJZCA9IHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZ2V0KGtleSk7XG4gICAgICBpZiAobGFzdFVwZGF0ZU9wSWQgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9IGVsc2UgaWYgKGxhc3RVcGRhdGVPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIHVwZGF0ZXM6IHsgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LnNldChrZXksIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb2xkVmFsdWUgPyBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkgOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlLlxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAoaXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiBpdGVtLl9pZCkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXNJZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBMaXZlT2JqZWN0ID0gY2xhc3MgX0xpdmVPYmplY3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcykge1xuICAgIGNvbnN0IHBhcmVudFRvQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCByb290ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpc1Jvb3RDcmR0KGNyZHQpKSB7XG4gICAgICAgIHJvb3QgPSBbaWQsIGNyZHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBbaWQsIGNyZHRdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGNyZHQucGFyZW50SWQpO1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2godHVwbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRvQ2hpbGRyZW4uc2V0KGNyZHQucGFyZW50SWQsIFt0dXBsZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IGNhbid0IGJlIG51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0Ll9idWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fbWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIGlmIChvcC50eXBlID09PSAzIC8qIFVQREFURV9PQkpFQ1QgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVVwZGF0ZShvcCwgaXNMb2NhbCk7XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmICghaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIHRoaXMucGFyZW50Lm5vZGUuX2lkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgcGFyZW50SWQ6IHRoaXMucGFyZW50Lm5vZGUuX2lkLFxuICAgICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKSB7XG4gICAgbGV0IGlzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCByZXZlcnNlID0gW107XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZSA9IHtcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHMoaWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZS5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZCwga2V5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3AuZGF0YVtrZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcC5vcElkKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGUuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBpc01vZGlmaWVkID8ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH0gOiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLl9tYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9tYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoW10pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IEpTT04uc3RyaW5naWZ5KGNyZHQuZGF0YSkgIT09IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvZGVidWcudHNcbmZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG1zZywgdHJhY2VSb290KSB7XG4gIGNvbnN0IGVycm9yTGlrZSA9IHsgbmFtZTogbXNnIH07XG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3JMaWtlLCB0cmFjZVJvb3QpO1xuICByZXR1cm4gZXJyb3JMaWtlLnN0YWNrO1xufVxuXG4vLyBzcmMvbGliL0pzb24udHNcbmZ1bmN0aW9uIGlzSnNvblNjYWxhcihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSnNvbkFycmF5KGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoZGF0YSkge1xuICByZXR1cm4gIWlzSnNvblNjYWxhcihkYXRhKSAmJiAhaXNKc29uQXJyYXkoZGF0YSk7XG59XG5cbi8vIHNyYy9saWIvb2JqZWN0VG9RdWVyeS50c1xudmFyIGlkZW50aWZpZXJSZWdleCA9IC9eW2EtekEtWl9dW2EtekEtWjAtOV9dKiQvO1xuZnVuY3Rpb24gb2JqZWN0VG9RdWVyeShvYmopIHtcbiAgbGV0IGZpbHRlckxpc3QgPSBbXTtcbiAgY29uc3QgZW50cmllczIgPSBPYmplY3QuZW50cmllcyhvYmopO1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzID0gW107XG4gIGNvbnN0IGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IgPSBbXTtcbiAgY29uc3QgaW5kZXhlZEtleXMgPSBbXTtcbiAgZW50cmllczIuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKCFpZGVudGlmaWVyUmVnZXgudGVzdChrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgbXVzdCBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgX1wiKTtcbiAgICB9XG4gICAgaWYgKGlzU2ltcGxlVmFsdWUodmFsdWUpKSB7XG4gICAgICBrZXlWYWx1ZVBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9IGVsc2UgaWYgKGlzVmFsdWVXaXRoT3BlcmF0b3IodmFsdWUpKSB7XG4gICAgICBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhKFwic3RhcnRzV2l0aFwiIGluIHZhbHVlKSkge1xuICAgICAgaW5kZXhlZEtleXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH1cbiAgfSk7XG4gIGZpbHRlckxpc3QgPSBbXG4gICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzKGtleVZhbHVlUGFpcnMpLFxuICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcihrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKVxuICBdO1xuICBpbmRleGVkS2V5cy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBuZXN0ZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICAgIGNvbnN0IG5LZXlWYWx1ZVBhaXJzID0gW107XG4gICAgY29uc3QgbktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IgPSBbXTtcbiAgICBuZXN0ZWRFbnRyaWVzLmZvckVhY2goKFtuZXN0ZWRLZXksIG5lc3RlZFZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGlzU3RyaW5nRW1wdHkobmVzdGVkS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2ltcGxlVmFsdWUobmVzdGVkVmFsdWUpKSB7XG4gICAgICAgIG5LZXlWYWx1ZVBhaXJzLnB1c2goW2Zvcm1hdEZpbHRlcktleShrZXksIG5lc3RlZEtleSksIG5lc3RlZFZhbHVlXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsdWVXaXRoT3BlcmF0b3IobmVzdGVkVmFsdWUpKSB7XG4gICAgICAgIG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLnB1c2goW1xuICAgICAgICAgIGZvcm1hdEZpbHRlcktleShrZXksIG5lc3RlZEtleSksXG4gICAgICAgICAgbmVzdGVkVmFsdWVcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmlsdGVyTGlzdCA9IFtcbiAgICAgIC4uLmZpbHRlckxpc3QsXG4gICAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMobktleVZhbHVlUGFpcnMpLFxuICAgICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKVxuICAgIF07XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyTGlzdC5tYXAoXG4gICAgKHsga2V5LCBvcGVyYXRvciwgdmFsdWUgfSkgPT4gZm9ybWF0RmlsdGVyKGtleSwgb3BlcmF0b3IsIGZvcm1hdEZpbHRlclZhbHVlKHZhbHVlKSlcbiAgKS5qb2luKFwiIEFORCBcIik7XG59XG52YXIgZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzID0gKGtleVZhbHVlUGFpcnMpID0+IHtcbiAgY29uc3QgZmlsdGVycyA9IFtdO1xuICBrZXlWYWx1ZVBhaXJzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICBrZXksXG4gICAgICBvcGVyYXRvcjogXCI6XCIsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcnM7XG59O1xudmFyIGdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IChrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKSA9PiB7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoXCJzdGFydHNXaXRoXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgb3BlcmF0b3I6IFwiXlwiLFxuICAgICAgICB2YWx1ZTogdmFsdWUuc3RhcnRzV2l0aFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZpbHRlcnM7XG59O1xudmFyIGlzU2ltcGxlVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgaXNWYWx1ZVdpdGhPcGVyYXRvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIFwic3RhcnRzV2l0aFwiIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBmb3JtYXRGaWx0ZXIgPSAoa2V5LCBvcGVyYXRvciwgdmFsdWUpID0+IHtcbiAgcmV0dXJuIGAke2tleX0ke29wZXJhdG9yfSR7dmFsdWV9YDtcbn07XG52YXIgZm9ybWF0RmlsdGVyS2V5ID0gKGtleSwgbmVzdGVkS2V5KSA9PiB7XG4gIGlmIChuZXN0ZWRLZXkpIHtcbiAgICByZXR1cm4gYCR7a2V5fVske0pTT04uc3RyaW5naWZ5KG5lc3RlZEtleSl9XWA7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG52YXIgZm9ybWF0RmlsdGVyVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChpc1N0cmluZ0VtcHR5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufTtcbnZhciBpc1N0cmluZ0VtcHR5ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAhdmFsdWUgfHwgdmFsdWUudG9TdHJpbmcoKS50cmltKCkgPT09IFwiXCI7XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQ2xpZW50TXNnLnRzXG52YXIgQ2xpZW50TXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENsaWVudE1zZ0NvZGUyKSA9PiB7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiQlJPQURDQVNUX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNUX0VWRU5UXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfU1RPUkFHRVwiXSA9IDIwMF0gPSBcIkZFVENIX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfWURPQ1wiXSA9IDMwMF0gPSBcIkZFVENIX1lET0NcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMV0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIHJldHVybiBDbGllbnRNc2dDb2RlMjtcbn0pKENsaWVudE1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvcmVmcy9JbW11dGFibGVSZWYudHNcbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgcGF0Y2gpIHtcbiAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgbmV3VmFsdWUgPSB7IC4uLnRhcmdldCB9O1xuICBPYmplY3Qua2V5cyhwYXRjaCkuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgY29uc3QgdmFsID0gcGF0Y2hba2V5XTtcbiAgICBpZiAobmV3VmFsdWVba2V5XSAhPT0gdmFsKSB7XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIG5ld1ZhbHVlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZWQgPyBuZXdWYWx1ZSA6IHRhcmdldDtcbn1cbnZhciBJbW11dGFibGVSZWYgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2V2ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIH1cbiAgZ2V0IGRpZEludmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2Lm9ic2VydmFibGU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9ldi5ub3RpZnkoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlID8/ICh0aGlzLl9jYWNoZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9PdGhlcnNSZWYudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBPdGhlcnNSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3ByZXNlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGNvbm5lY3Rpb25JZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25zLmtleXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCB1c2VycyA9IGNvbXBhY3QoXG4gICAgICBBcnJheS5mcm9tKHRoaXMuX3ByZXNlbmNlcy5rZXlzKCkpLm1hcChcbiAgICAgICAgKGNvbm5lY3Rpb25JZCkgPT4gdGhpcy5nZXRVc2VyKE51bWJlcihjb25uZWN0aW9uSWQpKVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIHVzZXJzO1xuICB9XG4gIGNsZWFyT3RoZXJzKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNvbm4gPSB0aGlzLl9jb25uZWN0aW9ucy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHRoaXMuX3ByZXNlbmNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY29ubiAhPT0gdm9pZCAwICYmIHByZXNlbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYWtlVXNlcihjb25uLCBwcmVzZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZ2V0VXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBjb25zdCBjYWNoZWRVc2VyID0gdGhpcy5fdXNlcnMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLl9nZXRVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNvbXB1dGVkVXNlcikge1xuICAgICAgdGhpcy5fdXNlcnMuc2V0KGNvbm5lY3Rpb25JZCwgY29tcHV0ZWRVc2VyKTtcbiAgICAgIHJldHVybiBjb21wdXRlZFVzZXI7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl91c2Vycy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY29yZHMgYSBrbm93biBjb25uZWN0aW9uLiBUaGlzIHJlY29yZHMgdGhlIGNvbm5lY3Rpb24gSUQgYW5kIHRoZVxuICAgKiBhc3NvY2lhdGVkIG1ldGFkYXRhLlxuICAgKi9cbiAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIG1ldGFVc2VySWQsIG1ldGFVc2VySW5mbywgc2NvcGVzKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuc2V0KFxuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgZnJlZXplKHtcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgaW5mbzogbWV0YVVzZXJJbmZvLFxuICAgICAgICBzY29wZXNcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAodGhpcy5fcHJlc2VuY2VzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIGtub3duIGNvbm5lY3Rpb25JZC4gUmVtb3ZlcyBib3RoIHRoZSBjb25uZWN0aW9uJ3MgbWV0YWRhdGEgYW5kXG4gICAqIHRoZSBwcmVzZW5jZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlcyBhIG5ldyB1c2VyIGZyb20gYSBmdWxsIHByZXNlbmNlIHVwZGF0ZS4gSWYgdGhlIHVzZXIgYWxyZWFkeSBleGlzdHMsXG4gICAqIGl0cyBrbm93biBwcmVzZW5jZSBkYXRhIGlzIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgc2V0T3RoZXIoY29ubmVjdGlvbklkLCBwcmVzZW5jZSkge1xuICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUoY29tcGFjdE9iamVjdChwcmVzZW5jZSkpKTtcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbnMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBwcmVzZW5jZSBkYXRhIGZvciBhbiBleGlzdGluZyBcIm90aGVyXCIuIElmIHdlIGRvbid0IGtub3cgdGhlXG4gICAqIGluaXRpYWwgcHJlc2VuY2UgZGF0YSBmb3IgdGhpcyB1c2VyIHlldCwgZGlzY2FyZCB0aGlzIHBhdGNoIGFuZCBhd2FpdCB0aGVcbiAgICogZnVsbCAuc2V0T3RoZXIoKSBjYWxsIGZpcnN0LlxuICAgKi9cbiAgcGF0Y2hPdGhlcihjb25uZWN0aW9uSWQsIHBhdGNoKSB7XG4gICAgY29uc3Qgb2xkUHJlc2VuY2UgPSB0aGlzLl9wcmVzZW5jZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgIGlmIChvbGRQcmVzZW5jZSAhPT0gbmV3UHJlc2VuY2UpIHtcbiAgICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUobmV3UHJlc2VuY2UpKTtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9QYXRjaGFibGVSZWYudHNcbnZhciBQYXRjaGFibGVSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBmcmVlemUoY29tcGFjdE9iamVjdChkYXRhKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoZXMgdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgKi9cbiAgcGF0Y2gocGF0Y2gpIHtcbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBuZXdEYXRhID0gbWVyZ2Uob2xkRGF0YSwgcGF0Y2gpO1xuICAgIGlmIChvbGREYXRhICE9PSBuZXdEYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZnJlZXplKG5ld0RhdGEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9WYWx1ZVJlZi50c1xudmFyIFZhbHVlUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKGluaXRpYWxWYWx1ZSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKG5ld1ZhbHVlKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxufTtcbnZhciBEZXJpdmVkUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IGFyZ3MucG9wKCk7XG4gICAgY29uc3Qgb3RoZXJSZWZzID0gYXJncztcbiAgICB0aGlzLl9yZWZzID0gb3RoZXJSZWZzO1xuICAgIHRoaXMuX3JlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICByZWYuZGlkSW52YWxpZGF0ZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5pbnZhbGlkYXRlKCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybUZuO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0oXG4gICAgICAuLi50aGlzLl9yZWZzLm1hcCgocmVmKSA9PiByZWYuY3VycmVudClcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvcm9vbS50c1xudmFyIE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFID0gMTAyNCAqIDEwMjQgLSAxMDI0O1xuZnVuY3Rpb24gbWFrZUlkRmFjdG9yeShjb25uZWN0aW9uSWQpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgcmV0dXJuICgpID0+IGAke2Nvbm5lY3Rpb25JZH06JHtjb3VudCsrfWA7XG59XG5mdW5jdGlvbiB1c2VyVG9UcmVlTm9kZShrZXksIHVzZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlVzZXJcIixcbiAgICBpZDogYCR7dXNlci5jb25uZWN0aW9uSWR9YCxcbiAgICBrZXksXG4gICAgcGF5bG9hZDoge1xuICAgICAgY29ubmVjdGlvbklkOiB1c2VyLmNvbm5lY3Rpb25JZCxcbiAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgaW5mbzogdXNlci5pbmZvLFxuICAgICAgcHJlc2VuY2U6IHVzZXIucHJlc2VuY2UsXG4gICAgICBpc1JlYWRPbmx5OiAhdXNlci5jYW5Xcml0ZVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluc3RhbGxCYWNrZ3JvdW5kVGFiU3B5KCkge1xuICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgY29uc3QgaW5CYWNrZ3JvdW5kU2luY2UgPSB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgIGlmIChkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA9IGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPz8gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRvYz8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgZG9jPy5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB9O1xuICByZXR1cm4gW2luQmFja2dyb3VuZFNpbmNlLCB1bnN1Yl07XG59XG52YXIgQ29tbWVudHNBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50c0FwaShyb29tSWQsIGdldEF1dGhWYWx1ZSwgZmV0Y2hDbGllbnRBcGkpIHtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb21tZW50c0FwaShlbmRwb2ludCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gYXdhaXQgZ2V0QXV0aFZhbHVlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKHJvb21JZCwgZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmZXRjaEpzb24oZW5kcG9pbnQsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDb21tZW50c0FwaShlbmRwb2ludCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IENvbW1lbnRzQXBpRXJyb3IoXG4gICAgICAgICAgICBlcnJvckJvZHkubWVzc2FnZSxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yQm9keVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBDb21tZW50c0FwaUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkcyhvcHRpb25zKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zPy5xdWVyeSkge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KG9wdGlvbnMucXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHNBcGkoXG4gICAgICBcIi90aHJlYWRzXCIsXG4gICAgICB7XG4gICAgICAgIHNpbmNlOiBvcHRpb25zPy5zaW5jZT8udG9JU09TdHJpbmcoKSxcbiAgICAgICAgcXVlcnlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiBqc29uLmRhdGEubWFwKCh0aHJlYWQpID0+IGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKSksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIChub3RpZmljYXRpb24pID0+IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShub3RpZmljYXRpb24pXG4gICAgICAgICksXG4gICAgICAgIGRlbGV0ZWRUaHJlYWRzOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChcbiAgICAgICAgICAoaW5mbykgPT4gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhpbmZvKVxuICAgICAgICApLFxuICAgICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIChpbmZvKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oaW5mbylcbiAgICAgICAgKSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkczogW10sXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogW10sXG4gICAgICAgIGRlbGV0ZWRUaHJlYWRzOiBbXSxcbiAgICAgICAgZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uczogW10sXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICByZXF1ZXN0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkcy5cIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZCh7IHRocmVhZElkIH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHNBcGkoXG4gICAgICBgL3RocmVhZC13aXRoLW5vdGlmaWNhdGlvbi8ke3RocmVhZElkfWBcbiAgICApO1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZDogY29udmVydFRvVGhyZWFkRGF0YShqc29uLnRocmVhZCksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uOiBqc29uLmluYm94Tm90aWZpY2F0aW9uID8gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKGpzb24uaW5ib3hOb3RpZmljYXRpb24pIDogdm9pZCAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aHJlYWQgJHt0aHJlYWRJZH0uYCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRocmVhZCh7XG4gICAgbWV0YWRhdGEsXG4gICAgYm9keSxcbiAgICBjb21tZW50SWQsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIGNvbnN0IHRocmVhZCA9IGF3YWl0IGZldGNoSnNvbihcIi90aHJlYWRzXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVUaHJlYWQoeyB0aHJlYWRJZCB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9YCwge1xuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdFRocmVhZE1ldGFkYXRhKHtcbiAgICBtZXRhZGF0YSxcbiAgICB0aHJlYWRJZFxuICB9KSB7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L21ldGFkYXRhYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzUmVzb2x2ZWQoeyB0aHJlYWRJZCB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vbWFyay1hcy1yZXNvbHZlZGAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQoeyB0aHJlYWRJZCB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vbWFyay1hcy11bnJlc29sdmVkYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGJvZHlcbiAgfSkge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50c2AsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdENvbW1lbnQoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBib2R5XG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVDb21tZW50Mih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkXG4gIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gYWRkUmVhY3Rpb24yKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX0vcmVhY3Rpb25zYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1vamkgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKHJlYWN0aW9uKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW1vdmVSZWFjdGlvbjIoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX0vcmVhY3Rpb25zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGVtb2ppKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0VGhyZWFkcyxcbiAgICBnZXRUaHJlYWQsXG4gICAgY3JlYXRlVGhyZWFkLFxuICAgIGRlbGV0ZVRocmVhZCxcbiAgICBlZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgbWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gICAgbWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICBjcmVhdGVDb21tZW50LFxuICAgIGVkaXRDb21tZW50LFxuICAgIGRlbGV0ZUNvbW1lbnQ6IGRlbGV0ZUNvbW1lbnQyLFxuICAgIGFkZFJlYWN0aW9uOiBhZGRSZWFjdGlvbjIsXG4gICAgcmVtb3ZlUmVhY3Rpb246IHJlbW92ZVJlYWN0aW9uMlxuICB9O1xufVxudmFyIE1BUktfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0JBVENIX0RFTEFZMiA9IDUwO1xuZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRpb25zLCBjb25maWcpIHtcbiAgY29uc3QgaW5pdGlhbFByZXNlbmNlID0gb3B0aW9ucy5pbml0aWFsUHJlc2VuY2U7XG4gIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gb3B0aW9ucy5pbml0aWFsU3RvcmFnZTtcbiAgY29uc3QgW2luQmFja2dyb3VuZFNpbmNlLCB1bmluc3RhbGxCZ1RhYlNweV0gPSBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpO1xuICBjb25zdCBkZWxlZ2F0ZXMgPSB7XG4gICAgLi4uY29uZmlnLmRlbGVnYXRlcyxcbiAgICAvLyBBIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byBnbyBpbnRvIFwiem9tYmllIHN0YXRlXCIgb25seSBpZiBhbGwgb2YgdGhlXG4gICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnMgYXBwbHk6XG4gICAgLy9cbiAgICAvLyAtIFRoZSBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIGNsaWVudCBvcHRpb24gaXMgY29uZmlndXJlZFxuICAgIC8vIC0gVGhlIGJyb3dzZXIgd2luZG93IGhhcyBiZWVuIGluIHRoZSBiYWNrZ3JvdW5kIGZvciBhdCBsZWFzdFxuICAgIC8vICAgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBtaWxsaXNlY29uZHNcbiAgICAvLyAtIFRoZXJlIGFyZSBubyBwZW5kaW5nIGNoYW5nZXNcbiAgICAvL1xuICAgIGNhblpvbWJpZSgpIHtcbiAgICAgIHJldHVybiBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgIT09IHZvaWQgMCAmJiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICE9PSBudWxsICYmIERhdGUubm93KCkgPiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICsgY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICYmIGdldFN0b3JhZ2VTdGF0dXMoKSAhPT0gXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYW5hZ2VkU29ja2V0ID0gbmV3IE1hbmFnZWRTb2NrZXQoXG4gICAgZGVsZWdhdGVzLFxuICAgIGNvbmZpZy5lbmFibGVEZWJ1Z0xvZ2dpbmdcbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBidWZmZXI6IHtcbiAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgbGFzdEZsdXNoZWRBdDogMCxcbiAgICAgIHByZXNlbmNlVXBkYXRlczogKFxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgaW5pdGlhbCBwcmVzZW5jZSBtZXNzYWdlIGFzIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGVcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgICAgIGRhdGE6IGluaXRpYWxQcmVzZW5jZVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdXG4gICAgfSxcbiAgICBzdGF0aWNTZXNzaW9uSW5mbzogbmV3IFZhbHVlUmVmKG51bGwpLFxuICAgIGR5bmFtaWNTZXNzaW9uSW5mbzogbmV3IFZhbHVlUmVmKG51bGwpLFxuICAgIG15UHJlc2VuY2U6IG5ldyBQYXRjaGFibGVSZWYoaW5pdGlhbFByZXNlbmNlKSxcbiAgICBvdGhlcnM6IG5ldyBPdGhlcnNSZWYoKSxcbiAgICBpbml0aWFsU3RvcmFnZSxcbiAgICBpZEZhY3Rvcnk6IG51bGwsXG4gICAgLy8gU3RvcmFnZVxuICAgIGNsb2NrOiAwLFxuICAgIG9wQ2xvY2s6IDAsXG4gICAgbm9kZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgcm9vdDogdm9pZCAwLFxuICAgIHVuZG9TdGFjazogW10sXG4gICAgcmVkb1N0YWNrOiBbXSxcbiAgICBwYXVzZWRIaXN0b3J5OiBudWxsLFxuICAgIGFjdGl2ZUJhdGNoOiBudWxsLFxuICAgIHVuYWNrbm93bGVkZ2VkT3BzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIC8vIERlYnVnXG4gICAgb3BTdGFja1RyYWNlczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSA6IHZvaWQgMFxuICB9O1xuICBjb25zdCBkb05vdEJhdGNoVXBkYXRlcyA9IChjYikgPT4gY2IoKTtcbiAgY29uc3QgYmF0Y2hVcGRhdGVzID0gY29uZmlnLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID8/IGRvTm90QmF0Y2hVcGRhdGVzO1xuICBsZXQgbGFzdFRva2VuS2V5O1xuICBmdW5jdGlvbiBvblN0YXR1c0RpZENoYW5nZShuZXdTdGF0dXMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZTtcbiAgICBpZiAoYXV0aFZhbHVlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0b2tlbktleSA9IGdldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSk7XG4gICAgICBpZiAodG9rZW5LZXkgIT09IGxhc3RUb2tlbktleSkge1xuICAgICAgICBsYXN0VG9rZW5LZXkgPSB0b2tlbktleTtcbiAgICAgICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBhdXRoVmFsdWUudG9rZW4ucGFyc2VkO1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmlkIDogdG9rZW4udWlkLFxuICAgICAgICAgICAgdXNlckluZm86IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pbmZvIDogdG9rZW4udWlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICAgICAgICB1c2VySWQ6IHZvaWQgMCxcbiAgICAgICAgICAgIHVzZXJJbmZvOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgZXZlbnRIdWIuc3RhdHVzLm5vdGlmeShuZXdTdGF0dXMpO1xuICAgICAgbm90aWZ5U2VsZkNoYW5nZWQoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICB9XG4gIGxldCBfY29ubmVjdGlvbkxvc3NUaW1lcklkO1xuICBsZXQgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQobmV3U3RhdHVzKSB7XG4gICAgaWYgKG5ld1N0YXR1cyA9PT0gXCJyZWNvbm5lY3RpbmdcIikge1xuICAgICAgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcImxvc3RcIik7XG4gICAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBjb250ZXh0Lm90aGVycy5jbGVhck90aGVycygpO1xuICAgICAgICAgIG5vdGlmeSh7IG90aGVyczogW3sgdHlwZTogXCJyZXNldFwiIH1dIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBjb25maWcubG9zdENvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KF9jb25uZWN0aW9uTG9zc1RpbWVySWQpO1xuICAgICAgaWYgKF9oYXNMb3N0Q29ubmVjdGlvbikge1xuICAgICAgICBpZiAobmV3U3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcImZhaWxlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwicmVzdG9yZWRcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRGlkQ29ubmVjdCgpIHtcbiAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgIGRhdGE6IChcbiAgICAgICAgLy8gQmVjYXVzZSBjb250ZXh0Lm1lLmN1cnJlbnQgaXMgYSByZWFkb25seSBvYmplY3QsIHdlJ2xsIGhhdmUgdG9cbiAgICAgICAgLy8gbWFrZSBhIGNvcHkgaGVyZS4gT3RoZXJ3aXNlLCB0eXBlIGVycm9ycyBoYXBwZW4gbGF0ZXIgd2hlblxuICAgICAgICAvLyBcInBhdGNoaW5nXCIgbXkgcHJlc2VuY2UuXG4gICAgICAgIHsgLi4uY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQgfVxuICAgICAgKVxuICAgIH07XG4gICAgaWYgKF9nZXRTdG9yYWdlJCAhPT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gb25EaWREaXNjb25uZWN0KCkge1xuICAgIGNsZWFyVGltZW91dChjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQpO1xuICB9XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTWVzc2FnZS5zdWJzY3JpYmUoaGFuZGxlU2VydmVyTWVzc2FnZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUob25TdGF0dXNEaWRDaGFuZ2UpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5zdGF0dXNEaWRDaGFuZ2Uuc3Vic2NyaWJlKGhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5kaWRDb25uZWN0LnN1YnNjcmliZShvbkRpZENvbm5lY3QpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5kaWREaXNjb25uZWN0LnN1YnNjcmliZShvbkRpZERpc2Nvbm5lY3QpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5vbkxpdmVibG9ja3NFcnJvci5zdWJzY3JpYmUoKGVycikgPT4ge1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGVycm9yMihcbiAgICAgICAgICBgQ29ubmVjdGlvbiB0byB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZC4gUmVhc29uOiAke2Vyci5tZXNzYWdlfSAoY29kZTogJHtlcnIuY29kZX0pLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50SHViLmVycm9yLm5vdGlmeShlcnIpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgcG9vbCA9IHtcbiAgICByb29tSWQ6IGNvbmZpZy5yb29tSWQsXG4gICAgZ2V0Tm9kZTogKGlkKSA9PiBjb250ZXh0Lm5vZGVzLmdldChpZCksXG4gICAgYWRkTm9kZTogKGlkLCBub2RlKSA9PiB2b2lkIGNvbnRleHQubm9kZXMuc2V0KGlkLCBub2RlKSxcbiAgICBkZWxldGVOb2RlOiAoaWQpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5kZWxldGUoaWQpLFxuICAgIGdlbmVyYXRlSWQ6ICgpID0+IGAke2dldENvbm5lY3Rpb25JZCgpfToke2NvbnRleHQuY2xvY2srK31gLFxuICAgIGdlbmVyYXRlT3BJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5vcENsb2NrKyt9YCxcbiAgICBkaXNwYXRjaChvcHMsIHJldmVyc2UsIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICBjb25zdCBhY3RpdmVCYXRjaCA9IGNvbnRleHQuYWN0aXZlQmF0Y2g7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrVHJhY2UgPSBjYXB0dXJlU3RhY2tUcmFjZShcIlN0b3JhZ2UgbXV0YXRpb25cIiwgdGhpcy5kaXNwYXRjaCk7XG4gICAgICAgIGlmIChzdGFja1RyYWNlKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICAgIGlmIChvcC5vcElkKSB7XG4gICAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuc2V0KG9wLm9wSWQsIHN0YWNrVHJhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZUJhdGNoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgICAgYWN0aXZlQmF0Y2gub3BzLnB1c2gob3ApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICAgICAgYWN0aXZlQmF0Y2gudXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlQmF0Y2gucmV2ZXJzZU9wcy51bnNoaWZ0KC4uLnJldmVyc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhyZXZlcnNlLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICBkaXNwYXRjaE9wcyhvcHMpO1xuICAgICAgICAgIG5vdGlmeSh7IHN0b3JhZ2VVcGRhdGVzIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3NlcnRTdG9yYWdlSXNXcml0YWJsZTogKCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVzID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uY3VycmVudD8uc2NvcGVzO1xuICAgICAgaWYgKHNjb3BlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKHNjb3Blcyk7XG4gICAgICBpZiAoIWNhbldyaXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCB3cml0ZSB0byBzdG9yYWdlIHdpdGggYSByZWFkIG9ubHkgdXNlciwgcGxlYXNlIGVuc3VyZSB0aGUgdXNlciBoYXMgd3JpdGUgcGVybWlzc2lvbnNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgZXZlbnRIdWIgPSB7XG4gICAgc3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAvLyBOZXcvcmVjb21tZW5kZWQgQVBJXG4gICAgbG9zdENvbm5lY3Rpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGN1c3RvbUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzZWxmOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBteVByZXNlbmNlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBvdGhlcnM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGVycm9yOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlQmF0Y2g6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGhpc3Rvcnk6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlU3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICB5ZG9jOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBjb21tZW50czogbWFrZUV2ZW50U291cmNlKClcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDbGllbnRBcGkocm9vbUlkLCBlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zMiwgcGFyYW1zKSB7XG4gICAgY29uc3QgdXJsID0gdXJsam9pbihcbiAgICAgIGNvbmZpZy5iYXNlVXJsLFxuICAgICAgYC92Mi9jL3Jvb21zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJvb21JZCl9JHtlbmRwb2ludH1gLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgICBjb25zdCBmZXRjaGVyID0gY29uZmlnLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmZXRjaDtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hlcih1cmwsIHtcbiAgICAgIC4uLm9wdGlvbnMyLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5vcHRpb25zMj8uaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSl9YFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbUZldGNoKGF1dGhWYWx1ZSwgcm9vbUlkKSB7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKHJvb21JZCwgXCIvc3RvcmFnZVwiLCBhdXRoVmFsdWUsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBodHRwUG9zdFRvUm9vbShlbmRwb2ludCwgYm9keSkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhdXRob3JpemVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoY29uZmlnLnJvb21JZCwgZW5kcG9pbnQsIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dE1lbnRpb24odXNlcklkLCBtZW50aW9uSWQpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYXV0aG9yaXplZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKFxuICAgICAgY29uZmlnLnJvb21JZCxcbiAgICAgIFwiL3RleHQtbWVudGlvbnNcIixcbiAgICAgIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBtZW50aW9uSWRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRleHRNZW50aW9uKG1lbnRpb25JZCkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhdXRob3JpemVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoXG4gICAgICBjb25maWcucm9vbUlkLFxuICAgICAgYC90ZXh0LW1lbnRpb25zLyR7bWVudGlvbklkfWAsXG4gICAgICBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXBvcnRUZXh0RWRpdG9yKHR5cGUsIHJvb3RLZXkpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKGNvbmZpZy5yb29tSWQsIFwiL3RleHQtbWV0YWRhdGFcIiwgYXV0aFZhbHVlLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdEtleVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZW5kTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VzKTtcbiAgICBjb25zdCBub25jZSA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ/Lm5vbmNlO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAgJiYgbm9uY2UpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VyaWFsaXplZFBheWxvYWQpLmxlbmd0aDtcbiAgICAgIGlmIChzaXplID4gTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUpIHtcbiAgICAgICAgdm9pZCBodHRwUG9zdFRvUm9vbShcIi9zZW5kLW1lc3NhZ2VcIiwgeyBub25jZSwgbWVzc2FnZXMgfSkudGhlbihcbiAgICAgICAgICAocmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNwLm9rICYmIHJlc3Auc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXNzYWdlIHdhcyB0b28gbGFyZ2UgZm9yIHdlYnNvY2tldHMgYW5kIHNlbnQgb3ZlciBIVFRQIGluc3RlYWRcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG1hbmFnZWRTb2NrZXQuc2VuZChzZXJpYWxpemVkUGF5bG9hZCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8sXG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8sXG4gICAgY29udGV4dC5teVByZXNlbmNlLFxuICAgIChzdGF0aWNTZXNzaW9uLCBkeW5hbWljU2Vzc2lvbiwgbXlQcmVzZW5jZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY1Nlc3Npb24gPT09IG51bGwgfHwgZHluYW1pY1Nlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShkeW5hbWljU2Vzc2lvbi5zY29wZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbm5lY3Rpb25JZDogZHluYW1pY1Nlc3Npb24uYWN0b3IsXG4gICAgICAgICAgaWQ6IHN0YXRpY1Nlc3Npb24udXNlcklkLFxuICAgICAgICAgIGluZm86IHN0YXRpY1Nlc3Npb24udXNlckluZm8sXG4gICAgICAgICAgcHJlc2VuY2U6IG15UHJlc2VuY2UsXG4gICAgICAgICAgY2FuV3JpdGUsXG4gICAgICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChkeW5hbWljU2Vzc2lvbi5zY29wZXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICApO1xuICBsZXQgX2xhc3RTZWxmO1xuICBmdW5jdGlvbiBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb25zdCBjdXJyU2VsZiA9IHNlbGYuY3VycmVudDtcbiAgICBpZiAoY3VyclNlbGYgIT09IG51bGwgJiYgY3VyclNlbGYgIT09IF9sYXN0U2VsZikge1xuICAgICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgZXZlbnRIdWIuc2VsZi5ub3RpZnkoY3VyclNlbGYpO1xuICAgICAgfSk7XG4gICAgICBfbGFzdFNlbGYgPSBjdXJyU2VsZjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VsZkFzVHJlZU5vZGUgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBzZWxmLFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyB1c2VyVG9UcmVlTm9kZShcIk1lXCIsIG1lKSA6IG51bGxcbiAgKTtcbiAgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSwgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKG1lc3NhZ2UuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IGxvYWQgc3RvcmFnZSB3aXRob3V0IGl0ZW1zXCIpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHVwZGF0ZVJvb3QobWVzc2FnZS5pdGVtcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5yb290ID0gTGl2ZU9iamVjdC5fZnJvbUl0ZW1zKG1lc3NhZ2UuaXRlbXMsIHBvb2wpO1xuICAgIH1cbiAgICBjb25zdCBjYW5Xcml0ZSA9IHNlbGYuY3VycmVudD8uY2FuV3JpdGUgPz8gdHJ1ZTtcbiAgICBjb25zdCBzdGFja1NpemVCZWZvcmUgPSBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dC5pbml0aWFsU3RvcmFnZSkge1xuICAgICAgaWYgKGNvbnRleHQucm9vdC5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChjYW5Xcml0ZSkge1xuICAgICAgICAgIGNvbnRleHQucm9vdC5zZXQoa2V5LCBjbG9uZUxzb24oY29udGV4dC5pbml0aWFsU3RvcmFnZVtrZXldKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcG9wdWxhdGUgbWlzc2luZyBzdG9yYWdlIGtleSAnJHtrZXl9JywgYnV0IGN1cnJlbnQgdXNlciBoYXMgbm8gd3JpdGUgYWNjZXNzYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gc3RhY2tTaXplQmVmb3JlO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvb3QoaXRlbXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBjb250ZXh0Lm5vZGVzKSB7XG4gICAgICBjdXJyZW50SXRlbXMuc2V0KGlkLCBub2RlLl9zZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IGdldFRyZWVzRGlmZk9wZXJhdGlvbnMoY3VycmVudEl0ZW1zLCBuZXcgTWFwKGl0ZW1zKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCBmYWxzZSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICB9XG4gIGZ1bmN0aW9uIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA+PSA1MCkge1xuICAgICAgY29udGV4dC51bmRvU3RhY2suc2hpZnQoKTtcbiAgICB9XG4gICAgY29udGV4dC51bmRvU3RhY2sucHVzaChoaXN0b3J5T3BzKTtcbiAgICBvbkhpc3RvcnlDaGFuZ2UoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRUb1VuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkudW5zaGlmdCguLi5oaXN0b3J5T3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3RpZnkodXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzO1xuICAgIGNvbnN0IG90aGVyc1VwZGF0ZXMgPSB1cGRhdGVzLm90aGVycztcbiAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgaWYgKG90aGVyc1VwZGF0ZXMgIT09IHZvaWQgMCAmJiBvdGhlcnNVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuY3VycmVudDtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBvdGhlcnNVcGRhdGVzKSB7XG4gICAgICAgICAgZXZlbnRIdWIub3RoZXJzLm5vdGlmeSh7IC4uLmV2ZW50LCBvdGhlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGVzLnByZXNlbmNlID8/IGZhbHNlKSB7XG4gICAgICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgZXZlbnRIdWIubXlQcmVzZW5jZS5ub3RpZnkoY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3JhZ2VVcGRhdGVzICE9PSB2b2lkIDAgJiYgc3RvcmFnZVVwZGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgdXBkYXRlczIgPSBBcnJheS5mcm9tKHN0b3JhZ2VVcGRhdGVzLnZhbHVlcygpKTtcbiAgICAgICAgZXZlbnRIdWIuc3RvcmFnZUJhdGNoLm5vdGlmeSh1cGRhdGVzMik7XG4gICAgICB9XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbklkKCkge1xuICAgIGNvbnN0IGluZm8gPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5hY3RvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnRlcm5hbC4gVHJpZWQgdG8gZ2V0IGNvbm5lY3Rpb24gaWQgYnV0IGNvbm5lY3Rpb24gd2FzIG5ldmVyIG9wZW5cIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcHMocmF3T3BzLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgcmV2ZXJzZTogW10sXG4gICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIHByZXNlbmNlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlZE5vZGVJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG9wcyA9IHJhd09wcy5tYXAoKG9wKSA9PiB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiICYmICFvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm9wLCBvcElkOiBwb29sLmdlbmVyYXRlT3BJZCgpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3A7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgIGlmIChvcC50eXBlID09PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZSA9IHtcbiAgICAgICAgICB0eXBlOiBcInByZXNlbmNlXCIsXG4gICAgICAgICAgZGF0YToge31cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgICAgIHJldmVyc2UuZGF0YVtrZXldID0gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gob3AuZGF0YSk7XG4gICAgICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7IHR5cGU6IFwicGFydGlhbFwiLCBkYXRhOiBvcC5kYXRhIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFba2V5XSA9IG9wLmRhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnJldmVyc2UudW5zaGlmdChyZXZlcnNlKTtcbiAgICAgICAgb3V0cHV0LnByZXNlbmNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzb3VyY2U7XG4gICAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgICAgc291cmNlID0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb3BJZCA9IG5uKG9wLm9wSWQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWxldGVkID0gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5kZWxldGUob3BJZCk7XG4gICAgICAgICAgc291cmNlID0gZGVsZXRlZCA/IDIgLyogQUNLICovIDogMSAvKiBSRU1PVEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwbHlPcFJlc3VsdCA9IGFwcGx5T3Aob3AsIHNvdXJjZSk7XG4gICAgICAgIGlmIChhcHBseU9wUmVzdWx0Lm1vZGlmaWVkKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUlkID0gYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZDtcbiAgICAgICAgICBpZiAoIShub2RlSWQgJiYgY3JlYXRlZE5vZGVJZHMuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICBubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSxcbiAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyhcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuZ2V0KG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpKSxcbiAgICAgICAgICAgICAgICBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucmV2ZXJzZS51bnNoaWZ0KC4uLmFwcGx5T3BSZXN1bHQucmV2ZXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcC50eXBlID09PSAyIC8qIENSRUFURV9MSVNUICovIHx8IG9wLnR5cGUgPT09IDcgLyogQ1JFQVRFX01BUCAqLyB8fCBvcC50eXBlID09PSA0IC8qIENSRUFURV9PQkpFQ1QgKi8pIHtcbiAgICAgICAgICAgIGNyZWF0ZWROb2RlSWRzLmFkZChubihvcC5pZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3BzLFxuICAgICAgcmV2ZXJzZTogb3V0cHV0LnJldmVyc2UsXG4gICAgICB1cGRhdGVzOiB7XG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzOiBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMsXG4gICAgICAgIHByZXNlbmNlOiBvdXRwdXQucHJlc2VuY2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5T3Aob3AsIHNvdXJjZSkge1xuICAgIGlmIChpc0Fja09wKG9wKSkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovOlxuICAgICAgY2FzZSAzIC8qIFVQREFURV9PQkpFQ1QgKi86XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLmlkKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLl9hcHBseShvcCwgc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLyk7XG4gICAgICB9XG4gICAgICBjYXNlIDEgLyogU0VUX1BBUkVOVF9LRVkgKi86IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLmlkKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnQubm9kZS5fc2V0Q2hpbGRLZXkoXG4gICAgICAgICAgICBhc1BvcyhvcC5wYXJlbnRLZXkpLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHNvdXJjZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIGNhc2UgNyAvKiBDUkVBVEVfTUFQICovOlxuICAgICAgY2FzZSA4IC8qIENSRUFURV9SRUdJU1RFUiAqLzoge1xuICAgICAgICBpZiAob3AucGFyZW50SWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChwYXJlbnROb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50Tm9kZS5fYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVByZXNlbmNlKHBhdGNoLCBvcHRpb25zMikge1xuICAgIGNvbnN0IG9sZFZhbHVlcyA9IHt9O1xuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgICAgdHlwZTogXCJwYXJ0aWFsXCIsXG4gICAgICAgIGRhdGE6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVWYWx1ZSA9IHBhdGNoW2tleV07XG4gICAgICBpZiAob3ZlcnJpZGVWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFba2V5XSA9IG92ZXJyaWRlVmFsdWU7XG4gICAgICBvbGRWYWx1ZXNba2V5XSA9IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50W2tleV07XG4gICAgfVxuICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChwYXRjaCk7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gucmV2ZXJzZU9wcy51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiBcInByZXNlbmNlXCIsXG4gICAgICAgICAgZGF0YTogb2xkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC51cGRhdGVzLnByZXNlbmNlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgICAgYWRkVG9VbmRvU3RhY2soXG4gICAgICAgICAgICBbeyB0eXBlOiBcInByZXNlbmNlXCIsIGRhdGE6IG9sZFZhbHVlcyB9XSxcbiAgICAgICAgICAgIGRvTm90QmF0Y2hVcGRhdGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBub3RpZnkoeyBwcmVzZW5jZTogdHJ1ZSB9LCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLnRhcmdldEFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IG9sZFVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0T3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKTtcbiAgICAgIGNvbnN0IG5ld1VzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgaWYgKG9sZFVzZXIgPT09IHZvaWQgMCAmJiBuZXdVc2VyICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbnRlclwiLCB1c2VyOiBuZXdVc2VyIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnBhdGNoT3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKSwgbWVzc2FnZTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgIHVwZGF0ZXM6IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgdXNlclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJsZWF2ZVwiLCB1c2VyIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgYWN0b3I6IG1lc3NhZ2UuYWN0b3IsXG4gICAgICBub25jZTogbWVzc2FnZS5ub25jZSxcbiAgICAgIHNjb3BlczogbWVzc2FnZS5zY29wZXNcbiAgICB9KTtcbiAgICBjb250ZXh0LmlkRmFjdG9yeSA9IG1ha2VJZEZhY3RvcnkobWVzc2FnZS5hY3Rvcik7XG4gICAgbm90aWZ5U2VsZkNoYW5nZWQoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb25JZCBvZiBjb250ZXh0Lm90aGVycy5jb25uZWN0aW9uSWRzKCkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2Nvbm5lY3Rpb25JZF07XG4gICAgICBpZiAodXNlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVzc2FnZS51c2Vycykge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNba2V5XTtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IE51bWJlcihrZXkpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICB1c2VyLmlkLFxuICAgICAgICB1c2VyLmluZm8sXG4gICAgICAgIHVzZXIuc2NvcGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInJlc2V0XCIgfTtcbiAgfVxuICBmdW5jdGlvbiBjYW5VbmRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGNhblJlZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gb25IaXN0b3J5Q2hhbmdlKGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGJhdGNoZWRVcGRhdGVzV3JhcHBlcigoKSA9PiB7XG4gICAgICBldmVudEh1Yi5oaXN0b3J5Lm5vdGlmeSh7IGNhblVuZG86IGNhblVuZG8oKSwgY2FuUmVkbzogY2FuUmVkbygpIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICBtZXNzYWdlLmFjdG9yLFxuICAgICAgbWVzc2FnZS5pZCxcbiAgICAgIG1lc3NhZ2UuaW5mbyxcbiAgICAgIG1lc3NhZ2Uuc2NvcGVzXG4gICAgKTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICBkYXRhOiBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCxcbiAgICAgIHRhcmdldEFjdG9yOiBtZXNzYWdlLmFjdG9yXG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICByZXR1cm4gdXNlciA/IHsgdHlwZTogXCJlbnRlclwiLCB1c2VyIH0gOiB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAoIWlzSnNvbk9iamVjdChkYXRhKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZXModGV4dCkge1xuICAgIGNvbnN0IGRhdGEgPSB0cnlQYXJzZUpzb24odGV4dCk7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChpc0pzb25BcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoZGF0YS5tYXAoKGl0ZW0pID0+IHBhcnNlU2VydmVyTWVzc2FnZShpdGVtKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFjdChbcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFwcGx5QW5kU2VuZE9wcyhvZmZsaW5lT3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAob2ZmbGluZU9wcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgY29uc3Qgb3BzID0gQXJyYXkuZnJvbShvZmZsaW5lT3BzLnZhbHVlcygpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhvcHMsIHRydWUpO1xuICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgb3BzOiByZXN1bHQub3BzXG4gICAgfSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlcyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU2VydmVyTWVzc2FnZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHBhcnNlU2VydmVyTWVzc2FnZXMoZXZlbnQuZGF0YSk7XG4gICAgaWYgKG1lc3NhZ2VzID09PSBudWxsIHx8IG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBvdGhlcnM6IFtdXG4gICAgfTtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAxMDEgLyogVVNFUl9KT0lORUQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJKb2luZWRVcGRhdGUgPSBvblVzZXJKb2luZWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHVzZXJKb2luZWRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaCh1c2VySm9pbmVkVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyc1ByZXNlbmNlVXBkYXRlID0gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAob3RoZXJzUHJlc2VuY2VVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChvdGhlcnNQcmVzZW5jZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDMgLyogQlJPQURDQVNURURfRVZFTlQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVycyA9IGNvbnRleHQub3RoZXJzLmN1cnJlbnQ7XG4gICAgICAgICAgICBldmVudEh1Yi5jdXN0b21FdmVudC5ub3RpZnkoe1xuICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IG1lc3NhZ2UuYWN0b3IsXG4gICAgICAgICAgICAgIHVzZXI6IG1lc3NhZ2UuYWN0b3IgPCAwID8gbnVsbCA6IG90aGVycy5maW5kKCh1KSA9PiB1LmNvbm5lY3Rpb25JZCA9PT0gbWVzc2FnZS5hY3RvcikgPz8gbnVsbCxcbiAgICAgICAgICAgICAgZXZlbnQ6IG1lc3NhZ2UuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAyIC8qIFVTRVJfTEVGVCAqLzoge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQyID0gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQyKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2goZXZlbnQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDMwMCAvKiBVUERBVEVfWURPQyAqLzoge1xuICAgICAgICAgICAgZXZlbnRIdWIueWRvYy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDQgLyogUk9PTV9TVEFURSAqLzoge1xuICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChvblJvb21TdGF0ZU1lc3NhZ2UobWVzc2FnZSwgZG9Ob3RCYXRjaFVwZGF0ZXMpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi86IHtcbiAgICAgICAgICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLzoge1xuICAgICAgICAgICAgY29uc3QgYXBwbHlSZXN1bHQgPSBhcHBseU9wcyhtZXNzYWdlLm9wcywgZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXBwbHlSZXN1bHQudXBkYXRlcy5zdG9yYWdlVXBkYXRlcykge1xuICAgICAgICAgICAgICB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyh1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLCB2YWx1ZSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI5OSAvKiBSRUpFQ1RfU1RPUkFHRV9PUCAqLzoge1xuICAgICAgICAgICAgZXJyb3JXaXRoVGl0bGUoXG4gICAgICAgICAgICAgIFwiU3RvcmFnZSBtdXRhdGlvbiByZWplY3Rpb24gZXJyb3JcIixcbiAgICAgICAgICAgICAgbWVzc2FnZS5yZWFzb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3Qgb3BJZCBvZiBtZXNzYWdlLm9wSWRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2UgPSBjb250ZXh0Lm9wU3RhY2tUcmFjZXM/LmdldChvcElkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgIHRyYWNlcy5hZGQodHJhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHJhY2VzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgd2FybldpdGhUaXRsZShcbiAgICAgICAgICAgICAgICAgIFwiVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBjYWxscyBjYXVzZWQgdGhlIHJlamVjdGVkIHN0b3JhZ2UgbXV0YXRpb25zOlwiLFxuICAgICAgICAgICAgICAgICAgYFxuXG4ke0FycmF5LmZyb20odHJhY2VzKS5qb2luKFwiXFxuXFxuXCIpfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgU3RvcmFnZSBtdXRhdGlvbnMgcmVqZWN0ZWQgYnkgc2VydmVyOiAke21lc3NhZ2UucmVhc29ufWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQwMCAvKiBUSFJFQURfQ1JFQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNyAvKiBUSFJFQURfREVMRVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMSAvKiBUSFJFQURfTUVUQURBVEFfVVBEQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwOCAvKiBUSFJFQURfVVBEQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNSAvKiBDT01NRU5UX1JFQUNUSU9OX0FEREVEICovOlxuICAgICAgICAgIGNhc2UgNDA2IC8qIENPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMiAvKiBDT01NRU5UX0NSRUFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDMgLyogQ09NTUVOVF9FRElURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDQgLyogQ09NTUVOVF9ERUxFVEVEICovOiB7XG4gICAgICAgICAgICBldmVudEh1Yi5jb21tZW50cy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vdGlmeSh1cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hOb3dPclNvb24oKSB7XG4gICAgY29uc3Qgc3RvcmFnZU9wcyA9IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zO1xuICAgIGlmIChzdG9yYWdlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygc3RvcmFnZU9wcykge1xuICAgICAgICBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNldChubihvcC5vcElkKSwgb3ApO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH1cbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMgPSBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkTWlsbGlzID0gbm93IC0gY29udGV4dC5idWZmZXIubGFzdEZsdXNoZWRBdDtcbiAgICBpZiAoZWxhcHNlZE1pbGxpcyA+PSBjb25maWcudGhyb3R0bGVEZWxheSkge1xuICAgICAgY29uc3QgbWVzc2FnZXNUb0ZsdXNoID0gc2VyaWFsaXplQnVmZmVyKCk7XG4gICAgICBpZiAobWVzc2FnZXNUb0ZsdXNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXNUb0ZsdXNoKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyID0ge1xuICAgICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgICAgbGFzdEZsdXNoZWRBdDogbm93LFxuICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXSxcbiAgICAgICAgcHJlc2VuY2VVcGRhdGVzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAgIGZsdXNoTm93T3JTb29uLFxuICAgICAgICBjb25maWcudGhyb3R0bGVEZWxheSAtIGVsYXBzZWRNaWxsaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlcigpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy50eXBlID09PSBcImZ1bGxcIiA/IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIC8vIFBvcHVsYXRpbmcgdGhlIGB0YXJnZXRBY3RvcmAgZmllbGQgdHVybnMgdGhpcyBtZXNzYWdlIGludG9cbiAgICAgICAgICAvLyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlIG1lc3NhZ2UgKG5vdCBhIHBhdGNoKSwgd2hpY2ggd2lsbCBnZXRcbiAgICAgICAgICAvLyBpbnRlcnByZXRlZCBieSBvdGhlciBjbGllbnRzIGFzIHN1Y2guXG4gICAgICAgICAgdGFyZ2V0QWN0b3I6IC0xLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICAgIG9wczogY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXM7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlWURvYyh1cGRhdGUsIGd1aWQpIHtcbiAgICBjb25zdCBjbGllbnRNc2cgPSB7XG4gICAgICB0eXBlOiAzMDEgLyogVVBEQVRFX1lET0MgKi8sXG4gICAgICB1cGRhdGUsXG4gICAgICBndWlkXG4gICAgfTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKGNsaWVudE1zZyk7XG4gICAgZXZlbnRIdWIueWRvYy5ub3RpZnkoY2xpZW50TXNnKTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zMiA9IHtcbiAgICBzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeTogZmFsc2VcbiAgfSkge1xuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiICYmICFvcHRpb25zMi5zaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMyAvKiBCUk9BRENBU1RfRVZFTlQgKi8sXG4gICAgICBldmVudFxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2hPcHMob3BzKSB7XG4gICAgY29uc3QgeyBzdG9yYWdlT3BlcmF0aW9ucyB9ID0gY29udGV4dC5idWZmZXI7XG4gICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGxldCBfZ2V0U3RvcmFnZSQgPSBudWxsO1xuICBsZXQgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NJbml0aWFsU3RvcmFnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdW5hY2tub3dsZWRnZWRPcHMgPSBuZXcgTWFwKGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMpO1xuICAgIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICBhcHBseUFuZFNlbmRPcHModW5hY2tub3dsZWRnZWRPcHMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlPy4oKTtcbiAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgZXZlbnRIdWIuc3RvcmFnZURpZExvYWQubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtU3RvcmFnZSgpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0cmVhbUZldGNoKG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLCBjb25maWcucm9vbUlkKTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKHsgdHlwZTogMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLywgaXRlbXMgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaFN0b3JhZ2Uob3B0aW9uczIpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfc3RyZWFtRGF0YSkge1xuICAgICAgdm9pZCBzdHJlYW1TdG9yYWdlKCk7XG4gICAgfSBlbHNlIGlmICghbWVzc2FnZXMuc29tZSgobXNnKSA9PiBtc2cudHlwZSA9PT0gMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8pKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHsgdHlwZTogMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8gfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zMi5mbHVzaCkge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRMb2FkaW5nU3RvcmFnZSgpIHtcbiAgICBpZiAoX2dldFN0b3JhZ2UkID09PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiB0cnVlIH0pO1xuICAgICAgX2dldFN0b3JhZ2UkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlJDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU25hcHNob3QoKSB7XG4gICAgY29uc3Qgcm9vdCA9IGNvbnRleHQucm9vdDtcbiAgICBpZiAocm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZSgpIHtcbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICByb290OiBjb250ZXh0LnJvb3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IG5uKGNvbnRleHQucm9vdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZldGNoWURvYyh2ZWN0b3IsIGd1aWQpIHtcbiAgICBpZiAoIWNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLmZpbmQoKG0pID0+IHtcbiAgICAgIHJldHVybiBtLnR5cGUgPT09IDMwMCAvKiBGRVRDSF9ZRE9DICovICYmIG0udmVjdG9yID09PSB2ZWN0b3IgJiYgbS5ndWlkID09PSBndWlkO1xuICAgIH0pKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMzAwIC8qIEZFVENIX1lET0MgKi8sXG4gICAgICAgIHZlY3RvcixcbiAgICAgICAgZ3VpZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gdW5kbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5kbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQudW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICBjb250ZXh0LnJlZG9TdGFjay5wdXNoKHJlc3VsdC5yZXZlcnNlKTtcbiAgICAgIG9uSGlzdG9yeUNoYW5nZShkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcCBvZiByZXN1bHQub3BzKSB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnJlZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC51bmRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSAwO1xuICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGxldCByZXR1cm5WYWx1ZSA9IHZvaWQgMDtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IHtcbiAgICAgICAgb3BzOiBbXSxcbiAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICAgIHByZXNlbmNlOiBmYWxzZSxcbiAgICAgICAgICBvdGhlcnM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2VPcHM6IFtdXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IG51bGw7XG4gICAgICAgIGlmIChjdXJyZW50QmF0Y2gucmV2ZXJzZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYWRkVG9VbmRvU3RhY2soY3VycmVudEJhdGNoLnJldmVyc2VPcHMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGlzcGF0Y2hPcHMoY3VycmVudEJhdGNoLm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5KGN1cnJlbnRCYXRjaC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHBhdXNlSGlzdG9yeSgpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBbXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lSGlzdG9yeSgpIHtcbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5wYXVzZWRIaXN0b3J5O1xuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgaWYgKGhpc3RvcnlPcHMgIT09IG51bGwgJiYgaGlzdG9yeU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoVXBkYXRlcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gX2dldFN0b3JhZ2UkID09PSBudWxsID8gXCJub3QtbG9hZGVkXCIgOiBcImxvYWRpbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuc2l6ZSA9PT0gMCA/IFwic3luY2hyb25pemVkXCIgOiBcInN5bmNocm9uaXppbmdcIjtcbiAgICB9XG4gIH1cbiAgbGV0IF9sYXN0U3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmFnZVN0YXR1cygpIHtcbiAgICBjb25zdCBzdG9yYWdlU3RhdHVzID0gZ2V0U3RvcmFnZVN0YXR1cygpO1xuICAgIGlmIChfbGFzdFN0b3JhZ2VTdGF0dXMgIT09IHN0b3JhZ2VTdGF0dXMpIHtcbiAgICAgIF9sYXN0U3RvcmFnZVN0YXR1cyA9IHN0b3JhZ2VTdGF0dXM7XG4gICAgICBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm5vdGlmeShzdG9yYWdlU3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmVzZW5jZVJlYWR5KCkge1xuICAgIHJldHVybiBzZWxmLmN1cnJlbnQgIT09IG51bGw7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsUHJlc2VuY2VSZWFkeSgpIHtcbiAgICB3aGlsZSAoIWlzUHJlc2VuY2VSZWFkeSgpKSB7XG4gICAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IFByb21pc2Vfd2l0aFJlc29sdmVycygpO1xuICAgICAgY29uc3QgdW5zdWIxID0gZXZlbnRzLnNlbGYuc3Vic2NyaWJlT25jZShyZXNvbHZlKTtcbiAgICAgIGNvbnN0IHVuc3ViMiA9IGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlT25jZShyZXNvbHZlKTtcbiAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB1bnN1YjEoKTtcbiAgICAgIHVuc3ViMigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1N0b3JhZ2VSZWFkeSgpIHtcbiAgICByZXR1cm4gZ2V0U3RvcmFnZVNuYXBzaG90KCkgIT09IG51bGw7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsU3RvcmFnZVJlYWR5KCkge1xuICAgIHdoaWxlICghaXNTdG9yYWdlUmVhZHkoKSkge1xuICAgICAgYXdhaXQgZ2V0U3RvcmFnZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBvdGhlcnNfZm9yRGV2VG9vbHMgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBjb250ZXh0Lm90aGVycyxcbiAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKChvdGhlciwgaW5kZXgpID0+IHVzZXJUb1RyZWVOb2RlKGBPdGhlciAke2luZGV4fWAsIG90aGVyKSlcbiAgKTtcbiAgY29uc3QgZXZlbnRzID0ge1xuICAgIHN0YXR1czogZXZlbnRIdWIuc3RhdHVzLm9ic2VydmFibGUsXG4gICAgbG9zdENvbm5lY3Rpb246IGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm9ic2VydmFibGUsXG4gICAgY3VzdG9tRXZlbnQ6IGV2ZW50SHViLmN1c3RvbUV2ZW50Lm9ic2VydmFibGUsXG4gICAgb3RoZXJzOiBldmVudEh1Yi5vdGhlcnMub2JzZXJ2YWJsZSxcbiAgICBzZWxmOiBldmVudEh1Yi5zZWxmLm9ic2VydmFibGUsXG4gICAgbXlQcmVzZW5jZTogZXZlbnRIdWIubXlQcmVzZW5jZS5vYnNlcnZhYmxlLFxuICAgIGVycm9yOiBldmVudEh1Yi5lcnJvci5vYnNlcnZhYmxlLFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0b3JhZ2U6IGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VCYXRjaDogZXZlbnRIdWIuc3RvcmFnZUJhdGNoLm9ic2VydmFibGUsXG4gICAgaGlzdG9yeTogZXZlbnRIdWIuaGlzdG9yeS5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VTdGF0dXM6IGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMub2JzZXJ2YWJsZSxcbiAgICB5ZG9jOiBldmVudEh1Yi55ZG9jLm9ic2VydmFibGUsXG4gICAgY29tbWVudHM6IGV2ZW50SHViLmNvbW1lbnRzLm9ic2VydmFibGVcbiAgfTtcbiAgY29uc3QgY29tbWVudHNBcGkgPSBjcmVhdGVDb21tZW50c0FwaShcbiAgICBjb25maWcucm9vbUlkLFxuICAgIGRlbGVnYXRlcy5hdXRoZW50aWNhdGUsXG4gICAgZmV0Y2hDbGllbnRBcGlcbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihlbmRwb2ludCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENsaWVudEFwaShcbiAgICAgIGNvbmZpZy5yb29tSWQsXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIG9wdGlvbnMyXG4gICAgKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgICByZXR1cm4gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcbiAgICAgIFwiL25vdGlmaWNhdGlvbi1zZXR0aW5nc1wiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcbiAgICAgIFwiL25vdGlmaWNhdGlvbi1zZXR0aW5nc1wiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzZXR0aW5ncyksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcIi9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGluYm94Tm90aWZpY2F0aW9uSWRzIH0pXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBNQVJLX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9CQVRDSF9ERUxBWTIgfVxuICApO1xuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGJhdGNoZWRNYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLmdldChpbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIGdldCBwcmVzZW5jZUJ1ZmZlcigpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcz8uZGF0YSA/PyBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCB1bmRvU3RhY2soKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LnVuZG9TdGFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgbm9kZUNvdW50KCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lm5vZGVzLnNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAvLyBzZW5kIG1ldGFkYXRhIHdoZW4gdXNpbmcgYSB0ZXh0IGVkaXRvclxuICAgICAgICByZXBvcnRUZXh0RWRpdG9yLFxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGNyZWF0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBkZWxldGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGRlbGV0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBTdXBwb3J0IGZvciB0aGUgTGl2ZWJsb2NrcyBicm93c2VyIGV4dGVuc2lvblxuICAgICAgICBnZXRTZWxmX2ZvckRldlRvb2xzOiAoKSA9PiBzZWxmQXNUcmVlTm9kZS5jdXJyZW50LFxuICAgICAgICBnZXRPdGhlcnNfZm9yRGV2VG9vbHM6ICgpID0+IG90aGVyc19mb3JEZXZUb29scy5jdXJyZW50LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgc2ltdWxhdGU6IHtcbiAgICAgICAgICAvLyBUaGVzZSBleGlzdCBvbmx5IGZvciBvdXIgRTJFIHRlc3RpbmcgYXBwXG4gICAgICAgICAgZXhwbGljaXRDbG9zZTogKGV2ZW50KSA9PiBtYW5hZ2VkU29ja2V0Ll9wcml2YXRlU2VuZE1hY2hpbmVFdmVudCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pLFxuICAgICAgICAgIHJhd1NlbmQ6IChkYXRhKSA9PiBtYW5hZ2VkU29ja2V0LnNlbmQoZGF0YSlcbiAgICAgICAgfSxcbiAgICAgICAgY29tbWVudHM6IHtcbiAgICAgICAgICAuLi5jb21tZW50c0FwaVxuICAgICAgICB9LFxuICAgICAgICBub3RpZmljYXRpb25zOiB7XG4gICAgICAgICAgZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgICAgIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlkOiBjb25maWcucm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKGV2ZW50cyksXG4gICAgICBjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmNvbm5lY3QoKSxcbiAgICAgIHJlY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKSxcbiAgICAgIGRpc2Nvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuZGlzY29ubmVjdCgpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICB1bmluc3RhbGxCZ1RhYlNweSgpO1xuICAgICAgICBtYW5hZ2VkU29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgdXBkYXRlUHJlc2VuY2UsXG4gICAgICB1cGRhdGVZRG9jLFxuICAgICAgYnJvYWRjYXN0RXZlbnQsXG4gICAgICAvLyBTdG9yYWdlXG4gICAgICBiYXRjaCxcbiAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgdW5kbyxcbiAgICAgICAgcmVkbyxcbiAgICAgICAgY2FuVW5kbyxcbiAgICAgICAgY2FuUmVkbyxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIHBhdXNlOiBwYXVzZUhpc3RvcnksXG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGlzdG9yeVxuICAgICAgfSxcbiAgICAgIGZldGNoWURvYyxcbiAgICAgIGdldFN0b3JhZ2UsXG4gICAgICBnZXRTdG9yYWdlU25hcHNob3QsXG4gICAgICBnZXRTdG9yYWdlU3RhdHVzLFxuICAgICAgaXNQcmVzZW5jZVJlYWR5LFxuICAgICAgaXNTdG9yYWdlUmVhZHksXG4gICAgICB3YWl0VW50aWxQcmVzZW5jZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFByZXNlbmNlUmVhZHkpLFxuICAgICAgd2FpdFVudGlsU3RvcmFnZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSksXG4gICAgICBldmVudHMsXG4gICAgICAvLyBDb3JlXG4gICAgICBnZXRTdGF0dXM6ICgpID0+IG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCksXG4gICAgICBnZXRTZWxmOiAoKSA9PiBzZWxmLmN1cnJlbnQsXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgZ2V0UHJlc2VuY2U6ICgpID0+IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgZ2V0T3RoZXJzOiAoKSA9PiBjb250ZXh0Lm90aGVycy5jdXJyZW50XG4gICAgfSxcbiAgICAvLyBFeHBsaWN0bHkgbWFrZSB0aGUgaW50ZXJuYWwgZmllbGQgbm9uLWVudW1lcmFibGUsIHRvIGF2b2lkIGFnZ3Jlc3NpdmVcbiAgICAvLyBmcmVlemluZyB3aGVuIHVzZWQgd2l0aCBJbW1lclxuICAgIGtJbnRlcm5hbCxcbiAgICB7IGVudW1lcmFibGU6IGZhbHNlIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4oZXZlbnRzKSB7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZFVwZGF0ZXMgPSB1cGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gaXNTYW1lTm9kZU9yQ2hpbGRPZih1cGRhdGUubm9kZSwgbm9kZSlcbiAgICAgICk7XG4gICAgICBpZiAocmVsYXRlZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFjayhyZWxhdGVkVXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgIGlmICh1cGRhdGUubm9kZS5faWQgPT09IG5vZGUuX2lkKSB7XG4gICAgICAgICAgY2FsbGJhY2sodXBkYXRlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZpcnN0LCBzZWNvbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIGlzUm9vbUV2ZW50TmFtZShmaXJzdCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm15LXByZXNlbmNlXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJvdGhlcnNcIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvdGhlcnMsIC4uLmludGVybmFsRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNiKG90aGVycywgaW50ZXJuYWxFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5lcnJvci5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImxvc3QtY29ubmVjdGlvblwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGlzdG9yeVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuaGlzdG9yeS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RvcmFnZS1zdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBhc3NlcnROZXZlcihcbiAgICAgICAgICAgIGZpcnN0LFxuICAgICAgICAgICAgYFwiJHtTdHJpbmcoZmlyc3QpfVwiIGlzIG5vdCBhIHZhbGlkIGV2ZW50IG5hbWVgXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlY29uZCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gZmlyc3Q7XG4gICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZShzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgYSBsaXN0ZW5lciBjYWxsYmFja1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTGl2ZU5vZGUoZmlyc3QpKSB7XG4gICAgICBjb25zdCBub2RlID0gZmlyc3Q7XG4gICAgICBpZiAob3B0aW9ucz8uaXNEZWVwKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIG5vZGVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke1N0cmluZyhmaXJzdCl9IGlzIG5vdCBhIHZhbHVlIHRoYXQgY2FuIGJlIHN1YnNjcmliZWQgdG8uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN1YnNjcmliZTtcbn1cbmZ1bmN0aW9uIGlzUm9vbUV2ZW50TmFtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibXktcHJlc2VuY2VcIiB8fCB2YWx1ZSA9PT0gXCJvdGhlcnNcIiB8fCB2YWx1ZSA9PT0gXCJldmVudFwiIHx8IHZhbHVlID09PSBcImVycm9yXCIgfHwgdmFsdWUgPT09IFwiaGlzdG9yeVwiIHx8IHZhbHVlID09PSBcInN0YXR1c1wiIHx8IHZhbHVlID09PSBcInN0b3JhZ2Utc3RhdHVzXCIgfHwgdmFsdWUgPT09IFwibG9zdC1jb25uZWN0aW9uXCIgfHwgdmFsdWUgPT09IFwiY29ubmVjdGlvblwiO1xufVxuZnVuY3Rpb24gbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcikge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIiwgcm9vbUlkIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICB1cmwucHJvdG9jb2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsLnBhdGhuYW1lID0gXCIvdjdcIjtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInJvb21JZFwiLCByb29tSWQpO1xuICAgIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJwdWJrZXlcIiwgYXV0aFZhbHVlLnB1YmxpY0FwaUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihhdXRoVmFsdWUsIFwiVW5oYW5kbGVkIGNhc2VcIik7XG4gICAgfVxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidmVyc2lvblwiLCBQS0dfVkVSU0lPTiB8fCBcImRldlwiKTtcbiAgICByZXR1cm4gbmV3IHdzKHVybC50b1N0cmluZygpKTtcbiAgfTtcbn1cblxuLy8gc3JjL3N0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgdGhyZWFkczoge30sXG4gICAgcXVlcmllczoge30sXG4gICAgb3B0aW1pc3RpY1VwZGF0ZXM6IFtdLFxuICAgIGluYm94Tm90aWZpY2F0aW9uczoge30sXG4gICAgbm90aWZpY2F0aW9uU2V0dGluZ3M6IHt9XG4gIH0pO1xuICBjb25zdCBvcHRpbWlzdGljVXBkYXRlc0V2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIHJldHVybiB7XG4gICAgLi4uc3RvcmUsXG4gICAgZGVsZXRlVGhyZWFkKHRocmVhZElkKSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgdGhyZWFkczogZGVsZXRlS2V5SW1tdXRhYmxlKHN0YXRlLnRocmVhZHMsIHRocmVhZElkKSxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHN0YXRlLmluYm94Tm90aWZpY2F0aW9ucykuZmlsdGVyKFxuICAgICAgICAgICAgICAoW19pZCwgbm90aWZpY2F0aW9uXSkgPT4gbm90aWZpY2F0aW9uLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgbm90aWZpY2F0aW9uLnRocmVhZElkID09PSB0aHJlYWRJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlVGhyZWFkQW5kTm90aWZpY2F0aW9uKHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb24pIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZC5pZF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgdGhyZWFkczogZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCB8fCBjb21wYXJlVGhyZWFkcyh0aHJlYWQsIGV4aXN0aW5nVGhyZWFkKSA9PT0gMSA/IHsgLi4uc3RhdGUudGhyZWFkcywgW3RocmVhZC5pZF06IHRocmVhZCB9IDogc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDAgPyBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMgOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICBbaW5ib3hOb3RpZmljYXRpb24uaWRdOiBpbmJveE5vdGlmaWNhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnModGhyZWFkcywgaW5ib3hOb3RpZmljYXRpb25zLCBkZWxldGVkVGhyZWFkcywgZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucywgcXVlcnlLZXkpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB0aHJlYWRzOiBhcHBseVRocmVhZFVwZGF0ZXMoc3RhdGUudGhyZWFkcywge1xuICAgICAgICAgIG5ld1RocmVhZHM6IHRocmVhZHMsXG4gICAgICAgICAgZGVsZXRlZFRocmVhZHNcbiAgICAgICAgfSksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogYXBwbHlOb3RpZmljYXRpb25zVXBkYXRlcyhcbiAgICAgICAgICBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmV3SW5ib3hOb3RpZmljYXRpb25zOiBpbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICBkZWxldGVkTm90aWZpY2F0aW9uczogZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcXVlcmllczogcXVlcnlLZXkgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgICAuLi5zdGF0ZS5xdWVyaWVzLFxuICAgICAgICAgIFtxdWVyeUtleV06IHsgaXNMb2FkaW5nOiBmYWxzZSwgZGF0YTogdm9pZCAwIH1cbiAgICAgICAgfSA6IHN0YXRlLnF1ZXJpZXNcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHVwZGF0ZVJvb21JbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc2V0dGluZ3MsIHF1ZXJ5S2V5KSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgbm90aWZpY2F0aW9uU2V0dGluZ3M6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ub3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgICAgICBbcm9vbUlkXTogc2V0dGluZ3NcbiAgICAgICAgfSxcbiAgICAgICAgcXVlcmllczoge1xuICAgICAgICAgIC4uLnN0YXRlLnF1ZXJpZXMsXG4gICAgICAgICAgW3F1ZXJ5S2V5XTogeyBpc0xvYWRpbmc6IGZhbHNlLCBkYXRhOiB2b2lkIDAgfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBwdXNoT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlKSB7XG4gICAgICBvcHRpbWlzdGljVXBkYXRlc0V2ZW50U291cmNlLm5vdGlmeShvcHRpbWlzdGljVXBkYXRlKTtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogWy4uLnN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLCBvcHRpbWlzdGljVXBkYXRlXVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwgcXVlcnlTdGF0ZSkge1xuICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHF1ZXJpZXM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5xdWVyaWVzLFxuICAgICAgICAgIFtxdWVyeUtleV06IHF1ZXJ5U3RhdGVcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgb3B0aW1pc3RpY1VwZGF0ZXNFdmVudFNvdXJjZVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlS2V5SW1tdXRhYmxlKHJlY29yZCwga2V5KSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVjb3JkLCBrZXkpKSB7XG4gICAgY29uc3QgeyBba2V5XTogX3RvRGVsZXRlLCAuLi5yZXN0IH0gPSByZWNvcmQ7XG4gICAgcmV0dXJuIHJlc3Q7XG4gIH1cbiAgcmV0dXJuIHJlY29yZDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVUaHJlYWRzKHRocmVhZDEsIHRocmVhZDIpIHtcbiAgaWYgKHRocmVhZDEudXBkYXRlZEF0ICYmIHRocmVhZDIudXBkYXRlZEF0KSB7XG4gICAgcmV0dXJuIHRocmVhZDEudXBkYXRlZEF0ID4gdGhyZWFkMi51cGRhdGVkQXQgPyAxIDogdGhyZWFkMS51cGRhdGVkQXQgPCB0aHJlYWQyLnVwZGF0ZWRBdCA/IC0xIDogMDtcbiAgfSBlbHNlIGlmICh0aHJlYWQxLnVwZGF0ZWRBdCB8fCB0aHJlYWQyLnVwZGF0ZWRBdCkge1xuICAgIHJldHVybiB0aHJlYWQxLnVwZGF0ZWRBdCA/IDEgOiAtMTtcbiAgfVxuICBpZiAodGhyZWFkMS5jcmVhdGVkQXQgPiB0aHJlYWQyLmNyZWF0ZWRBdCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHRocmVhZDEuY3JlYXRlZEF0IDwgdGhyZWFkMi5jcmVhdGVkQXQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBhcHBseU9wdGltaXN0aWNVcGRhdGVzKHN0YXRlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB0aHJlYWRzOiB7XG4gICAgICAuLi5zdGF0ZS50aHJlYWRzXG4gICAgfSxcbiAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgIC4uLnN0YXRlLmluYm94Tm90aWZpY2F0aW9uc1xuICAgIH0sXG4gICAgbm90aWZpY2F0aW9uU2V0dGluZ3M6IHtcbiAgICAgIC4uLnN0YXRlLm5vdGlmaWNhdGlvblNldHRpbmdzXG4gICAgfVxuICB9O1xuICBmb3IgKGNvbnN0IG9wdGltaXN0aWNVcGRhdGUgb2Ygc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICBzd2l0Y2ggKG9wdGltaXN0aWNVcGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcImNyZWF0ZS10aHJlYWRcIjoge1xuICAgICAgICByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZC5pZF0gPSBvcHRpbWlzdGljVXBkYXRlLnRocmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZWRpdC10aHJlYWQtbWV0YWRhdGFcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlYWQudXBkYXRlZEF0ICE9PSB2b2lkIDAgJiYgdGhyZWFkLnVwZGF0ZWRBdCA+IG9wdGltaXN0aWNVcGRhdGUudXBkYXRlZEF0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IHtcbiAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgdXBkYXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLnVwZGF0ZWRBdCxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgLi4udGhyZWFkLm1ldGFkYXRhLFxuICAgICAgICAgICAgLi4ub3B0aW1pc3RpY1VwZGF0ZS5tZXRhZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay10aHJlYWQtYXMtcmVzb2x2ZWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIHJlc29sdmVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstdGhyZWFkLWFzLXVucmVzb2x2ZWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIHJlc29sdmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjcmVhdGUtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB1cHNlcnRDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpLmZpbmQoXG4gICAgICAgICAgKG5vdGlmaWNhdGlvbikgPT4gbm90aWZpY2F0aW9uLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgbm90aWZpY2F0aW9uLnRocmVhZElkID09PSB0aHJlYWQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW2luYm94Tm90aWZpY2F0aW9uLmlkXSA9IHtcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICBub3RpZmllZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0gdXBzZXJ0Q29tbWVudChcbiAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSBkZWxldGVDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtdGhyZWFkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdID0ge1xuICAgICAgICAgIC4uLnJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdLFxuICAgICAgICAgIGRlbGV0ZWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5kZWxldGVkQXQsXG4gICAgICAgICAgdXBkYXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdCxcbiAgICAgICAgICBjb21tZW50czogW11cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYWRkLXJlYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSBhZGRSZWFjdGlvbihcbiAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50SWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5yZWFjdGlvblxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJyZW1vdmUtcmVhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IHJlbW92ZVJlYWN0aW9uKFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmVtb2ppLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUudXNlcklkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUucmVtb3ZlZEF0XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9uLWFzLXJlYWRcIjoge1xuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF0gPSB7XG4gICAgICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF0sXG4gICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLnJlYWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLWFsbC1pbmJveC1ub3RpZmljYXRpb25zLWFzLXJlYWRcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW2lkXSA9IHtcbiAgICAgICAgICAgIC4uLnJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNbaWRdLFxuICAgICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLnJlYWRBdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWluYm94LW5vdGlmaWNhdGlvblwiOiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXTogXyxcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgfSA9IHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnM7XG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMgPSBpbmJveE5vdGlmaWNhdGlvbnM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1hbGwtaW5ib3gtbm90aWZpY2F0aW9uc1wiOiB7XG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMgPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXBkYXRlLW5vdGlmaWNhdGlvbi1zZXR0aW5nc1wiOiB7XG4gICAgICAgIHJlc3VsdC5ub3RpZmljYXRpb25TZXR0aW5nc1tvcHRpbWlzdGljVXBkYXRlLnJvb21JZF0gPSB7XG4gICAgICAgICAgLi4ucmVzdWx0Lm5vdGlmaWNhdGlvblNldHRpbmdzW29wdGltaXN0aWNVcGRhdGUucm9vbUlkXSxcbiAgICAgICAgICAuLi5vcHRpbWlzdGljVXBkYXRlLnNldHRpbmdzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhcHBseVRocmVhZFVwZGF0ZXMoZXhpc3RpbmdUaHJlYWRzLCB1cGRhdGVzKSB7XG4gIGNvbnN0IHVwZGF0ZWRUaHJlYWRzID0geyAuLi5leGlzdGluZ1RocmVhZHMgfTtcbiAgdXBkYXRlcy5uZXdUaHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gdXBkYXRlZFRocmVhZHNbdGhyZWFkLmlkXTtcbiAgICBpZiAoZXhpc3RpbmdUaHJlYWQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVUaHJlYWRzKGV4aXN0aW5nVGhyZWFkLCB0aHJlYWQpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gMSkgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVkVGhyZWFkc1t0aHJlYWQuaWRdID0gdGhyZWFkO1xuICB9KTtcbiAgdXBkYXRlcy5kZWxldGVkVGhyZWFkcy5mb3JFYWNoKCh7IGlkLCBkZWxldGVkQXQgfSkgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gdXBkYXRlZFRocmVhZHNbaWRdO1xuICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSByZXR1cm47XG4gICAgZXhpc3RpbmdUaHJlYWQuZGVsZXRlZEF0ID0gZGVsZXRlZEF0O1xuICAgIGV4aXN0aW5nVGhyZWFkLnVwZGF0ZWRBdCA9IGRlbGV0ZWRBdDtcbiAgICBleGlzdGluZ1RocmVhZC5jb21tZW50cyA9IFtdO1xuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZWRUaHJlYWRzO1xufVxuZnVuY3Rpb24gYXBwbHlOb3RpZmljYXRpb25zVXBkYXRlcyhleGlzdGluZ0luYm94Tm90aWZpY2F0aW9ucywgdXBkYXRlcykge1xuICBjb25zdCB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zID0geyAuLi5leGlzdGluZ0luYm94Tm90aWZpY2F0aW9ucyB9O1xuICB1cGRhdGVzLm5ld0luYm94Tm90aWZpY2F0aW9ucy5mb3JFYWNoKChub3RpZmljYXRpb24pID0+IHtcbiAgICBjb25zdCBleGlzdGluZ05vdGlmaWNhdGlvbiA9IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnNbbm90aWZpY2F0aW9uLmlkXTtcbiAgICBpZiAoZXhpc3RpbmdOb3RpZmljYXRpb24pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVJbmJveE5vdGlmaWNhdGlvbnMoXG4gICAgICAgIGV4aXN0aW5nTm90aWZpY2F0aW9uLFxuICAgICAgICBub3RpZmljYXRpb25cbiAgICAgICk7XG4gICAgICBpZiAocmVzdWx0ID09PSAxKSByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnNbbm90aWZpY2F0aW9uLmlkXSA9IG5vdGlmaWNhdGlvbjtcbiAgfSk7XG4gIHVwZGF0ZXMuZGVsZXRlZE5vdGlmaWNhdGlvbnMuZm9yRWFjaChcbiAgICAoeyBpZCB9KSA9PiBkZWxldGUgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tpZF1cbiAgKTtcbiAgcmV0dXJuIHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnM7XG59XG5mdW5jdGlvbiBjb21wYXJlSW5ib3hOb3RpZmljYXRpb25zKGluYm94Tm90aWZpY2F0aW9uQSwgaW5ib3hOb3RpZmljYXRpb25CKSB7XG4gIGlmIChpbmJveE5vdGlmaWNhdGlvbkEubm90aWZpZWRBdCA+IGluYm94Tm90aWZpY2F0aW9uQi5ub3RpZmllZEF0KSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoaW5ib3hOb3RpZmljYXRpb25BLm5vdGlmaWVkQXQgPCBpbmJveE5vdGlmaWNhdGlvbkIubm90aWZpZWRBdCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCAmJiBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0KSB7XG4gICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPiBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0ID8gMSA6IGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPCBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0ID8gLTEgOiAwO1xuICB9IGVsc2UgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgfHwgaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCkge1xuICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gdXBzZXJ0Q29tbWVudCh0aHJlYWQsIGNvbW1lbnQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGNvbW1lbnQudGhyZWFkSWQgIT09IHRocmVhZC5pZCkge1xuICAgIHdhcm4oXG4gICAgICBgQ29tbWVudCAke2NvbW1lbnQuaWR9IGRvZXMgbm90IGJlbG9uZyB0byB0aHJlYWQgJHt0aHJlYWQuaWR9YFxuICAgICk7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoZXhpc3RpbmdDb21tZW50MikgPT4gZXhpc3RpbmdDb21tZW50Mi5pZCA9PT0gY29tbWVudC5pZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwLCBjb21tZW50LmNyZWF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVkVGhyZWFkID0ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgdXBkYXRlZEF0LFxuICAgICAgY29tbWVudHM6IFsuLi50aHJlYWQuY29tbWVudHMsIGNvbW1lbnRdXG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmVkaXRlZEF0ID09PSB2b2lkIDAgfHwgY29tbWVudC5lZGl0ZWRBdCA9PT0gdm9pZCAwIHx8IGV4aXN0aW5nQ29tbWVudC5lZGl0ZWRBdCA8PSBjb21tZW50LmVkaXRlZEF0KSB7XG4gICAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAgIChleGlzdGluZ0NvbW1lbnQyKSA9PiBleGlzdGluZ0NvbW1lbnQyLmlkID09PSBjb21tZW50LmlkID8gY29tbWVudCA6IGV4aXN0aW5nQ29tbWVudDJcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZWRUaHJlYWQgPSB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICB0aHJlYWQudXBkYXRlZEF0Py5nZXRUaW1lKCkgfHwgMCxcbiAgICAgICAgICBjb21tZW50LmVkaXRlZEF0Py5nZXRUaW1lKCkgfHwgY29tbWVudC5jcmVhdGVkQXQuZ2V0VGltZSgpXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgfVxuICByZXR1cm4gdGhyZWFkO1xufVxuZnVuY3Rpb24gZGVsZXRlQ29tbWVudCh0aHJlYWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgZGVsZXRlZEF0LFxuICAgICAgYm9keTogdm9pZCAwXG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgaWYgKCF1cGRhdGVkQ29tbWVudHMuc29tZSgoY29tbWVudCkgPT4gY29tbWVudC5kZWxldGVkQXQgPT09IHZvaWQgMCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgZGVsZXRlZEF0LFxuICAgICAgdXBkYXRlZEF0OiBkZWxldGVkQXQsXG4gICAgICBjb21tZW50czogW11cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4udGhyZWFkLFxuICAgIHVwZGF0ZWRBdDogZGVsZXRlZEF0LFxuICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZFJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCByZWFjdGlvbikge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIHJlYWN0aW9uczogdXBzZXJ0UmVhY3Rpb24oY29tbWVudC5yZWFjdGlvbnMsIHJlYWN0aW9uKVxuICAgIH0gOiBjb21tZW50XG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4udGhyZWFkLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoXG4gICAgICBNYXRoLm1heChyZWFjdGlvbi5jcmVhdGVkQXQuZ2V0VGltZSgpLCB0aHJlYWQudXBkYXRlZEF0Py5nZXRUaW1lKCkgfHwgMClcbiAgICApLFxuICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCBlbW9qaSwgdXNlcklkLCByZW1vdmVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IGNvbW1lbnQucmVhY3Rpb25zLm1hcChcbiAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamkgPyB7XG4gICAgICAgICAgLi4ucmVhY3Rpb24sXG4gICAgICAgICAgdXNlcnM6IHJlYWN0aW9uLnVzZXJzLmZpbHRlcigodXNlcikgPT4gdXNlci5pZCAhPT0gdXNlcklkKVxuICAgICAgICB9IDogcmVhY3Rpb25cbiAgICAgICkuZmlsdGVyKChyZWFjdGlvbikgPT4gcmVhY3Rpb24udXNlcnMubGVuZ3RoID4gMClcbiAgICAgIC8vIFJlbW92ZSByZWFjdGlvbnMgd2l0aCBubyB1c2VycyBsZWZ0XG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHJlbW92ZWRBdC5nZXRUaW1lKCksIHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwKVxuICAgICksXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gdXBzZXJ0UmVhY3Rpb24ocmVhY3Rpb25zLCByZWFjdGlvbikge1xuICBjb25zdCBleGlzdGluZ1JlYWN0aW9uID0gcmVhY3Rpb25zLmZpbmQoXG4gICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamlcbiAgKTtcbiAgaWYgKGV4aXN0aW5nUmVhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5yZWFjdGlvbnMsXG4gICAgICB7XG4gICAgICAgIGVtb2ppOiByZWFjdGlvbi5lbW9qaSxcbiAgICAgICAgY3JlYXRlZEF0OiByZWFjdGlvbi5jcmVhdGVkQXQsXG4gICAgICAgIHVzZXJzOiBbeyBpZDogcmVhY3Rpb24udXNlcklkIH1dXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBpZiAoZXhpc3RpbmdSZWFjdGlvbi51c2Vycy5zb21lKCh1c2VyKSA9PiB1c2VyLmlkID09PSByZWFjdGlvbi51c2VySWQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiByZWFjdGlvbnMubWFwKFxuICAgICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamkgPyB7XG4gICAgICAgIC4uLmV4aXN0aW5nUmVhY3Rpb24yLFxuICAgICAgICB1c2VyczogWy4uLmV4aXN0aW5nUmVhY3Rpb24yLnVzZXJzLCB7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH0gOiBleGlzdGluZ1JlYWN0aW9uMlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlYWN0aW9ucztcbn1cblxuLy8gc3JjL2NsaWVudC50c1xudmFyIE1JTl9USFJPVFRMRSA9IDE2O1xudmFyIE1BWF9USFJPVFRMRSA9IDFlMztcbnZhciBERUZBVUxUX1RIUk9UVExFID0gMTAwO1xudmFyIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVCA9IDE1ZTM7XG52YXIgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMjAwO1xudmFyIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDFlMztcbnZhciBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAzZTQ7XG52YXIgREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDVlMztcbnZhciBSRVNPTFZFX1VTRVJTX0JBVENIX0RFTEFZID0gNTA7XG52YXIgUkVTT0xWRV9ST09NU19JTkZPX0JBVENIX0RFTEFZID0gNTA7XG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgaWYgKHR5cGVvZiBiYXNlVXJsID09PSBcInN0cmluZ1wiICYmIGJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4gYmFzZVVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CQVNFX1VSTDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKSB7XG4gIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgIHJldHVybiBhdXRoVmFsdWUucHVibGljQXBpS2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdXRoVmFsdWUudG9rZW4ucmF3O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnQob3B0aW9ucykge1xuICBjb25zdCBjbGllbnRPcHRpb25zID0gb3B0aW9ucztcbiAgY29uc3QgdGhyb3R0bGVEZWxheSA9IGdldFRocm90dGxlKGNsaWVudE9wdGlvbnMudGhyb3R0bGUgPz8gREVGQVVMVF9USFJPVFRMRSk7XG4gIGNvbnN0IGxvc3RDb25uZWN0aW9uVGltZW91dCA9IGdldExvc3RDb25uZWN0aW9uVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmxvc3RDb25uZWN0aW9uVGltZW91dCA/PyBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG4gIGNvbnN0IGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ID0gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFxuICApO1xuICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybChjbGllbnRPcHRpb25zLmJhc2VVcmwpO1xuICBjb25zdCBhdXRoTWFuYWdlciA9IGNyZWF0ZUF1dGhNYW5hZ2VyKG9wdGlvbnMpO1xuICBjb25zdCByb29tc0J5SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiB0ZWFyZG93blJvb20ocm9vbSkge1xuICAgIHVubGlua0RldlRvb2xzKHJvb20uaWQpO1xuICAgIHJvb21zQnlJZC5kZWxldGUocm9vbS5pZCk7XG4gICAgcm9vbS5kZXN0cm95KCk7XG4gIH1cbiAgZnVuY3Rpb24gbGVhc2VSb29tKGRldGFpbHMpIHtcbiAgICBjb25zdCBsZWF2ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGYgPSBsZWF2ZTtcbiAgICAgIGlmICghZGV0YWlscy51bnN1YnMuZGVsZXRlKHNlbGYpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGlzIGxlYXZlIGZ1bmN0aW9uIHdhcyBhbHJlYWR5IGNhbGxlZC4gQ2FsbGluZyBpdCBtb3JlIHRoYW4gb25jZSBoYXMgbm8gZWZmZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGV0YWlscy51bnN1YnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRlYXJkb3duUm9vbShkZXRhaWxzLnJvb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBkZXRhaWxzLnVuc3Vicy5hZGQobGVhdmUpO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiBkZXRhaWxzLnJvb20sXG4gICAgICBsZWF2ZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXJSb29tKHJvb21JZCwgLi4uYXJncykge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcm9vbXNCeUlkLmdldChyb29tSWQpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVhc2VSb29tKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uczIgPSBhcmdzWzBdID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9ICh0eXBlb2Ygb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSkgPz8ge307XG4gICAgY29uc3QgaW5pdGlhbFN0b3JhZ2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsU3RvcmFnZShyb29tSWQpIDogb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2UpID8/IHt9O1xuICAgIGNvbnN0IG5ld1Jvb20gPSBjcmVhdGVSb29tKFxuICAgICAgeyBpbml0aWFsUHJlc2VuY2UsIGluaXRpYWxTdG9yYWdlIH0sXG4gICAgICB7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgdGhyb3R0bGVEZWxheSxcbiAgICAgICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgcG9seWZpbGxzOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscyxcbiAgICAgICAgZGVsZWdhdGVzOiBjbGllbnRPcHRpb25zLm1vY2tlZERlbGVnYXRlcyA/PyB7XG4gICAgICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5XZWJTb2NrZXRcbiAgICAgICAgICApLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcilcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2dnaW5nOiBjbGllbnRPcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IG9wdGlvbnMyPy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgdW5zdGFibGVfZmFsbGJhY2tUb0hUVFA6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCxcbiAgICAgICAgdW5zdGFibGVfc3RyZWFtRGF0YTogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX3N0cmVhbURhdGFcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IG5ld1Jvb21EZXRhaWxzID0ge1xuICAgICAgcm9vbTogbmV3Um9vbSxcbiAgICAgIHVuc3ViczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgcm9vbXNCeUlkLnNldChyb29tSWQsIG5ld1Jvb21EZXRhaWxzKTtcbiAgICBzZXR1cERldlRvb2xzKCgpID0+IEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSkpO1xuICAgIGxpbmtEZXZUb29scyhyb29tSWQsIG5ld1Jvb20pO1xuICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSBvcHRpb25zMi5hdXRvQ29ubmVjdCA/PyB0cnVlO1xuICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGF0b2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5hdG9iID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIllvdSBuZWVkIHRvIHBvbHlmaWxsIGF0b2IgdG8gdXNlIHRoZSBjbGllbnQgaW4geW91ciBlbnZpcm9ubWVudC4gUGxlYXNlIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGF0IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLWNsaWVudC9hdG9iLXBvbHlmaWxsXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbC5hdG9iID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMuYXRvYjtcbiAgICAgIH1cbiAgICAgIG5ld1Jvb20uY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhc2VSb29tKG5ld1Jvb21EZXRhaWxzKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJvb20gPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnJvb207XG4gICAgcmV0dXJuIHJvb20gPyByb29tIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgYXV0aE1hbmFnZXIucmVzZXQoKTtcbiAgICBmb3IgKGNvbnN0IHsgcm9vbSB9IG9mIHJvb21zQnlJZC52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFpc0lkbGUocm9vbS5nZXRTdGF0dXMoKSkpIHtcbiAgICAgICAgcm9vbS5yZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY3VycmVudFVzZXJJZFN0b3JlID0gY3JlYXRlU3RvcmUobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zLFxuICAgIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uXG4gIH0gPSBjcmVhdGVOb3RpZmljYXRpb25zQXBpKHtcbiAgICBiYXNlVXJsLFxuICAgIGZldGNoZXI6IGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZldGNoLFxuICAgIGF1dGhNYW5hZ2VyLFxuICAgIGN1cnJlbnRVc2VySWRTdG9yZVxuICB9KTtcbiAgY29uc3QgY2FjaGVTdG9yZSA9IGNyZWF0ZUNsaWVudFN0b3JlKCk7XG4gIGNvbnN0IHJlc29sdmVVc2VycyA9IGNsaWVudE9wdGlvbnMucmVzb2x2ZVVzZXJzO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVVc2VycyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVVzZXJzLFxuICAgIFwiU2V0IHRoZSByZXNvbHZlVXNlcnMgb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHVzZXIgaW5mby5cIlxuICApO1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShcbiAgICBhc3luYyAoYmF0Y2hlZFVzZXJJZHMpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZHMgPSBiYXRjaGVkVXNlcklkcy5mbGF0KCk7XG4gICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycz8uKHsgdXNlcklkcyB9KTtcbiAgICAgIHdhcm5JZk5vUmVzb2x2ZVVzZXJzKCk7XG4gICAgICByZXR1cm4gdXNlcnMgPz8gdXNlcklkcy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICB9LFxuICAgIHsgZGVsYXk6IFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCByZXNvbHZlUm9vbXNJbmZvID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlUm9vbXNJbmZvO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8gPSBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoXG4gICAgKCkgPT4gIXJlc29sdmVSb29tc0luZm8sXG4gICAgXCJTZXQgdGhlIHJlc29sdmVSb29tc0luZm8gb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHJvb20gaW5mby5cIlxuICApO1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoXG4gICAgYXN5bmMgKGJhdGNoZWRSb29tSWRzKSA9PiB7XG4gICAgICBjb25zdCByb29tSWRzID0gYmF0Y2hlZFJvb21JZHMuZmxhdCgpO1xuICAgICAgY29uc3Qgcm9vbXNJbmZvID0gYXdhaXQgcmVzb2x2ZVJvb21zSW5mbz8uKHsgcm9vbUlkcyB9KTtcbiAgICAgIHdhcm5JZk5vUmVzb2x2ZVJvb21zSW5mbygpO1xuICAgICAgcmV0dXJuIHJvb21zSW5mbyA/PyByb29tSWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9ST09NU19JTkZPX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBlbnRlclJvb20sXG4gICAgICBnZXRSb29tLFxuICAgICAgbG9nb3V0LFxuICAgICAgLy8gSW50ZXJuYWxcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgICAgICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICAgICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgICAgICAgZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbnRVc2VySWRTdG9yZSxcbiAgICAgICAgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uczogY2xpZW50T3B0aW9ucy5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zLFxuICAgICAgICBjYWNoZVN0b3JlLFxuICAgICAgICB1c2Vyc1N0b3JlLFxuICAgICAgICByb29tc0luZm9TdG9yZSxcbiAgICAgICAgZ2V0Um9vbUlkcygpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyb29tc0J5SWQua2V5cygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAga0ludGVybmFsLFxuICAgIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfVxuICApO1xufVxudmFyIE5vdGlmaWNhdGlvbnNBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn07XG5mdW5jdGlvbiBjaGVja0JvdW5kcyhvcHRpb24sIHZhbHVlLCBtaW4sIG1heCwgcmVjb21tZW5kZWRNaW4pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIG1heCAhPT0gdm9pZCAwID8gYCR7b3B0aW9ufSBzaG91bGQgYmUgYmV0d2VlbiAke3JlY29tbWVuZGVkTWluID8/IG1pbn0gYW5kICR7bWF4fS5gIDogYCR7b3B0aW9ufSBzaG91bGQgYmUgYXQgbGVhc3QgJHtyZWNvbW1lbmRlZE1pbiA/PyBtaW59LmBcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gZ2V0VGhyb3R0bGUodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFwidGhyb3R0bGVcIiwgdmFsdWUsIE1JTl9USFJPVFRMRSwgTUFYX1RIUk9UVExFKTtcbn1cbmZ1bmN0aW9uIGdldExvc3RDb25uZWN0aW9uVGltZW91dCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJsb3N0Q29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKGNvbmRpdGlvbiwgLi4uYXJncykge1xuICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFoYXNXYXJuZWQgJiYgKHR5cGVvZiBjb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGNvbmRpdGlvbigpIDogY29uZGl0aW9uKSkge1xuICAgICAgICB3YXJuKC4uLmFyZ3MpO1xuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9jb21tZW50cy9jb21tZW50LWJvZHkudHNcbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keVRleHQoZWxlbWVudCkge1xuICByZXR1cm4gIShcInR5cGVcIiBpbiBlbGVtZW50KSAmJiBcInRleHRcIiBpbiBlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LnRleHQgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5TWVudGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJtZW50aW9uXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5TGluayhlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJsaW5rXCI7XG59XG52YXIgY29tbWVudEJvZHlFbGVtZW50c0d1YXJkcyA9IHtcbiAgcGFyYWdyYXBoOiBpc0NvbW1lbnRCb2R5UGFyYWdyYXBoLFxuICB0ZXh0OiBpc0NvbW1lbnRCb2R5VGV4dCxcbiAgbGluazogaXNDb21tZW50Qm9keUxpbmssXG4gIG1lbnRpb246IGlzQ29tbWVudEJvZHlNZW50aW9uXG59O1xudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlcyA9IHtcbiAgcGFyYWdyYXBoOiBcImJsb2NrXCIsXG4gIHRleHQ6IFwiaW5saW5lXCIsXG4gIGxpbms6IFwiaW5saW5lXCIsXG4gIG1lbnRpb246IFwiaW5saW5lXCJcbn07XG5mdW5jdGlvbiB0cmF2ZXJzZUNvbW1lbnRCb2R5KGJvZHksIGVsZW1lbnRPclZpc2l0b3IsIHBvc3NpYmx5VmlzaXRvcikge1xuICBpZiAoIWJvZHkgfHwgIWJvZHk/LmNvbnRlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50T3JWaXNpdG9yID09PSBcInN0cmluZ1wiID8gZWxlbWVudE9yVmlzaXRvciA6IHZvaWQgMDtcbiAgY29uc3QgdHlwZSA9IGVsZW1lbnQgPyBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXNbZWxlbWVudF0gOiBcImFsbFwiO1xuICBjb25zdCBndWFyZCA9IGVsZW1lbnQgPyBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzW2VsZW1lbnRdIDogKCkgPT4gdHJ1ZTtcbiAgY29uc3QgdmlzaXRvciA9IHR5cGVvZiBlbGVtZW50T3JWaXNpdG9yID09PSBcImZ1bmN0aW9uXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogcG9zc2libHlWaXNpdG9yO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJvZHkuY29udGVudCkge1xuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgaWYgKGd1YXJkKGJsb2NrKSkge1xuICAgICAgICB2aXNpdG9yPy4oYmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGlubGluZSBvZiBibG9jay5jaGlsZHJlbikge1xuICAgICAgICBpZiAoZ3VhcmQoaW5saW5lKSkge1xuICAgICAgICAgIHZpc2l0b3I/LihpbmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHkoYm9keSkge1xuICBjb25zdCBtZW50aW9uZWRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB0cmF2ZXJzZUNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgXCJtZW50aW9uXCIsXG4gICAgKG1lbnRpb24pID0+IG1lbnRpb25lZElkcy5hZGQobWVudGlvbi5pZClcbiAgKTtcbiAgcmV0dXJuIEFycmF5LmZyb20obWVudGlvbmVkSWRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkoYm9keSwgcmVzb2x2ZVVzZXJzKSB7XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAoIXJlc29sdmVVc2Vycykge1xuICAgIHJldHVybiByZXNvbHZlZFVzZXJzO1xuICB9XG4gIGNvbnN0IHVzZXJJZHMgPSBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHkoYm9keSk7XG4gIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzKHtcbiAgICB1c2VySWRzXG4gIH0pO1xuICBmb3IgKGNvbnN0IFtpbmRleCwgdXNlcklkXSBvZiB1c2VySWRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IHVzZXIgPSB1c2Vycz8uW2luZGV4XTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmVzb2x2ZWRVc2Vycy5zZXQodXNlcklkLCB1c2VyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG59XG52YXIgaHRtbEVzY2FwYWJsZXMgPSB7XG4gIFwiJlwiOiBcIiZhbXA7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICAnXCInOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImIzM5O1wiXG59O1xudmFyIGh0bWxFc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhodG1sRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gaHRtbFNhZmUodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbU3RyaW5nKHZhbHVlKV0sIFtdKTtcbn1cbmZ1bmN0aW9uIGpvaW5IdG1sKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtcIlwiXSwgW10pO1xuICB9XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlSHRtbCh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIdG1sU2FmZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBqb2luSHRtbCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIGh0bWxFc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gaHRtbEVzY2FwYWJsZXNbY2hhcmFjdGVyXVxuICApO1xufVxudmFyIEh0bWxTYWZlU3RyaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICB0aGlzLl9zdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZUh0bWwobm4odGhpcy5fdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gaHRtbChzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMpO1xufVxudmFyIG1hcmtkb3duRXNjYXBhYmxlcyA9IHtcbiAgXzogXCJcXFxcX1wiLFxuICBcIipcIjogXCJcXFxcKlwiLFxuICBcIiNcIjogXCJcXFxcI1wiLFxuICBcImBcIjogXCJcXFxcYFwiLFxuICBcIn5cIjogXCJcXFxcflwiLFxuICBcIiFcIjogXCJcXFxcIVwiLFxuICBcInxcIjogXCJcXFxcfFwiLFxuICBcIihcIjogXCJcXFxcKFwiLFxuICBcIilcIjogXCJcXFxcKVwiLFxuICBcIntcIjogXCJcXFxce1wiLFxuICBcIn1cIjogXCJcXFxcfVwiLFxuICBcIltcIjogXCJcXFxcW1wiLFxuICBcIl1cIjogXCJcXFxcXVwiXG59O1xudmFyIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMobWFya2Rvd25Fc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBqb2luTWFya2Rvd24oc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFtcIlwiXSwgW10pO1xuICB9XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZU1hcmtkb3duKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcmtkb3duU2FmZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBqb2luTWFya2Rvd24odmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBtYXJrZG93bkVzY2FwYWJsZXNbY2hhcmFjdGVyXVxuICApO1xufVxudmFyIE1hcmtkb3duU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgdGhpcy5fc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVNYXJrZG93bihubih0aGlzLl92YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBtYXJrZG93bihzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoc3RyaW5ncywgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIHRvQWJzb2x1dGVVcmwodXJsKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgdXJsLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH0gZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgcmV0dXJuIFwiaHR0cHM6Ly9cIiArIHVybDtcbiAgfVxuICByZXR1cm47XG59XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IGNoaWxkcmVuLFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCxcbiAgbGluazogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmwsXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBgQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbiA/IGh0bWxgPHA+JHtodG1sU2FmZShjaGlsZHJlbil9PC9wPmAgOiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzdHJvbmc+JHtjaGlsZHJlbn08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8ZW0+JHtjaGlsZHJlbn08L2VtPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8cz4ke2NoaWxkcmVufTwvcz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGNvZGU+JHtjaGlsZHJlbn08L2NvZGU+YDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8YSBocmVmPVwiJHtocmVmfVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj4ke2VsZW1lbnQudGV4dCA/PyBlbGVtZW50LnVybH08L2E+YDtcbiAgfSxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPHNwYW4gZGF0YS1tZW50aW9uPkAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH08L3NwYW4+YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmAqKiR7Y2hpbGRyZW59KipgO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXyR7Y2hpbGRyZW59X2A7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gfn4ke2NoaWxkcmVufX5+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBcXGAke2NoaWxkcmVufVxcYGA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIG1hcmtkb3duYFske2VsZW1lbnQudGV4dCA/PyBlbGVtZW50LnVybH1dKCR7aHJlZn0pYDtcbiAgfSxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIG1hcmtkb3duYEAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gc3RyaW5naWZ5Q29tbWVudEJvZHkoYm9keSwgb3B0aW9ucykge1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgPz8gXCJwbGFpblwiO1xuICBjb25zdCBzZXBhcmF0b3IgPSBvcHRpb25zPy5zZXBhcmF0b3IgPz8gKGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gXCJcXG5cXG5cIiA6IFwiXFxuXCIpO1xuICBjb25zdCBlbGVtZW50cyA9IHtcbiAgICAuLi5mb3JtYXQgPT09IFwiaHRtbFwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgOiBmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA6IHN0cmluZ2lmeUNvbW1lbnRCb2R5UGxhaW5FbGVtZW50cyxcbiAgICAuLi5vcHRpb25zPy5lbGVtZW50c1xuICB9O1xuICBjb25zdCByZXNvbHZlZFVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIG9wdGlvbnM/LnJlc29sdmVVc2Vyc1xuICApO1xuICBjb25zdCBibG9ja3MgPSBib2R5LmNvbnRlbnQuZmxhdE1hcCgoYmxvY2ssIGJsb2NrSW5kZXgpID0+IHtcbiAgICBzd2l0Y2ggKGJsb2NrLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJwYXJhZ3JhcGhcIjoge1xuICAgICAgICBjb25zdCBpbmxpbmVzID0gYmxvY2suY2hpbGRyZW4uZmxhdE1hcCgoaW5saW5lLCBpbmxpbmVJbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TWVudGlvbihpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5saW5lLmlkID8gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5tZW50aW9uKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIHVzZXI6IHJlc29sdmVkVXNlcnMuZ2V0KGlubGluZS5pZClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0gOiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlMaW5rKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLmxpbmsoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgaHJlZjogdG9BYnNvbHV0ZVVybChpbmxpbmUudXJsKSA/PyBpbmxpbmUudXJsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keVRleHQoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50cy50ZXh0KHsgZWxlbWVudDogaW5saW5lIH0sIGlubGluZUluZGV4KV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZWxlbWVudHMucGFyYWdyYXBoKFxuICAgICAgICAgICAgeyBlbGVtZW50OiBibG9jaywgY2hpbGRyZW46IGlubGluZXMuam9pbihcIlwiKSB9LFxuICAgICAgICAgICAgYmxvY2tJbmRleFxuICAgICAgICAgIClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYmxvY2tzLmpvaW4oc2VwYXJhdG9yKTtcbn1cblxuLy8gc3JjL2NyZHRzL3V0aWxzLnRzXG5mdW5jdGlvbiB0b1BsYWluTHNvbihsc29uKSB7XG4gIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGxzb24udG9PYmplY3QoKSkuZmxhdE1hcChcbiAgICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gW1trZXksIHRvUGxhaW5Mc29uKHZhbHVlKV1dIDogW11cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBbLi4ubHNvbl0ubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHRvUGxhaW5Mc29uKHZhbHVlKV0pXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGRhdGE6IFsuLi5sc29uXS5tYXAoKGl0ZW0pID0+IHRvUGxhaW5Mc29uKGl0ZW0pKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxzb247XG4gIH1cbn1cblxuLy8gc3JjL2ltbXV0YWJsZS50c1xuZnVuY3Rpb24gbHNvbk9iamVjdFRvSnNvbihvYmopIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHZhbCA9IG9ialtrZXldO1xuICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsaXZlT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QpIHtcbiAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24obGl2ZU9iamVjdC50b09iamVjdCgpKTtcbn1cbmZ1bmN0aW9uIGxpdmVNYXBUb0pzb24obWFwKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbHNvbkxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChsc29uVG9Kc29uKTtcbn1cbmZ1bmN0aW9uIGxpdmVMaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZS50b0FycmF5KCkpO1xufVxuZnVuY3Rpb24gbHNvblRvSnNvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIGxpdmVPYmplY3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gbGl2ZUxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiBsaXZlTWFwVG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiB2YWx1ZS5kYXRhO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZGVlcExpdmVpZnkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdCh2YWx1ZS5tYXAoZGVlcExpdmVpZnkpKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IGluaXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgdmFsID0gdmFsdWVba2V5XTtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGluaXRba2V5XSA9IGRlZXBMaXZlaWZ5KHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChpbml0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZUxpc3QobGl2ZUxpc3QsIHByZXYsIG5leHQpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgcHJldkVuZCA9IHByZXYubGVuZ3RoIC0gMTtcbiAgbGV0IG5leHRFbmQgPSBuZXh0Lmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2Tm9kZSA9IHByZXZbMF07XG4gIGxldCBuZXh0Tm9kZSA9IG5leHRbMF07XG4gIG91dGVyOiB7XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgKytpO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgIH1cbiAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgIHByZXZFbmQtLTtcbiAgICAgIG5leHRFbmQtLTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB9XG4gIH1cbiAgaWYgKGkgPiBwcmV2RW5kKSB7XG4gICAgaWYgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGkgPiBuZXh0RW5kKSB7XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGkgPD0gcHJldkVuZCAmJiBpIDw9IG5leHRFbmQpIHtcbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICAgIGNvbnN0IGxpdmVMaXN0Tm9kZSA9IGxpdmVMaXN0LmdldChpKTtcbiAgICAgIGlmIChpc0xpdmVPYmplY3QobGl2ZUxpc3ROb2RlKSAmJiBpc1BsYWluT2JqZWN0KHByZXZOb2RlKSAmJiBpc1BsYWluT2JqZWN0KG5leHROb2RlKSkge1xuICAgICAgICBwYXRjaExpdmVPYmplY3QobGl2ZUxpc3ROb2RlLCBwcmV2Tm9kZSwgbmV4dE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZUxpc3Quc2V0KGksIGRlZXBMaXZlaWZ5KG5leHROb2RlKSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3RLZXkobGl2ZU9iamVjdCwga2V5LCBwcmV2LCBuZXh0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBub25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXh0KTtcbiAgICBpZiAobm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgIGVycm9yMihcbiAgICAgICAgYE5ldyBzdGF0ZSBwYXRoOiAnJHtub25TZXJpYWxpemFibGVWYWx1ZS5wYXRofScgdmFsdWU6ICcke1N0cmluZyhcbiAgICAgICAgICBub25TZXJpYWxpemFibGVWYWx1ZS52YWx1ZVxuICAgICAgICApfScgaXMgbm90IHNlcmlhbGl6YWJsZS5cbk9ubHkgc2VyaWFsaXphYmxlIHZhbHVlIGNhbiBiZSBzeW5jZWQgd2l0aCBMaXZlYmxvY2tzLmBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHZhbHVlID0gbGl2ZU9iamVjdC5nZXQoa2V5KTtcbiAgaWYgKG5leHQgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3QuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9IGVsc2UgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaXNMaXZlTGlzdCh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShwcmV2KSAmJiBBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlTGlzdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSBpZiAoaXNMaXZlT2JqZWN0KHZhbHVlKSAmJiBpc1BsYWluT2JqZWN0KHByZXYpICYmIGlzUGxhaW5PYmplY3QobmV4dCkpIHtcbiAgICBwYXRjaExpdmVPYmplY3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2Uge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3Qocm9vdCwgcHJldiwgbmV4dCkge1xuICBjb25zdCB1cGRhdGVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICBwYXRjaExpdmVPYmplY3RLZXkocm9vdCwga2V5LCBwcmV2W2tleV0sIG5leHRba2V5XSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgIGlmIChuZXh0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgcm9vdC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICByb290LnVwZGF0ZSh1cGRhdGVzKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyZW50c1BhdGgobm9kZSkge1xuICBjb25zdCBwYXRoID0gW107XG4gIHdoaWxlIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgaWYgKGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5ub2RlLl9pbmRleE9mUG9zaXRpb24obm9kZS5wYXJlbnQua2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5rZXkpO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnQubm9kZTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdChzdGF0ZSwgdXBkYXRlcykge1xuICByZXR1cm4gdXBkYXRlcy5yZWR1Y2UoXG4gICAgKHN0YXRlMiwgdXBkYXRlKSA9PiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlMiwgdXBkYXRlKSxcbiAgICBzdGF0ZVxuICApO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZSwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGggPSBnZXRQYXJlbnRzUGF0aCh1cGRhdGUubm9kZSk7XG4gIHJldHVybiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGhJdGVtID0gcGF0aC5wb3AoKTtcbiAgaWYgKHBhdGhJdGVtID09PSB2b2lkIDApIHtcbiAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiTGl2ZU9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlT2JqZWN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZUxpc3RcIjoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVMaXN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIGFycmF5XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLm1hcCgoeCkgPT4geCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdFVwZGF0ZSBvZiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUubWFwKFxuICAgICAgICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGluZGV4ID09PSBsaXN0VXBkYXRlLmluZGV4ID8gbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pIDogaXRlbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUuaW5kZXggPT09IG5ld1N0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZS5wdXNoKGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleClcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUuc3BsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCA+IGxpc3RVcGRhdGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5pbmRleCArIDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVNYXBcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU1hcCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICBjb25zdCBuZXdBcnJheSA9IFsuLi5zdGF0ZV07XG4gICAgbmV3QXJyYXlbcGF0aEl0ZW1dID0gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShcbiAgICAgIHN0YXRlW3BhdGhJdGVtXSxcbiAgICAgIHBhdGgsXG4gICAgICB1cGRhdGVcbiAgICApO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSBlbHNlIGlmIChpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN0YXRlW3BhdGhJdGVtXTtcbiAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXRlQXNPYmogPSBzdGF0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlQXNPYmosXG4gICAgICAgIFtwYXRoSXRlbV06IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUobm9kZSwgcGF0aCwgdXBkYXRlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vIHNyYy9saWIvZGVwcmVjYXRpb24udHNcbnZhciBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmhhcyhrZXkpKSB7XG4gICAgICBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuYWRkKGtleSk7XG4gICAgICBlcnJvcldpdGhUaXRsZShcIkRlcHJlY2F0aW9uIHdhcm5pbmdcIiwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXByZWNhdGVJZihjb25kaXRpb24sIG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IHVzYWdlRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgdXNhZ2VFcnJvci5uYW1lID0gXCJVc2FnZSBlcnJvclwiO1xuICAgIGVycm9yV2l0aFRpdGxlKFwiVXNhZ2UgZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgdGhyb3cgdXNhZ2VFcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JJZihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9Qb2xsZXIudHNcbmZ1bmN0aW9uIG1ha2VQb2xsZXIoY2FsbGJhY2spIHtcbiAgbGV0IGNvbnRleHQgPSB7XG4gICAgc3RhdGU6IFwic3RvcHBlZFwiLFxuICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgaW50ZXJ2YWw6IG51bGwsXG4gICAgbGFzdFNjaGVkdWxlZEF0OiBudWxsLFxuICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gIH07XG4gIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICBzY2hlZHVsZShjb250ZXh0LmludGVydmFsKTtcbiAgICB9XG4gICAgdm9pZCBjYWxsYmFjaygpO1xuICB9XG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGludGVydmFsKSB7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInJ1bm5pbmdcIixcbiAgICAgIGludGVydmFsOiBjb250ZXh0LnN0YXRlICE9PSBcInN0b3BwZWRcIiA/IGNvbnRleHQuaW50ZXJ2YWwgOiBpbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKSxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzY2hlZHVsZVJlbWFpbmluZyhyZW1haW5pbmcpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJwYXVzZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicnVubmluZ1wiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogc2V0VGltZW91dChwb2xsLCByZW1haW5pbmcpLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KGludGVydmFsKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlKGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KGludGVydmFsKSB7XG4gICAgc3RvcCgpO1xuICAgIHN0YXJ0KGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInBhdXNlZFwiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBjb250ZXh0LmludGVydmFsIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gY29udGV4dC5sYXN0U2NoZWR1bGVkQXQpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09IFwicGF1c2VkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW1haW5pbmcoY29udGV4dC5yZW1haW5pbmdJbnRlcnZhbCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJzdG9wcGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQudGltZW91dEhhbmRsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgfVxuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJzdG9wcGVkXCIsXG4gICAgICBpbnRlcnZhbDogbnVsbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogbnVsbCxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICByZXN0YXJ0LFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqQSkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iakIpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgQ2xpZW50TXNnQ29kZSxcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgQ3JkdFR5cGUsXG4gIExpdmVMaXN0LFxuICBMaXZlTWFwLFxuICBMaXZlT2JqZWN0LFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIE9wQ29kZSxcbiAgU2VydmVyTXNnQ29kZSxcbiAgV2Vic29ja2V0Q2xvc2VDb2RlcyxcbiAgYWNrT3AsXG4gIGFkZFJlYWN0aW9uLFxuICBhcHBseU9wdGltaXN0aWNVcGRhdGVzLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYjY0ZGVjb2RlLFxuICBjbG9uZUxzb24sXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBjcmVhdGVDbGllbnQsXG4gIGRlbGV0ZUNvbW1lbnQsXG4gIGRlcHJlY2F0ZSxcbiAgZGVwcmVjYXRlSWYsXG4gIGRldGVjdER1cGVzLFxuICBlcnJvcklmLFxuICBmcmVlemUsXG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgaXNDaGlsZENyZHQsXG4gIGlzSnNvbkFycmF5LFxuICBpc0pzb25PYmplY3QsXG4gIGlzSnNvblNjYWxhcixcbiAgaXNMaXZlTm9kZSxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNSb290Q3JkdCxcbiAga0ludGVybmFsLFxuICBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3QsXG4gIGxzb25Ub0pzb24sXG4gIG1ha2VFdmVudFNvdXJjZSxcbiAgbWFrZVBvbGxlcixcbiAgbWFrZVBvc2l0aW9uLFxuICBtZW1vaXplT25TdWNjZXNzLFxuICBubixcbiAgb2JqZWN0VG9RdWVyeSxcbiAgcGF0Y2hMaXZlT2JqZWN0S2V5LFxuICByYWlzZSxcbiAgcmVtb3ZlUmVhY3Rpb24sXG4gIHNoYWxsb3csXG4gIHN0cmluZ2lmeSxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHksXG4gIHRocm93VXNhZ2VFcnJvcixcbiAgdG9QbGFpbkxzb24sXG4gIHRyeVBhcnNlSnNvbixcbiAgdXBzZXJ0Q29tbWVudCxcbiAgd2FpdCxcbiAgd2l0aFRpbWVvdXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentsContext: () => (/* binding */ ComponentsContext),\n/* harmony export */   ComponentsProvider: () => (/* binding */ ComponentsProvider),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   useComponents: () => (/* binding */ useComponents)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ ComponentsContext,ComponentsProvider,defaultComponents,useComponents auto */ \n\nconst defaultComponents = {\n    Anchor: \"a\"\n};\nconst ComponentsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction useComponents(components) {\n    const contextComponents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComponentsContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...defaultComponents,\n            ...contextComponents,\n            ...components\n        }), [\n        contextComponents,\n        components\n    ]);\n}\nfunction ComponentsProvider({ children, components: providerComponents }) {\n    const contextComponents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComponentsContext);\n    const components = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...defaultComponents,\n            ...contextComponents,\n            ...providerComponents\n        }), [\n        contextComponents,\n        providerComponents\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComponentsContext.Provider, {\n        value: components\n    }, children);\n}\n //# sourceMappingURL=components.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBb0JPLE1BQUFBLG9CQUFBO0lBQXNDQyxRQUFBO0FBRTdDO0FBRU8sTUFBQUMsa0NBQUFDLG9EQUFBQSxDQUEwQjtBQUkxQixTQUFBQyxjQUFBQyxVQUFBO0lBQ0wsTUFBQUMsb0JBQUFDLGlEQUFBQSxDQUFBTDtJQUVBLE9BQUFNLDhDQUFBQSxDQUFPO1lBQ0UsR0FBQVIsaUJBQUE7WUFDRixHQUFBTSxpQkFBQTtZQUNBLEdBQUFELFVBQUE7UUFDQSxJQUNMO1FBQUFDO1FBQUFEO0tBQUE7QUFHSjtBQUVPLFNBQUFJLG1CQUFBLEVBQTRCQyxRQUFBLEVBQ2pDTCxZQUFBTSxrQkFBQSxFQUVGO0lBQ0UsTUFBQUwsb0JBQUFDLGlEQUFBQSxDQUFBTDtJQUNBLE1BQUFHLGFBQUFHLDhDQUFBQSxDQUFtQjtZQUNWLEdBQUFSLGlCQUFBO1lBQ0YsR0FBQU0saUJBQUE7WUFDQSxHQUFBSyxrQkFBQTtRQUNBLElBQ0w7UUFBQUw7UUFBQUs7S0FBQTtJQUlGLHFDQUFBQyxnREFBQSxDQUFBVixrQkFBQVksUUFBQTtRQUNHQyxPQUFBVjtJQUFrQyxHQUFBSztBQUl2QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uLi9zcmMvY29tcG9uZW50cy50c3g/NzE0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHR5cGUge1xuICBDb21wb25lbnRQcm9wc1dpdGhvdXRSZWYsXG4gIENvbXBvbmVudFR5cGUsXG4gIFByb3BzV2l0aENoaWxkcmVuLFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbENvbXBvbmVudHMge1xuICBBbmNob3I6IENvbXBvbmVudFR5cGU8Q29tcG9uZW50UHJvcHNXaXRob3V0UmVmPFwiYVwiPj4gfCBcImFcIjtcbn1cblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50cyA9IEdsb2JhbENvbXBvbmVudHM7XG5cbnR5cGUgQ29tcG9uZW50c1Byb3ZpZGVyUHJvcHMgPSBQcm9wc1dpdGhDaGlsZHJlbjx7XG4gIGNvbXBvbmVudHM/OiBQYXJ0aWFsPENvbXBvbmVudHM+O1xufT47XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29tcG9uZW50czogQ29tcG9uZW50cyA9IHtcbiAgQW5jaG9yOiBcImFcIixcbn07XG5cbmV4cG9ydCBjb25zdCBDb21wb25lbnRzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Q29tcG9uZW50cyB8IHVuZGVmaW5lZD4oXG4gIHVuZGVmaW5lZFxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbXBvbmVudHMoY29tcG9uZW50cz86IFBhcnRpYWw8Q29tcG9uZW50cz4pOiBDb21wb25lbnRzIHtcbiAgY29uc3QgY29udGV4dENvbXBvbmVudHMgPSB1c2VDb250ZXh0KENvbXBvbmVudHNDb250ZXh0KTtcblxuICByZXR1cm4gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgLi4uZGVmYXVsdENvbXBvbmVudHMsXG4gICAgICAuLi5jb250ZXh0Q29tcG9uZW50cyxcbiAgICAgIC4uLmNvbXBvbmVudHMsXG4gICAgfSksXG4gICAgW2NvbnRleHRDb21wb25lbnRzLCBjb21wb25lbnRzXVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29tcG9uZW50c1Byb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGNvbXBvbmVudHM6IHByb3ZpZGVyQ29tcG9uZW50cyxcbn06IENvbXBvbmVudHNQcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IGNvbnRleHRDb21wb25lbnRzID0gdXNlQ29udGV4dChDb21wb25lbnRzQ29udGV4dCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICAuLi5kZWZhdWx0Q29tcG9uZW50cyxcbiAgICAgIC4uLmNvbnRleHRDb21wb25lbnRzLFxuICAgICAgLi4ucHJvdmlkZXJDb21wb25lbnRzLFxuICAgIH0pLFxuICAgIFtjb250ZXh0Q29tcG9uZW50cywgcHJvdmlkZXJDb21wb25lbnRzXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPENvbXBvbmVudHNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb21wb25lbnRzfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NvbXBvbmVudHNDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuIl0sIm5hbWVzIjpbImRlZmF1bHRDb21wb25lbnRzIiwiQW5jaG9yIiwiQ29tcG9uZW50c0NvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJjb250ZXh0Q29tcG9uZW50cyIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwiQ29tcG9uZW50c1Byb3ZpZGVyIiwiY2hpbGRyZW4iLCJwcm92aWRlckNvbXBvbmVudHMiLCJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/Comment.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/Comment.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Comment: () => (/* binding */ Comment),\n/* harmony export */   CommentLink: () => (/* binding */ CommentLink),\n/* harmony export */   CommentMention: () => (/* binding */ CommentMention),\n/* harmony export */   CommentNonInteractiveLink: () => (/* binding */ CommentNonInteractiveLink),\n/* harmony export */   CommentNonInteractiveReaction: () => (/* binding */ CommentNonInteractiveReaction),\n/* harmony export */   CommentReaction: () => (/* binding */ CommentReaction)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs\");\n/* harmony import */ var _radix_ui_react_toggle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @radix-ui/react-toggle */ \"(ssr)/./node_modules/@radix-ui/react-toggle/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _icons_Check_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../icons/Check.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Check.mjs\");\n/* harmony import */ var _icons_Cross_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../icons/Cross.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Cross.mjs\");\n/* harmony import */ var _icons_Delete_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../icons/Delete.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Delete.mjs\");\n/* harmony import */ var _icons_Edit_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../icons/Edit.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Edit.mjs\");\n/* harmony import */ var _icons_Ellipsis_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../icons/Ellipsis.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Ellipsis.mjs\");\n/* harmony import */ var _icons_EmojiAdd_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../icons/EmojiAdd.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/EmojiAdd.mjs\");\n/* harmony import */ var _overrides_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../overrides.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\");\n/* harmony import */ var _primitives_Comment_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/Comment/index.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Comment/index.mjs\");\n/* harmony import */ var _primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../primitives/Composer/index.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/index.mjs\");\n/* harmony import */ var _primitives_Timestamp_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../primitives/Timestamp.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Timestamp.mjs\");\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/shared.mjs\");\n/* harmony import */ var _slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../slate/plugins/mentions.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/mentions.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* harmony import */ var _utils_use_refs_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils/use-refs.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-refs.mjs\");\n/* harmony import */ var _utils_use_visible_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../utils/use-visible.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-visible.mjs\");\n/* harmony import */ var _utils_use_window_focus_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/use-window-focus.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-window-focus.mjs\");\n/* harmony import */ var _Composer_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./Composer.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/Composer.mjs\");\n/* harmony import */ var _internal_Avatar_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./internal/Avatar.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Avatar.mjs\");\n/* harmony import */ var _internal_Button_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./internal/Button.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Button.mjs\");\n/* harmony import */ var _internal_Dropdown_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./internal/Dropdown.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Dropdown.mjs\");\n/* harmony import */ var _internal_Emoji_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./internal/Emoji.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.mjs\");\n/* harmony import */ var _internal_EmojiPicker_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./internal/EmojiPicker.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/EmojiPicker.mjs\");\n/* harmony import */ var _internal_List_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./internal/List.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/List.mjs\");\n/* harmony import */ var _internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./internal/Tooltip.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.mjs\");\n/* harmony import */ var _internal_User_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/User.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/User.mjs\");\n/* harmony import */ var _radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @radix-ui/react-tooltip */ \"(ssr)/./node_modules/@radix-ui/react-tooltip/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @radix-ui/react-popover */ \"(ssr)/./node_modules/@radix-ui/react-popover/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @radix-ui/react-dropdown-menu */ \"(ssr)/./node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ Comment,CommentLink,CommentMention,CommentNonInteractiveLink,CommentNonInteractiveReaction,CommentReaction auto */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst REACTIONS_TRUNCATE = 5;\nfunction CommentMention({ userId, className, ...props }) {\n    const currentId = (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_1__.useCurrentUserId)();\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Comment_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Mention, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_3__.classNames)(\"lb-comment-mention\", className),\n        \"data-self\": userId === currentId ? \"\" : void 0,\n        ...props\n    }, _slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_4__.MENTION_CHARACTER, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_User_mjs__WEBPACK_IMPORTED_MODULE_5__.User, {\n        userId\n    }));\n}\nfunction CommentLink({ href, children, className, ...props }) {\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Comment_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Link, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_3__.classNames)(\"lb-comment-link\", className),\n        href,\n        ...props\n    }, children);\n}\nfunction CommentNonInteractiveLink({ href: _href, children, className, ...props }) {\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_3__.classNames)(\"lb-comment-link\", className),\n        ...props\n    }, children);\n}\nconst CommentReactionButton = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ reaction, overrides, className, ...props }, forwardedRef)=>{\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_6__.useOverrides)(overrides);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_7__.Button, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_3__.classNames)(\"lb-comment-reaction\", className),\n        variant: \"outline\",\n        \"aria-label\": $.COMMENT_REACTION_DESCRIPTION(reaction.emoji, reaction.users.length),\n        ...props,\n        ref: forwardedRef\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Emoji_mjs__WEBPACK_IMPORTED_MODULE_8__.Emoji, {\n        className: \"lb-comment-reaction-emoji\",\n        emoji: reaction.emoji\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"lb-comment-reaction-count\"\n    }, reaction.users.length));\n});\nconst CommentReaction = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ comment, reaction, overrides, disabled, ...props }, forwardedRef)=>{\n    const addReaction = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_9__._useAddReaction)();\n    const removeReaction = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_9__.useRemoveReaction)();\n    const currentId = (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_1__.useCurrentUserId)();\n    const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return reaction.users.some((users)=>users.id === currentId);\n    }, [\n        currentId,\n        reaction\n    ]);\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_6__.useOverrides)(overrides);\n    const tooltipContent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, $.COMMENT_REACTION_LIST(/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_List_mjs__WEBPACK_IMPORTED_MODULE_10__.List, {\n            values: reaction.users.map((users, index)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_User_mjs__WEBPACK_IMPORTED_MODULE_5__.User, {\n                    key: users.id,\n                    userId: users.id,\n                    capitalize: index === 0,\n                    replaceSelf: true\n                })),\n            formatRemaining: $.LIST_REMAINING_USERS,\n            truncate: REACTIONS_TRUNCATE\n        }), reaction.emoji, reaction.users.length)), [\n        $,\n        reaction\n    ]);\n    const handlePressedChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((isPressed)=>{\n        if (isPressed) {\n            addReaction({\n                threadId: comment.threadId,\n                commentId: comment.id,\n                emoji: reaction.emoji\n            });\n        } else {\n            removeReaction({\n                threadId: comment.threadId,\n                commentId: comment.id,\n                emoji: reaction.emoji\n            });\n        }\n    }, [\n        addReaction,\n        comment.threadId,\n        comment.id,\n        reaction.emoji,\n        removeReaction\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n        content: tooltipContent,\n        multiline: true,\n        className: \"lb-comment-reaction-tooltip\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_toggle__WEBPACK_IMPORTED_MODULE_12__.Root, {\n        asChild: true,\n        pressed: isActive,\n        onPressedChange: handlePressedChange,\n        disabled,\n        ref: forwardedRef\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommentReactionButton, {\n        \"data-self\": isActive ? \"\" : void 0,\n        reaction,\n        overrides,\n        ...props\n    })));\n});\nconst CommentNonInteractiveReaction = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ reaction, overrides, ...props }, forwardedRef)=>{\n    const currentId = (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_1__.useCurrentUserId)();\n    const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return reaction.users.some((users)=>users.id === currentId);\n    }, [\n        currentId,\n        reaction\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommentReactionButton, {\n        disableable: false,\n        \"data-self\": isActive ? \"\" : void 0,\n        reaction,\n        overrides,\n        ...props,\n        ref: forwardedRef\n    });\n});\nfunction AutoMarkReadThreadIdHandler({ threadId, commentRef }) {\n    const markThreadAsRead = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_9__.useMarkThreadAsRead)();\n    const isWindowFocused = (0,_utils_use_window_focus_mjs__WEBPACK_IMPORTED_MODULE_13__.useWindowFocus)();\n    (0,_utils_use_visible_mjs__WEBPACK_IMPORTED_MODULE_14__.useVisibleCallback)(commentRef, ()=>{\n        markThreadAsRead(threadId);\n    }, {\n        enabled: isWindowFocused\n    });\n    return null;\n}\nconst Comment = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ comment, indentContent = true, showDeleted, showActions = \"hover\", showReactions = true, onAuthorClick, onMentionClick, onCommentEdit, onCommentDelete, overrides, className, additionalActions, additionalActionsClassName, autoMarkReadThreadId, ...props }, forwardedRef)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const mergedRefs = (0,_utils_use_refs_mjs__WEBPACK_IMPORTED_MODULE_15__.useRefs)(forwardedRef, ref);\n    const self = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_9__._useSelf)();\n    const deleteComment = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_9__.useDeleteComment)();\n    const editComment = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_9__.useEditComment)();\n    const addReaction = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_9__._useAddReaction)();\n    const removeReaction = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_9__.useRemoveReaction)();\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_6__.useOverrides)(overrides);\n    const [isEditing, setEditing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isTarget, setTarget] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isMoreActionOpen, setMoreActionOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isReactionActionOpen, setReactionActionOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const stopPropagation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.stopPropagation();\n    }, []);\n    const handleEdit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setEditing(true);\n    }, []);\n    const handleEditCancel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.stopPropagation();\n        setEditing(false);\n    }, []);\n    const handleEditSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ body }, event)=>{\n        onCommentEdit?.(comment);\n        event.preventDefault();\n        setEditing(false);\n        editComment({\n            commentId: comment.id,\n            threadId: comment.threadId,\n            body\n        });\n    }, [\n        comment,\n        editComment,\n        onCommentEdit\n    ]);\n    const handleDelete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        onCommentDelete?.(comment);\n        deleteComment({\n            commentId: comment.id,\n            threadId: comment.threadId\n        });\n    }, [\n        comment,\n        deleteComment,\n        onCommentDelete\n    ]);\n    const handleAuthorClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onAuthorClick?.(comment.userId, event);\n    }, [\n        comment.userId,\n        onAuthorClick\n    ]);\n    const handleReactionSelect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((emoji)=>{\n        const reactionIndex = comment.reactions.findIndex((reaction)=>reaction.emoji === emoji);\n        if (reactionIndex >= 0 && self?.id && comment.reactions[reactionIndex].users.some((user)=>user.id === self?.id)) {\n            removeReaction({\n                threadId: comment.threadId,\n                commentId: comment.id,\n                emoji\n            });\n        } else {\n            addReaction({\n                threadId: comment.threadId,\n                commentId: comment.id,\n                emoji\n            });\n        }\n    }, [\n        addReaction,\n        comment.id,\n        comment.reactions,\n        comment.threadId,\n        removeReaction,\n        self?.id\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const isWindowDefined = \"undefined\" !== \"undefined\";\n        if (!isWindowDefined) return;\n        const hash = window.location.hash;\n        const commentId = hash.slice(1);\n        if (commentId === comment.id) {\n            setTarget(true);\n        }\n    }, []);\n    if (!showDeleted && !comment.body) {\n        return null;\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_16__.TooltipProvider, null, autoMarkReadThreadId && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AutoMarkReadThreadIdHandler, {\n        commentRef: ref,\n        threadId: autoMarkReadThreadId\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: comment.id,\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_3__.classNames)(\"lb-root lb-comment\", indentContent && \"lb-comment:indent-content\", showActions === \"hover\" && \"lb-comment:show-actions-hover\", (isMoreActionOpen || isReactionActionOpen) && \"lb-comment:action-open\", className),\n        \"data-deleted\": !comment.body ? \"\" : void 0,\n        \"data-editing\": isEditing ? \"\" : void 0,\n        \"data-target\": isTarget ? \"\" : void 0,\n        dir: $.dir,\n        ...props,\n        ref: mergedRefs\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-comment-header\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-comment-details\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Avatar_mjs__WEBPACK_IMPORTED_MODULE_17__.Avatar, {\n        className: \"lb-comment-avatar\",\n        userId: comment.userId,\n        onClick: handleAuthorClick\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"lb-comment-details-labels\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_User_mjs__WEBPACK_IMPORTED_MODULE_5__.User, {\n        className: \"lb-comment-author\",\n        userId: comment.userId,\n        onClick: handleAuthorClick\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"lb-comment-date\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Timestamp_mjs__WEBPACK_IMPORTED_MODULE_18__.Timestamp, {\n        locale: $.locale,\n        date: comment.createdAt,\n        className: \"lb-comment-date-created\"\n    }), comment.editedAt && comment.body && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \" \", /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"lb-comment-date-edited\"\n    }, $.COMMENT_EDITED))))), showActions && !isEditing && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_3__.classNames)(\"lb-comment-actions\", additionalActionsClassName)\n    }, additionalActions ?? null, showReactions && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_EmojiPicker_mjs__WEBPACK_IMPORTED_MODULE_19__.EmojiPicker, {\n        onEmojiSelect: handleReactionSelect,\n        onOpenChange: setReactionActionOpen\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n        content: $.COMMENT_ADD_REACTION\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_20__.PopoverTrigger, {\n        asChild: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_7__.Button, {\n        className: \"lb-comment-action\",\n        onClick: stopPropagation,\n        \"aria-label\": $.COMMENT_ADD_REACTION\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_EmojiAdd_mjs__WEBPACK_IMPORTED_MODULE_21__.EmojiAddIcon, {\n        className: \"lb-button-icon\"\n    }))))), comment.userId === self?.id && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Dropdown_mjs__WEBPACK_IMPORTED_MODULE_22__.Dropdown, {\n        open: isMoreActionOpen,\n        onOpenChange: setMoreActionOpen,\n        align: \"end\",\n        content: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Dropdown_mjs__WEBPACK_IMPORTED_MODULE_22__.DropdownItem, {\n            onSelect: handleEdit,\n            onClick: stopPropagation\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Edit_mjs__WEBPACK_IMPORTED_MODULE_23__.EditIcon, {\n            className: \"lb-dropdown-item-icon\"\n        }), $.COMMENT_EDIT), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Dropdown_mjs__WEBPACK_IMPORTED_MODULE_22__.DropdownItem, {\n            onSelect: handleDelete,\n            onClick: stopPropagation\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Delete_mjs__WEBPACK_IMPORTED_MODULE_24__.DeleteIcon, {\n            className: \"lb-dropdown-item-icon\"\n        }), $.COMMENT_DELETE))\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n        content: $.COMMENT_MORE\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_25__.DropdownMenuTrigger, {\n        asChild: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_7__.Button, {\n        className: \"lb-comment-action\",\n        disabled: !comment.body,\n        onClick: stopPropagation,\n        \"aria-label\": $.COMMENT_MORE\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Ellipsis_mjs__WEBPACK_IMPORTED_MODULE_26__.EllipsisIcon, {\n        className: \"lb-button-icon\"\n    }))))))), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-comment-content\"\n    }, isEditing ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Composer_mjs__WEBPACK_IMPORTED_MODULE_27__.Composer, {\n        className: \"lb-comment-composer\",\n        onComposerSubmit: handleEditSubmit,\n        defaultValue: comment.body,\n        autoFocus: true,\n        showAttribution: false,\n        actions: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n            content: $.COMMENT_EDIT_COMPOSER_CANCEL,\n            \"aria-label\": $.COMMENT_EDIT_COMPOSER_CANCEL\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_7__.Button, {\n            className: \"lb-composer-action\",\n            onClick: handleEditCancel\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Cross_mjs__WEBPACK_IMPORTED_MODULE_28__.CrossIcon, {\n            className: \"lb-button-icon\"\n        }))), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__.ShortcutTooltip, {\n            content: $.COMMENT_EDIT_COMPOSER_SAVE,\n            shortcut: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__.ShortcutTooltipKey, {\n                name: \"enter\"\n            })\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_29__.Submit, {\n            asChild: true\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_7__.Button, {\n            variant: \"primary\",\n            className: \"lb-composer-action\",\n            onClick: stopPropagation,\n            \"aria-label\": $.COMMENT_EDIT_COMPOSER_SAVE\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Check_mjs__WEBPACK_IMPORTED_MODULE_30__.CheckIcon, {\n            className: \"lb-button-icon\"\n        }))))),\n        overrides: {\n            COMPOSER_PLACEHOLDER: $.COMMENT_EDIT_COMPOSER_PLACEHOLDER\n        }\n    }) : comment.body ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Comment_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Body, {\n        className: \"lb-comment-body\",\n        body: comment.body,\n        components: {\n            Mention: ({ userId })=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommentMention, {\n                    userId,\n                    onClick: (event)=>onMentionClick?.(userId, event)\n                }),\n            Link: CommentLink\n        }\n    }), showReactions && comment.reactions.length > 0 && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-comment-reactions\"\n    }, comment.reactions.map((reaction)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommentReaction, {\n            key: reaction.emoji,\n            comment,\n            reaction,\n            overrides\n        })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_EmojiPicker_mjs__WEBPACK_IMPORTED_MODULE_19__.EmojiPicker, {\n        onEmojiSelect: handleReactionSelect\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n        content: $.COMMENT_ADD_REACTION\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_20__.PopoverTrigger, {\n        asChild: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_7__.Button, {\n        className: \"lb-comment-reaction lb-comment-reaction-add\",\n        variant: \"outline\",\n        onClick: stopPropagation,\n        \"aria-label\": $.COMMENT_ADD_REACTION\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_EmojiAdd_mjs__WEBPACK_IMPORTED_MODULE_21__.EmojiAddIcon, {\n        className: \"lb-button-icon\"\n    }))))))) : /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-comment-body\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", {\n        className: \"lb-comment-deleted\"\n    }, $.COMMENT_DELETED)))));\n});\n //# sourceMappingURL=Comment.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL0NvbW1lbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkVBLE1BQUFBLHFCQUFBO0FBbUZPLFNBQUFDLGVBQUEsRUFBd0JDLE1BQUEsRUFDN0JDLFNBQUEsRUFDQSxHQUFBQyxPQUVGO0lBQ0UsTUFBQUMsWUFBQUMsNkRBQUFBO0lBQ0EscUNBQUFDLGdEQUFBLENBQUFFLGtFQUFBQSxFQUFBO1FBQ0dOLFdBQUFPLGtFQUFBQSxDQUFBLHNCQUFBUDtRQUNzRCxhQUFBRCxXQUFBRyxZQUFBO1FBQ2QsR0FBQUQsS0FBQTtJQUNuQyxHQUFBTywwRUFBQUEsRUFBQSw4QkFBQUosZ0RBQUEsQ0FBQUssb0RBQUFBLEVBQUE7UUFHSFY7SUFBSztBQUdaO0FBRU8sU0FBQVcsWUFBQSxFQUFxQkMsSUFBQSxFQUMxQkMsUUFBQSxFQUNBWixTQUFBLEVBQ0EsR0FBQUMsT0FFRjtJQUNFLHFDQUFBRyxnREFBQSxDQUFBUywrREFBQUEsRUFBQTtRQUNHYixXQUFBTyxrRUFBQUEsQ0FBQSxtQkFBQVA7UUFDbURXO1FBQ2xELEdBQUFWLEtBQUE7SUFDSSxHQUFBVztBQUtWO0FBRU8sU0FBQUUsMEJBQUEsRUFBbUNILE1BQUFJLEtBQUEsRUFDbENILFFBQUEsRUFDTlosU0FBQSxFQUNBLEdBQUFDLE9BRUY7SUFDRSxxQ0FBQUcsZ0RBQUE7UUFDR0osV0FBQU8sa0VBQUFBLENBQUEsbUJBQUFQO1FBQXVELEdBQUFDLEtBQUE7SUFBTyxHQUFBVztBQUluRTtBQUVBLE1BQUFJLHNDQUFBQyxpREFBQUEsQ0FBQSxHQUFBQyxRQUFBLEVBQUFDLFNBQUEsRUFBQW5CLFNBQUEsS0FBQUMsT0FBQSxFQUFBbUI7SUFJRSxNQUFBQyxJQUFBQyw0REFBQUEsQ0FBQUg7SUFDQSxx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QixnREFBQTtRQUdDSixXQUFBO0lBQWMsR0FBQWdDLFFBQUFzRixTQUFBLENBQUF4RSxHQUFBLEVBQUE1QixXQUFBLDhCQUFBZCxnREFBQSxDQUFBMkIsaUJBQUE7WUFFVmlCLEtBQUE5QixTQUFBUSxLQUFBO1lBQ2VNO1lBQ2RkO1lBQ0FDO1FBQ0EsbUNBQUFmLGdEQUFBLENBQUFzSSxtRUFBQUEsRUFBQTtRQUdIQyxlQUFBdkI7SUFBMkIsaUNBQUFoSCxnREFBQSxDQUFBdUQsMkRBQUFBLEVBQUE7UUFDekJDLFNBQUF2QyxFQUFBd0gsb0JBQUE7SUFBbUIsaUNBQUF6SSxnREFBQSxDQUFBMEksb0VBQUFBLEVBQUE7UUFDakI5RSxTQUFBO0lBQTBCLGlDQUFBNUQsZ0RBQUEsQ0FBQW1CLHdEQUFBQSxFQUFBO1FBQ3hCdkIsV0FBQTtRQUNXd0IsU0FBQTtRQUNGMEcsU0FBQXZCO1FBQ0MsY0FBQXRGLEVBQUF3SCxvQkFBQTtJQUNLLGlDQUFBekksZ0RBQUEsQ0FBQTJJLDhEQUFBQSxFQUFBO1FBRWIvSSxXQUFBO0lBQXVCLHlDQUFBSSxnREFBQTtRQVNyQ0osV0FBQTtJQUFjLGlDQUFBSSxnREFBQTtRQUNaSixXQUFBO0lBQVksR0FBQXFCLEVBQUE0SixlQUFBO0FBS3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4uLy4uL3NyYy9jb21wb25lbnRzL0NvbW1lbnQudHN4P2RhNDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB0eXBlIHtcbiAgQ29tbWVudERhdGEsXG4gIENvbW1lbnRSZWFjdGlvbiBhcyBDb21tZW50UmVhY3Rpb25EYXRhLFxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHtcbiAgdXNlQWRkUmVhY3Rpb24sXG4gIHVzZURlbGV0ZUNvbW1lbnQsXG4gIHVzZUVkaXRDb21tZW50LFxuICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICB1c2VSZW1vdmVSZWFjdGlvbixcbiAgdXNlU2VsZixcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBUb2dnbGVQcmltaXRpdmUgZnJvbSBcIkByYWRpeC11aS9yZWFjdC10b2dnbGVcIjtcbmltcG9ydCB0eXBlIHtcbiAgQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmLFxuICBGb3JtRXZlbnQsXG4gIE1vdXNlRXZlbnQsXG4gIFJlYWN0Tm9kZSxcbiAgUmVmT2JqZWN0LFxuICBTeW50aGV0aWNFdmVudCxcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtcbiAgZm9yd2FyZFJlZixcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgdXNlUmVmLFxuICB1c2VTdGF0ZSxcbn0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IENoZWNrSWNvbiB9IGZyb20gXCIuLi9pY29ucy9DaGVja1wiO1xuaW1wb3J0IHsgQ3Jvc3NJY29uIH0gZnJvbSBcIi4uL2ljb25zL0Nyb3NzXCI7XG5pbXBvcnQgeyBEZWxldGVJY29uIH0gZnJvbSBcIi4uL2ljb25zL0RlbGV0ZVwiO1xuaW1wb3J0IHsgRWRpdEljb24gfSBmcm9tIFwiLi4vaWNvbnMvRWRpdFwiO1xuaW1wb3J0IHsgRWxsaXBzaXNJY29uIH0gZnJvbSBcIi4uL2ljb25zL0VsbGlwc2lzXCI7XG5pbXBvcnQgeyBFbW9qaUFkZEljb24gfSBmcm9tIFwiLi4vaWNvbnMvRW1vamlBZGRcIjtcbmltcG9ydCB0eXBlIHtcbiAgQ29tbWVudE92ZXJyaWRlcyxcbiAgQ29tcG9zZXJPdmVycmlkZXMsXG4gIEdsb2JhbE92ZXJyaWRlcyxcbn0gZnJvbSBcIi4uL292ZXJyaWRlc1wiO1xuaW1wb3J0IHsgdXNlT3ZlcnJpZGVzIH0gZnJvbSBcIi4uL292ZXJyaWRlc1wiO1xuaW1wb3J0IHR5cGUgeyBDb21wb3NlclN1Ym1pdENvbW1lbnQgfSBmcm9tIFwiLi4vcHJpbWl0aXZlc1wiO1xuaW1wb3J0ICogYXMgQ29tbWVudFByaW1pdGl2ZSBmcm9tIFwiLi4vcHJpbWl0aXZlcy9Db21tZW50XCI7XG5pbXBvcnQgdHlwZSB7XG4gIENvbW1lbnRCb2R5TGlua1Byb3BzLFxuICBDb21tZW50Qm9keU1lbnRpb25Qcm9wcyxcbiAgQ29tbWVudExpbmtQcm9wcyxcbiAgQ29tbWVudE1lbnRpb25Qcm9wcyxcbn0gZnJvbSBcIi4uL3ByaW1pdGl2ZXMvQ29tbWVudC90eXBlc1wiO1xuaW1wb3J0ICogYXMgQ29tcG9zZXJQcmltaXRpdmUgZnJvbSBcIi4uL3ByaW1pdGl2ZXMvQ29tcG9zZXJcIjtcbmltcG9ydCB7IFRpbWVzdGFtcCB9IGZyb20gXCIuLi9wcmltaXRpdmVzL1RpbWVzdGFtcFwiO1xuaW1wb3J0IHsgdXNlQ3VycmVudFVzZXJJZCB9IGZyb20gXCIuLi9zaGFyZWRcIjtcbmltcG9ydCB7IE1FTlRJT05fQ0hBUkFDVEVSIH0gZnJvbSBcIi4uL3NsYXRlL3BsdWdpbnMvbWVudGlvbnNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiLi4vdXRpbHMvY2xhc3MtbmFtZXNcIjtcbmltcG9ydCB7IHVzZVJlZnMgfSBmcm9tIFwiLi4vdXRpbHMvdXNlLXJlZnNcIjtcbmltcG9ydCB7IHVzZVZpc2libGVDYWxsYmFjayB9IGZyb20gXCIuLi91dGlscy91c2UtdmlzaWJsZVwiO1xuaW1wb3J0IHsgdXNlV2luZG93Rm9jdXMgfSBmcm9tIFwiLi4vdXRpbHMvdXNlLXdpbmRvdy1mb2N1c1wiO1xuaW1wb3J0IHsgQ29tcG9zZXIgfSBmcm9tIFwiLi9Db21wb3NlclwiO1xuaW1wb3J0IHsgQXZhdGFyIH0gZnJvbSBcIi4vaW50ZXJuYWwvQXZhdGFyXCI7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiLi9pbnRlcm5hbC9CdXR0b25cIjtcbmltcG9ydCB7IERyb3Bkb3duLCBEcm9wZG93bkl0ZW0sIERyb3Bkb3duVHJpZ2dlciB9IGZyb20gXCIuL2ludGVybmFsL0Ryb3Bkb3duXCI7XG5pbXBvcnQgeyBFbW9qaSB9IGZyb20gXCIuL2ludGVybmFsL0Vtb2ppXCI7XG5pbXBvcnQgeyBFbW9qaVBpY2tlciwgRW1vamlQaWNrZXJUcmlnZ2VyIH0gZnJvbSBcIi4vaW50ZXJuYWwvRW1vamlQaWNrZXJcIjtcbmltcG9ydCB7IExpc3QgfSBmcm9tIFwiLi9pbnRlcm5hbC9MaXN0XCI7XG5pbXBvcnQge1xuICBTaG9ydGN1dFRvb2x0aXAsXG4gIFNob3J0Y3V0VG9vbHRpcEtleSxcbiAgVG9vbHRpcCxcbiAgVG9vbHRpcFByb3ZpZGVyLFxufSBmcm9tIFwiLi9pbnRlcm5hbC9Ub29sdGlwXCI7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSBcIi4vaW50ZXJuYWwvVXNlclwiO1xuXG5jb25zdCBSRUFDVElPTlNfVFJVTkNBVEUgPSA1O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbW1lbnRQcm9wcyBleHRlbmRzIENvbXBvbmVudFByb3BzV2l0aG91dFJlZjxcImRpdlwiPiB7XG4gIC8qKlxuICAgKiBUaGUgY29tbWVudCB0byBkaXNwbGF5LlxuICAgKi9cbiAgY29tbWVudDogQ29tbWVudERhdGE7XG5cbiAgLyoqXG4gICAqIEhvdyB0byBzaG93IG9yIGhpZGUgdGhlIGFjdGlvbnMuXG4gICAqL1xuICBzaG93QWN0aW9ucz86IGJvb2xlYW4gfCBcImhvdmVyXCI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2hvdyB0aGUgY29tbWVudCBpZiBpdCB3YXMgZGVsZXRlZC4gSWYgc2V0IHRvIGBmYWxzZWAsIGl0IHdpbGwgcmVuZGVyIGRlbGV0ZWQgY29tbWVudHMgYXMgYG51bGxgLlxuICAgKi9cbiAgc2hvd0RlbGV0ZWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHNob3cgcmVhY3Rpb25zLlxuICAgKi9cbiAgc2hvd1JlYWN0aW9ucz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gaW5kZW50IHRoZSBjb21tZW50J3MgY29udGVudC5cbiAgICovXG4gIGluZGVudENvbnRlbnQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgY29tbWVudCBpcyBlZGl0ZWQuXG4gICAqL1xuICBvbkNvbW1lbnRFZGl0PzogKGNvbW1lbnQ6IENvbW1lbnREYXRhKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgY29tbWVudCBpcyBkZWxldGVkLlxuICAgKi9cbiAgb25Db21tZW50RGVsZXRlPzogKGNvbW1lbnQ6IENvbW1lbnREYXRhKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaGFuZGxlciBjYWxsZWQgd2hlbiBjbGlja2luZyBvbiB0aGUgYXV0aG9yLlxuICAgKi9cbiAgb25BdXRob3JDbGljaz86ICh1c2VySWQ6IHN0cmluZywgZXZlbnQ6IE1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaGFuZGxlciBjYWxsZWQgd2hlbiBjbGlja2luZyBvbiBhIG1lbnRpb24uXG4gICAqL1xuICBvbk1lbnRpb25DbGljaz86ICh1c2VySWQ6IHN0cmluZywgZXZlbnQ6IE1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgY29tcG9uZW50J3Mgc3RyaW5ncy5cbiAgICovXG4gIG92ZXJyaWRlcz86IFBhcnRpYWw8R2xvYmFsT3ZlcnJpZGVzICYgQ29tbWVudE92ZXJyaWRlcyAmIENvbXBvc2VyT3ZlcnJpZGVzPjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhdXRvTWFya1JlYWRUaHJlYWRJZD86IHN0cmluZztcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRpdGlvbmFsQWN0aW9ucz86IFJlYWN0Tm9kZTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRpdGlvbmFsQWN0aW9uc0NsYXNzTmFtZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENvbW1lbnRSZWFjdGlvbkJ1dHRvblByb3BzXG4gIGV4dGVuZHMgQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBCdXR0b24+IHtcbiAgcmVhY3Rpb246IENvbW1lbnRSZWFjdGlvbkRhdGE7XG4gIG92ZXJyaWRlcz86IFBhcnRpYWw8R2xvYmFsT3ZlcnJpZGVzICYgQ29tbWVudE92ZXJyaWRlcz47XG59XG5cbmludGVyZmFjZSBDb21tZW50UmVhY3Rpb25Qcm9wcyBleHRlbmRzIENvbXBvbmVudFByb3BzV2l0aG91dFJlZjxcImJ1dHRvblwiPiB7XG4gIGNvbW1lbnQ6IENvbW1lbnREYXRhO1xuICByZWFjdGlvbjogQ29tbWVudFJlYWN0aW9uRGF0YTtcbiAgb3ZlcnJpZGVzPzogUGFydGlhbDxHbG9iYWxPdmVycmlkZXMgJiBDb21tZW50T3ZlcnJpZGVzPjtcbn1cblxudHlwZSBDb21tZW50Tm9uSW50ZXJhY3RpdmVSZWFjdGlvblByb3BzID0gT21pdDxDb21tZW50UmVhY3Rpb25Qcm9wcywgXCJjb21tZW50XCI+O1xuXG5leHBvcnQgZnVuY3Rpb24gQ29tbWVudE1lbnRpb24oe1xuICB1c2VySWQsXG4gIGNsYXNzTmFtZSxcbiAgLi4ucHJvcHNcbn06IENvbW1lbnRCb2R5TWVudGlvblByb3BzICYgQ29tbWVudE1lbnRpb25Qcm9wcykge1xuICBjb25zdCBjdXJyZW50SWQgPSB1c2VDdXJyZW50VXNlcklkKCk7XG4gIHJldHVybiAoXG4gICAgPENvbW1lbnRQcmltaXRpdmUuTWVudGlvblxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwibGItY29tbWVudC1tZW50aW9uXCIsIGNsYXNzTmFtZSl9XG4gICAgICBkYXRhLXNlbGY9e3VzZXJJZCA9PT0gY3VycmVudElkID8gXCJcIiA6IHVuZGVmaW5lZH1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICB7TUVOVElPTl9DSEFSQUNURVJ9XG4gICAgICA8VXNlciB1c2VySWQ9e3VzZXJJZH0gLz5cbiAgICA8L0NvbW1lbnRQcmltaXRpdmUuTWVudGlvbj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvbW1lbnRMaW5rKHtcbiAgaHJlZixcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZSxcbiAgLi4ucHJvcHNcbn06IENvbW1lbnRCb2R5TGlua1Byb3BzICYgQ29tbWVudExpbmtQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxDb21tZW50UHJpbWl0aXZlLkxpbmtcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcImxiLWNvbW1lbnQtbGlua1wiLCBjbGFzc05hbWUpfVxuICAgICAgaHJlZj17aHJlZn1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Db21tZW50UHJpbWl0aXZlLkxpbms+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb21tZW50Tm9uSW50ZXJhY3RpdmVMaW5rKHtcbiAgaHJlZjogX2hyZWYsXG4gIGNoaWxkcmVuLFxuICBjbGFzc05hbWUsXG4gIC4uLnByb3BzXG59OiBDb21tZW50Qm9keUxpbmtQcm9wcyAmIENvbW1lbnRMaW5rUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8c3BhbiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJsYi1jb21tZW50LWxpbmtcIiwgY2xhc3NOYW1lKX0gey4uLnByb3BzfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L3NwYW4+XG4gICk7XG59XG5cbmNvbnN0IENvbW1lbnRSZWFjdGlvbkJ1dHRvbiA9IGZvcndhcmRSZWY8XG4gIEhUTUxCdXR0b25FbGVtZW50LFxuICBDb21tZW50UmVhY3Rpb25CdXR0b25Qcm9wc1xuPigoeyByZWFjdGlvbiwgb3ZlcnJpZGVzLCBjbGFzc05hbWUsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCAkID0gdXNlT3ZlcnJpZGVzKG92ZXJyaWRlcyk7XG4gIHJldHVybiAoXG4gICAgPEJ1dHRvblxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwibGItY29tbWVudC1yZWFjdGlvblwiLCBjbGFzc05hbWUpfVxuICAgICAgdmFyaWFudD1cIm91dGxpbmVcIlxuICAgICAgYXJpYS1sYWJlbD17JC5DT01NRU5UX1JFQUNUSU9OX0RFU0NSSVBUSU9OKFxuICAgICAgICByZWFjdGlvbi5lbW9qaSxcbiAgICAgICAgcmVhY3Rpb24udXNlcnMubGVuZ3RoXG4gICAgICApfVxuICAgICAgey4uLnByb3BzfVxuICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgPlxuICAgICAgPEVtb2ppIGNsYXNzTmFtZT1cImxiLWNvbW1lbnQtcmVhY3Rpb24tZW1vamlcIiBlbW9qaT17cmVhY3Rpb24uZW1vaml9IC8+XG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJsYi1jb21tZW50LXJlYWN0aW9uLWNvdW50XCI+e3JlYWN0aW9uLnVzZXJzLmxlbmd0aH08L3NwYW4+XG4gICAgPC9CdXR0b24+XG4gICk7XG59KTtcblxuZXhwb3J0IGNvbnN0IENvbW1lbnRSZWFjdGlvbiA9IGZvcndhcmRSZWY8XG4gIEhUTUxCdXR0b25FbGVtZW50LFxuICBDb21tZW50UmVhY3Rpb25Qcm9wc1xuPigoeyBjb21tZW50LCByZWFjdGlvbiwgb3ZlcnJpZGVzLCBkaXNhYmxlZCwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IGFkZFJlYWN0aW9uID0gdXNlQWRkUmVhY3Rpb24oKTtcbiAgY29uc3QgcmVtb3ZlUmVhY3Rpb24gPSB1c2VSZW1vdmVSZWFjdGlvbigpO1xuICBjb25zdCBjdXJyZW50SWQgPSB1c2VDdXJyZW50VXNlcklkKCk7XG4gIGNvbnN0IGlzQWN0aXZlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHJlYWN0aW9uLnVzZXJzLnNvbWUoKHVzZXJzKSA9PiB1c2Vycy5pZCA9PT0gY3VycmVudElkKTtcbiAgfSwgW2N1cnJlbnRJZCwgcmVhY3Rpb25dKTtcbiAgY29uc3QgJCA9IHVzZU92ZXJyaWRlcyhvdmVycmlkZXMpO1xuICBjb25zdCB0b29sdGlwQ29udGVudCA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKFxuICAgICAgPHNwYW4+XG4gICAgICAgIHskLkNPTU1FTlRfUkVBQ1RJT05fTElTVChcbiAgICAgICAgICA8TGlzdFxuICAgICAgICAgICAgdmFsdWVzPXtyZWFjdGlvbi51c2Vycy5tYXAoKHVzZXJzLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICA8VXNlclxuICAgICAgICAgICAgICAgIGtleT17dXNlcnMuaWR9XG4gICAgICAgICAgICAgICAgdXNlcklkPXt1c2Vycy5pZH1cbiAgICAgICAgICAgICAgICBjYXBpdGFsaXplPXtpbmRleCA9PT0gMH1cbiAgICAgICAgICAgICAgICByZXBsYWNlU2VsZlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICBmb3JtYXRSZW1haW5pbmc9eyQuTElTVF9SRU1BSU5JTkdfVVNFUlN9XG4gICAgICAgICAgICB0cnVuY2F0ZT17UkVBQ1RJT05TX1RSVU5DQVRFfVxuICAgICAgICAgIC8+LFxuICAgICAgICAgIHJlYWN0aW9uLmVtb2ppLFxuICAgICAgICAgIHJlYWN0aW9uLnVzZXJzLmxlbmd0aFxuICAgICAgICApfVxuICAgICAgPC9zcGFuPlxuICAgICksXG4gICAgWyQsIHJlYWN0aW9uXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZVByZXNzZWRDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAoaXNQcmVzc2VkOiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAoaXNQcmVzc2VkKSB7XG4gICAgICAgIGFkZFJlYWN0aW9uKHtcbiAgICAgICAgICB0aHJlYWRJZDogY29tbWVudC50aHJlYWRJZCxcbiAgICAgICAgICBjb21tZW50SWQ6IGNvbW1lbnQuaWQsXG4gICAgICAgICAgZW1vamk6IHJlYWN0aW9uLmVtb2ppLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZVJlYWN0aW9uKHtcbiAgICAgICAgICB0aHJlYWRJZDogY29tbWVudC50aHJlYWRJZCxcbiAgICAgICAgICBjb21tZW50SWQ6IGNvbW1lbnQuaWQsXG4gICAgICAgICAgZW1vamk6IHJlYWN0aW9uLmVtb2ppLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFthZGRSZWFjdGlvbiwgY29tbWVudC50aHJlYWRJZCwgY29tbWVudC5pZCwgcmVhY3Rpb24uZW1vamksIHJlbW92ZVJlYWN0aW9uXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPFRvb2x0aXBcbiAgICAgIGNvbnRlbnQ9e3Rvb2x0aXBDb250ZW50fVxuICAgICAgbXVsdGlsaW5lXG4gICAgICBjbGFzc05hbWU9XCJsYi1jb21tZW50LXJlYWN0aW9uLXRvb2x0aXBcIlxuICAgID5cbiAgICAgIDxUb2dnbGVQcmltaXRpdmUuUm9vdFxuICAgICAgICBhc0NoaWxkXG4gICAgICAgIHByZXNzZWQ9e2lzQWN0aXZlfVxuICAgICAgICBvblByZXNzZWRDaGFuZ2U9e2hhbmRsZVByZXNzZWRDaGFuZ2V9XG4gICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICA+XG4gICAgICAgIDxDb21tZW50UmVhY3Rpb25CdXR0b25cbiAgICAgICAgICBkYXRhLXNlbGY9e2lzQWN0aXZlID8gXCJcIiA6IHVuZGVmaW5lZH1cbiAgICAgICAgICByZWFjdGlvbj17cmVhY3Rpb259XG4gICAgICAgICAgb3ZlcnJpZGVzPXtvdmVycmlkZXN9XG4gICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAvPlxuICAgICAgPC9Ub2dnbGVQcmltaXRpdmUuUm9vdD5cbiAgICA8L1Rvb2x0aXA+XG4gICk7XG59KTtcblxuZXhwb3J0IGNvbnN0IENvbW1lbnROb25JbnRlcmFjdGl2ZVJlYWN0aW9uID0gZm9yd2FyZFJlZjxcbiAgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gIENvbW1lbnROb25JbnRlcmFjdGl2ZVJlYWN0aW9uUHJvcHNcbj4oKHsgcmVhY3Rpb24sIG92ZXJyaWRlcywgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRJZCA9IHVzZUN1cnJlbnRVc2VySWQoKTtcbiAgY29uc3QgaXNBY3RpdmUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gcmVhY3Rpb24udXNlcnMuc29tZSgodXNlcnMpID0+IHVzZXJzLmlkID09PSBjdXJyZW50SWQpO1xuICB9LCBbY3VycmVudElkLCByZWFjdGlvbl0pO1xuXG4gIHJldHVybiAoXG4gICAgPENvbW1lbnRSZWFjdGlvbkJ1dHRvblxuICAgICAgZGlzYWJsZWFibGU9e2ZhbHNlfVxuICAgICAgZGF0YS1zZWxmPXtpc0FjdGl2ZSA/IFwiXCIgOiB1bmRlZmluZWR9XG4gICAgICByZWFjdGlvbj17cmVhY3Rpb259XG4gICAgICBvdmVycmlkZXM9e292ZXJyaWRlc31cbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgIC8+XG4gICk7XG59KTtcblxuLy8gQSB2b2lkIGNvbXBvbmVudCAod2hpY2ggZG9lc24ndCByZW5kZXIgYW55dGhpbmcpIHJlc3BvbnNpYmxlIGZvciBtYXJraW5nIGEgdGhyZWFkXG4vLyBhcyByZWFkIHdoZW4gdGhlIGNvbW1lbnQgaXQncyB1c2VkIGluIGJlY29tZXMgdmlzaWJsZS5cbi8vIE1vdmluZyB0aGlzIGxvZ2ljIGludG8gYSBzZXBhcmF0ZSBjb21wb25lbnQgYWxsb3dzIHVzIHRvIHVzZSB0aGUgdmlzaWJpbGl0eVxuLy8gYW5kIGZvY3VzIGhvb2tzIFwiY29uZGl0aW9uYWxseVwiIGJ5IGNvbmRpdGlvbmFsbHkgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50LlxuZnVuY3Rpb24gQXV0b01hcmtSZWFkVGhyZWFkSWRIYW5kbGVyKHtcbiAgdGhyZWFkSWQsXG4gIGNvbW1lbnRSZWYsXG59OiB7XG4gIHRocmVhZElkOiBzdHJpbmc7XG4gIGNvbW1lbnRSZWY6IFJlZk9iamVjdDxIVE1MRWxlbWVudD47XG59KSB7XG4gIGNvbnN0IG1hcmtUaHJlYWRBc1JlYWQgPSB1c2VNYXJrVGhyZWFkQXNSZWFkKCk7XG4gIGNvbnN0IGlzV2luZG93Rm9jdXNlZCA9IHVzZVdpbmRvd0ZvY3VzKCk7XG5cbiAgdXNlVmlzaWJsZUNhbGxiYWNrKFxuICAgIGNvbW1lbnRSZWYsXG4gICAgKCkgPT4ge1xuICAgICAgbWFya1RocmVhZEFzUmVhZCh0aHJlYWRJZCk7XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBUaGUgdW5kZXJseWluZyBJbnRlcnNlY3Rpb25PYnNlcnZlciBpcyBvbmx5IGVuYWJsZWQgd2hlbiB0aGUgd2luZG93IGlzIGZvY3VzZWRcbiAgICAgIGVuYWJsZWQ6IGlzV2luZG93Rm9jdXNlZCxcbiAgICB9XG4gICk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGlzcGxheXMgYSBzaW5nbGUgY29tbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogPD5cbiAqICAge3RocmVhZC5jb21tZW50cy5tYXAoKGNvbW1lbnQpID0+IChcbiAqICAgICA8Q29tbWVudCBrZXk9e2NvbW1lbnQuaWR9IGNvbW1lbnQ9e2NvbW1lbnR9IC8+XG4gKiAgICkpfVxuICogPC8+XG4gKi9cbmV4cG9ydCBjb25zdCBDb21tZW50ID0gZm9yd2FyZFJlZjxIVE1MRGl2RWxlbWVudCwgQ29tbWVudFByb3BzPihcbiAgKFxuICAgIHtcbiAgICAgIGNvbW1lbnQsXG4gICAgICBpbmRlbnRDb250ZW50ID0gdHJ1ZSxcbiAgICAgIHNob3dEZWxldGVkLFxuICAgICAgc2hvd0FjdGlvbnMgPSBcImhvdmVyXCIsXG4gICAgICBzaG93UmVhY3Rpb25zID0gdHJ1ZSxcbiAgICAgIG9uQXV0aG9yQ2xpY2ssXG4gICAgICBvbk1lbnRpb25DbGljayxcbiAgICAgIG9uQ29tbWVudEVkaXQsXG4gICAgICBvbkNvbW1lbnREZWxldGUsXG4gICAgICBvdmVycmlkZXMsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBhZGRpdGlvbmFsQWN0aW9ucyxcbiAgICAgIGFkZGl0aW9uYWxBY3Rpb25zQ2xhc3NOYW1lLFxuICAgICAgYXV0b01hcmtSZWFkVGhyZWFkSWQsXG4gICAgICAuLi5wcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gICAgY29uc3QgbWVyZ2VkUmVmcyA9IHVzZVJlZnMoZm9yd2FyZGVkUmVmLCByZWYpO1xuICAgIGNvbnN0IHNlbGYgPSB1c2VTZWxmKCk7XG4gICAgY29uc3QgZGVsZXRlQ29tbWVudCA9IHVzZURlbGV0ZUNvbW1lbnQoKTtcbiAgICBjb25zdCBlZGl0Q29tbWVudCA9IHVzZUVkaXRDb21tZW50KCk7XG4gICAgY29uc3QgYWRkUmVhY3Rpb24gPSB1c2VBZGRSZWFjdGlvbigpO1xuICAgIGNvbnN0IHJlbW92ZVJlYWN0aW9uID0gdXNlUmVtb3ZlUmVhY3Rpb24oKTtcbiAgICBjb25zdCAkID0gdXNlT3ZlcnJpZGVzKG92ZXJyaWRlcyk7XG4gICAgY29uc3QgW2lzRWRpdGluZywgc2V0RWRpdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2lzVGFyZ2V0LCBzZXRUYXJnZXRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtpc01vcmVBY3Rpb25PcGVuLCBzZXRNb3JlQWN0aW9uT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2lzUmVhY3Rpb25BY3Rpb25PcGVuLCBzZXRSZWFjdGlvbkFjdGlvbk9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3Qgc3RvcFByb3BhZ2F0aW9uID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBTeW50aGV0aWNFdmVudCkgPT4ge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgaGFuZGxlRWRpdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHNldEVkaXRpbmcodHJ1ZSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgaGFuZGxlRWRpdENhbmNlbCA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGV2ZW50OiBNb3VzZUV2ZW50PEhUTUxCdXR0b25FbGVtZW50PikgPT4ge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgc2V0RWRpdGluZyhmYWxzZSk7XG4gICAgICB9LFxuICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgaGFuZGxlRWRpdFN1Ym1pdCA9IHVzZUNhbGxiYWNrKFxuICAgICAgKHsgYm9keSB9OiBDb21wb3NlclN1Ym1pdENvbW1lbnQsIGV2ZW50OiBGb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PikgPT4ge1xuICAgICAgICAvLyBUT0RPOiBBZGQgYSB3YXkgdG8gcHJldmVudERlZmF1bHQgZnJvbSB3aXRoaW4gdGhpcyBjYWxsYmFjaywgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3IgKGUuZy4gc2hvd2luZyBhIGNvbmZpcm1hdGlvbiBkaWFsb2cpXG4gICAgICAgIG9uQ29tbWVudEVkaXQ/Lihjb21tZW50KTtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRFZGl0aW5nKGZhbHNlKTtcbiAgICAgICAgZWRpdENvbW1lbnQoe1xuICAgICAgICAgIGNvbW1lbnRJZDogY29tbWVudC5pZCxcbiAgICAgICAgICB0aHJlYWRJZDogY29tbWVudC50aHJlYWRJZCxcbiAgICAgICAgICBib2R5LFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBbY29tbWVudCwgZWRpdENvbW1lbnQsIG9uQ29tbWVudEVkaXRdXG4gICAgKTtcblxuICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIC8vIFRPRE86IEFkZCBhIHdheSB0byBwcmV2ZW50RGVmYXVsdCBmcm9tIHdpdGhpbiB0aGlzIGNhbGxiYWNrLCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciAoZS5nLiBzaG93aW5nIGEgY29uZmlybWF0aW9uIGRpYWxvZylcbiAgICAgIG9uQ29tbWVudERlbGV0ZT8uKGNvbW1lbnQpO1xuXG4gICAgICBkZWxldGVDb21tZW50KHtcbiAgICAgICAgY29tbWVudElkOiBjb21tZW50LmlkLFxuICAgICAgICB0aHJlYWRJZDogY29tbWVudC50aHJlYWRJZCxcbiAgICAgIH0pO1xuICAgIH0sIFtjb21tZW50LCBkZWxldGVDb21tZW50LCBvbkNvbW1lbnREZWxldGVdKTtcblxuICAgIGNvbnN0IGhhbmRsZUF1dGhvckNsaWNrID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZXZlbnQ6IE1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIG9uQXV0aG9yQ2xpY2s/Lihjb21tZW50LnVzZXJJZCwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIFtjb21tZW50LnVzZXJJZCwgb25BdXRob3JDbGlja11cbiAgICApO1xuXG4gICAgY29uc3QgaGFuZGxlUmVhY3Rpb25TZWxlY3QgPSB1c2VDYWxsYmFjayhcbiAgICAgIChlbW9qaTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWN0aW9uSW5kZXggPSBjb21tZW50LnJlYWN0aW9ucy5maW5kSW5kZXgoXG4gICAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgcmVhY3Rpb25JbmRleCA+PSAwICYmXG4gICAgICAgICAgc2VsZj8uaWQgJiZcbiAgICAgICAgICBjb21tZW50LnJlYWN0aW9uc1tyZWFjdGlvbkluZGV4XS51c2Vycy5zb21lKFxuICAgICAgICAgICAgKHVzZXIpID0+IHVzZXIuaWQgPT09IHNlbGY/LmlkXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICByZW1vdmVSZWFjdGlvbih7XG4gICAgICAgICAgICB0aHJlYWRJZDogY29tbWVudC50aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZDogY29tbWVudC5pZCxcbiAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFJlYWN0aW9uKHtcbiAgICAgICAgICAgIHRocmVhZElkOiBjb21tZW50LnRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkOiBjb21tZW50LmlkLFxuICAgICAgICAgICAgZW1vamksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIGFkZFJlYWN0aW9uLFxuICAgICAgICBjb21tZW50LmlkLFxuICAgICAgICBjb21tZW50LnJlYWN0aW9ucyxcbiAgICAgICAgY29tbWVudC50aHJlYWRJZCxcbiAgICAgICAgcmVtb3ZlUmVhY3Rpb24sXG4gICAgICAgIHNlbGY/LmlkLFxuICAgICAgXVxuICAgICk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgaXNXaW5kb3dEZWZpbmVkID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIGlmICghaXNXaW5kb3dEZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGhhc2guc2xpY2UoMSk7XG5cbiAgICAgIGlmIChjb21tZW50SWQgPT09IGNvbW1lbnQuaWQpIHtcbiAgICAgICAgc2V0VGFyZ2V0KHRydWUpO1xuICAgICAgfVxuICAgIH0sIFtdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblxuICAgIGlmICghc2hvd0RlbGV0ZWQgJiYgIWNvbW1lbnQuYm9keSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxUb29sdGlwUHJvdmlkZXI+XG4gICAgICAgIHthdXRvTWFya1JlYWRUaHJlYWRJZCAmJiAoXG4gICAgICAgICAgPEF1dG9NYXJrUmVhZFRocmVhZElkSGFuZGxlclxuICAgICAgICAgICAgY29tbWVudFJlZj17cmVmfVxuICAgICAgICAgICAgdGhyZWFkSWQ9e2F1dG9NYXJrUmVhZFRocmVhZElkfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBpZD17Y29tbWVudC5pZH1cbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICBcImxiLXJvb3QgbGItY29tbWVudFwiLFxuICAgICAgICAgICAgaW5kZW50Q29udGVudCAmJiBcImxiLWNvbW1lbnQ6aW5kZW50LWNvbnRlbnRcIixcbiAgICAgICAgICAgIHNob3dBY3Rpb25zID09PSBcImhvdmVyXCIgJiYgXCJsYi1jb21tZW50OnNob3ctYWN0aW9ucy1ob3ZlclwiLFxuICAgICAgICAgICAgKGlzTW9yZUFjdGlvbk9wZW4gfHwgaXNSZWFjdGlvbkFjdGlvbk9wZW4pICYmXG4gICAgICAgICAgICAgIFwibGItY29tbWVudDphY3Rpb24tb3BlblwiLFxuICAgICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgICAgKX1cbiAgICAgICAgICBkYXRhLWRlbGV0ZWQ9eyFjb21tZW50LmJvZHkgPyBcIlwiIDogdW5kZWZpbmVkfVxuICAgICAgICAgIGRhdGEtZWRpdGluZz17aXNFZGl0aW5nID8gXCJcIiA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBgOnRhcmdldGAgZG9lc24ndCB3b3JrIGFzIGV4cGVjdGVkIHNvIHdlIGFsc28gZGVmaW5lIGl0IG1hbnVhbGx5LlxuICAgICAgICAgIGRhdGEtdGFyZ2V0PXtpc1RhcmdldCA/IFwiXCIgOiB1bmRlZmluZWR9XG4gICAgICAgICAgZGlyPXskLmRpcn1cbiAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgcmVmPXttZXJnZWRSZWZzfVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsYi1jb21tZW50LWhlYWRlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsYi1jb21tZW50LWRldGFpbHNcIj5cbiAgICAgICAgICAgICAgPEF2YXRhclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxiLWNvbW1lbnQtYXZhdGFyXCJcbiAgICAgICAgICAgICAgICB1c2VySWQ9e2NvbW1lbnQudXNlcklkfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUF1dGhvckNsaWNrfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJsYi1jb21tZW50LWRldGFpbHMtbGFiZWxzXCI+XG4gICAgICAgICAgICAgICAgPFVzZXJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxiLWNvbW1lbnQtYXV0aG9yXCJcbiAgICAgICAgICAgICAgICAgIHVzZXJJZD17Y29tbWVudC51c2VySWR9XG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVBdXRob3JDbGlja31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImxiLWNvbW1lbnQtZGF0ZVwiPlxuICAgICAgICAgICAgICAgICAgPFRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU9eyQubG9jYWxlfVxuICAgICAgICAgICAgICAgICAgICBkYXRlPXtjb21tZW50LmNyZWF0ZWRBdH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibGItY29tbWVudC1kYXRlLWNyZWF0ZWRcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIHtjb21tZW50LmVkaXRlZEF0ICYmIGNvbW1lbnQuYm9keSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAge1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImxiLWNvbW1lbnQtZGF0ZS1lZGl0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHskLkNPTU1FTlRfRURJVEVEfVxuICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7c2hvd0FjdGlvbnMgJiYgIWlzRWRpdGluZyAmJiAoXG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgICBcImxiLWNvbW1lbnQtYWN0aW9uc1wiLFxuICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEFjdGlvbnNDbGFzc05hbWVcbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2FkZGl0aW9uYWxBY3Rpb25zID8/IG51bGx9XG4gICAgICAgICAgICAgICAge3Nob3dSZWFjdGlvbnMgJiYgKFxuICAgICAgICAgICAgICAgICAgPEVtb2ppUGlja2VyXG4gICAgICAgICAgICAgICAgICAgIG9uRW1vamlTZWxlY3Q9e2hhbmRsZVJlYWN0aW9uU2VsZWN0fVxuICAgICAgICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2U9e3NldFJlYWN0aW9uQWN0aW9uT3Blbn1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPFRvb2x0aXAgY29udGVudD17JC5DT01NRU5UX0FERF9SRUFDVElPTn0+XG4gICAgICAgICAgICAgICAgICAgICAgPEVtb2ppUGlja2VyVHJpZ2dlciBhc0NoaWxkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsYi1jb21tZW50LWFjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3N0b3BQcm9wYWdhdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17JC5DT01NRU5UX0FERF9SRUFDVElPTn1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEVtb2ppQWRkSWNvbiBjbGFzc05hbWU9XCJsYi1idXR0b24taWNvblwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICA8L0Vtb2ppUGlja2VyVHJpZ2dlcj5cbiAgICAgICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuICAgICAgICAgICAgICAgICAgPC9FbW9qaVBpY2tlcj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHtjb21tZW50LnVzZXJJZCA9PT0gc2VsZj8uaWQgJiYgKFxuICAgICAgICAgICAgICAgICAgPERyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzTW9yZUFjdGlvbk9wZW59XG4gICAgICAgICAgICAgICAgICAgIG9uT3BlbkNoYW5nZT17c2V0TW9yZUFjdGlvbk9wZW59XG4gICAgICAgICAgICAgICAgICAgIGFsaWduPVwiZW5kXCJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudD17XG4gICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxEcm9wZG93bkl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q9e2hhbmRsZUVkaXR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3N0b3BQcm9wYWdhdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEVkaXRJY29uIGNsYXNzTmFtZT1cImxiLWRyb3Bkb3duLWl0ZW0taWNvblwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHskLkNPTU1FTlRfRURJVH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRHJvcGRvd25JdGVtPlxuICAgICAgICAgICAgICAgICAgICAgICAgPERyb3Bkb3duSXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD17aGFuZGxlRGVsZXRlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtzdG9wUHJvcGFnYXRpb259XG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxEZWxldGVJY29uIGNsYXNzTmFtZT1cImxiLWRyb3Bkb3duLWl0ZW0taWNvblwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHskLkNPTU1FTlRfREVMRVRFfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Ecm9wZG93bkl0ZW0+XG4gICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPFRvb2x0aXAgY29udGVudD17JC5DT01NRU5UX01PUkV9PlxuICAgICAgICAgICAgICAgICAgICAgIDxEcm9wZG93blRyaWdnZXIgYXNDaGlsZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibGItY29tbWVudC1hY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IWNvbW1lbnQuYm9keX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17c3RvcFByb3BhZ2F0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXskLkNPTU1FTlRfTU9SRX1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEVsbGlwc2lzSWNvbiBjbGFzc05hbWU9XCJsYi1idXR0b24taWNvblwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICA8L0Ryb3Bkb3duVHJpZ2dlcj5cbiAgICAgICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuICAgICAgICAgICAgICAgICAgPC9Ecm9wZG93bj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsYi1jb21tZW50LWNvbnRlbnRcIj5cbiAgICAgICAgICAgIHtpc0VkaXRpbmcgPyAoXG4gICAgICAgICAgICAgIDxDb21wb3NlclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxiLWNvbW1lbnQtY29tcG9zZXJcIlxuICAgICAgICAgICAgICAgIG9uQ29tcG9zZXJTdWJtaXQ9e2hhbmRsZUVkaXRTdWJtaXR9XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtjb21tZW50LmJvZHl9XG4gICAgICAgICAgICAgICAgYXV0b0ZvY3VzXG4gICAgICAgICAgICAgICAgc2hvd0F0dHJpYnV0aW9uPXtmYWxzZX1cbiAgICAgICAgICAgICAgICBhY3Rpb25zPXtcbiAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxUb29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudD17JC5DT01NRU5UX0VESVRfQ09NUE9TRVJfQ0FOQ0VMfVxuICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9eyQuQ09NTUVOVF9FRElUX0NPTVBPU0VSX0NBTkNFTH1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxiLWNvbXBvc2VyLWFjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVFZGl0Q2FuY2VsfVxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxDcm9zc0ljb24gY2xhc3NOYW1lPVwibGItYnV0dG9uLWljb25cIiAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgICAgICAgICAgIDxTaG9ydGN1dFRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50PXskLkNPTU1FTlRfRURJVF9DT01QT1NFUl9TQVZFfVxuICAgICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0PXs8U2hvcnRjdXRUb29sdGlwS2V5IG5hbWU9XCJlbnRlclwiIC8+fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgPENvbXBvc2VyUHJpbWl0aXZlLlN1Ym1pdCBhc0NoaWxkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50PVwicHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxiLWNvbXBvc2VyLWFjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3N0b3BQcm9wYWdhdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17JC5DT01NRU5UX0VESVRfQ09NUE9TRVJfU0FWRX1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrSWNvbiBjbGFzc05hbWU9XCJsYi1idXR0b24taWNvblwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICA8L0NvbXBvc2VyUHJpbWl0aXZlLlN1Ym1pdD5cbiAgICAgICAgICAgICAgICAgICAgPC9TaG9ydGN1dFRvb2x0aXA+XG4gICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzPXt7XG4gICAgICAgICAgICAgICAgICBDT01QT1NFUl9QTEFDRUhPTERFUjogJC5DT01NRU5UX0VESVRfQ09NUE9TRVJfUExBQ0VIT0xERVIsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkgOiBjb21tZW50LmJvZHkgPyAoXG4gICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPENvbW1lbnRQcmltaXRpdmUuQm9keVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibGItY29tbWVudC1ib2R5XCJcbiAgICAgICAgICAgICAgICAgIGJvZHk9e2NvbW1lbnQuYm9keX1cbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM9e3tcbiAgICAgICAgICAgICAgICAgICAgTWVudGlvbjogKHsgdXNlcklkIH0pID0+IChcbiAgICAgICAgICAgICAgICAgICAgICA8Q29tbWVudE1lbnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZD17dXNlcklkfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGV2ZW50KSA9PiBvbk1lbnRpb25DbGljaz8uKHVzZXJJZCwgZXZlbnQpfVxuICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIExpbms6IENvbW1lbnRMaW5rLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIHtzaG93UmVhY3Rpb25zICYmIGNvbW1lbnQucmVhY3Rpb25zLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsYi1jb21tZW50LXJlYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgICB7Y29tbWVudC5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgIDxDb21tZW50UmVhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17cmVhY3Rpb24uZW1vaml9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50PXtjb21tZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhY3Rpb249e3JlYWN0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzPXtvdmVycmlkZXN9XG4gICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgIDxFbW9qaVBpY2tlciBvbkVtb2ppU2VsZWN0PXtoYW5kbGVSZWFjdGlvblNlbGVjdH0+XG4gICAgICAgICAgICAgICAgICAgICAgPFRvb2x0aXAgY29udGVudD17JC5DT01NRU5UX0FERF9SRUFDVElPTn0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8RW1vamlQaWNrZXJUcmlnZ2VyIGFzQ2hpbGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsYi1jb21tZW50LXJlYWN0aW9uIGxiLWNvbW1lbnQtcmVhY3Rpb24tYWRkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50PVwib3V0bGluZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17c3RvcFByb3BhZ2F0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9eyQuQ09NTUVOVF9BRERfUkVBQ1RJT059XG4gICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RW1vamlBZGRJY29uIGNsYXNzTmFtZT1cImxiLWJ1dHRvbi1pY29uXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0Vtb2ppUGlja2VyVHJpZ2dlcj5cbiAgICAgICAgICAgICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgICAgICAgICAgIDwvRW1vamlQaWNrZXI+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGItY29tbWVudC1ib2R5XCI+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibGItY29tbWVudC1kZWxldGVkXCI+eyQuQ09NTUVOVF9ERUxFVEVEfTwvcD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvVG9vbHRpcFByb3ZpZGVyPlxuICAgICk7XG4gIH1cbik7XG4iXSwibmFtZXMiOlsiUkVBQ1RJT05TX1RSVU5DQVRFIiwiQ29tbWVudE1lbnRpb24iLCJ1c2VySWQiLCJjbGFzc05hbWUiLCJwcm9wcyIsImN1cnJlbnRJZCIsInVzZUN1cnJlbnRVc2VySWQiLCJSZWFjdF9fZGVmYXVsdCIsImNyZWF0ZUVsZW1lbnQiLCJDb21tZW50TWVudGlvbiQxIiwiY2xhc3NOYW1lcyIsIk1FTlRJT05fQ0hBUkFDVEVSIiwiVXNlciIsIkNvbW1lbnRMaW5rIiwiaHJlZiIsImNoaWxkcmVuIiwiQ29tbWVudExpbmskMSIsIkNvbW1lbnROb25JbnRlcmFjdGl2ZUxpbmsiLCJfaHJlZiIsIkNvbW1lbnRSZWFjdGlvbkJ1dHRvbiIsImZvcndhcmRSZWYiLCJyZWFjdGlvbiIsIm92ZXJyaWRlcyIsImZvcndhcmRlZFJlZiIsIiQiLCJ1c2VPdmVycmlkZXMiLCJCdXR0b24iLCJ2YXJpYW50IiwiQ09NTUVOVF9SRUFDVElPTl9ERVNDUklQVElPTiIsImVtb2ppIiwidXNlcnMiLCJsZW5ndGgiLCJyZWYiLCJFbW9qaSIsIkNvbW1lbnRSZWFjdGlvbiIsImNvbW1lbnQiLCJkaXNhYmxlZCIsImFkZFJlYWN0aW9uIiwidXNlQWRkUmVhY3Rpb24iLCJyZW1vdmVSZWFjdGlvbiIsInVzZVJlbW92ZVJlYWN0aW9uIiwiaXNBY3RpdmUiLCJ1c2VNZW1vIiwic29tZSIsImlkIiwidG9vbHRpcENvbnRlbnQiLCJDT01NRU5UX1JFQUNUSU9OX0xJU1QiLCJMaXN0IiwidmFsdWVzIiwibWFwIiwiaW5kZXgiLCJrZXkiLCJjYXBpdGFsaXplIiwicmVwbGFjZVNlbGYiLCJmb3JtYXRSZW1haW5pbmciLCJMSVNUX1JFTUFJTklOR19VU0VSUyIsInRydW5jYXRlIiwiaGFuZGxlUHJlc3NlZENoYW5nZSIsInVzZUNhbGxiYWNrIiwiaXNQcmVzc2VkIiwidGhyZWFkSWQiLCJjb21tZW50SWQiLCJUb29sdGlwIiwiY29udGVudCIsIm11bHRpbGluZSIsIlRvZ2dsZVByaW1pdGl2ZSIsIlJvb3QiLCJhc0NoaWxkIiwicHJlc3NlZCIsIm9uUHJlc3NlZENoYW5nZSIsIkNvbW1lbnROb25JbnRlcmFjdGl2ZVJlYWN0aW9uIiwiZGlzYWJsZWFibGUiLCJBdXRvTWFya1JlYWRUaHJlYWRJZEhhbmRsZXIiLCJjb21tZW50UmVmIiwibWFya1RocmVhZEFzUmVhZCIsInVzZU1hcmtUaHJlYWRBc1JlYWQiLCJpc1dpbmRvd0ZvY3VzZWQiLCJ1c2VXaW5kb3dGb2N1cyIsInVzZVZpc2libGVDYWxsYmFjayIsImVuYWJsZWQiLCJDb21tZW50IiwiaW5kZW50Q29udGVudCIsInNob3dEZWxldGVkIiwic2hvd0FjdGlvbnMiLCJzaG93UmVhY3Rpb25zIiwib25BdXRob3JDbGljayIsIm9uTWVudGlvbkNsaWNrIiwib25Db21tZW50RWRpdCIsIm9uQ29tbWVudERlbGV0ZSIsImFkZGl0aW9uYWxBY3Rpb25zIiwiYWRkaXRpb25hbEFjdGlvbnNDbGFzc05hbWUiLCJhdXRvTWFya1JlYWRUaHJlYWRJZCIsInVzZVJlZiIsIm1lcmdlZFJlZnMiLCJ1c2VSZWZzIiwic2VsZiIsInVzZVNlbGYiLCJkZWxldGVDb21tZW50IiwidXNlRGVsZXRlQ29tbWVudCIsImVkaXRDb21tZW50IiwidXNlRWRpdENvbW1lbnQiLCJpc0VkaXRpbmciLCJzZXRFZGl0aW5nIiwidXNlU3RhdGUiLCJpc1RhcmdldCIsInNldFRhcmdldCIsImlzTW9yZUFjdGlvbk9wZW4iLCJzZXRNb3JlQWN0aW9uT3BlbiIsImlzUmVhY3Rpb25BY3Rpb25PcGVuIiwic2V0UmVhY3Rpb25BY3Rpb25PcGVuIiwic3RvcFByb3BhZ2F0aW9uIiwiZXZlbnQiLCJoYW5kbGVFZGl0IiwiaGFuZGxlRWRpdENhbmNlbCIsImhhbmRsZUVkaXRTdWJtaXQiLCJib2R5IiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVEZWxldGUiLCJoYW5kbGVBdXRob3JDbGljayIsImhhbmRsZVJlYWN0aW9uU2VsZWN0IiwicmVhY3Rpb25JbmRleCIsInJlYWN0aW9ucyIsImZpbmRJbmRleCIsInVzZXIiLCJ1c2VFZmZlY3QiLCJpc1dpbmRvd0RlZmluZWQiLCJoYXNoIiwid2luZG93IiwibG9jYXRpb24iLCJzbGljZSIsIlRvb2x0aXBQcm92aWRlciIsImRpciIsIkF2YXRhciIsIm9uQ2xpY2siLCJUaW1lc3RhbXAiLCJsb2NhbGUiLCJkYXRlIiwiY3JlYXRlZEF0IiwiZWRpdGVkQXQiLCJGcmFnbWVudCIsIkNPTU1FTlRfRURJVEVEIiwiRW1vamlQaWNrZXIiLCJvbkVtb2ppU2VsZWN0Iiwib25PcGVuQ2hhbmdlIiwiQ09NTUVOVF9BRERfUkVBQ1RJT04iLCJQb3BvdmVyVHJpZ2dlciIsIkVtb2ppQWRkSWNvbiIsIkRyb3Bkb3duIiwib3BlbiIsImFsaWduIiwiRHJvcGRvd25JdGVtIiwib25TZWxlY3QiLCJFZGl0SWNvbiIsIkNPTU1FTlRfRURJVCIsIkRlbGV0ZUljb24iLCJDT01NRU5UX0RFTEVURSIsIkNPTU1FTlRfTU9SRSIsIkRyb3Bkb3duTWVudVRyaWdnZXIiLCJFbGxpcHNpc0ljb24iLCJDb21wb3NlciIsIm9uQ29tcG9zZXJTdWJtaXQiLCJkZWZhdWx0VmFsdWUiLCJhdXRvRm9jdXMiLCJzaG93QXR0cmlidXRpb24iLCJhY3Rpb25zIiwiQ09NTUVOVF9FRElUX0NPTVBPU0VSX0NBTkNFTCIsIkNyb3NzSWNvbiIsIlNob3J0Y3V0VG9vbHRpcCIsIkNPTU1FTlRfRURJVF9DT01QT1NFUl9TQVZFIiwic2hvcnRjdXQiLCJTaG9ydGN1dFRvb2x0aXBLZXkiLCJuYW1lIiwiQ29tcG9zZXJTdWJtaXQiLCJDaGVja0ljb24iLCJDT01QT1NFUl9QTEFDRUhPTERFUiIsIkNPTU1FTlRfRURJVF9DT01QT1NFUl9QTEFDRUhPTERFUiIsIkNvbW1lbnRCb2R5IiwiY29tcG9uZW50cyIsIk1lbnRpb24iLCJMaW5rIiwiQ09NTUVOVF9ERUxFVEVEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/Comment.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/Composer.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/Composer.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composer: () => (/* binding */ Composer)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _icons_Emoji_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../icons/Emoji.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Emoji.mjs\");\n/* harmony import */ var _icons_Mention_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../icons/Mention.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Mention.mjs\");\n/* harmony import */ var _icons_Send_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../icons/Send.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Send.mjs\");\n/* harmony import */ var _overrides_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../overrides.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\");\n/* harmony import */ var _primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../primitives/Composer/index.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/index.mjs\");\n/* harmony import */ var _primitives_Composer_contexts_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/Composer/contexts.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/contexts.mjs\");\n/* harmony import */ var _slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../slate/plugins/mentions.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/mentions.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* harmony import */ var _utils_use_controllable_state_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/use-controllable-state.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-controllable-state.mjs\");\n/* harmony import */ var _internal_Attribution_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./internal/Attribution.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Attribution.mjs\");\n/* harmony import */ var _internal_Avatar_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./internal/Avatar.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Avatar.mjs\");\n/* harmony import */ var _internal_Button_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/Button.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Button.mjs\");\n/* harmony import */ var _internal_EmojiPicker_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./internal/EmojiPicker.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/EmojiPicker.mjs\");\n/* harmony import */ var _internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/Tooltip.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.mjs\");\n/* harmony import */ var _internal_User_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./internal/User.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/User.mjs\");\n/* harmony import */ var _radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @radix-ui/react-tooltip */ \"(ssr)/./node_modules/@radix-ui/react-tooltip/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @radix-ui/react-popover */ \"(ssr)/./node_modules/@radix-ui/react-popover/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ Composer auto */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ComposerInsertMentionEditorAction({ label, className, onClick, ...props }) {\n    const { createMention } = (0,_primitives_Composer_contexts_mjs__WEBPACK_IMPORTED_MODULE_1__.useComposer)();\n    const preventDefault = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.preventDefault();\n    }, []);\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onClick?.(event);\n        if (!event.isDefaultPrevented()) {\n            event.stopPropagation();\n            createMention();\n        }\n    }, [\n        createMention,\n        onClick\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_2__.Tooltip, {\n        content: label\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_3__.Button, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__.classNames)(\"lb-composer-editor-action\", className),\n        onMouseDown: preventDefault,\n        onClick: handleClick,\n        \"aria-label\": label,\n        ...props\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Mention_mjs__WEBPACK_IMPORTED_MODULE_5__.MentionIcon, {\n        className: \"lb-button-icon\"\n    })));\n}\nfunction ComposerInsertEmojiEditorAction({ label, onPickerOpenChange, className, ...props }) {\n    const { insertText } = (0,_primitives_Composer_contexts_mjs__WEBPACK_IMPORTED_MODULE_1__.useComposer)();\n    const preventDefault = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.preventDefault();\n    }, []);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_EmojiPicker_mjs__WEBPACK_IMPORTED_MODULE_6__.EmojiPicker, {\n        onEmojiSelect: insertText,\n        onOpenChange: onPickerOpenChange\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_2__.Tooltip, {\n        content: label\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_7__.PopoverTrigger, {\n        asChild: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_3__.Button, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__.classNames)(\"lb-composer-editor-action\", className),\n        onMouseDown: preventDefault,\n        \"aria-label\": label,\n        ...props\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Emoji_mjs__WEBPACK_IMPORTED_MODULE_8__.EmojiIcon, {\n        className: \"lb-button-icon\"\n    })))));\n}\nfunction ComposerMention({ userId }) {\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_9__.Mention, {\n        className: \"lb-composer-mention\"\n    }, _slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_10__.MENTION_CHARACTER, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_User_mjs__WEBPACK_IMPORTED_MODULE_11__.User, {\n        userId\n    }));\n}\nfunction ComposerMentionSuggestions({ userIds }) {\n    return userIds.length > 0 ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_9__.Suggestions, {\n        className: \"lb-root lb-portal lb-elevation lb-composer-suggestions lb-composer-mention-suggestions\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_9__.SuggestionsList, {\n        className: \"lb-composer-suggestions-list lb-composer-mention-suggestions-list\"\n    }, userIds.map((userId)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_9__.SuggestionsListItem, {\n            key: userId,\n            className: \"lb-composer-suggestions-list-item lb-composer-mention-suggestion\",\n            value: userId\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Avatar_mjs__WEBPACK_IMPORTED_MODULE_12__.Avatar, {\n            userId,\n            className: \"lb-composer-mention-suggestion-avatar\"\n        }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_User_mjs__WEBPACK_IMPORTED_MODULE_11__.User, {\n            userId,\n            className: \"lb-composer-mention-suggestion-user\"\n        }))))) : null;\n}\nfunction ComposerLink({ href, children }) {\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_9__.Link, {\n        href,\n        className: \"lb-composer-link\"\n    }, children);\n}\nconst editorComponents = {\n    Mention: ComposerMention,\n    MentionSuggestions: ComposerMentionSuggestions,\n    Link: ComposerLink\n};\nconst ComposerWithContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ defaultValue, disabled, autoFocus, collapsed: controlledCollapsed, defaultCollapsed, onCollapsedChange: controlledOnCollapsedChange, actions, overrides, showAttribution, onFocus, onBlur, className, ...props }, forwardedRef)=>{\n    const client = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_13__.useClient)();\n    const hasResolveMentionSuggestions = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_14__.kInternal].resolveMentionSuggestions !== void 0;\n    const self = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_13__._useSelf)();\n    const isDisabled = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>disabled || !self?.canComment, [\n        disabled,\n        self?.canComment\n    ]);\n    const { isEmpty } = (0,_primitives_Composer_contexts_mjs__WEBPACK_IMPORTED_MODULE_1__.useComposer)();\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_15__.useOverrides)(overrides);\n    const [isEmojiPickerOpen, setEmojiPickerOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [collapsed, onCollapsedChange] = (0,_utils_use_controllable_state_mjs__WEBPACK_IMPORTED_MODULE_16__.useControllableState)(controlledCollapsed === void 0 && defaultCollapsed === void 0 ? false : controlledCollapsed, controlledOnCollapsedChange, defaultCollapsed);\n    const preventDefault = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.preventDefault();\n    }, []);\n    const stopPropagation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.stopPropagation();\n    }, []);\n    const handleEditorClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.stopPropagation();\n        if (isEmpty) {\n            onCollapsedChange?.(false);\n        }\n    }, [\n        isEmpty,\n        onCollapsedChange\n    ]);\n    const handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onFocus?.(event);\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        if (isEmpty) {\n            onCollapsedChange?.(false);\n        }\n    }, [\n        isEmpty,\n        onCollapsedChange,\n        onFocus\n    ]);\n    const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onBlur?.(event);\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        const isOutside = !event.currentTarget.contains(event.relatedTarget);\n        if (isOutside && isEmpty && !isEmojiPickerOpen) {\n            onCollapsedChange?.(true);\n        }\n    }, [\n        isEmojiPickerOpen,\n        isEmpty,\n        onBlur,\n        onCollapsedChange\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__.classNames)(\"lb-root lb-composer lb-composer-form\", className),\n        dir: $.dir,\n        ...props,\n        ref: forwardedRef,\n        \"data-collapsed\": collapsed ? \"\" : void 0,\n        onFocus: handleFocus,\n        onBlur: handleBlur\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_9__.Editor, {\n        className: \"lb-composer-editor\",\n        onClick: handleEditorClick,\n        placeholder: $.COMPOSER_PLACEHOLDER,\n        defaultValue,\n        disabled: isDisabled,\n        autoFocus,\n        components: editorComponents,\n        dir: $.dir\n    }), !collapsed && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-composer-footer\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-composer-editor-actions\"\n    }, hasResolveMentionSuggestions && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerInsertMentionEditorAction, {\n        label: $.COMPOSER_INSERT_MENTION,\n        disabled: isDisabled\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerInsertEmojiEditorAction, {\n        label: $.COMPOSER_INSERT_EMOJI,\n        onPickerOpenChange: setEmojiPickerOpen,\n        disabled: isDisabled\n    })), showAttribution && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Attribution_mjs__WEBPACK_IMPORTED_MODULE_17__.Attribution, null), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-composer-actions\"\n    }, actions ?? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_2__.ShortcutTooltip, {\n        content: $.COMPOSER_SEND,\n        shortcut: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_2__.ShortcutTooltipKey, {\n            name: \"enter\"\n        })\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_9__.Submit, {\n        disabled: isDisabled,\n        asChild: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_3__.Button, {\n        onMouseDown: preventDefault,\n        onClick: stopPropagation,\n        className: \"lb-composer-action\",\n        variant: \"primary\",\n        \"aria-label\": $.COMPOSER_SEND\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Send_mjs__WEBPACK_IMPORTED_MODULE_18__.SendIcon, null))))))));\n});\nconst Composer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ threadId, commentId, metadata, onComposerSubmit, onFocus, ...props }, forwardedRef)=>{\n    const createThread = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_13__._useCreateThread)();\n    const createComment = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_13__.useCreateComment)();\n    const editComment = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_13__.useEditComment)();\n    const handleCommentSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((comment, event)=>{\n        onComposerSubmit?.(comment, event);\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        if (commentId && threadId) {\n            editComment({\n                commentId,\n                threadId,\n                body: comment.body\n            });\n        } else if (threadId) {\n            createComment({\n                threadId,\n                body: comment.body\n            });\n        } else {\n            createThread({\n                body: comment.body,\n                metadata: metadata ?? {}\n            });\n        }\n    }, [\n        commentId,\n        createComment,\n        createThread,\n        editComment,\n        metadata,\n        onComposerSubmit,\n        threadId\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_19__.TooltipProvider, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Composer_index_mjs__WEBPACK_IMPORTED_MODULE_9__.Form, {\n        onComposerSubmit: handleCommentSubmit,\n        onFocus,\n        asChild: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerWithContext, {\n        ...props,\n        ref: forwardedRef\n    })));\n});\n //# sourceMappingURL=Composer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL0NvbXBvc2VyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZKQSxTQUFBQSxrQ0FBQSxFQUEyQ0MsS0FBQSxFQUN6Q0MsU0FBQSxFQUNBQyxPQUFBLEVBQ0EsR0FBQUMsT0FFRjtJQUNFLFFBQUFDLGFBQUEsS0FBQUMsOEVBQUFBO0lBRUEsTUFBQUMsaUJBQUFDLGtEQUFBQSxDQUFBLENBQUFDO1FBQ0VBLE1BQUFGLGNBQUE7SUFBcUI7SUFHdkIsTUFBQUcsY0FBQUYsa0RBQUFBLENBQW9CLENBQUFDO1FBRWhCTixVQUFBTTtRQUVBLEtBQUFBLE1BQUFFLGtCQUFBO1lBQ0VGLE1BQUFHLGVBQUE7WUFDQVA7UUFBYztJQUNoQixHQUNGO1FBQUFBO1FBQUFGO0tBQUE7SUFJRixxQ0FBQVUsZ0RBQUEsQ0FBQUUsMERBQUFBLEVBQUE7UUFDR0MsU0FBQWY7SUFBaUIsaUNBQUFZLGdEQUFBLENBQUFJLHdEQUFBQSxFQUFBO1FBQ2ZmLFdBQUFnQixrRUFBQUEsQ0FBQSw2QkFBQWhCO1FBQzZEaUIsYUFBQVo7UUFDL0NKLFNBQUFPO1FBQ0osY0FBQVQ7UUFDRyxHQUFBRyxLQUFBO0lBQ1IsaUNBQUFTLGdEQUFBLENBQUFPLDJEQUFBQSxFQUFBO1FBRUhsQixXQUFBO0lBQXNCO0FBSS9CO0FBRUEsU0FBQW1CLGdDQUFBLEVBQXlDcEIsS0FBQSxFQUN2Q3FCLGtCQUFBLEVBQ0FwQixTQUFBLEVBQ0EsR0FBQUUsT0FFRjtJQUNFLFFBQUFtQixVQUFBLEtBQUFqQiw4RUFBQUE7SUFFQSxNQUFBQyxpQkFBQUMsa0RBQUFBLENBQUEsQ0FBQUM7UUFDRUEsTUFBQUYsY0FBQTtJQUFxQjtJQUd2QixxQ0FBQU0sZ0RBQUEsQ0FBQVcsa0VBQUFBLEVBQUE7UUFDR0MsZUFBQUY7UUFBMkJHLGNBQUFKO0lBQTBCLGlD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QUVETSxjQUFBO2dCQUFjTjtnQkFDWlksTUFBQUQsUUFBQUMsSUFBQTtZQUNjO1FBQ2Y7WUFFRFIsYUFBQTtnQkFBYVEsTUFBQUQsUUFBQUMsSUFBQTtnQkFDR1YsVUFBQUEsWUFBQTtZQUNTO1FBQ3hCO0lBQ0gsR0FDRjtRQUNBRDtRQUNFSztRQUNBRjtRQUNBSTtRQUNBTjtRQUNBQztRQUNBSDtLQUNBO0lBSUoscUNBQUFuRyxnREFBQSxDQUFBZ0gscUVBQUFBLEVBQUEsb0NBQUFoSCxnREFBQSxDQUFBaUgsZ0VBQUFBLEVBQUE7UUFFS1gsa0JBQUFPO1FBQ21CeEQ7UUFDbEJ0QyxTQUFBO0lBQ08saUNBQUFmLGdEQUFBLENBQUF3QyxxQkFBQTtRQUVOLEdBQUFqRCxLQUFBO1FBQXdCMEYsS0FBQTFCO0lBQVk7QUFFekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi4vLi4vc3JjL2NvbXBvbmVudHMvQ29tcG9zZXIudHN4P2YxMjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB0eXBlIHsgQmFzZU1ldGFkYXRhLCBETSB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyBrSW50ZXJuYWwgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHtcbiAgdXNlQ2xpZW50LFxuICB1c2VDcmVhdGVDb21tZW50LFxuICB1c2VDcmVhdGVUaHJlYWQsXG4gIHVzZUVkaXRDb21tZW50LFxuICB1c2VTZWxmLFxufSBmcm9tIFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmLFxuICBGb2N1c0V2ZW50LFxuICBGb3JtRXZlbnQsXG4gIEZvcndhcmRlZFJlZixcbiAgTW91c2VFdmVudCxcbiAgUmVhY3ROb2RlLFxuICBSZWZBdHRyaWJ1dGVzLFxuICBTeW50aGV0aWNFdmVudCxcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IEVtb2ppSWNvbiB9IGZyb20gXCIuLi9pY29ucy9FbW9qaVwiO1xuaW1wb3J0IHsgTWVudGlvbkljb24gfSBmcm9tIFwiLi4vaWNvbnMvTWVudGlvblwiO1xuaW1wb3J0IHsgU2VuZEljb24gfSBmcm9tIFwiLi4vaWNvbnMvU2VuZFwiO1xuaW1wb3J0IHR5cGUgeyBDb21wb3Nlck92ZXJyaWRlcywgR2xvYmFsT3ZlcnJpZGVzIH0gZnJvbSBcIi4uL292ZXJyaWRlc1wiO1xuaW1wb3J0IHsgdXNlT3ZlcnJpZGVzIH0gZnJvbSBcIi4uL292ZXJyaWRlc1wiO1xuaW1wb3J0ICogYXMgQ29tcG9zZXJQcmltaXRpdmUgZnJvbSBcIi4uL3ByaW1pdGl2ZXMvQ29tcG9zZXJcIjtcbmltcG9ydCB7IHVzZUNvbXBvc2VyIH0gZnJvbSBcIi4uL3ByaW1pdGl2ZXMvQ29tcG9zZXIvY29udGV4dHNcIjtcbmltcG9ydCB0eXBlIHtcbiAgQ29tcG9zZXJFZGl0b3JDb21wb25lbnRzLFxuICBDb21wb3NlckVkaXRvckxpbmtQcm9wcyxcbiAgQ29tcG9zZXJFZGl0b3JNZW50aW9uUHJvcHMsXG4gIENvbXBvc2VyRWRpdG9yTWVudGlvblN1Z2dlc3Rpb25zUHJvcHMsXG4gIENvbXBvc2VyRWRpdG9yUHJvcHMsXG4gIENvbXBvc2VyU3VibWl0Q29tbWVudCxcbn0gZnJvbSBcIi4uL3ByaW1pdGl2ZXMvQ29tcG9zZXIvdHlwZXNcIjtcbmltcG9ydCB7IE1FTlRJT05fQ0hBUkFDVEVSIH0gZnJvbSBcIi4uL3NsYXRlL3BsdWdpbnMvbWVudGlvbnNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiLi4vdXRpbHMvY2xhc3MtbmFtZXNcIjtcbmltcG9ydCB7IHVzZUNvbnRyb2xsYWJsZVN0YXRlIH0gZnJvbSBcIi4uL3V0aWxzL3VzZS1jb250cm9sbGFibGUtc3RhdGVcIjtcbmltcG9ydCB7IEF0dHJpYnV0aW9uIH0gZnJvbSBcIi4vaW50ZXJuYWwvQXR0cmlidXRpb25cIjtcbmltcG9ydCB7IEF2YXRhciB9IGZyb20gXCIuL2ludGVybmFsL0F2YXRhclwiO1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIi4vaW50ZXJuYWwvQnV0dG9uXCI7XG5pbXBvcnQgdHlwZSB7IEVtb2ppUGlja2VyUHJvcHMgfSBmcm9tIFwiLi9pbnRlcm5hbC9FbW9qaVBpY2tlclwiO1xuaW1wb3J0IHsgRW1vamlQaWNrZXIsIEVtb2ppUGlja2VyVHJpZ2dlciB9IGZyb20gXCIuL2ludGVybmFsL0Vtb2ppUGlja2VyXCI7XG5pbXBvcnQge1xuICBTaG9ydGN1dFRvb2x0aXAsXG4gIFNob3J0Y3V0VG9vbHRpcEtleSxcbiAgVG9vbHRpcCxcbiAgVG9vbHRpcFByb3ZpZGVyLFxufSBmcm9tIFwiLi9pbnRlcm5hbC9Ub29sdGlwXCI7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSBcIi4vaW50ZXJuYWwvVXNlclwiO1xuXG5pbnRlcmZhY2UgRWRpdG9yQWN0aW9uUHJvcHMgZXh0ZW5kcyBDb21wb25lbnRQcm9wc1dpdGhvdXRSZWY8XCJidXR0b25cIj4ge1xuICBsYWJlbDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRW1vamlFZGl0b3JBY3Rpb25Qcm9wcyBleHRlbmRzIEVkaXRvckFjdGlvblByb3BzIHtcbiAgb25QaWNrZXJPcGVuQ2hhbmdlPzogRW1vamlQaWNrZXJQcm9wc1tcIm9uT3BlbkNoYW5nZVwiXTtcbn1cblxudHlwZSBDb21wb3NlckNyZWF0ZVRocmVhZFByb3BzPE0gZXh0ZW5kcyBCYXNlTWV0YWRhdGE+ID0ge1xuICB0aHJlYWRJZD86IG5ldmVyO1xuICBjb21tZW50SWQ/OiBuZXZlcjtcblxuICAvKipcbiAgICogVGhlIG1ldGFkYXRhIG9mIHRoZSB0aHJlYWQgdG8gY3JlYXRlLlxuICAgKi9cbiAgbWV0YWRhdGE/OiBNO1xufTtcblxudHlwZSBDb21wb3NlckNyZWF0ZUNvbW1lbnRQcm9wcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdGhyZWFkIHRvIHJlcGx5IHRvLlxuICAgKi9cbiAgdGhyZWFkSWQ6IHN0cmluZztcbiAgY29tbWVudElkPzogbmV2ZXI7XG4gIG1ldGFkYXRhPzogbmV2ZXI7XG59O1xuXG50eXBlIENvbXBvc2VyRWRpdENvbW1lbnRQcm9wcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdGhyZWFkIHRvIGVkaXQgYSBjb21tZW50IGluLlxuICAgKi9cbiAgdGhyZWFkSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBjb21tZW50IHRvIGVkaXQuXG4gICAqL1xuICBjb21tZW50SWQ6IHN0cmluZztcbiAgbWV0YWRhdGE/OiBuZXZlcjtcbn07XG5cbmV4cG9ydCB0eXBlIENvbXBvc2VyUHJvcHM8TSBleHRlbmRzIEJhc2VNZXRhZGF0YSA9IERNPiA9IE9taXQ8XG4gIENvbXBvbmVudFByb3BzV2l0aG91dFJlZjxcImZvcm1cIj4sXG4gIFwiZGVmYXVsdFZhbHVlXCJcbj4gJlxuICAoXG4gICAgfCBDb21wb3NlckNyZWF0ZVRocmVhZFByb3BzPE0+XG4gICAgfCBDb21wb3NlckNyZWF0ZUNvbW1lbnRQcm9wc1xuICAgIHwgQ29tcG9zZXJFZGl0Q29tbWVudFByb3BzXG4gICkgJiB7XG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IGhhbmRsZXIgY2FsbGVkIHdoZW4gdGhlIGNvbXBvc2VyIGlzIHN1Ym1pdHRlZC5cbiAgICAgKi9cbiAgICBvbkNvbXBvc2VyU3VibWl0PzogKFxuICAgICAgY29tbWVudDogQ29tcG9zZXJTdWJtaXRDb21tZW50LFxuICAgICAgZXZlbnQ6IEZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+XG4gICAgKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb3NlcidzIGluaXRpYWwgdmFsdWUuXG4gICAgICovXG4gICAgZGVmYXVsdFZhbHVlPzogQ29tcG9zZXJFZGl0b3JQcm9wc1tcImRlZmF1bHRWYWx1ZVwiXTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNvbXBvc2VyIGlzIGNvbGxhcHNlZC4gU2V0dGluZyBhIHZhbHVlIHdpbGwgbWFrZSB0aGUgY29tcG9zZXIgY29udHJvbGxlZC5cbiAgICAgKi9cbiAgICBjb2xsYXBzZWQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IGhhbmRsZXIgY2FsbGVkIHdoZW4gdGhlIGNvbGxhcHNlZCBzdGF0ZSBvZiB0aGUgY29tcG9zZXIgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBvbkNvbGxhcHNlZENoYW5nZT86IChjb2xsYXBzZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjb21wb3NlciBpcyBpbml0aWFsbHkgY29sbGFwc2VkLiBTZXR0aW5nIGEgdmFsdWUgd2lsbCBtYWtlIHRoZSBjb21wb3NlciB1bmNvbnRyb2xsZWQuXG4gICAgICovXG4gICAgZGVmYXVsdENvbGxhcHNlZD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjb21wb3NlciBpcyBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlZD86IENvbXBvc2VyRWRpdG9yUHJvcHNbXCJkaXNhYmxlZFwiXTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZm9jdXMgdGhlIGNvbXBvc2VyIG9uIG1vdW50LlxuICAgICAqL1xuICAgIGF1dG9Gb2N1cz86IENvbXBvc2VyRWRpdG9yUHJvcHNbXCJhdXRvRm9jdXNcIl07XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgY29tcG9uZW50J3Mgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBvdmVycmlkZXM/OiBQYXJ0aWFsPEdsb2JhbE92ZXJyaWRlcyAmIENvbXBvc2VyT3ZlcnJpZGVzPjtcblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFjdGlvbnM/OiBSZWFjdE5vZGU7XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzaG93QXR0cmlidXRpb24/OiBib29sZWFuO1xuICB9O1xuXG5mdW5jdGlvbiBDb21wb3Nlckluc2VydE1lbnRpb25FZGl0b3JBY3Rpb24oe1xuICBsYWJlbCxcbiAgY2xhc3NOYW1lLFxuICBvbkNsaWNrLFxuICAuLi5wcm9wc1xufTogRWRpdG9yQWN0aW9uUHJvcHMpIHtcbiAgY29uc3QgeyBjcmVhdGVNZW50aW9uIH0gPSB1c2VDb21wb3NlcigpO1xuXG4gIGNvbnN0IHByZXZlbnREZWZhdWx0ID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBTeW50aGV0aWNFdmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKFxuICAgIChldmVudDogTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pID0+IHtcbiAgICAgIG9uQ2xpY2s/LihldmVudCk7XG5cbiAgICAgIGlmICghZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNyZWF0ZU1lbnRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtjcmVhdGVNZW50aW9uLCBvbkNsaWNrXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPFRvb2x0aXAgY29udGVudD17bGFiZWx9PlxuICAgICAgPEJ1dHRvblxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJsYi1jb21wb3Nlci1lZGl0b3ItYWN0aW9uXCIsIGNsYXNzTmFtZSl9XG4gICAgICAgIG9uTW91c2VEb3duPXtwcmV2ZW50RGVmYXVsdH1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgIGFyaWEtbGFiZWw9e2xhYmVsfVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICA+XG4gICAgICAgIDxNZW50aW9uSWNvbiBjbGFzc05hbWU9XCJsYi1idXR0b24taWNvblwiIC8+XG4gICAgICA8L0J1dHRvbj5cbiAgICA8L1Rvb2x0aXA+XG4gICk7XG59XG5cbmZ1bmN0aW9uIENvbXBvc2VySW5zZXJ0RW1vamlFZGl0b3JBY3Rpb24oe1xuICBsYWJlbCxcbiAgb25QaWNrZXJPcGVuQ2hhbmdlLFxuICBjbGFzc05hbWUsXG4gIC4uLnByb3BzXG59OiBFbW9qaUVkaXRvckFjdGlvblByb3BzKSB7XG4gIGNvbnN0IHsgaW5zZXJ0VGV4dCB9ID0gdXNlQ29tcG9zZXIoKTtcblxuICBjb25zdCBwcmV2ZW50RGVmYXVsdCA9IHVzZUNhbGxiYWNrKChldmVudDogU3ludGhldGljRXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8RW1vamlQaWNrZXIgb25FbW9qaVNlbGVjdD17aW5zZXJ0VGV4dH0gb25PcGVuQ2hhbmdlPXtvblBpY2tlck9wZW5DaGFuZ2V9PlxuICAgICAgPFRvb2x0aXAgY29udGVudD17bGFiZWx9PlxuICAgICAgICA8RW1vamlQaWNrZXJUcmlnZ2VyIGFzQ2hpbGQ+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwibGItY29tcG9zZXItZWRpdG9yLWFjdGlvblwiLCBjbGFzc05hbWUpfVxuICAgICAgICAgICAgb25Nb3VzZURvd249e3ByZXZlbnREZWZhdWx0fVxuICAgICAgICAgICAgYXJpYS1sYWJlbD17bGFiZWx9XG4gICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEVtb2ppSWNvbiBjbGFzc05hbWU9XCJsYi1idXR0b24taWNvblwiIC8+XG4gICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDwvRW1vamlQaWNrZXJUcmlnZ2VyPlxuICAgICAgPC9Ub29sdGlwPlxuICAgIDwvRW1vamlQaWNrZXI+XG4gICk7XG59XG5cbmZ1bmN0aW9uIENvbXBvc2VyTWVudGlvbih7IHVzZXJJZCB9OiBDb21wb3NlckVkaXRvck1lbnRpb25Qcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxDb21wb3NlclByaW1pdGl2ZS5NZW50aW9uIGNsYXNzTmFtZT1cImxiLWNvbXBvc2VyLW1lbnRpb25cIj5cbiAgICAgIHtNRU5USU9OX0NIQVJBQ1RFUn1cbiAgICAgIDxVc2VyIHVzZXJJZD17dXNlcklkfSAvPlxuICAgIDwvQ29tcG9zZXJQcmltaXRpdmUuTWVudGlvbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gQ29tcG9zZXJNZW50aW9uU3VnZ2VzdGlvbnMoe1xuICB1c2VySWRzLFxufTogQ29tcG9zZXJFZGl0b3JNZW50aW9uU3VnZ2VzdGlvbnNQcm9wcykge1xuICByZXR1cm4gdXNlcklkcy5sZW5ndGggPiAwID8gKFxuICAgIDxDb21wb3NlclByaW1pdGl2ZS5TdWdnZXN0aW9ucyBjbGFzc05hbWU9XCJsYi1yb290IGxiLXBvcnRhbCBsYi1lbGV2YXRpb24gbGItY29tcG9zZXItc3VnZ2VzdGlvbnMgbGItY29tcG9zZXItbWVudGlvbi1zdWdnZXN0aW9uc1wiPlxuICAgICAgPENvbXBvc2VyUHJpbWl0aXZlLlN1Z2dlc3Rpb25zTGlzdCBjbGFzc05hbWU9XCJsYi1jb21wb3Nlci1zdWdnZXN0aW9ucy1saXN0IGxiLWNvbXBvc2VyLW1lbnRpb24tc3VnZ2VzdGlvbnMtbGlzdFwiPlxuICAgICAgICB7dXNlcklkcy5tYXAoKHVzZXJJZCkgPT4gKFxuICAgICAgICAgIDxDb21wb3NlclByaW1pdGl2ZS5TdWdnZXN0aW9uc0xpc3RJdGVtXG4gICAgICAgICAgICBrZXk9e3VzZXJJZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImxiLWNvbXBvc2VyLXN1Z2dlc3Rpb25zLWxpc3QtaXRlbSBsYi1jb21wb3Nlci1tZW50aW9uLXN1Z2dlc3Rpb25cIlxuICAgICAgICAgICAgdmFsdWU9e3VzZXJJZH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8QXZhdGFyXG4gICAgICAgICAgICAgIHVzZXJJZD17dXNlcklkfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsYi1jb21wb3Nlci1tZW50aW9uLXN1Z2dlc3Rpb24tYXZhdGFyXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8VXNlclxuICAgICAgICAgICAgICB1c2VySWQ9e3VzZXJJZH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibGItY29tcG9zZXItbWVudGlvbi1zdWdnZXN0aW9uLXVzZXJcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L0NvbXBvc2VyUHJpbWl0aXZlLlN1Z2dlc3Rpb25zTGlzdEl0ZW0+XG4gICAgICAgICkpfVxuICAgICAgPC9Db21wb3NlclByaW1pdGl2ZS5TdWdnZXN0aW9uc0xpc3Q+XG4gICAgPC9Db21wb3NlclByaW1pdGl2ZS5TdWdnZXN0aW9ucz5cbiAgKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIENvbXBvc2VyTGluayh7IGhyZWYsIGNoaWxkcmVuIH06IENvbXBvc2VyRWRpdG9yTGlua1Byb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPENvbXBvc2VyUHJpbWl0aXZlLkxpbmsgaHJlZj17aHJlZn0gY2xhc3NOYW1lPVwibGItY29tcG9zZXItbGlua1wiPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQ29tcG9zZXJQcmltaXRpdmUuTGluaz5cbiAgKTtcbn1cblxuY29uc3QgZWRpdG9yQ29tcG9uZW50czogQ29tcG9zZXJFZGl0b3JDb21wb25lbnRzID0ge1xuICBNZW50aW9uOiBDb21wb3Nlck1lbnRpb24sXG4gIE1lbnRpb25TdWdnZXN0aW9uczogQ29tcG9zZXJNZW50aW9uU3VnZ2VzdGlvbnMsXG4gIExpbms6IENvbXBvc2VyTGluayxcbn07XG5cbmNvbnN0IENvbXBvc2VyV2l0aENvbnRleHQgPSBmb3J3YXJkUmVmPFxuICBIVE1MRm9ybUVsZW1lbnQsXG4gIE9taXQ8Q29tcG9zZXJQcm9wcywgXCJ0aHJlYWRJZFwiIHwgXCJjb21tZW50SWRcIiB8IFwib25Db21wb3NlclN1Ym1pdFwiPlxuPihcbiAgKFxuICAgIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgYXV0b0ZvY3VzLFxuICAgICAgY29sbGFwc2VkOiBjb250cm9sbGVkQ29sbGFwc2VkLFxuICAgICAgZGVmYXVsdENvbGxhcHNlZCxcbiAgICAgIG9uQ29sbGFwc2VkQ2hhbmdlOiBjb250cm9sbGVkT25Db2xsYXBzZWRDaGFuZ2UsXG4gICAgICBhY3Rpb25zLFxuICAgICAgb3ZlcnJpZGVzLFxuICAgICAgc2hvd0F0dHJpYnV0aW9uLFxuICAgICAgb25Gb2N1cyxcbiAgICAgIG9uQmx1cixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSA9PiB7XG4gICAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gICAgY29uc3QgaGFzUmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyA9XG4gICAgICBjbGllbnRba0ludGVybmFsXS5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc2VsZiA9IHVzZVNlbGYoKTtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gdXNlTWVtbyhcbiAgICAgICgpID0+IGRpc2FibGVkIHx8ICFzZWxmPy5jYW5Db21tZW50LFxuICAgICAgW2Rpc2FibGVkLCBzZWxmPy5jYW5Db21tZW50XVxuICAgICk7XG4gICAgY29uc3QgeyBpc0VtcHR5IH0gPSB1c2VDb21wb3NlcigpO1xuICAgIGNvbnN0ICQgPSB1c2VPdmVycmlkZXMob3ZlcnJpZGVzKTtcbiAgICBjb25zdCBbaXNFbW9qaVBpY2tlck9wZW4sIHNldEVtb2ppUGlja2VyT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2NvbGxhcHNlZCwgb25Db2xsYXBzZWRDaGFuZ2VdID0gdXNlQ29udHJvbGxhYmxlU3RhdGUoXG4gICAgICAvLyBJZiB0aGUgY29tcG9zZXIgaXMgbmVpdGhlciBjb250cm9sbGVkIG5vciB1bmNvbnRyb2xsZWQsIGl0IGRlZmF1bHRzIHRvIGNvbnRyb2xsZWQgYXMgdW5jb2xsYXBzZWQuXG4gICAgICBjb250cm9sbGVkQ29sbGFwc2VkID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdENvbGxhcHNlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZmFsc2VcbiAgICAgICAgOiBjb250cm9sbGVkQ29sbGFwc2VkLFxuICAgICAgY29udHJvbGxlZE9uQ29sbGFwc2VkQ2hhbmdlLFxuICAgICAgZGVmYXVsdENvbGxhcHNlZFxuICAgICk7XG5cbiAgICBjb25zdCBwcmV2ZW50RGVmYXVsdCA9IHVzZUNhbGxiYWNrKChldmVudDogU3ludGhldGljRXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc3RvcFByb3BhZ2F0aW9uID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBTeW50aGV0aWNFdmVudCkgPT4ge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgaGFuZGxlRWRpdG9yQ2xpY2sgPSB1c2VDYWxsYmFjayhcbiAgICAgIChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICBvbkNvbGxhcHNlZENoYW5nZT8uKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtpc0VtcHR5LCBvbkNvbGxhcHNlZENoYW5nZV1cbiAgICApO1xuXG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjayhcbiAgICAgIChldmVudDogRm9jdXNFdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIG9uRm9jdXM/LihldmVudCk7XG5cbiAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICBvbkNvbGxhcHNlZENoYW5nZT8uKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtpc0VtcHR5LCBvbkNvbGxhcHNlZENoYW5nZSwgb25Gb2N1c11cbiAgICApO1xuXG4gICAgY29uc3QgaGFuZGxlQmx1ciA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGV2ZW50OiBGb2N1c0V2ZW50PEhUTUxGb3JtRWxlbWVudD4pID0+IHtcbiAgICAgICAgb25CbHVyPy4oZXZlbnQpO1xuXG4gICAgICAgIGlmIChldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzT3V0c2lkZSA9ICFldmVudC5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuXG4gICAgICAgIGlmIChpc091dHNpZGUgJiYgaXNFbXB0eSAmJiAhaXNFbW9qaVBpY2tlck9wZW4pIHtcbiAgICAgICAgICBvbkNvbGxhcHNlZENoYW5nZT8uKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2lzRW1vamlQaWNrZXJPcGVuLCBpc0VtcHR5LCBvbkJsdXIsIG9uQ29sbGFwc2VkQ2hhbmdlXVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGZvcm1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgIFwibGItcm9vdCBsYi1jb21wb3NlciBsYi1jb21wb3Nlci1mb3JtXCIsXG4gICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgICl9XG4gICAgICAgIGRpcj17JC5kaXJ9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICAgIGRhdGEtY29sbGFwc2VkPXtjb2xsYXBzZWQgPyBcIlwiIDogdW5kZWZpbmVkfVxuICAgICAgICBvbkZvY3VzPXtoYW5kbGVGb2N1c31cbiAgICAgICAgb25CbHVyPXtoYW5kbGVCbHVyfVxuICAgICAgPlxuICAgICAgICA8Q29tcG9zZXJQcmltaXRpdmUuRWRpdG9yXG4gICAgICAgICAgY2xhc3NOYW1lPVwibGItY29tcG9zZXItZWRpdG9yXCJcbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVFZGl0b3JDbGlja31cbiAgICAgICAgICBwbGFjZWhvbGRlcj17JC5DT01QT1NFUl9QTEFDRUhPTERFUn1cbiAgICAgICAgICBkZWZhdWx0VmFsdWU9e2RlZmF1bHRWYWx1ZX1cbiAgICAgICAgICBkaXNhYmxlZD17aXNEaXNhYmxlZH1cbiAgICAgICAgICBhdXRvRm9jdXM9e2F1dG9Gb2N1c31cbiAgICAgICAgICBjb21wb25lbnRzPXtlZGl0b3JDb21wb25lbnRzfVxuICAgICAgICAgIGRpcj17JC5kaXJ9XG4gICAgICAgIC8+XG4gICAgICAgIHshY29sbGFwc2VkICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxiLWNvbXBvc2VyLWZvb3RlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsYi1jb21wb3Nlci1lZGl0b3ItYWN0aW9uc1wiPlxuICAgICAgICAgICAgICB7aGFzUmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyAmJiAoXG4gICAgICAgICAgICAgICAgPENvbXBvc2VySW5zZXJ0TWVudGlvbkVkaXRvckFjdGlvblxuICAgICAgICAgICAgICAgICAgbGFiZWw9eyQuQ09NUE9TRVJfSU5TRVJUX01FTlRJT059XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNEaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8Q29tcG9zZXJJbnNlcnRFbW9qaUVkaXRvckFjdGlvblxuICAgICAgICAgICAgICAgIGxhYmVsPXskLkNPTVBPU0VSX0lOU0VSVF9FTU9KSX1cbiAgICAgICAgICAgICAgICBvblBpY2tlck9wZW5DaGFuZ2U9e3NldEVtb2ppUGlja2VyT3Blbn1cbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNEaXNhYmxlZH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3Nob3dBdHRyaWJ1dGlvbiAmJiA8QXR0cmlidXRpb24gLz59XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxiLWNvbXBvc2VyLWFjdGlvbnNcIj5cbiAgICAgICAgICAgICAge2FjdGlvbnMgPz8gKFxuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICA8U2hvcnRjdXRUb29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ9eyQuQ09NUE9TRVJfU0VORH1cbiAgICAgICAgICAgICAgICAgICAgc2hvcnRjdXQ9ezxTaG9ydGN1dFRvb2x0aXBLZXkgbmFtZT1cImVudGVyXCIgLz59XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxDb21wb3NlclByaW1pdGl2ZS5TdWJtaXQgZGlzYWJsZWQ9e2lzRGlzYWJsZWR9IGFzQ2hpbGQ+XG4gICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd249e3ByZXZlbnREZWZhdWx0fVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17c3RvcFByb3BhZ2F0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibGItY29tcG9zZXItYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJwcmltYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9eyQuQ09NUE9TRVJfU0VORH1cbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VuZEljb24gLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9Db21wb3NlclByaW1pdGl2ZS5TdWJtaXQ+XG4gICAgICAgICAgICAgICAgICA8L1Nob3J0Y3V0VG9vbHRpcD5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9mb3JtPlxuICAgICk7XG4gIH1cbik7XG5cbi8qKlxuICogRGlzcGxheXMgYSBjb21wb3NlciB0byBjcmVhdGUgY29tbWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxDb21wb3NlciAvPlxuICovXG5leHBvcnQgY29uc3QgQ29tcG9zZXIgPSBmb3J3YXJkUmVmKFxuICA8TSBleHRlbmRzIEJhc2VNZXRhZGF0YSA9IERNPihcbiAgICB7XG4gICAgICB0aHJlYWRJZCxcbiAgICAgIGNvbW1lbnRJZCxcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgb25Db21wb3NlclN1Ym1pdCxcbiAgICAgIG9uRm9jdXMsXG4gICAgICAuLi5wcm9wc1xuICAgIH06IENvbXBvc2VyUHJvcHM8TT4sXG4gICAgZm9yd2FyZGVkUmVmOiBGb3J3YXJkZWRSZWY8SFRNTEZvcm1FbGVtZW50PlxuICApID0+IHtcbiAgICBjb25zdCBjcmVhdGVUaHJlYWQgPSB1c2VDcmVhdGVUaHJlYWQoKTtcbiAgICBjb25zdCBjcmVhdGVDb21tZW50ID0gdXNlQ3JlYXRlQ29tbWVudCgpO1xuICAgIGNvbnN0IGVkaXRDb21tZW50ID0gdXNlRWRpdENvbW1lbnQoKTtcblxuICAgIGNvbnN0IGhhbmRsZUNvbW1lbnRTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICAgIChjb21tZW50OiBDb21wb3NlclN1Ym1pdENvbW1lbnQsIGV2ZW50OiBGb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PikgPT4ge1xuICAgICAgICBvbkNvbXBvc2VyU3VibWl0Py4oY29tbWVudCwgZXZlbnQpO1xuXG4gICAgICAgIGlmIChldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tZW50SWQgJiYgdGhyZWFkSWQpIHtcbiAgICAgICAgICBlZGl0Q29tbWVudCh7XG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGJvZHk6IGNvbW1lbnQuYm9keSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aHJlYWRJZCkge1xuICAgICAgICAgIGNyZWF0ZUNvbW1lbnQoe1xuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBib2R5OiBjb21tZW50LmJvZHksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3JlYXRlVGhyZWFkKHtcbiAgICAgICAgICAgIGJvZHk6IGNvbW1lbnQuYm9keSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICBjcmVhdGVDb21tZW50LFxuICAgICAgICBjcmVhdGVUaHJlYWQsXG4gICAgICAgIGVkaXRDb21tZW50LFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgb25Db21wb3NlclN1Ym1pdCxcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICBdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8VG9vbHRpcFByb3ZpZGVyPlxuICAgICAgICA8Q29tcG9zZXJQcmltaXRpdmUuRm9ybVxuICAgICAgICAgIG9uQ29tcG9zZXJTdWJtaXQ9e2hhbmRsZUNvbW1lbnRTdWJtaXR9XG4gICAgICAgICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICAgICAgICBhc0NoaWxkXG4gICAgICAgID5cbiAgICAgICAgICA8Q29tcG9zZXJXaXRoQ29udGV4dCB7Li4ucHJvcHN9IHJlZj17Zm9yd2FyZGVkUmVmfSAvPlxuICAgICAgICA8L0NvbXBvc2VyUHJpbWl0aXZlLkZvcm0+XG4gICAgICA8L1Rvb2x0aXBQcm92aWRlcj5cbiAgICApO1xuICB9XG4pIGFzIDxNIGV4dGVuZHMgQmFzZU1ldGFkYXRhID0gRE0+KFxuICBwcm9wczogQ29tcG9zZXJQcm9wczxNPiAmIFJlZkF0dHJpYnV0ZXM8SFRNTEZvcm1FbGVtZW50PlxuKSA9PiBKU1guRWxlbWVudDtcbiJdLCJuYW1lcyI6WyJDb21wb3Nlckluc2VydE1lbnRpb25FZGl0b3JBY3Rpb24iLCJsYWJlbCIsImNsYXNzTmFtZSIsIm9uQ2xpY2siLCJwcm9wcyIsImNyZWF0ZU1lbnRpb24iLCJ1c2VDb21wb3NlciIsInByZXZlbnREZWZhdWx0IiwidXNlQ2FsbGJhY2siLCJldmVudCIsImhhbmRsZUNsaWNrIiwiaXNEZWZhdWx0UHJldmVudGVkIiwic3RvcFByb3BhZ2F0aW9uIiwiUmVhY3RfX2RlZmF1bHQiLCJjcmVhdGVFbGVtZW50IiwiVG9vbHRpcCIsImNvbnRlbnQiLCJCdXR0b24iLCJjbGFzc05hbWVzIiwib25Nb3VzZURvd24iLCJNZW50aW9uSWNvbiIsIkNvbXBvc2VySW5zZXJ0RW1vamlFZGl0b3JBY3Rpb24iLCJvblBpY2tlck9wZW5DaGFuZ2UiLCJpbnNlcnRUZXh0IiwiRW1vamlQaWNrZXIiLCJvbkVtb2ppU2VsZWN0Iiwib25PcGVuQ2hhbmdlIiwiUG9wb3ZlclRyaWdnZXIiLCJhc0NoaWxkIiwiRW1vamlJY29uIiwiQ29tcG9zZXJNZW50aW9uIiwidXNlcklkIiwiQ29tcG9zZXJNZW50aW9uJDEiLCJNRU5USU9OX0NIQVJBQ1RFUiIsIlVzZXIiLCJDb21wb3Nlck1lbnRpb25TdWdnZXN0aW9ucyIsInVzZXJJZHMiLCJsZW5ndGgiLCJDb21wb3NlclN1Z2dlc3Rpb25zIiwiQ29tcG9zZXJTdWdnZXN0aW9uc0xpc3QiLCJtYXAiLCJDb21wb3NlclN1Z2dlc3Rpb25zTGlzdEl0ZW0iLCJrZXkiLCJ2YWx1ZSIsIkF2YXRhciIsIkNvbXBvc2VyTGluayIsImhyZWYiLCJjaGlsZHJlbiIsIkNvbXBvc2VyTGluayQxIiwiZWRpdG9yQ29tcG9uZW50cyIsIk1lbnRpb24iLCJNZW50aW9uU3VnZ2VzdGlvbnMiLCJMaW5rIiwiQ29tcG9zZXJXaXRoQ29udGV4dCIsImZvcndhcmRSZWYiLCJkZWZhdWx0VmFsdWUiLCJkaXNhYmxlZCIsImF1dG9Gb2N1cyIsImNvbGxhcHNlZCIsImNvbnRyb2xsZWRDb2xsYXBzZWQiLCJkZWZhdWx0Q29sbGFwc2VkIiwib25Db2xsYXBzZWRDaGFuZ2UiLCJjb250cm9sbGVkT25Db2xsYXBzZWRDaGFuZ2UiLCJhY3Rpb25zIiwib3ZlcnJpZGVzIiwic2hvd0F0dHJpYnV0aW9uIiwib25Gb2N1cyIsIm9uQmx1ciIsImZvcndhcmRlZFJlZiIsImNsaWVudCIsInVzZUNsaWVudCIsImhhc1Jlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMiLCJrSW50ZXJuYWwiLCJyZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zIiwic2VsZiIsInVzZVNlbGYiLCJpc0Rpc2FibGVkIiwidXNlTWVtbyIsImNhbkNvbW1lbnQiLCJpc0VtcHR5IiwiJCIsInVzZU92ZXJyaWRlcyIsImlzRW1vamlQaWNrZXJPcGVuIiwic2V0RW1vamlQaWNrZXJPcGVuIiwidXNlU3RhdGUiLCJ1c2VDb250cm9sbGFibGVTdGF0ZSIsImhhbmRsZUVkaXRvckNsaWNrIiwiaGFuZGxlRm9jdXMiLCJoYW5kbGVCbHVyIiwiaXNPdXRzaWRlIiwiY3VycmVudFRhcmdldCIsImNvbnRhaW5zIiwicmVsYXRlZFRhcmdldCIsImRpciIsInJlZiIsIkNvbXBvc2VyRWRpdG9yIiwicGxhY2Vob2xkZXIiLCJDT01QT1NFUl9QTEFDRUhPTERFUiIsImNvbXBvbmVudHMiLCJDT01QT1NFUl9JTlNFUlRfTUVOVElPTiIsIkNPTVBPU0VSX0lOU0VSVF9FTU9KSSIsIkF0dHJpYnV0aW9uIiwiRnJhZ21lbnQiLCJTaG9ydGN1dFRvb2x0aXAiLCJDT01QT1NFUl9TRU5EIiwic2hvcnRjdXQiLCJTaG9ydGN1dFRvb2x0aXBLZXkiLCJuYW1lIiwiQ29tcG9zZXJTdWJtaXQiLCJ2YXJpYW50IiwiU2VuZEljb24iLCJDb21wb3NlciIsInRocmVhZElkIiwiY29tbWVudElkIiwibWV0YWRhdGEiLCJvbkNvbXBvc2VyU3VibWl0IiwiY3JlYXRlVGhyZWFkIiwidXNlQ3JlYXRlVGhyZWFkIiwiY3JlYXRlQ29tbWVudCIsInVzZUNyZWF0ZUNvbW1lbnQiLCJlZGl0Q29tbWVudCIsInVzZUVkaXRDb21tZW50IiwiaGFuZGxlQ29tbWVudFN1Ym1pdCIsImNvbW1lbnQiLCJib2R5IiwiVG9vbHRpcFByb3ZpZGVyIiwiQ29tcG9zZXJGb3JtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/Composer.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/InboxNotification.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/InboxNotification.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InboxNotification: () => (/* binding */ InboxNotification)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs\");\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @radix-ui/react-tooltip */ \"(ssr)/./node_modules/@radix-ui/react-tooltip/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components.mjs\");\n/* harmony import */ var _icons_Check_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../icons/Check.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Check.mjs\");\n/* harmony import */ var _icons_Delete_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../icons/Delete.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Delete.mjs\");\n/* harmony import */ var _icons_Ellipsis_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../icons/Ellipsis.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Ellipsis.mjs\");\n/* harmony import */ var _icons_Missing_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../icons/Missing.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Missing.mjs\");\n/* harmony import */ var _overrides_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../overrides.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\");\n/* harmony import */ var _primitives_Timestamp_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../primitives/Timestamp.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Timestamp.mjs\");\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../shared.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/shared.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* harmony import */ var _utils_url_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../utils/url.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/url.mjs\");\n/* harmony import */ var _internal_Avatar_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./internal/Avatar.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Avatar.mjs\");\n/* harmony import */ var _internal_Button_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./internal/Button.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Button.mjs\");\n/* harmony import */ var _internal_Dropdown_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./internal/Dropdown.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Dropdown.mjs\");\n/* harmony import */ var _internal_InboxNotificationThread_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./internal/InboxNotificationThread.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/InboxNotificationThread.mjs\");\n/* harmony import */ var _internal_List_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./internal/List.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/List.mjs\");\n/* harmony import */ var _internal_Room_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./internal/Room.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Room.mjs\");\n/* harmony import */ var _internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./internal/Tooltip.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.mjs\");\n/* harmony import */ var _internal_User_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./internal/User.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/User.mjs\");\n/* harmony import */ var _radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @radix-ui/react-dropdown-menu */ \"(ssr)/./node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ InboxNotification auto */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst InboxNotificationLayout = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ inboxNotification, children, aside, title, date, unread, markAsReadOnClick, onClick, href, showActions, overrides, components, className, asChild, ...props }, forwardedRef)=>{\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_1__.useOverrides)(overrides);\n    const { Anchor } = (0,_components_mjs__WEBPACK_IMPORTED_MODULE_2__.useComponents)(components);\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_3__.Slot : Anchor;\n    const [isMoreActionOpen, setMoreActionOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const markInboxNotificationAsRead = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_4__.useMarkInboxNotificationAsRead)();\n    const deleteInboxNotification = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_4__.useDeleteInboxNotification)();\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onClick?.(event);\n        const shouldMarkAsReadOnClick = markAsReadOnClick ?? Boolean(href);\n        if (unread && shouldMarkAsReadOnClick) {\n            markInboxNotificationAsRead(inboxNotification.id);\n        }\n    }, [\n        href,\n        inboxNotification.id,\n        markAsReadOnClick,\n        markInboxNotificationAsRead,\n        onClick,\n        unread\n    ]);\n    const stopPropagation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.stopPropagation();\n    }, []);\n    const preventDefaultAndStopPropagation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.preventDefault();\n        event.stopPropagation();\n    }, []);\n    const handleMoreClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.preventDefault();\n        event.stopPropagation();\n        setMoreActionOpen((open)=>!open);\n    }, []);\n    const handleMarkAsRead = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        markInboxNotificationAsRead(inboxNotification.id);\n    }, [\n        inboxNotification.id,\n        markInboxNotificationAsRead\n    ]);\n    const handleDelete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        deleteInboxNotification(inboxNotification.id);\n    }, [\n        inboxNotification.id,\n        deleteInboxNotification\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_5__.TooltipProvider, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_6__.classNames)(\"lb-root lb-inbox-notification\", showActions === \"hover\" && \"lb-inbox-notification:show-actions-hover\", isMoreActionOpen && \"lb-inbox-notification:action-open\", className),\n        dir: $.dir,\n        \"data-unread\": unread ? \"\" : void 0,\n        \"data-kind\": inboxNotification.kind,\n        onClick: handleClick,\n        href,\n        ...props,\n        ref: forwardedRef\n    }, aside && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-inbox-notification-aside\"\n    }, aside), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-inbox-notification-content\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-inbox-notification-header\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"lb-inbox-notification-title\"\n    }, title), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-inbox-notification-details\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"lb-inbox-notification-details-labels\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Timestamp_mjs__WEBPACK_IMPORTED_MODULE_7__.Timestamp, {\n        locale: $.locale,\n        date,\n        className: \"lb-inbox-notification-date\"\n    }), unread && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"lb-inbox-notification-unread-indicator\",\n        role: \"presentation\"\n    }))), showActions && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-inbox-notification-actions\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Dropdown_mjs__WEBPACK_IMPORTED_MODULE_8__.Dropdown, {\n        open: isMoreActionOpen,\n        onOpenChange: setMoreActionOpen,\n        align: \"end\",\n        content: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, unread ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Dropdown_mjs__WEBPACK_IMPORTED_MODULE_8__.DropdownItem, {\n            onSelect: handleMarkAsRead,\n            onClick: stopPropagation\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Check_mjs__WEBPACK_IMPORTED_MODULE_9__.CheckIcon, {\n            className: \"lb-dropdown-item-icon\"\n        }), $.INBOX_NOTIFICATION_MARK_AS_READ) : null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Dropdown_mjs__WEBPACK_IMPORTED_MODULE_8__.DropdownItem, {\n            onSelect: handleDelete,\n            onClick: stopPropagation\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Delete_mjs__WEBPACK_IMPORTED_MODULE_10__.DeleteIcon, {\n            className: \"lb-dropdown-item-icon\"\n        }), $.INBOX_NOTIFICATION_DELETE))\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Tooltip_mjs__WEBPACK_IMPORTED_MODULE_11__.Tooltip, {\n        content: $.INBOX_NOTIFICATION_MORE\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_12__.DropdownMenuTrigger, {\n        asChild: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Button_mjs__WEBPACK_IMPORTED_MODULE_13__.Button, {\n        className: \"lb-inbox-notification-action\",\n        onClick: handleMoreClick,\n        onPointerDown: preventDefaultAndStopPropagation,\n        onPointerUp: preventDefaultAndStopPropagation,\n        \"aria-label\": $.INBOX_NOTIFICATION_MORE\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Ellipsis_mjs__WEBPACK_IMPORTED_MODULE_14__.EllipsisIcon, {\n        className: \"lb-button-icon\"\n    }))))))), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"lb-inbox-notification-body\"\n    }, children))));\n});\nfunction InboxNotificationIcon({ className, ...props }) {\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_6__.classNames)(\"lb-inbox-notification-icon\", className),\n        ...props\n    });\n}\nfunction InboxNotificationAvatar({ className, ...props }) {\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Avatar_mjs__WEBPACK_IMPORTED_MODULE_15__.Avatar, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_6__.classNames)(\"lb-inbox-notification-avatar\", className),\n        ...props\n    });\n}\nconst InboxNotificationThread = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ inboxNotification, href, showRoomName = true, showActions = \"hover\", overrides, ...props }, forwardedRef)=>{\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_1__.useOverrides)(overrides);\n    const thread = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_4__._useInboxNotificationThread)(inboxNotification.id);\n    const currentUserId = (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_16__.useCurrentUserId)();\n    const { info } = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_4__.useRoomInfo)(inboxNotification.roomId);\n    const { unread, date, aside, title, content, commentId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const contents = (0,_internal_InboxNotificationThread_mjs__WEBPACK_IMPORTED_MODULE_17__.generateInboxNotificationThreadContents)(inboxNotification, thread, currentUserId ?? \"\");\n        switch(contents.type){\n            case \"comments\":\n                {\n                    const reversedUserIds = [\n                        ...contents.userIds\n                    ].reverse();\n                    const firstUserId = reversedUserIds[0];\n                    const aside2 = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(InboxNotificationAvatar, {\n                        userId: firstUserId\n                    });\n                    const title2 = $.INBOX_NOTIFICATION_THREAD_COMMENTS_LIST(/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_List_mjs__WEBPACK_IMPORTED_MODULE_18__.List, {\n                        values: reversedUserIds.map((userId, index)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_User_mjs__WEBPACK_IMPORTED_MODULE_19__.User, {\n                                key: userId,\n                                userId,\n                                capitalize: index === 0,\n                                replaceSelf: true\n                            })),\n                        formatRemaining: $.LIST_REMAINING_USERS,\n                        truncate: _internal_InboxNotificationThread_mjs__WEBPACK_IMPORTED_MODULE_17__.INBOX_NOTIFICATION_THREAD_MAX_COMMENTS - 1\n                    }), showRoomName ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Room_mjs__WEBPACK_IMPORTED_MODULE_20__.Room, {\n                        roomId: thread.roomId\n                    }) : void 0, reversedUserIds.length);\n                    const content2 = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                        className: \"lb-inbox-notification-comments\"\n                    }, contents.comments.map((comment)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_InboxNotificationThread_mjs__WEBPACK_IMPORTED_MODULE_17__.InboxNotificationComment, {\n                            key: comment.id,\n                            comment,\n                            showHeader: contents.comments.length > 1,\n                            overrides\n                        })));\n                    return {\n                        unread: contents.unread,\n                        date: contents.date,\n                        aside: aside2,\n                        title: title2,\n                        content: content2,\n                        threadId: thread.id,\n                        commentId: contents.comments[contents.comments.length - 1].id\n                    };\n                }\n            case \"mention\":\n                {\n                    const mentionUserId = contents.userIds[0];\n                    const mentionComment = contents.comments[0];\n                    const aside2 = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(InboxNotificationAvatar, {\n                        userId: mentionUserId\n                    });\n                    const title2 = $.INBOX_NOTIFICATION_THREAD_MENTION(/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_User_mjs__WEBPACK_IMPORTED_MODULE_19__.User, {\n                        key: mentionUserId,\n                        userId: mentionUserId,\n                        capitalize: true\n                    }), showRoomName ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Room_mjs__WEBPACK_IMPORTED_MODULE_20__.Room, {\n                        roomId: thread.roomId\n                    }) : void 0);\n                    const content2 = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                        className: \"lb-inbox-notification-comments\"\n                    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_InboxNotificationThread_mjs__WEBPACK_IMPORTED_MODULE_17__.InboxNotificationComment, {\n                        key: mentionComment.id,\n                        comment: mentionComment,\n                        showHeader: false\n                    }));\n                    return {\n                        unread: contents.unread,\n                        date: contents.date,\n                        aside: aside2,\n                        title: title2,\n                        content: content2,\n                        threadId: thread.id,\n                        commentId: mentionComment.id\n                    };\n                }\n            default:\n                return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_21__.assertNever)(contents, \"Unexpected thread inbox notification type\");\n        }\n    }, [\n        $,\n        currentUserId,\n        inboxNotification,\n        overrides,\n        showRoomName,\n        thread\n    ]);\n    const resolvedHref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const resolvedHref2 = href ?? info?.url;\n        return resolvedHref2 ? (0,_utils_url_mjs__WEBPACK_IMPORTED_MODULE_22__.generateURL)(resolvedHref2, void 0, commentId) : void 0;\n    }, [\n        commentId,\n        href,\n        info?.url\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(InboxNotificationLayout, {\n        inboxNotification,\n        aside,\n        title,\n        date,\n        unread,\n        overrides,\n        href: resolvedHref,\n        showActions,\n        markAsReadOnClick: false,\n        ...props,\n        ref: forwardedRef\n    }, content);\n});\nconst InboxNotificationTextMention = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ inboxNotification, showActions = \"hover\", showRoomName = true, overrides, ...props }, ref)=>{\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_1__.useOverrides)(overrides);\n    const unread = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return !inboxNotification.readAt || inboxNotification.notifiedAt > inboxNotification.readAt;\n    }, [\n        inboxNotification.notifiedAt,\n        inboxNotification.readAt\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(InboxNotificationLayout, {\n        inboxNotification,\n        aside: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(InboxNotificationAvatar, {\n            userId: inboxNotification.createdBy\n        }),\n        title: $.INBOX_NOTIFICATION_TEXT_MENTION(/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_User_mjs__WEBPACK_IMPORTED_MODULE_19__.User, {\n            key: inboxNotification.createdBy,\n            userId: inboxNotification.createdBy,\n            capitalize: true\n        }), showRoomName ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Room_mjs__WEBPACK_IMPORTED_MODULE_20__.Room, {\n            roomId: inboxNotification.roomId\n        }) : void 0),\n        date: inboxNotification.notifiedAt,\n        unread,\n        overrides,\n        showActions,\n        ...props,\n        ref\n    });\n});\nconst InboxNotificationCustom = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ inboxNotification, showActions = \"hover\", title, aside, children, overrides, ...props }, forwardedRef)=>{\n    const unread = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return !inboxNotification.readAt || inboxNotification.notifiedAt > inboxNotification.readAt;\n    }, [\n        inboxNotification.notifiedAt,\n        inboxNotification.readAt\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(InboxNotificationLayout, {\n        inboxNotification,\n        aside,\n        title,\n        date: inboxNotification.notifiedAt,\n        unread,\n        overrides,\n        showActions,\n        ...props,\n        ref: forwardedRef\n    }, children);\n});\nconst InboxNotificationCustomMissing = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ inboxNotification, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(InboxNotificationCustom, {\n        inboxNotification,\n        ...props,\n        title: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"Custom notification kind \", /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, inboxNotification.kind), \" is not handled\"),\n        aside: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(InboxNotificationIcon, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_Missing_mjs__WEBPACK_IMPORTED_MODULE_23__.MissingIcon, null)),\n        ref: forwardedRef,\n        \"data-missing\": \"\"\n    }, \"Notifications of this kind wont be displayed in production. Use the\", \" \", /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"kinds\"), \" prop to define how they should be rendered.\");\n});\nconst inboxNotificationKindsWarnings = /* @__PURE__ */ new Set();\nconst InboxNotification = Object.assign(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ inboxNotification, kinds, ...props }, forwardedRef)=>{\n    switch(inboxNotification.kind){\n        case \"thread\":\n            {\n                const ResolvedInboxNotificationThread = kinds?.thread ?? InboxNotificationThread;\n                return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolvedInboxNotificationThread, {\n                    inboxNotification,\n                    ...props,\n                    ref: forwardedRef\n                });\n            }\n        case \"textMention\":\n            {\n                const ResolvedInboxNotificationTextMention = kinds?.textMention ?? InboxNotificationTextMention;\n                return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolvedInboxNotificationTextMention, {\n                    inboxNotification,\n                    ...props,\n                    ref: forwardedRef\n                });\n            }\n        default:\n            {\n                const ResolvedInboxNotificationCustom = kinds?.[inboxNotification.kind];\n                if (!ResolvedInboxNotificationCustom) {\n                    if (true) {\n                        if (!inboxNotificationKindsWarnings.has(inboxNotification.kind)) {\n                            inboxNotificationKindsWarnings.add(inboxNotification.kind);\n                            _liveblocks_core__WEBPACK_IMPORTED_MODULE_21__.console.warn(`Custom notification kind \"${inboxNotification.kind}\" is not handled so notifications of this kind will not be displayed in production. Use the kinds prop to define how they should be rendered.`);\n                        }\n                        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(InboxNotificationCustomMissing, {\n                            inboxNotification,\n                            ...props,\n                            ref: forwardedRef\n                        });\n                    } else {}\n                }\n                return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolvedInboxNotificationCustom, {\n                    inboxNotification,\n                    ...props,\n                    ref: forwardedRef\n                });\n            }\n    }\n}), {\n    Thread: InboxNotificationThread,\n    TextMention: InboxNotificationTextMention,\n    Custom: InboxNotificationCustom,\n    Icon: InboxNotificationIcon,\n    Avatar: InboxNotificationAvatar\n});\n //# sourceMappingURL=InboxNotification.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL0luYm94Tm90aWZpY2F0aW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNk1BLE1BQUFBLHdDQUFBQyxpREFBQUEsQ0FBZ0MsR0FLNUJDLGlCQUFBLEVBQ0VDLFFBQUEsRUFDQUMsS0FBQSxFQUNBQyxLQUFBLEVBQ0FDLElBQUEsRUFDQUMsTUFBQSxFQUNBQyxpQkFBQSxFQUNBQyxPQUFBLEVBQ0FDLElBQUEsRUFDQUMsV0FBQSxFQUNBQyxTQUFBLEVBQ0FDLFVBQUEsRUFDQUMsU0FBQSxFQUNBQyxPQUFBLEVBQ0EsR0FBQUMsT0FDRyxFQUFBQztJQUlMLE1BQUFDLElBQUFDLDREQUFBQSxDQUFBUDtJQUNBLFFBQUFRLE1BQUEsS0FBQUMsOERBQUFBLENBQUFSO0lBQ0EsTUFBQVMsWUFBQVAsVUFBQVEsc0RBQUFBLEdBQUFIO0lBQ0EsT0FBQUksa0JBQUFDLGtCQUFBLEdBQUFDLCtDQUFBQSxDQUFBO0lBQ0EsTUFBQUMsOEJBQUFDLGlGQUFBQTtJQUNBLE1BQUFDLDBCQUFBQyw2RUFBQUE7SUFFQSxNQUFBQyxjQUFBQyxrREFBQUEsQ0FBb0IsQ0FBQUM7UUFFaEJ4QixVQUFBd0I7UUFFQSxNQUFBQywwQkFBQTFCLHFCQUFBMkIsUUFBQXpCO1FBRUEsSUFBQUgsVUFBQTJCLHlCQUFBO1lBQ0VQLDRCQUFBekIsa0JBQUFrQyxFQUFBO1FBQWdEO0lBQ2xELEdBQ0Y7UUFDQTFCO1FBQ0VSLGtCQUFBa0MsRUFBQTtRQUNrQjVCO1FBQ2xCbUI7UUFDQWxCO1FBQ0FGO0tBQ0E7SUFJSixNQUFBOEIsa0JBQUFMLGtEQUFBQSxDQUFBLENBQUFDO1FBQ0VBLE1BQUFJLGVBQUE7SUFBc0I7SUFHeEIsTUFBQUMsbUNBQUFOLGtEQUFBQSxDQUF5QyxDQUFBQztRQUVyQ0EsTUFBQU0sY0FBQTtR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QUE5SSxrQkFBQStDLElBQUE7NEJBQ0VvRiwrQkFBQVksR0FBQSxDQUFBL0ksa0JBQUErQyxJQUFBOzRCQUVBaUcsc0RBQU9BLENBQVBDLElBQUEsQ0FBUSw2QkFBQWpKLGtCQUFBK0MsSUFBQTt3QkFFUjt3QkFHRixxQ0FBQUwsZ0RBQUEsQ0FBQXVGLGdDQUFBOzRCQUNHakk7NEJBQ0MsR0FBQWMsS0FBQTs0QkFDSWtDLEtBQUFqQzt3QkFDQztvQkFDUCxTQUlLO2dCQUNUO2dCQUdGLHFDQUFBMkIsZ0RBQUEsQ0FBQWtHLGlDQUFBO29CQUNHNUk7b0JBQ0MsR0FBQWMsS0FBQTtvQkFDSWtDLEtBQUFqQztnQkFDQztZQUNQO0lBRUo7QUFDRixJQUVKO0lBQ0FtSSxRQUFBekU7SUFDVTBFLGFBQUF4QjtJQUNLeUIsUUFBQXBCO0lBQ0xxQixNQUFBL0U7SUFDRkUsUUFBQUQ7QUFDRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uLi8uLi9zcmMvY29tcG9uZW50cy9JbmJveE5vdGlmaWNhdGlvbi50c3g/OGM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHR5cGUge1xuICBJbmJveE5vdGlmaWNhdGlvbkN1c3RvbURhdGEsXG4gIEluYm94Tm90aWZpY2F0aW9uRGF0YSxcbiAgSW5ib3hOb3RpZmljYXRpb25UZXh0TWVudGlvbkRhdGEsXG4gIEluYm94Tm90aWZpY2F0aW9uVGhyZWFkRGF0YSxcbiAgS0RBRCxcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7IGFzc2VydE5ldmVyLCBjb25zb2xlIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7XG4gIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uLFxuICB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZCxcbiAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICB1c2VSb29tSW5mbyxcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL3JlYWN0XCI7XG5pbXBvcnQgeyBTbG90IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1zbG90XCI7XG5pbXBvcnQgeyBUb29sdGlwUHJvdmlkZXIgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXRvb2x0aXBcIjtcbmltcG9ydCB0eXBlIHtcbiAgQ29tcG9uZW50UHJvcHMsXG4gIENvbXBvbmVudFByb3BzV2l0aG91dFJlZixcbiAgQ29tcG9uZW50VHlwZSxcbiAgTW91c2VFdmVudCBhcyBSZWFjdE1vdXNlRXZlbnQsXG4gIFJlYWN0Tm9kZSxcbiAgU3ludGhldGljRXZlbnQsXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgdHlwZSB7IEdsb2JhbENvbXBvbmVudHMgfSBmcm9tIFwiLi4vY29tcG9uZW50c1wiO1xuaW1wb3J0IHsgdXNlQ29tcG9uZW50cyB9IGZyb20gXCIuLi9jb21wb25lbnRzXCI7XG5pbXBvcnQgeyBDaGVja0ljb24gfSBmcm9tIFwiLi4vaWNvbnMvQ2hlY2tcIjtcbmltcG9ydCB7IERlbGV0ZUljb24gfSBmcm9tIFwiLi4vaWNvbnMvRGVsZXRlXCI7XG5pbXBvcnQgeyBFbGxpcHNpc0ljb24gfSBmcm9tIFwiLi4vaWNvbnMvRWxsaXBzaXNcIjtcbmltcG9ydCB7IE1pc3NpbmdJY29uIH0gZnJvbSBcIi4uL2ljb25zL01pc3NpbmdcIjtcbmltcG9ydCB0eXBlIHtcbiAgQ29tbWVudE92ZXJyaWRlcyxcbiAgR2xvYmFsT3ZlcnJpZGVzLFxuICBJbmJveE5vdGlmaWNhdGlvbk92ZXJyaWRlcyxcbn0gZnJvbSBcIi4uL292ZXJyaWRlc1wiO1xuaW1wb3J0IHsgdXNlT3ZlcnJpZGVzIH0gZnJvbSBcIi4uL292ZXJyaWRlc1wiO1xuaW1wb3J0IHsgVGltZXN0YW1wIH0gZnJvbSBcIi4uL3ByaW1pdGl2ZXMvVGltZXN0YW1wXCI7XG5pbXBvcnQgeyB1c2VDdXJyZW50VXNlcklkIH0gZnJvbSBcIi4uL3NoYXJlZFwiO1xuaW1wb3J0IHR5cGUgeyBTbG90UHJvcCB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCIuLi91dGlscy9jbGFzcy1uYW1lc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVVUkwgfSBmcm9tIFwiLi4vdXRpbHMvdXJsXCI7XG5pbXBvcnQgeyBBdmF0YXIsIHR5cGUgQXZhdGFyUHJvcHMgfSBmcm9tIFwiLi9pbnRlcm5hbC9BdmF0YXJcIjtcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIuL2ludGVybmFsL0J1dHRvblwiO1xuaW1wb3J0IHsgRHJvcGRvd24sIERyb3Bkb3duSXRlbSwgRHJvcGRvd25UcmlnZ2VyIH0gZnJvbSBcIi4vaW50ZXJuYWwvRHJvcGRvd25cIjtcbmltcG9ydCB7XG4gIGdlbmVyYXRlSW5ib3hOb3RpZmljYXRpb25UaHJlYWRDb250ZW50cyxcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX1RIUkVBRF9NQVhfQ09NTUVOVFMsXG4gIEluYm94Tm90aWZpY2F0aW9uQ29tbWVudCxcbn0gZnJvbSBcIi4vaW50ZXJuYWwvSW5ib3hOb3RpZmljYXRpb25UaHJlYWRcIjtcbmltcG9ydCB7IExpc3QgfSBmcm9tIFwiLi9pbnRlcm5hbC9MaXN0XCI7XG5pbXBvcnQgeyBSb29tIH0gZnJvbSBcIi4vaW50ZXJuYWwvUm9vbVwiO1xuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gXCIuL2ludGVybmFsL1Rvb2x0aXBcIjtcbmltcG9ydCB7IFVzZXIgfSBmcm9tIFwiLi9pbnRlcm5hbC9Vc2VyXCI7XG5cbnR5cGUgQ29tcG9uZW50VHlwZVdpdGhSZWY8XG4gIFQgZXh0ZW5kcyBrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHMsXG4gIFAsXG4+ID0gQ29tcG9uZW50VHlwZTxQICYgUGljazxDb21wb25lbnRQcm9wczxUPiwgXCJyZWZcIj4+O1xuXG50eXBlIEluYm94Tm90aWZpY2F0aW9uS2luZHM8S1MgZXh0ZW5kcyBLREFEID0gS0RBRD4gPSB7XG4gIC8vIEZvciBzb21lIHJlYXNvbiwgd2UgY2Fubm90IGRpcmVjdGx5IHVzZSBLREFEIGluIHRoZSBtYXBwZWQgdHlwZSBsaW5lXG4gIC8vIGJlbG93LCBiZWNhdXNlIGl0IHdpbGwgcmVzdWx0IGluICd7fScgcmF0aGVyIHRoYW4gcGlja2luZyB1cCB0aGVcbiAgLy8gZGVmaW5pdGlvbiBmcm9tIHRoZSB1c2VyLXByb3ZpZGVkICdBY3Rpdml0aWVzRGF0YScuIE1pZ2h0IGJlIGFuIGludGVybmFsXG4gIC8vIFRTIG9wdGltaXphdGlvbiwgc28gd2UncmUgbWFraW5nIGl0IGEgcGFyYW0gdG8gZGVmZXIgdGhlIHJlc29sdXRpb24uXG4gIFtLIGluIEtTXTogQ29tcG9uZW50VHlwZVdpdGhSZWY8XCJhXCIsIEluYm94Tm90aWZpY2F0aW9uQ3VzdG9tS2luZFByb3BzPEs+Pjtcbn0gJiB7XG4gIHRocmVhZDogQ29tcG9uZW50VHlwZVdpdGhSZWY8XCJhXCIsIEluYm94Tm90aWZpY2F0aW9uVGhyZWFkS2luZFByb3BzPjtcbiAgdGV4dE1lbnRpb246IENvbXBvbmVudFR5cGVXaXRoUmVmPFwiYVwiLCBJbmJveE5vdGlmaWNhdGlvblRleHRNZW50aW9uS2luZFByb3BzPjtcbn07XG5cbmludGVyZmFjZSBJbmJveE5vdGlmaWNhdGlvblNoYXJlZFByb3BzIHtcbiAgLyoqXG4gICAqIEhvdyB0byBzaG93IG9yIGhpZGUgdGhlIGFjdGlvbnMuXG4gICAqL1xuICBzaG93QWN0aW9ucz86IGJvb2xlYW4gfCBcImhvdmVyXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5ib3hOb3RpZmljYXRpb25Qcm9wc1xuICBleHRlbmRzIE9taXQ8Q29tcG9uZW50UHJvcHNXaXRob3V0UmVmPFwiYVwiPiwgXCJ0aXRsZVwiPixcbiAgICBJbmJveE5vdGlmaWNhdGlvblNoYXJlZFByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBpbmJveCBub3RpZmljYXRpb24gdG8gZGlzcGxheS5cbiAgICovXG4gIGluYm94Tm90aWZpY2F0aW9uOiBJbmJveE5vdGlmaWNhdGlvbkRhdGE7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHNwZWNpZmljIGtpbmRzIG9mIGluYm94IG5vdGlmaWNhdGlvbnMuXG4gICAqL1xuICBraW5kcz86IFBhcnRpYWw8SW5ib3hOb3RpZmljYXRpb25LaW5kcz47XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBjb21wb25lbnQncyBzdHJpbmdzLlxuICAgKi9cbiAgb3ZlcnJpZGVzPzogUGFydGlhbDxcbiAgICBHbG9iYWxPdmVycmlkZXMgJiBJbmJveE5vdGlmaWNhdGlvbk92ZXJyaWRlcyAmIENvbW1lbnRPdmVycmlkZXNcbiAgPjtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGNvbXBvbmVudCdzIGNvbXBvbmVudHMuXG4gICAqL1xuICBjb21wb25lbnRzPzogUGFydGlhbDxHbG9iYWxDb21wb25lbnRzPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmJveE5vdGlmaWNhdGlvblRocmVhZFByb3BzXG4gIGV4dGVuZHMgT21pdDxJbmJveE5vdGlmaWNhdGlvblByb3BzLCBcImtpbmRzXCIgfCBcImNoaWxkcmVuXCI+LFxuICAgIEluYm94Tm90aWZpY2F0aW9uU2hhcmVkUHJvcHMge1xuICAvKipcbiAgICogVGhlIGluYm94IG5vdGlmaWNhdGlvbiB0byBkaXNwbGF5LlxuICAgKi9cbiAgaW5ib3hOb3RpZmljYXRpb246IEluYm94Tm90aWZpY2F0aW9uVGhyZWFkRGF0YTtcblxuICAvKipcbiAgICogV2hldGhlciB0byBzaG93IHRoZSByb29tIG5hbWUgaW4gdGhlIHRpdGxlLlxuICAgKi9cbiAgc2hvd1Jvb21OYW1lPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmJveE5vdGlmaWNhdGlvblRleHRNZW50aW9uUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PEluYm94Tm90aWZpY2F0aW9uUHJvcHMsIFwia2luZHNcIj4sXG4gICAgSW5ib3hOb3RpZmljYXRpb25TaGFyZWRQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgaW5ib3ggbm90aWZpY2F0aW9uIHRvIGRpc3BsYXkuXG4gICAqL1xuICBpbmJveE5vdGlmaWNhdGlvbjogSW5ib3hOb3RpZmljYXRpb25UZXh0TWVudGlvbkRhdGE7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2hvdyB0aGUgcm9vbSBuYW1lIGluIHRoZSB0aXRsZS5cbiAgICovXG4gIHNob3dSb29tTmFtZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5ib3hOb3RpZmljYXRpb25DdXN0b21Qcm9wc1xuICBleHRlbmRzIE9taXQ8SW5ib3hOb3RpZmljYXRpb25Qcm9wcywgXCJraW5kc1wiPixcbiAgICBJbmJveE5vdGlmaWNhdGlvblNoYXJlZFByb3BzLFxuICAgIFNsb3RQcm9wIHtcbiAgLyoqXG4gICAqIFRoZSBpbmJveCBub3RpZmljYXRpb24gdG8gZGlzcGxheS5cbiAgICovXG4gIGluYm94Tm90aWZpY2F0aW9uOiBJbmJveE5vdGlmaWNhdGlvbkN1c3RvbURhdGE7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmJveCBub3RpZmljYXRpb24ncyBjb250ZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFJlYWN0Tm9kZTtcblxuICAvKipcbiAgICogVGhlIGluYm94IG5vdGlmaWNhdGlvbidzIHRpdGxlLlxuICAgKi9cbiAgdGl0bGU6IFJlYWN0Tm9kZTtcblxuICAvKipcbiAgICogVGhlIGluYm94IG5vdGlmaWNhdGlvbidzIGFzaWRlIGNvbnRlbnQuXG4gICAqIENhbiBiZSBjb21iaW5lZCB3aXRoIGBJbmJveE5vdGlmaWNhdGlvbi5JY29uYCBvciBgSW5ib3hOb3RpZmljYXRpb24uQXZhdGFyYCB0byBlYXNpbHkgZm9sbG93IGRlZmF1bHQgc3R5bGVzLlxuICAgKi9cbiAgYXNpZGU/OiBSZWFjdE5vZGU7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gbWFyayB0aGUgaW5ib3ggbm90aWZpY2F0aW9uIGFzIHJlYWQgd2hlbiBjbGlja2VkLlxuICAgKi9cbiAgbWFya0FzUmVhZE9uQ2xpY2s/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBJbmJveE5vdGlmaWNhdGlvblRocmVhZEtpbmRQcm9wcyA9IE9taXQ8XG4gIEluYm94Tm90aWZpY2F0aW9uUHJvcHMsXG4gIFwia2luZHNcIlxuPiAmIHtcbiAgaW5ib3hOb3RpZmljYXRpb246IEluYm94Tm90aWZpY2F0aW9uVGhyZWFkRGF0YTtcbn07XG5cbmV4cG9ydCB0eXBlIEluYm94Tm90aWZpY2F0aW9uVGV4dE1lbnRpb25LaW5kUHJvcHMgPSBPbWl0PFxuICBJbmJveE5vdGlmaWNhdGlvblByb3BzLFxuICBcImtpbmRzXCJcbj4gJiB7XG4gIGluYm94Tm90aWZpY2F0aW9uOiBJbmJveE5vdGlmaWNhdGlvblRleHRNZW50aW9uRGF0YTtcbn07XG5cbmV4cG9ydCB0eXBlIEluYm94Tm90aWZpY2F0aW9uQ3VzdG9tS2luZFByb3BzPEsgZXh0ZW5kcyBLREFEID0gS0RBRD4gPSBPbWl0PFxuICBJbmJveE5vdGlmaWNhdGlvblByb3BzLFxuICBcImtpbmRzXCJcbj4gJiB7XG4gIGluYm94Tm90aWZpY2F0aW9uOiBJbmJveE5vdGlmaWNhdGlvbkN1c3RvbURhdGE8Sz47XG59O1xuXG5pbnRlcmZhY2UgSW5ib3hOb3RpZmljYXRpb25MYXlvdXRQcm9wc1xuICBleHRlbmRzIE9taXQ8Q29tcG9uZW50UHJvcHNXaXRob3V0UmVmPFwiYVwiPiwgXCJ0aXRsZVwiPixcbiAgICBJbmJveE5vdGlmaWNhdGlvblNoYXJlZFByb3BzLFxuICAgIFNsb3RQcm9wIHtcbiAgaW5ib3hOb3RpZmljYXRpb246IEluYm94Tm90aWZpY2F0aW9uRGF0YTtcbiAgYXNpZGU6IFJlYWN0Tm9kZTtcbiAgdGl0bGU6IFJlYWN0Tm9kZTtcbiAgZGF0ZTogRGF0ZSB8IHN0cmluZyB8IG51bWJlcjtcbiAgdW5yZWFkPzogYm9vbGVhbjtcbiAgb3ZlcnJpZGVzPzogUGFydGlhbDxHbG9iYWxPdmVycmlkZXMgJiBJbmJveE5vdGlmaWNhdGlvbk92ZXJyaWRlcz47XG4gIGNvbXBvbmVudHM/OiBQYXJ0aWFsPEdsb2JhbENvbXBvbmVudHM+O1xuICBtYXJrQXNSZWFkT25DbGljaz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIEluYm94Tm90aWZpY2F0aW9uSWNvblByb3BzID0gQ29tcG9uZW50UHJvcHM8XCJkaXZcIj47XG5cbmV4cG9ydCB0eXBlIEluYm94Tm90aWZpY2F0aW9uQXZhdGFyUHJvcHMgPSBBdmF0YXJQcm9wcztcblxuY29uc3QgSW5ib3hOb3RpZmljYXRpb25MYXlvdXQgPSBmb3J3YXJkUmVmPFxuICBIVE1MQW5jaG9yRWxlbWVudCxcbiAgSW5ib3hOb3RpZmljYXRpb25MYXlvdXRQcm9wc1xuPihcbiAgKFxuICAgIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBhc2lkZSxcbiAgICAgIHRpdGxlLFxuICAgICAgZGF0ZSxcbiAgICAgIHVucmVhZCxcbiAgICAgIG1hcmtBc1JlYWRPbkNsaWNrLFxuICAgICAgb25DbGljayxcbiAgICAgIGhyZWYsXG4gICAgICBzaG93QWN0aW9ucyxcbiAgICAgIG92ZXJyaWRlcyxcbiAgICAgIGNvbXBvbmVudHMsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBhc0NoaWxkLFxuICAgICAgLi4ucHJvcHNcbiAgICB9LFxuICAgIGZvcndhcmRlZFJlZlxuICApID0+IHtcbiAgICBjb25zdCAkID0gdXNlT3ZlcnJpZGVzKG92ZXJyaWRlcyk7XG4gICAgY29uc3QgeyBBbmNob3IgfSA9IHVzZUNvbXBvbmVudHMoY29tcG9uZW50cyk7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gYXNDaGlsZCA/IFNsb3QgOiBBbmNob3I7XG4gICAgY29uc3QgW2lzTW9yZUFjdGlvbk9wZW4sIHNldE1vcmVBY3Rpb25PcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQgPSB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoKTtcbiAgICBjb25zdCBkZWxldGVJbmJveE5vdGlmaWNhdGlvbiA9IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uKCk7XG5cbiAgICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGV2ZW50OiBSZWFjdE1vdXNlRXZlbnQ8SFRNTEFuY2hvckVsZW1lbnQsIE1vdXNlRXZlbnQ+KSA9PiB7XG4gICAgICAgIG9uQ2xpY2s/LihldmVudCk7XG5cbiAgICAgICAgY29uc3Qgc2hvdWxkTWFya0FzUmVhZE9uQ2xpY2sgPSBtYXJrQXNSZWFkT25DbGljayA/PyBCb29sZWFuKGhyZWYpO1xuXG4gICAgICAgIGlmICh1bnJlYWQgJiYgc2hvdWxkTWFya0FzUmVhZE9uQ2xpY2spIHtcbiAgICAgICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb24uaWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBocmVmLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbi5pZCxcbiAgICAgICAgbWFya0FzUmVhZE9uQ2xpY2ssXG4gICAgICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICAgICAgb25DbGljayxcbiAgICAgICAgdW5yZWFkLFxuICAgICAgXVxuICAgICk7XG5cbiAgICBjb25zdCBzdG9wUHJvcGFnYXRpb24gPSB1c2VDYWxsYmFjaygoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50KSA9PiB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBwcmV2ZW50RGVmYXVsdEFuZFN0b3BQcm9wYWdhdGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGV2ZW50OiBTeW50aGV0aWNFdmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sXG4gICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCBoYW5kbGVNb3JlQ2xpY2sgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IFJlYWN0TW91c2VFdmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgc2V0TW9yZUFjdGlvbk9wZW4oKG9wZW4pID0+ICFvcGVuKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBoYW5kbGVNYXJrQXNSZWFkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uLmlkKTtcbiAgICB9LCBbaW5ib3hOb3RpZmljYXRpb24uaWQsIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZF0pO1xuXG4gICAgY29uc3QgaGFuZGxlRGVsZXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb24uaWQpO1xuICAgIH0sIFtpbmJveE5vdGlmaWNhdGlvbi5pZCwgZGVsZXRlSW5ib3hOb3RpZmljYXRpb25dKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8VG9vbHRpcFByb3ZpZGVyPlxuICAgICAgICA8Q29tcG9uZW50XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgXCJsYi1yb290IGxiLWluYm94LW5vdGlmaWNhdGlvblwiLFxuICAgICAgICAgICAgc2hvd0FjdGlvbnMgPT09IFwiaG92ZXJcIiAmJlxuICAgICAgICAgICAgICBcImxiLWluYm94LW5vdGlmaWNhdGlvbjpzaG93LWFjdGlvbnMtaG92ZXJcIixcbiAgICAgICAgICAgIGlzTW9yZUFjdGlvbk9wZW4gJiYgXCJsYi1pbmJveC1ub3RpZmljYXRpb246YWN0aW9uLW9wZW5cIixcbiAgICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICAgICl9XG4gICAgICAgICAgZGlyPXskLmRpcn1cbiAgICAgICAgICBkYXRhLXVucmVhZD17dW5yZWFkID8gXCJcIiA6IHVuZGVmaW5lZH1cbiAgICAgICAgICBkYXRhLWtpbmQ9e2luYm94Tm90aWZpY2F0aW9uLmtpbmR9XG4gICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgICAgaHJlZj17aHJlZn1cbiAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICAgID5cbiAgICAgICAgICB7YXNpZGUgJiYgPGRpdiBjbGFzc05hbWU9XCJsYi1pbmJveC1ub3RpZmljYXRpb24tYXNpZGVcIj57YXNpZGV9PC9kaXY+fVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGItaW5ib3gtbm90aWZpY2F0aW9uLWNvbnRlbnRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGItaW5ib3gtbm90aWZpY2F0aW9uLWhlYWRlclwiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJsYi1pbmJveC1ub3RpZmljYXRpb24tdGl0bGVcIj57dGl0bGV9PC9zcGFuPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxiLWluYm94LW5vdGlmaWNhdGlvbi1kZXRhaWxzXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibGItaW5ib3gtbm90aWZpY2F0aW9uLWRldGFpbHMtbGFiZWxzXCI+XG4gICAgICAgICAgICAgICAgICA8VGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZT17JC5sb2NhbGV9XG4gICAgICAgICAgICAgICAgICAgIGRhdGU9e2RhdGV9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxiLWluYm94LW5vdGlmaWNhdGlvbi1kYXRlXCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICB7dW5yZWFkICYmIChcbiAgICAgICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsYi1pbmJveC1ub3RpZmljYXRpb24tdW5yZWFkLWluZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHtzaG93QWN0aW9ucyAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsYi1pbmJveC1ub3RpZmljYXRpb24tYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgPERyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e2lzTW9yZUFjdGlvbk9wZW59XG4gICAgICAgICAgICAgICAgICAgIG9uT3BlbkNoYW5nZT17c2V0TW9yZUFjdGlvbk9wZW59XG4gICAgICAgICAgICAgICAgICAgIGFsaWduPVwiZW5kXCJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudD17XG4gICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt1bnJlYWQgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxEcm9wZG93bkl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD17aGFuZGxlTWFya0FzUmVhZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtzdG9wUHJvcGFnYXRpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tJY29uIGNsYXNzTmFtZT1cImxiLWRyb3Bkb3duLWl0ZW0taWNvblwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyQuSU5CT1hfTk9USUZJQ0FUSU9OX01BUktfQVNfUkVBRH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9Ecm9wZG93bkl0ZW0+XG4gICAgICAgICAgICAgICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxEcm9wZG93bkl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q9e2hhbmRsZURlbGV0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17c3RvcFByb3BhZ2F0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8RGVsZXRlSWNvbiBjbGFzc05hbWU9XCJsYi1kcm9wZG93bi1pdGVtLWljb25cIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICB7JC5JTkJPWF9OT1RJRklDQVRJT05fREVMRVRFfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Ecm9wZG93bkl0ZW0+XG4gICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPFRvb2x0aXAgY29udGVudD17JC5JTkJPWF9OT1RJRklDQVRJT05fTU9SRX0+XG4gICAgICAgICAgICAgICAgICAgICAgPERyb3Bkb3duVHJpZ2dlciBhc0NoaWxkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsYi1pbmJveC1ub3RpZmljYXRpb24tYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlTW9yZUNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvblBvaW50ZXJEb3duPXtwcmV2ZW50RGVmYXVsdEFuZFN0b3BQcm9wYWdhdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qb2ludGVyVXA9e3ByZXZlbnREZWZhdWx0QW5kU3RvcFByb3BhZ2F0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXskLklOQk9YX05PVElGSUNBVElPTl9NT1JFfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8RWxsaXBzaXNJY29uIGNsYXNzTmFtZT1cImxiLWJ1dHRvbi1pY29uXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgIDwvRHJvcGRvd25UcmlnZ2VyPlxuICAgICAgICAgICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgICAgICAgICA8L0Ryb3Bkb3duPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxiLWluYm94LW5vdGlmaWNhdGlvbi1ib2R5XCI+e2NoaWxkcmVufTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0NvbXBvbmVudD5cbiAgICAgIDwvVG9vbHRpcFByb3ZpZGVyPlxuICAgICk7XG4gIH1cbik7XG5cbmZ1bmN0aW9uIEluYm94Tm90aWZpY2F0aW9uSWNvbih7XG4gIGNsYXNzTmFtZSxcbiAgLi4ucHJvcHNcbn06IEluYm94Tm90aWZpY2F0aW9uSWNvblByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwibGItaW5ib3gtbm90aWZpY2F0aW9uLWljb25cIiwgY2xhc3NOYW1lKX1cbiAgICAgIHsuLi5wcm9wc31cbiAgICAvPlxuICApO1xufVxuXG5mdW5jdGlvbiBJbmJveE5vdGlmaWNhdGlvbkF2YXRhcih7XG4gIGNsYXNzTmFtZSxcbiAgLi4ucHJvcHNcbn06IEluYm94Tm90aWZpY2F0aW9uQXZhdGFyUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8QXZhdGFyXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJsYi1pbmJveC1ub3RpZmljYXRpb24tYXZhdGFyXCIsIGNsYXNzTmFtZSl9XG4gICAgICB7Li4ucHJvcHN9XG4gICAgLz5cbiAgKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5cyBhIHRocmVhZCBpbmJveCBub3RpZmljYXRpb24uXG4gKi9cbmNvbnN0IEluYm94Tm90aWZpY2F0aW9uVGhyZWFkID0gZm9yd2FyZFJlZjxcbiAgSFRNTEFuY2hvckVsZW1lbnQsXG4gIEluYm94Tm90aWZpY2F0aW9uVGhyZWFkUHJvcHNcbj4oXG4gIChcbiAgICB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbixcbiAgICAgIGhyZWYsXG4gICAgICBzaG93Um9vbU5hbWUgPSB0cnVlLFxuICAgICAgc2hvd0FjdGlvbnMgPSBcImhvdmVyXCIsXG4gICAgICBvdmVycmlkZXMsXG4gICAgICAuLi5wcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGNvbnN0ICQgPSB1c2VPdmVycmlkZXMob3ZlcnJpZGVzKTtcbiAgICBjb25zdCB0aHJlYWQgPSB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZChpbmJveE5vdGlmaWNhdGlvbi5pZCk7XG4gICAgY29uc3QgY3VycmVudFVzZXJJZCA9IHVzZUN1cnJlbnRVc2VySWQoKTtcbiAgICAvLyBUT0RPOiBJZiB5b3UgcHJvdmlkZSBgaHJlZmAgKG9yIHBsYW4gdG8pLCB3ZSBzaG91bGRuJ3QgcnVuIHRoaXMgaG9vay4gV2Ugc2hvdWxkIGZpbmQgYSB3YXkgdG8gY29uZGl0aW9uYWxseSBydW4gaXQuXG4gICAgLy8gICAgICAgQmVjYXVzZSBvZiBiYXRjaGluZyBhbmQgdGhlIGZhY3QgdGhhdCB0aGUgc2FtZSBob29rIHdpbGwgYmUgY2FsbGVkIHdpdGhpbiA8Um9vbSAvPiBpbiB0aGUgbm90aWZpY2F0aW9uJ3MgdGl0bGUsXG4gICAgLy8gICAgICAgaXQncyBub3QgYSBiaWcgZGVhbCwgdGhlIG9ubHkgc2NlbmFyaW8gd2hlcmUgaXQgd291bGQgYmUgc3VwZXJmbHVvdXMgd291bGQgYmUgaWYgdGhlIHVzZXIgcHJvdmlkZXMgdGhlaXIgb3duXG4gICAgLy8gICAgICAgYGhyZWZgIEFORCBkaXNhYmxlcyByb29tIG5hbWVzIGluIHRoZSB0aXRsZSB2aWEgYHNob3dSb29tTmFtZT17ZmFsc2V9YC5cbiAgICBjb25zdCB7IGluZm8gfSA9IHVzZVJvb21JbmZvKGluYm94Tm90aWZpY2F0aW9uLnJvb21JZCk7XG4gICAgY29uc3QgeyB1bnJlYWQsIGRhdGUsIGFzaWRlLCB0aXRsZSwgY29udGVudCwgY29tbWVudElkIH0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gZ2VuZXJhdGVJbmJveE5vdGlmaWNhdGlvblRocmVhZENvbnRlbnRzKFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgdGhyZWFkLFxuICAgICAgICBjdXJyZW50VXNlcklkID8/IFwiXCJcbiAgICAgICk7XG5cbiAgICAgIHN3aXRjaCAoY29udGVudHMudHlwZSkge1xuICAgICAgICBjYXNlIFwiY29tbWVudHNcIjoge1xuICAgICAgICAgIGNvbnN0IHJldmVyc2VkVXNlcklkcyA9IFsuLi5jb250ZW50cy51c2VySWRzXS5yZXZlcnNlKCk7XG4gICAgICAgICAgY29uc3QgZmlyc3RVc2VySWQgPSByZXZlcnNlZFVzZXJJZHNbMF07XG5cbiAgICAgICAgICBjb25zdCBhc2lkZSA9IDxJbmJveE5vdGlmaWNhdGlvbkF2YXRhciB1c2VySWQ9e2ZpcnN0VXNlcklkfSAvPjtcbiAgICAgICAgICBjb25zdCB0aXRsZSA9ICQuSU5CT1hfTk9USUZJQ0FUSU9OX1RIUkVBRF9DT01NRU5UU19MSVNUKFxuICAgICAgICAgICAgPExpc3RcbiAgICAgICAgICAgICAgdmFsdWVzPXtyZXZlcnNlZFVzZXJJZHMubWFwKCh1c2VySWQsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgPFVzZXJcbiAgICAgICAgICAgICAgICAgIGtleT17dXNlcklkfVxuICAgICAgICAgICAgICAgICAgdXNlcklkPXt1c2VySWR9XG4gICAgICAgICAgICAgICAgICBjYXBpdGFsaXplPXtpbmRleCA9PT0gMH1cbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VTZWxmXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgIGZvcm1hdFJlbWFpbmluZz17JC5MSVNUX1JFTUFJTklOR19VU0VSU31cbiAgICAgICAgICAgICAgdHJ1bmNhdGU9e0lOQk9YX05PVElGSUNBVElPTl9USFJFQURfTUFYX0NPTU1FTlRTIC0gMX1cbiAgICAgICAgICAgIC8+LFxuICAgICAgICAgICAgc2hvd1Jvb21OYW1lID8gPFJvb20gcm9vbUlkPXt0aHJlYWQucm9vbUlkfSAvPiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJldmVyc2VkVXNlcklkcy5sZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxiLWluYm94LW5vdGlmaWNhdGlvbi1jb21tZW50c1wiPlxuICAgICAgICAgICAgICB7Y29udGVudHMuY29tbWVudHMubWFwKChjb21tZW50KSA9PiAoXG4gICAgICAgICAgICAgICAgPEluYm94Tm90aWZpY2F0aW9uQ29tbWVudFxuICAgICAgICAgICAgICAgICAga2V5PXtjb21tZW50LmlkfVxuICAgICAgICAgICAgICAgICAgY29tbWVudD17Y29tbWVudH1cbiAgICAgICAgICAgICAgICAgIHNob3dIZWFkZXI9e2NvbnRlbnRzLmNvbW1lbnRzLmxlbmd0aCA+IDF9XG4gICAgICAgICAgICAgICAgICBvdmVycmlkZXM9e292ZXJyaWRlc31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5yZWFkOiBjb250ZW50cy51bnJlYWQsXG4gICAgICAgICAgICBkYXRlOiBjb250ZW50cy5kYXRlLFxuICAgICAgICAgICAgYXNpZGUsXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICB0aHJlYWRJZDogdGhyZWFkLmlkLFxuICAgICAgICAgICAgY29tbWVudElkOiBjb250ZW50cy5jb21tZW50c1tjb250ZW50cy5jb21tZW50cy5sZW5ndGggLSAxXS5pZCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBcIm1lbnRpb25cIjoge1xuICAgICAgICAgIGNvbnN0IG1lbnRpb25Vc2VySWQgPSBjb250ZW50cy51c2VySWRzWzBdO1xuICAgICAgICAgIGNvbnN0IG1lbnRpb25Db21tZW50ID0gY29udGVudHMuY29tbWVudHNbMF07XG5cbiAgICAgICAgICBjb25zdCBhc2lkZSA9IDxJbmJveE5vdGlmaWNhdGlvbkF2YXRhciB1c2VySWQ9e21lbnRpb25Vc2VySWR9IC8+O1xuICAgICAgICAgIGNvbnN0IHRpdGxlID0gJC5JTkJPWF9OT1RJRklDQVRJT05fVEhSRUFEX01FTlRJT04oXG4gICAgICAgICAgICA8VXNlciBrZXk9e21lbnRpb25Vc2VySWR9IHVzZXJJZD17bWVudGlvblVzZXJJZH0gY2FwaXRhbGl6ZSAvPixcbiAgICAgICAgICAgIHNob3dSb29tTmFtZSA/IDxSb29tIHJvb21JZD17dGhyZWFkLnJvb21JZH0gLz4gOiB1bmRlZmluZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxiLWluYm94LW5vdGlmaWNhdGlvbi1jb21tZW50c1wiPlxuICAgICAgICAgICAgICA8SW5ib3hOb3RpZmljYXRpb25Db21tZW50XG4gICAgICAgICAgICAgICAga2V5PXttZW50aW9uQ29tbWVudC5pZH1cbiAgICAgICAgICAgICAgICBjb21tZW50PXttZW50aW9uQ29tbWVudH1cbiAgICAgICAgICAgICAgICBzaG93SGVhZGVyPXtmYWxzZX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5yZWFkOiBjb250ZW50cy51bnJlYWQsXG4gICAgICAgICAgICBkYXRlOiBjb250ZW50cy5kYXRlLFxuICAgICAgICAgICAgYXNpZGUsXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICB0aHJlYWRJZDogdGhyZWFkLmlkLFxuICAgICAgICAgICAgY29tbWVudElkOiBtZW50aW9uQ29tbWVudC5pZCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoXG4gICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCB0aHJlYWQgaW5ib3ggbm90aWZpY2F0aW9uIHR5cGVcIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgWyQsIGN1cnJlbnRVc2VySWQsIGluYm94Tm90aWZpY2F0aW9uLCBvdmVycmlkZXMsIHNob3dSb29tTmFtZSwgdGhyZWFkXSk7XG4gICAgLy8gQWRkIHRoZSB0aHJlYWQgSUQgYW5kIGNvbW1lbnQgSUQgdG8gdGhlIGBocmVmYC5cbiAgICAvLyBBbmQgdXNlIFVSTCBmcm9tIGByZXNvbHZlUm9vbXNJbmZvYCBpZiBgaHJlZmAgaXNuJ3Qgc2V0LlxuICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gaHJlZiA/PyBpbmZvPy51cmw7XG5cbiAgICAgIHJldHVybiByZXNvbHZlZEhyZWZcbiAgICAgICAgPyBnZW5lcmF0ZVVSTChyZXNvbHZlZEhyZWYsIHVuZGVmaW5lZCwgY29tbWVudElkKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9LCBbY29tbWVudElkLCBocmVmLCBpbmZvPy51cmxdKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8SW5ib3hOb3RpZmljYXRpb25MYXlvdXRcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb249e2luYm94Tm90aWZpY2F0aW9ufVxuICAgICAgICBhc2lkZT17YXNpZGV9XG4gICAgICAgIHRpdGxlPXt0aXRsZX1cbiAgICAgICAgZGF0ZT17ZGF0ZX1cbiAgICAgICAgdW5yZWFkPXt1bnJlYWR9XG4gICAgICAgIG92ZXJyaWRlcz17b3ZlcnJpZGVzfVxuICAgICAgICBocmVmPXtyZXNvbHZlZEhyZWZ9XG4gICAgICAgIHNob3dBY3Rpb25zPXtzaG93QWN0aW9uc31cbiAgICAgICAgbWFya0FzUmVhZE9uQ2xpY2s9e2ZhbHNlfVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgPlxuICAgICAgICB7Y29udGVudH1cbiAgICAgIDwvSW5ib3hOb3RpZmljYXRpb25MYXlvdXQ+XG4gICAgKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBEaXNwbGF5cyBhIHRleHQgbWVudGlvbiBub3RpZmljYXRpb24ga2luZC5cbiAqL1xuY29uc3QgSW5ib3hOb3RpZmljYXRpb25UZXh0TWVudGlvbiA9IGZvcndhcmRSZWY8XG4gIEhUTUxBbmNob3JFbGVtZW50LFxuICBJbmJveE5vdGlmaWNhdGlvblRleHRNZW50aW9uUHJvcHNcbj4oXG4gIChcbiAgICB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbixcbiAgICAgIHNob3dBY3Rpb25zID0gXCJob3ZlclwiLFxuICAgICAgc2hvd1Jvb21OYW1lID0gdHJ1ZSxcbiAgICAgIG92ZXJyaWRlcyxcbiAgICAgIC4uLnByb3BzXG4gICAgfSxcbiAgICByZWZcbiAgKSA9PiB7XG4gICAgY29uc3QgJCA9IHVzZU92ZXJyaWRlcyhvdmVycmlkZXMpO1xuXG4gICAgY29uc3QgdW5yZWFkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAhaW5ib3hOb3RpZmljYXRpb24ucmVhZEF0IHx8XG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uLm5vdGlmaWVkQXQgPiBpbmJveE5vdGlmaWNhdGlvbi5yZWFkQXRcbiAgICAgICk7XG4gICAgfSwgW2luYm94Tm90aWZpY2F0aW9uLm5vdGlmaWVkQXQsIGluYm94Tm90aWZpY2F0aW9uLnJlYWRBdF0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxJbmJveE5vdGlmaWNhdGlvbkxheW91dFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbj17aW5ib3hOb3RpZmljYXRpb259XG4gICAgICAgIGFzaWRlPXs8SW5ib3hOb3RpZmljYXRpb25BdmF0YXIgdXNlcklkPXtpbmJveE5vdGlmaWNhdGlvbi5jcmVhdGVkQnl9IC8+fVxuICAgICAgICB0aXRsZT17JC5JTkJPWF9OT1RJRklDQVRJT05fVEVYVF9NRU5USU9OKFxuICAgICAgICAgIDxVc2VyXG4gICAgICAgICAgICBrZXk9e2luYm94Tm90aWZpY2F0aW9uLmNyZWF0ZWRCeX1cbiAgICAgICAgICAgIHVzZXJJZD17aW5ib3hOb3RpZmljYXRpb24uY3JlYXRlZEJ5fVxuICAgICAgICAgICAgY2FwaXRhbGl6ZVxuICAgICAgICAgIC8+LFxuICAgICAgICAgIHNob3dSb29tTmFtZSA/IDxSb29tIHJvb21JZD17aW5ib3hOb3RpZmljYXRpb24ucm9vbUlkfSAvPiA6IHVuZGVmaW5lZFxuICAgICAgICApfVxuICAgICAgICBkYXRlPXtpbmJveE5vdGlmaWNhdGlvbi5ub3RpZmllZEF0fVxuICAgICAgICB1bnJlYWQ9e3VucmVhZH1cbiAgICAgICAgb3ZlcnJpZGVzPXtvdmVycmlkZXN9XG4gICAgICAgIHNob3dBY3Rpb25zPXtzaG93QWN0aW9uc31cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBEaXNwbGF5cyBhIGN1c3RvbSBub3RpZmljYXRpb24ga2luZC5cbiAqL1xuY29uc3QgSW5ib3hOb3RpZmljYXRpb25DdXN0b20gPSBmb3J3YXJkUmVmPFxuICBIVE1MQW5jaG9yRWxlbWVudCxcbiAgSW5ib3hOb3RpZmljYXRpb25DdXN0b21Qcm9wc1xuPihcbiAgKFxuICAgIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uLFxuICAgICAgc2hvd0FjdGlvbnMgPSBcImhvdmVyXCIsXG4gICAgICB0aXRsZSxcbiAgICAgIGFzaWRlLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBvdmVycmlkZXMsXG4gICAgICAuLi5wcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGNvbnN0IHVucmVhZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgIWluYm94Tm90aWZpY2F0aW9uLnJlYWRBdCB8fFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbi5ub3RpZmllZEF0ID4gaW5ib3hOb3RpZmljYXRpb24ucmVhZEF0XG4gICAgICApO1xuICAgIH0sIFtpbmJveE5vdGlmaWNhdGlvbi5ub3RpZmllZEF0LCBpbmJveE5vdGlmaWNhdGlvbi5yZWFkQXRdKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8SW5ib3hOb3RpZmljYXRpb25MYXlvdXRcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb249e2luYm94Tm90aWZpY2F0aW9ufVxuICAgICAgICBhc2lkZT17YXNpZGV9XG4gICAgICAgIHRpdGxlPXt0aXRsZX1cbiAgICAgICAgZGF0ZT17aW5ib3hOb3RpZmljYXRpb24ubm90aWZpZWRBdH1cbiAgICAgICAgdW5yZWFkPXt1bnJlYWR9XG4gICAgICAgIG92ZXJyaWRlcz17b3ZlcnJpZGVzfVxuICAgICAgICBzaG93QWN0aW9ucz17c2hvd0FjdGlvbnN9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvSW5ib3hOb3RpZmljYXRpb25MYXlvdXQ+XG4gICAgKTtcbiAgfVxuKTtcblxuY29uc3QgSW5ib3hOb3RpZmljYXRpb25DdXN0b21NaXNzaW5nID0gZm9yd2FyZFJlZjxcbiAgSFRNTEFuY2hvckVsZW1lbnQsXG4gIE9taXQ8SW5ib3hOb3RpZmljYXRpb25DdXN0b21Qcm9wcywgXCJjaGlsZHJlblwiIHwgXCJ0aXRsZVwiIHwgXCJhc2lkZVwiPlxuPigoeyBpbmJveE5vdGlmaWNhdGlvbiwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPEluYm94Tm90aWZpY2F0aW9uQ3VzdG9tXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbj17aW5ib3hOb3RpZmljYXRpb259XG4gICAgICB7Li4ucHJvcHN9XG4gICAgICB0aXRsZT17XG4gICAgICAgIDw+XG4gICAgICAgICAgQ3VzdG9tIG5vdGlmaWNhdGlvbiBraW5kIDxjb2RlPntpbmJveE5vdGlmaWNhdGlvbi5raW5kfTwvY29kZT4gaXMgbm90XG4gICAgICAgICAgaGFuZGxlZFxuICAgICAgICA8Lz5cbiAgICAgIH1cbiAgICAgIGFzaWRlPXtcbiAgICAgICAgPEluYm94Tm90aWZpY2F0aW9uSWNvbj5cbiAgICAgICAgICA8TWlzc2luZ0ljb24gLz5cbiAgICAgICAgPC9JbmJveE5vdGlmaWNhdGlvbkljb24+XG4gICAgICB9XG4gICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgIGRhdGEtbWlzc2luZz1cIlwiXG4gICAgPlxuICAgICAgey8qIFRPRE86IEFkZCBsaW5rIHRvIHRoZSBkb2NzICovfVxuICAgICAgTm90aWZpY2F0aW9ucyBvZiB0aGlzIGtpbmQgd29u4oCZdCBiZSBkaXNwbGF5ZWQgaW4gcHJvZHVjdGlvbi4gVXNlIHRoZXtcIiBcIn1cbiAgICAgIDxjb2RlPmtpbmRzPC9jb2RlPiBwcm9wIHRvIGRlZmluZSBob3cgdGhleSBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgPC9JbmJveE5vdGlmaWNhdGlvbkN1c3RvbT5cbiAgKTtcbn0pO1xuXG4vLyBLZWVwcyB0cmFjayBvZiB3aGljaCBpbmJveCBub3RpZmljYXRpb24ga2luZHMgaXQgaGFzIHdhcm5lZCBhYm91dCBhbHJlYWR5LlxuY29uc3QgaW5ib3hOb3RpZmljYXRpb25LaW5kc1dhcm5pbmdzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBEaXNwbGF5cyBhIHNpbmdsZSBpbmJveCBub3RpZmljYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIDw+XG4gKiAgIHtpbmJveE5vdGlmaWNhdGlvbnMubWFwKChpbmJveE5vdGlmaWNhdGlvbikgPT4gKFxuICogICAgIDxJbmJveE5vdGlmaWNhdGlvblxuICogICAgICAga2V5PXtpbmJveE5vdGlmaWNhdGlvbi5pZH1cbiAqICAgICAgIGluYm94Tm90aWZpY2F0aW9uPXtpbmJveE5vdGlmaWNhdGlvbn1cbiAqICAgICAgIGhyZWY9e2Avcm9vbXMvJHtpbmJveE5vdGlmaWNhdGlvbi5yb29tSWR9YFxuICogICAgIC8+XG4gKiAgICkpfVxuICogPC8+XG4gKi9cbmV4cG9ydCBjb25zdCBJbmJveE5vdGlmaWNhdGlvbiA9IE9iamVjdC5hc3NpZ24oXG4gIGZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIEluYm94Tm90aWZpY2F0aW9uUHJvcHM+KFxuICAgICh7IGluYm94Tm90aWZpY2F0aW9uLCBraW5kcywgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgICBzd2l0Y2ggKGluYm94Tm90aWZpY2F0aW9uLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcInRocmVhZFwiOiB7XG4gICAgICAgICAgY29uc3QgUmVzb2x2ZWRJbmJveE5vdGlmaWNhdGlvblRocmVhZCA9XG4gICAgICAgICAgICBraW5kcz8udGhyZWFkID8/IEluYm94Tm90aWZpY2F0aW9uVGhyZWFkO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxSZXNvbHZlZEluYm94Tm90aWZpY2F0aW9uVGhyZWFkXG4gICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uPXtpbmJveE5vdGlmaWNhdGlvbn1cbiAgICAgICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgXCJ0ZXh0TWVudGlvblwiOiB7XG4gICAgICAgICAgY29uc3QgUmVzb2x2ZWRJbmJveE5vdGlmaWNhdGlvblRleHRNZW50aW9uID1cbiAgICAgICAgICAgIGtpbmRzPy50ZXh0TWVudGlvbiA/PyBJbmJveE5vdGlmaWNhdGlvblRleHRNZW50aW9uO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxSZXNvbHZlZEluYm94Tm90aWZpY2F0aW9uVGV4dE1lbnRpb25cbiAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb249e2luYm94Tm90aWZpY2F0aW9ufVxuICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IFJlc29sdmVkSW5ib3hOb3RpZmljYXRpb25DdXN0b20gPVxuICAgICAgICAgICAga2luZHM/LltpbmJveE5vdGlmaWNhdGlvbi5raW5kXTtcblxuICAgICAgICAgIGlmICghUmVzb2x2ZWRJbmJveE5vdGlmaWNhdGlvbkN1c3RvbSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICBpZiAoIWluYm94Tm90aWZpY2F0aW9uS2luZHNXYXJuaW5ncy5oYXMoaW5ib3hOb3RpZmljYXRpb24ua2luZCkpIHtcbiAgICAgICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbktpbmRzV2FybmluZ3MuYWRkKGluYm94Tm90aWZpY2F0aW9uLmtpbmQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFkZCBsaW5rIHRvIHRoZSBkb2NzXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgYEN1c3RvbSBub3RpZmljYXRpb24ga2luZCBcIiR7aW5ib3hOb3RpZmljYXRpb24ua2luZH1cIiBpcyBub3QgaGFuZGxlZCBzbyBub3RpZmljYXRpb25zIG9mIHRoaXMga2luZCB3aWxsIG5vdCBiZSBkaXNwbGF5ZWQgaW4gcHJvZHVjdGlvbi4gVXNlIHRoZSBraW5kcyBwcm9wIHRvIGRlZmluZSBob3cgdGhleSBzaG91bGQgYmUgcmVuZGVyZWQuYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxJbmJveE5vdGlmaWNhdGlvbkN1c3RvbU1pc3NpbmdcbiAgICAgICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uPXtpbmJveE5vdGlmaWNhdGlvbn1cbiAgICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgICAgICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBEb24ndCByZW5kZXIgYW55dGhpbmcgaW4gcHJvZHVjdGlvbiBpZiB0aGlzIGluYm94IG5vdGlmaWNhdGlvbiBraW5kIGlzIG5vdCBkZWZpbmVkLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFJlc29sdmVkSW5ib3hOb3RpZmljYXRpb25DdXN0b21cbiAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb249e2luYm94Tm90aWZpY2F0aW9ufVxuICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApLFxuICB7XG4gICAgVGhyZWFkOiBJbmJveE5vdGlmaWNhdGlvblRocmVhZCxcbiAgICBUZXh0TWVudGlvbjogSW5ib3hOb3RpZmljYXRpb25UZXh0TWVudGlvbixcbiAgICBDdXN0b206IEluYm94Tm90aWZpY2F0aW9uQ3VzdG9tLFxuICAgIEljb246IEluYm94Tm90aWZpY2F0aW9uSWNvbixcbiAgICBBdmF0YXI6IEluYm94Tm90aWZpY2F0aW9uQXZhdGFyLFxuICB9XG4pO1xuIl0sIm5hbWVzIjpbIkluYm94Tm90aWZpY2F0aW9uTGF5b3V0IiwiZm9yd2FyZFJlZiIsImluYm94Tm90aWZpY2F0aW9uIiwiY2hpbGRyZW4iLCJhc2lkZSIsInRpdGxlIiwiZGF0ZSIsInVucmVhZCIsIm1hcmtBc1JlYWRPbkNsaWNrIiwib25DbGljayIsImhyZWYiLCJzaG93QWN0aW9ucyIsIm92ZXJyaWRlcyIsImNvbXBvbmVudHMiLCJjbGFzc05hbWUiLCJhc0NoaWxkIiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCIkIiwidXNlT3ZlcnJpZGVzIiwiQW5jaG9yIiwidXNlQ29tcG9uZW50cyIsIkNvbXBvbmVudCIsIlNsb3QiLCJpc01vcmVBY3Rpb25PcGVuIiwic2V0TW9yZUFjdGlvbk9wZW4iLCJ1c2VTdGF0ZSIsIm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCIsInVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCIsImRlbGV0ZUluYm94Tm90aWZpY2F0aW9uIiwidXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24iLCJoYW5kbGVDbGljayIsInVzZUNhbGxiYWNrIiwiZXZlbnQiLCJzaG91bGRNYXJrQXNSZWFkT25DbGljayIsIkJvb2xlYW4iLCJpZCIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0QW5kU3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVNb3JlQ2xpY2siLCJvcGVuIiwiaGFuZGxlTWFya0FzUmVhZCIsImhhbmRsZURlbGV0ZSIsIlJlYWN0X19kZWZhdWx0IiwiY3JlYXRlRWxlbWVudCIsIlRvb2x0aXBQcm92aWRlciIsImNsYXNzTmFtZXMiLCJkaXIiLCJraW5kIiwicmVmIiwiVGltZXN0YW1wIiwibG9jYWxlIiwicm9sZSIsIkRyb3Bkb3duIiwib25PcGVuQ2hhbmdlIiwiYWxpZ24iLCJjb250ZW50IiwiRnJhZ21lbnQiLCJEcm9wZG93bkl0ZW0iLCJvblNlbGVjdCIsIkNoZWNrSWNvbiIsIklOQk9YX05PVElGSUNBVElPTl9NQVJLX0FTX1JFQUQiLCJEZWxldGVJY29uIiwiSU5CT1hfTk9USUZJQ0FUSU9OX0RFTEVURSIsIlRvb2x0aXAiLCJJTkJPWF9OT1RJRklDQVRJT05fTU9SRSIsIkRyb3Bkb3duTWVudVRyaWdnZXIiLCJCdXR0b24iLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyVXAiLCJFbGxpcHNpc0ljb24iLCJJbmJveE5vdGlmaWNhdGlvbkljb24iLCJJbmJveE5vdGlmaWNhdGlvbkF2YXRhciIsIkF2YXRhciIsIkluYm94Tm90aWZpY2F0aW9uVGhyZWFkIiwic2hvd1Jvb21OYW1lIiwidGhyZWFkIiwidXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQiLCJjdXJyZW50VXNlcklkIiwidXNlQ3VycmVudFVzZXJJZCIsImluZm8iLCJ1c2VSb29tSW5mbyIsInJvb21JZCIsImNvbW1lbnRJZCIsInVzZU1lbW8iLCJjb250ZW50cyIsImdlbmVyYXRlSW5ib3hOb3RpZmljYXRpb25UaHJlYWRDb250ZW50cyIsInR5cGUiLCJyZXZlcnNlZFVzZXJJZHMiLCJ1c2VySWRzIiwicmV2ZXJzZSIsImZpcnN0VXNlcklkIiwiYXNpZGUyIiwidXNlcklkIiwidGl0bGUyIiwiSU5CT1hfTk9USUZJQ0FUSU9OX1RIUkVBRF9DT01NRU5UU19MSVNUIiwiTGlzdCIsInZhbHVlcyIsIm1hcCIsImluZGV4IiwiVXNlciIsImtleSIsImNhcGl0YWxpemUiLCJyZXBsYWNlU2VsZiIsImZvcm1hdFJlbWFpbmluZyIsIkxJU1RfUkVNQUlOSU5HX1VTRVJTIiwidHJ1bmNhdGUiLCJJTkJPWF9OT1RJRklDQVRJT05fVEhSRUFEX01BWF9DT01NRU5UUyIsIlJvb20iLCJsZW5ndGgiLCJjb250ZW50MiIsImNvbW1lbnRzIiwiY29tbWVudCIsIkluYm94Tm90aWZpY2F0aW9uQ29tbWVudCIsInNob3dIZWFkZXIiLCJ0aHJlYWRJZCIsIm1lbnRpb25Vc2VySWQiLCJtZW50aW9uQ29tbWVudCIsIklOQk9YX05PVElGSUNBVElPTl9USFJFQURfTUVOVElPTiIsImFzc2VydE5ldmVyIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRIcmVmMiIsInVybCIsImdlbmVyYXRlVVJMIiwiSW5ib3hOb3RpZmljYXRpb25UZXh0TWVudGlvbiIsInJlYWRBdCIsIm5vdGlmaWVkQXQiLCJjcmVhdGVkQnkiLCJJTkJPWF9OT1RJRklDQVRJT05fVEVYVF9NRU5USU9OIiwiSW5ib3hOb3RpZmljYXRpb25DdXN0b20iLCJJbmJveE5vdGlmaWNhdGlvbkN1c3RvbU1pc3NpbmciLCJNaXNzaW5nSWNvbiIsImluYm94Tm90aWZpY2F0aW9uS2luZHNXYXJuaW5ncyIsIlNldCIsIkluYm94Tm90aWZpY2F0aW9uIiwiT2JqZWN0IiwiYXNzaWduIiwia2luZHMiLCJSZXNvbHZlZEluYm94Tm90aWZpY2F0aW9uVGhyZWFkIiwiUmVzb2x2ZWRJbmJveE5vdGlmaWNhdGlvblRleHRNZW50aW9uIiwidGV4dE1lbnRpb24iLCJSZXNvbHZlZEluYm94Tm90aWZpY2F0aW9uQ3VzdG9tIiwicHJvY2VzcyIsImhhcyIsImFkZCIsImNvbnNvbGUiLCJ3YXJuIiwiVGhyZWFkIiwiVGV4dE1lbnRpb24iLCJDdXN0b20iLCJJY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/InboxNotification.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/InboxNotificationList.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/InboxNotificationList.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InboxNotificationList: () => (/* binding */ InboxNotificationList)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* __next_internal_client_entry_do_not_use__ InboxNotificationList auto */ \n\nconst InboxNotificationList = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, className, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ol\", {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_1__.classNames)(\"lb-root lb-inbox-notification-list\", className),\n        ...props,\n        ref: forwardedRef\n    }, react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, (child, index)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"li\", {\n            key: index,\n            className: \"lb-inbox-notification-list-item\"\n        }, child)));\n});\n //# sourceMappingURL=InboxNotificationList.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL0luYm94Tm90aWZpY2F0aW9uTGlzdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFtQmEsTUFBQUEsc0NBQUFDLGlEQUFBQSxDQUFBLEdBQUFDLFFBQUEsRUFBQUMsU0FBQSxLQUFBQyxPQUFBLEVBQUFDO0lBSVgscUNBQUFDLGdEQUFBO1FBQ0dILFdBQUFLLGtFQUFBQSxDQUFBLHNDQUFBTDtRQUNzRSxHQUFBQyxLQUFBO1FBQ2pFSyxLQUFBSjtJQUNDLEdBQUFLLDJDQUFBQSxDQUFBQyxHQUFBLENBQUFULFVBQUEsQ0FBQVUsT0FBQUMsUUFBQSw4QkFBQVAsZ0RBQUE7WUFHRlEsS0FBQUQ7WUFBUVYsV0FBQTtRQUFpQixHQUFBUztBQU1sQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uLi8uLi9zcmMvY29tcG9uZW50cy9JbmJveE5vdGlmaWNhdGlvbkxpc3QudHN4PzY0NTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4sIGZvcndhcmRSZWYgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCIuLi91dGlscy9jbGFzcy1uYW1lc1wiO1xuXG5leHBvcnQgdHlwZSBJbmJveE5vdGlmaWNhdGlvbkxpc3RQcm9wcyA9IENvbXBvbmVudFByb3BzV2l0aG91dFJlZjxcIm9sXCI+O1xuXG4vKipcbiAqIERpc3BsYXlzIGluYm94IG5vdGlmaWNhdGlvbnMgYXMgYSBsaXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiA8SW5ib3hOb3RpZmljYXRpb25MaXN0PlxuICogICB7aW5ib3hOb3RpZmljYXRpb25zLm1hcCgoaW5ib3hOb3RpZmljYXRpb24pID0+IChcbiAqICAgICA8SW5ib3hOb3RpZmljYXRpb24ga2V5PXtpbmJveE5vdGlmaWNhdGlvbi5pZH0gaW5ib3hOb3RpZmljYXRpb249e2luYm94Tm90aWZpY2F0aW9ufSAvPlxuICogICApKX1cbiAqIDwvSW5ib3hOb3RpZmljYXRpb25MaXN0PlxuICovXG5leHBvcnQgY29uc3QgSW5ib3hOb3RpZmljYXRpb25MaXN0ID0gZm9yd2FyZFJlZjxcbiAgSFRNTE9MaXN0RWxlbWVudCxcbiAgSW5ib3hOb3RpZmljYXRpb25MaXN0UHJvcHNcbj4oKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPG9sXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJsYi1yb290IGxiLWluYm94LW5vdGlmaWNhdGlvbi1saXN0XCIsIGNsYXNzTmFtZSl9XG4gICAgICB7Li4ucHJvcHN9XG4gICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICA+XG4gICAgICB7Q2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGluZGV4KSA9PiAoXG4gICAgICAgIDxsaSBrZXk9e2luZGV4fSBjbGFzc05hbWU9XCJsYi1pbmJveC1ub3RpZmljYXRpb24tbGlzdC1pdGVtXCI+XG4gICAgICAgICAge2NoaWxkfVxuICAgICAgICA8L2xpPlxuICAgICAgKSl9XG4gICAgPC9vbD5cbiAgKTtcbn0pO1xuIl0sIm5hbWVzIjpbIkluYm94Tm90aWZpY2F0aW9uTGlzdCIsImZvcndhcmRSZWYiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiUmVhY3RfX2RlZmF1bHQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lcyIsInJlZiIsIkNoaWxkcmVuIiwibWFwIiwiY2hpbGQiLCJpbmRleCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/InboxNotificationList.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Attribution.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Attribution.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attribution: () => (/* binding */ Attribution)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n\n\n\nfunction Attribution({ className, ...props }) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", {\n    href: \"https://liveblocks.io\",\n    target: \"_blank\",\n    rel: \"noopener noreferrer\",\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_1__.classNames)(\"lb-composer-attribution\", className),\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 384 72\",\n    \"aria-label\": \"Made with Liveblocks\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M86 10h-8v50h8V10Zm16 14h-8v36h8V24Zm0-15h-8v9h8V9Zm13 15h-9l12 36h10l13-36h-9l-9 28-8-28Zm44-1c-11 0-18 8-18 19s7 19 18 19c8 0 15-4 17-13h-8c-1 4-5 6-9 6-6 0-9-3-9-10h27c0-10-6-21-18-21Zm0 7c5 0 9 3 9 8h-18c0-5 4-8 9-8Zm42-7c-4 0-8 2-11 6V10h-8v50h8v-5c3 4 7 6 11 6 11 0 16-9 16-19s-5-19-16-19Zm-2 32c-7 0-9-7-9-13s2-13 9-13 9 7 9 13-2 13-9 13Zm32-45h-8v50h8V10Zm24 51c11 0 18-8 18-19s-8-19-18-19c-11 0-19 8-19 19s7 19 19 19Zm0-6c-8 0-10-7-10-13s2-13 10-13c7 0 9 7 9 13s-2 13-9 13Zm39 6c8 0 15-4 17-12l-8-1c-2 4-4 6-9 6-7 0-9-6-9-12s2-12 9-12c5 0 8 3 8 7l9-1c-2-8-9-13-17-13-11 0-18 9-18 19 0 11 7 19 18 19Zm30-14 4-4 10 17h10l-15-23 15-13h-11l-13 13V10h-9v50h9V47Zm39 14c8 0 16-3 16-12 0-8-8-10-15-11-2-1-7-1-7-5 0-3 3-4 6-4 4 0 7 3 7 7l8-1c-1-9-8-12-15-12s-15 3-15 11 9 10 15 11c3 1 8 2 8 5 0 4-4 5-7 5-5 0-8-3-9-7l-8 1c1 8 9 12 16 12ZM41 27H0l12 12v17l29-29ZM20 60h40L48 48V32L20 60Z\",\n    fill: \"currentColor\"\n  })));\n}\n\n\n//# sourceMappingURL=Attribution.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0F0dHJpYnV0aW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFDc0I7O0FBRXpELHVCQUF1QixxQkFBcUI7QUFDNUMseUJBQXlCLGdEQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtFQUFVO0FBQ3pCO0FBQ0EsR0FBRyxrQkFBa0IsZ0RBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0JBQWtCLGdEQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0F0dHJpYnV0aW9uLm1qcz8xNWVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdF9fZGVmYXVsdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2xhc3MtbmFtZXMubWpzJztcblxuZnVuY3Rpb24gQXR0cmlidXRpb24oeyBjbGFzc05hbWUsIC4uLnByb3BzIH0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgaHJlZjogXCJodHRwczovL2xpdmVibG9ja3MuaW9cIixcbiAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJsYi1jb21wb3Nlci1hdHRyaWJ1dGlvblwiLCBjbGFzc05hbWUpLFxuICAgIC4uLnByb3BzXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDM4NCA3MlwiLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBcIk1hZGUgd2l0aCBMaXZlYmxvY2tzXCJcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTg2IDEwaC04djUwaDhWMTBabTE2IDE0aC04djM2aDhWMjRabTAtMTVoLTh2OWg4VjlabTEzIDE1aC05bDEyIDM2aDEwbDEzLTM2aC05bC05IDI4LTgtMjhabTQ0LTFjLTExIDAtMTggOC0xOCAxOXM3IDE5IDE4IDE5YzggMCAxNS00IDE3LTEzaC04Yy0xIDQtNSA2LTkgNi02IDAtOS0zLTktMTBoMjdjMC0xMC02LTIxLTE4LTIxWm0wIDdjNSAwIDkgMyA5IDhoLTE4YzAtNSA0LTggOS04Wm00Mi03Yy00IDAtOCAyLTExIDZWMTBoLTh2NTBoOHYtNWMzIDQgNyA2IDExIDYgMTEgMCAxNi05IDE2LTE5cy01LTE5LTE2LTE5Wm0tMiAzMmMtNyAwLTktNy05LTEzczItMTMgOS0xMyA5IDcgOSAxMy0yIDEzLTkgMTNabTMyLTQ1aC04djUwaDhWMTBabTI0IDUxYzExIDAgMTgtOCAxOC0xOXMtOC0xOS0xOC0xOWMtMTEgMC0xOSA4LTE5IDE5czcgMTkgMTkgMTlabTAtNmMtOCAwLTEwLTctMTAtMTNzMi0xMyAxMC0xM2M3IDAgOSA3IDkgMTNzLTIgMTMtOSAxM1ptMzkgNmM4IDAgMTUtNCAxNy0xMmwtOC0xYy0yIDQtNCA2LTkgNi03IDAtOS02LTktMTJzMi0xMiA5LTEyYzUgMCA4IDMgOCA3bDktMWMtMi04LTktMTMtMTctMTMtMTEgMC0xOCA5LTE4IDE5IDAgMTEgNyAxOSAxOCAxOVptMzAtMTQgNC00IDEwIDE3aDEwbC0xNS0yMyAxNS0xM2gtMTFsLTEzIDEzVjEwaC05djUwaDlWNDdabTM5IDE0YzggMCAxNi0zIDE2LTEyIDAtOC04LTEwLTE1LTExLTItMS03LTEtNy01IDAtMyAzLTQgNi00IDQgMCA3IDMgNyA3bDgtMWMtMS05LTgtMTItMTUtMTJzLTE1IDMtMTUgMTEgOSAxMCAxNSAxMWMzIDEgOCAyIDggNSAwIDQtNCA1LTcgNS01IDAtOC0zLTktN2wtOCAxYzEgOCA5IDEyIDE2IDEyWk00MSAyN0gwbDEyIDEydjE3bDI5LTI5Wk0yMCA2MGg0MEw0OCA0OFYzMkwyMCA2MFpcIixcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiXG4gIH0pKSk7XG59XG5cbmV4cG9ydCB7IEF0dHJpYnV0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdHRyaWJ1dGlvbi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Attribution.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Avatar.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Avatar.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Avatar: () => (/* binding */ Avatar)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* harmony import */ var _utils_get_initials_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/get-initials.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/get-initials.mjs\");\n/* __next_internal_client_entry_do_not_use__ Avatar auto */ \n\n\n\nfunction Avatar({ userId, className, ...props }) {\n    const { user, isLoading } = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_1__._useUser)(userId);\n    const resolvedUserName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>user?.name, [\n        user\n    ]);\n    const resolvedUserAvatar = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>user?.avatar, [\n        user\n    ]);\n    const resolvedUserInitials = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>resolvedUserName ? (0,_utils_get_initials_mjs__WEBPACK_IMPORTED_MODULE_2__.getInitials)(resolvedUserName) : void 0, [\n        resolvedUserName\n    ]);\n    const resolvedUserIdInitials = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>!isLoading && !user ? (0,_utils_get_initials_mjs__WEBPACK_IMPORTED_MODULE_2__.getInitials)(userId) : void 0, [\n        isLoading,\n        user,\n        userId\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_3__.classNames)(\"lb-avatar\", className),\n        \"data-loading\": isLoading ? \"\" : void 0,\n        ...props\n    }, resolvedUserAvatar && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n        className: \"lb-avatar-image\",\n        src: resolvedUserAvatar,\n        alt: resolvedUserName\n    }), resolvedUserInitials ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"lb-avatar-fallback\",\n        \"aria-hidden\": true\n    }, resolvedUserInitials) : resolvedUserIdInitials ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"lb-avatar-fallback\",\n        \"aria-label\": userId,\n        title: userId\n    }, resolvedUserIdInitials) : null);\n}\n //# sourceMappingURL=Avatar.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0F2YXRhci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBZ0JPLFNBQUFBLE9BQUEsRUFBQUMsTUFBQSxFQUFBQyxTQUFBLEtBQUFDLE9BQUE7SUFDTCxRQUFBQyxJQUFBLEVBQUFDLFNBQUEsS0FBQUMsMkRBQUFBLENBQUFMO0lBQ0EsTUFBQU0sbUJBQUFDLDhDQUFBQSxDQUFBLElBQUFKLE1BQUFLLE1BQUE7UUFBQUw7S0FBQTtJQUNBLE1BQUFNLHFCQUFBRiw4Q0FBQUEsQ0FBQSxJQUFBSixNQUFBTyxRQUFBO1FBQUFQO0tBQUE7SUFDQSxNQUFBUSx1QkFBQUosOENBQUFBLENBQTZCLElBQUFELG1CQUFBTSxvRUFBQUEsQ0FBQU4sb0JBQUEsUUFDK0I7UUFBQUE7S0FBQTtJQUc1RCxNQUFBTyx5QkFBQU4sOENBQUFBLENBQStCLEtBQUFILGFBQUEsQ0FBQUQsT0FBQVMsb0VBQUFBLENBQUFaLFVBQUEsUUFDc0I7UUFBQUk7UUFBQUQ7UUFBQUg7S0FBQTtJQUlyRCxxQ0FBQWMsZ0RBQUE7UUFDR2IsV0FBQWUsa0VBQUFBLENBQUEsYUFBQWY7UUFDNkMsZ0JBQUFHLFlBQUE7UUFDYixHQUFBRixLQUFBO0lBQzNCLEdBQUFPLHNCQUFBLDhCQUFBSyxnREFBQTtRQUdEYixXQUFBO1FBQ1dnQixLQUFBUjtRQUNMUyxLQUFBWjtJQUNBLElBQUFLLHVCQUFBLDhCQUFBRyxnREFBQTtRQUlOYixXQUFBO1FBQWU7SUFBZ0MsR0FBQVUsd0JBQUFFLHlCQUFBLDhCQUFBQyxnREFBQTtRQUkvQ2IsV0FBQTtRQUFlLGNBQUFEO1FBQWlDbUIsT0FBQW5CO0lBQWUsR0FBQWEsMEJBQUE7QUFNeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvaW50ZXJuYWwvQXZhdGFyLnRzeD85YWJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VVc2VyIH0gZnJvbSBcIkBsaXZlYmxvY2tzL3JlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudFByb3BzIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2NsYXNzLW5hbWVzXCI7XG5pbXBvcnQgeyBnZXRJbml0aWFscyB9IGZyb20gXCIuLi8uLi91dGlscy9nZXQtaW5pdGlhbHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBBdmF0YXJQcm9wcyBleHRlbmRzIENvbXBvbmVudFByb3BzPFwiZGl2XCI+IHtcbiAgLyoqXG4gICAqIFRoZSB1c2VyIElEIHRvIGRpc3BsYXkgdGhlIGF2YXRhciBmb3IuXG4gICAqL1xuICB1c2VySWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEF2YXRhcih7IHVzZXJJZCwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9OiBBdmF0YXJQcm9wcykge1xuICBjb25zdCB7IHVzZXIsIGlzTG9hZGluZyB9ID0gdXNlVXNlcih1c2VySWQpO1xuICBjb25zdCByZXNvbHZlZFVzZXJOYW1lID0gdXNlTWVtbygoKSA9PiB1c2VyPy5uYW1lLCBbdXNlcl0pO1xuICBjb25zdCByZXNvbHZlZFVzZXJBdmF0YXIgPSB1c2VNZW1vKCgpID0+IHVzZXI/LmF2YXRhciwgW3VzZXJdKTtcbiAgY29uc3QgcmVzb2x2ZWRVc2VySW5pdGlhbHMgPSB1c2VNZW1vKFxuICAgICgpID0+IChyZXNvbHZlZFVzZXJOYW1lID8gZ2V0SW5pdGlhbHMocmVzb2x2ZWRVc2VyTmFtZSkgOiB1bmRlZmluZWQpLFxuICAgIFtyZXNvbHZlZFVzZXJOYW1lXVxuICApO1xuICBjb25zdCByZXNvbHZlZFVzZXJJZEluaXRpYWxzID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoIWlzTG9hZGluZyAmJiAhdXNlciA/IGdldEluaXRpYWxzKHVzZXJJZCkgOiB1bmRlZmluZWQpLFxuICAgIFtpc0xvYWRpbmcsIHVzZXIsIHVzZXJJZF1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcImxiLWF2YXRhclwiLCBjbGFzc05hbWUpfVxuICAgICAgZGF0YS1sb2FkaW5nPXtpc0xvYWRpbmcgPyBcIlwiIDogdW5kZWZpbmVkfVxuICAgICAgey4uLnByb3BzfVxuICAgID5cbiAgICAgIHtyZXNvbHZlZFVzZXJBdmF0YXIgJiYgKFxuICAgICAgICA8aW1nXG4gICAgICAgICAgY2xhc3NOYW1lPVwibGItYXZhdGFyLWltYWdlXCJcbiAgICAgICAgICBzcmM9e3Jlc29sdmVkVXNlckF2YXRhcn1cbiAgICAgICAgICBhbHQ9e3Jlc29sdmVkVXNlck5hbWV9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgICAge3Jlc29sdmVkVXNlckluaXRpYWxzID8gKFxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJsYi1hdmF0YXItZmFsbGJhY2tcIiBhcmlhLWhpZGRlbj5cbiAgICAgICAgICB7cmVzb2x2ZWRVc2VySW5pdGlhbHN9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICkgOiByZXNvbHZlZFVzZXJJZEluaXRpYWxzID8gKFxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJsYi1hdmF0YXItZmFsbGJhY2tcIiBhcmlhLWxhYmVsPXt1c2VySWR9IHRpdGxlPXt1c2VySWR9PlxuICAgICAgICAgIHtyZXNvbHZlZFVzZXJJZEluaXRpYWxzfVxuICAgICAgICA8L3NwYW4+XG4gICAgICApIDogbnVsbH1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJBdmF0YXIiLCJ1c2VySWQiLCJjbGFzc05hbWUiLCJwcm9wcyIsInVzZXIiLCJpc0xvYWRpbmciLCJ1c2VVc2VyIiwicmVzb2x2ZWRVc2VyTmFtZSIsInVzZU1lbW8iLCJuYW1lIiwicmVzb2x2ZWRVc2VyQXZhdGFyIiwiYXZhdGFyIiwicmVzb2x2ZWRVc2VySW5pdGlhbHMiLCJnZXRJbml0aWFscyIsInJlc29sdmVkVXNlcklkSW5pdGlhbHMiLCJSZWFjdF9fZGVmYXVsdCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWVzIiwic3JjIiwiYWx0IiwidGl0bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Avatar.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Button.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Button.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* __next_internal_client_entry_do_not_use__ Button auto */ \n\nconst Button = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ variant = \"default\", disableable = true, className, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        type: \"button\",\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_1__.classNames)(\"lb-button\", !disableable && \"lb-button:non-disableable\", className),\n        \"data-variant\": variant,\n        ...props,\n        ref: forwardedRef\n    });\n});\n //# sourceMappingURL=Button.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0J1dHRvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFZTyxNQUFBQSx1QkFBQUMsaURBQUFBLENBQWUsR0FBQUMsVUFBQSxXQUFBQyxjQUFBLE1BQUFDLFNBQUEsS0FBQUMsT0FBQSxFQUFBQztJQUtsQixxQ0FBQUMsZ0RBQUE7UUFDR0UsTUFBQTtRQUNNTCxXQUFBTSxrRUFBQUEsQ0FDTSxhQUNULENBQUFQLGVBQUEsNkJBQ2dCQztRQUVsQixnQkFBQUY7UUFDYyxHQUFBRyxLQUFBO1FBQ1ZNLEtBQUFMO0lBQ0M7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9pbnRlcm5hbC9CdXR0b24udHN4PzQ5MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50UHJvcHMgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvY2xhc3MtbmFtZXNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBCdXR0b25Qcm9wcyBleHRlbmRzIENvbXBvbmVudFByb3BzPFwiYnV0dG9uXCI+IHtcbiAgdmFyaWFudD86IFwiZGVmYXVsdFwiIHwgXCJvdXRsaW5lXCIgfCBcInByaW1hcnlcIjtcbiAgZGlzYWJsZWFibGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgQnV0dG9uID0gZm9yd2FyZFJlZjxIVE1MQnV0dG9uRWxlbWVudCwgQnV0dG9uUHJvcHM+KFxuICAoXG4gICAgeyB2YXJpYW50ID0gXCJkZWZhdWx0XCIsIGRpc2FibGVhYmxlID0gdHJ1ZSwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LFxuICAgIGZvcndhcmRlZFJlZlxuICApID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgIFwibGItYnV0dG9uXCIsXG4gICAgICAgICAgIWRpc2FibGVhYmxlICYmIFwibGItYnV0dG9uOm5vbi1kaXNhYmxlYWJsZVwiLFxuICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICApfVxuICAgICAgICBkYXRhLXZhcmlhbnQ9e3ZhcmlhbnR9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbik7XG4iXSwibmFtZXMiOlsiQnV0dG9uIiwiZm9yd2FyZFJlZiIsInZhcmlhbnQiLCJkaXNhYmxlYWJsZSIsImNsYXNzTmFtZSIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiUmVhY3RfX2RlZmF1bHQiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsImNsYXNzTmFtZXMiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Button.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Dropdown.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Dropdown.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dropdown: () => (/* binding */ Dropdown),\n/* harmony export */   DropdownItem: () => (/* binding */ DropdownItem),\n/* harmony export */   DropdownTrigger: () => (/* reexport safe */ _radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_0__.DropdownMenuTrigger)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @radix-ui/react-dropdown-menu */ \"(ssr)/./node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../config.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/config.mjs\");\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../constants.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.mjs\");\n/* harmony import */ var _overrides_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../overrides.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* __next_internal_client_entry_do_not_use__ DropdownTrigger,Dropdown,DropdownItem auto */ \n\n\n\n\n\n\nfunction Dropdown({ children, content, defaultOpen, open, onOpenChange, className, ...props }) {\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_2__.useOverrides)();\n    const { portalContainer } = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_3__.useLiveblocksUIConfig)();\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_0__.Root, {\n        defaultOpen,\n        open,\n        onOpenChange,\n        dir: $.dir\n    }, children, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_0__.Portal, {\n        container: portalContainer\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_0__.Content, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__.classNames)(\"lb-root lb-portal lb-elevation lb-dropdown\", className),\n        sideOffset: _constants_mjs__WEBPACK_IMPORTED_MODULE_5__.FLOATING_ELEMENT_SIDE_OFFSET,\n        collisionPadding: _constants_mjs__WEBPACK_IMPORTED_MODULE_5__.FLOATING_ELEMENT_COLLISION_PADDING,\n        ...props\n    }, content)));\n}\nconst DropdownItem = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ children, className, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_dropdown_menu__WEBPACK_IMPORTED_MODULE_0__.DropdownMenuItem, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__.classNames)(\"lb-dropdown-item\", className),\n        ...props,\n        ref: forwardedRef\n    }, children);\n});\n //# sourceMappingURL=Dropdown.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0Ryb3Bkb3duLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JPLFNBQUFBLFNBQUEsRUFBa0JDLFFBQUEsRUFDdkJDLE9BQUEsRUFDQUMsV0FBQSxFQUNBQyxJQUFBLEVBQ0FDLFlBQUEsRUFDQUMsU0FBQSxFQUNBLEdBQUFDLE9BRUY7SUFDRSxNQUFBQyxJQUFBQyw0REFBQUE7SUFDQSxRQUFBQyxlQUFBLEtBQUFDLGtFQUFBQTtJQUVBLHFDQUFBQyxnREFBQSxDQUFBRSwrREFBQTtRQUNHWDtRQUNDQztRQUNBQztRQUNBVyxLQUFBUixFQUFBUSxHQUFBO0lBQ08sR0FBQWYsVUFBQSw4QkFBQVcsZ0RBQUEsQ0FBQUUsaUVBQUE7UUFHTkksV0FBQVI7SUFBd0MsaUNBQUFFLGdEQUFBLENBQUFFLGtFQUFBO1FBQ3RDUixXQUFBYyxrRUFBQUEsQ0FDWSw4Q0FDVGQ7UUFFRmUsWUFBQUMsd0VBQUFBO1FBQ1lDLGtCQUFBQyw4RUFBQUE7UUFDTSxHQUFBakIsS0FBQTtJQUNkLEdBQUFMO0FBT2Q7QUFFYSxNQUFBdUIsNkJBQUFDLGlEQUFBQSxDQUFBLEdBQUF6QixRQUFBLEVBQUFLLFNBQUEsS0FBQUMsT0FBQSxFQUFBb0I7SUFJWCxxQ0FBQWYsZ0RBQUEsQ0FBQUUsMkVBQUE7UUFDR1IsV0FBQWMsa0VBQUFBLENBQUEsb0JBQUFkO1FBQ29ELEdBQUFDLEtBQUE7UUFDL0NzQixLQUFBRjtJQUNDLEdBQUExQjtBQUtYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2ludGVybmFsL0Ryb3Bkb3duLnRzeD8xOTI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgKiBhcyBEcm9wZG93bk1lbnVQcmltaXRpdmUgZnJvbSBcIkByYWRpeC11aS9yZWFjdC1kcm9wZG93bi1tZW51XCI7XG5pbXBvcnQgdHlwZSB7IFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgdXNlTGl2ZWJsb2Nrc1VJQ29uZmlnIH0gZnJvbSBcIi4uLy4uL2NvbmZpZ1wiO1xuaW1wb3J0IHtcbiAgRkxPQVRJTkdfRUxFTUVOVF9DT0xMSVNJT05fUEFERElORyxcbiAgRkxPQVRJTkdfRUxFTUVOVF9TSURFX09GRlNFVCxcbn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgdXNlT3ZlcnJpZGVzIH0gZnJvbSBcIi4uLy4uL292ZXJyaWRlc1wiO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCIuLi8uLi91dGlscy9jbGFzcy1uYW1lc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duUHJvcHNcbiAgZXh0ZW5kcyBQaWNrPFxuICAgICAgRHJvcGRvd25NZW51UHJpbWl0aXZlLkRyb3Bkb3duTWVudVByb3BzLFxuICAgICAgXCJkZWZhdWx0T3BlblwiIHwgXCJvcGVuXCIgfCBcIm9uT3BlbkNoYW5nZVwiXG4gICAgPixcbiAgICBQaWNrPERyb3Bkb3duTWVudVByaW1pdGl2ZS5Ecm9wZG93bk1lbnVUcmlnZ2VyUHJvcHMsIFwiY2hpbGRyZW5cIj4sXG4gICAgT21pdDxEcm9wZG93bk1lbnVQcmltaXRpdmUuRHJvcGRvd25NZW51Q29udGVudFByb3BzLCBcImNvbnRlbnRcIj4ge1xuICBjb250ZW50OiBSZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEcm9wZG93bih7XG4gIGNoaWxkcmVuLFxuICBjb250ZW50LFxuICBkZWZhdWx0T3BlbixcbiAgb3BlbixcbiAgb25PcGVuQ2hhbmdlLFxuICBjbGFzc05hbWUsXG4gIC4uLnByb3BzXG59OiBEcm9wZG93blByb3BzKSB7XG4gIGNvbnN0ICQgPSB1c2VPdmVycmlkZXMoKTtcbiAgY29uc3QgeyBwb3J0YWxDb250YWluZXIgfSA9IHVzZUxpdmVibG9ja3NVSUNvbmZpZygpO1xuXG4gIHJldHVybiAoXG4gICAgPERyb3Bkb3duTWVudVByaW1pdGl2ZS5Sb290XG4gICAgICBkZWZhdWx0T3Blbj17ZGVmYXVsdE9wZW59XG4gICAgICBvcGVuPXtvcGVufVxuICAgICAgb25PcGVuQ2hhbmdlPXtvbk9wZW5DaGFuZ2V9XG4gICAgICBkaXI9eyQuZGlyfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDxEcm9wZG93bk1lbnVQcmltaXRpdmUuUG9ydGFsIGNvbnRhaW5lcj17cG9ydGFsQ29udGFpbmVyfT5cbiAgICAgICAgPERyb3Bkb3duTWVudVByaW1pdGl2ZS5Db250ZW50XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgXCJsYi1yb290IGxiLXBvcnRhbCBsYi1lbGV2YXRpb24gbGItZHJvcGRvd25cIixcbiAgICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICAgICl9XG4gICAgICAgICAgc2lkZU9mZnNldD17RkxPQVRJTkdfRUxFTUVOVF9TSURFX09GRlNFVH1cbiAgICAgICAgICBjb2xsaXNpb25QYWRkaW5nPXtGTE9BVElOR19FTEVNRU5UX0NPTExJU0lPTl9QQURESU5HfVxuICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgPlxuICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICA8L0Ryb3Bkb3duTWVudVByaW1pdGl2ZS5Db250ZW50PlxuICAgICAgPC9Ecm9wZG93bk1lbnVQcmltaXRpdmUuUG9ydGFsPlxuICAgIDwvRHJvcGRvd25NZW51UHJpbWl0aXZlLlJvb3Q+XG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBEcm9wZG93bkl0ZW0gPSBmb3J3YXJkUmVmPFxuICBIVE1MRGl2RWxlbWVudCxcbiAgRHJvcGRvd25NZW51UHJpbWl0aXZlLkRyb3Bkb3duTWVudUl0ZW1Qcm9wc1xuPigoeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8RHJvcGRvd25NZW51UHJpbWl0aXZlLkRyb3Bkb3duTWVudUl0ZW1cbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcImxiLWRyb3Bkb3duLWl0ZW1cIiwgY2xhc3NOYW1lKX1cbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0Ryb3Bkb3duTWVudVByaW1pdGl2ZS5Ecm9wZG93bk1lbnVJdGVtPlxuICApO1xufSk7XG5cbmV4cG9ydCB7IERyb3Bkb3duTWVudVRyaWdnZXIgYXMgRHJvcGRvd25UcmlnZ2VyIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1kcm9wZG93bi1tZW51XCI7XG4iXSwibmFtZXMiOlsiRHJvcGRvd24iLCJjaGlsZHJlbiIsImNvbnRlbnQiLCJkZWZhdWx0T3BlbiIsIm9wZW4iLCJvbk9wZW5DaGFuZ2UiLCJjbGFzc05hbWUiLCJwcm9wcyIsIiQiLCJ1c2VPdmVycmlkZXMiLCJwb3J0YWxDb250YWluZXIiLCJ1c2VMaXZlYmxvY2tzVUlDb25maWciLCJSZWFjdF9fZGVmYXVsdCIsImNyZWF0ZUVsZW1lbnQiLCJEcm9wZG93bk1lbnVQcmltaXRpdmUiLCJSb290IiwiZGlyIiwiUG9ydGFsIiwiY29udGFpbmVyIiwiQ29udGVudCIsImNsYXNzTmFtZXMiLCJzaWRlT2Zmc2V0IiwiRkxPQVRJTkdfRUxFTUVOVF9TSURFX09GRlNFVCIsImNvbGxpc2lvblBhZGRpbmciLCJGTE9BVElOR19FTEVNRU5UX0NPTExJU0lPTl9QQURESU5HIiwiRHJvcGRvd25JdGVtIiwiZm9yd2FyZFJlZiIsImZvcndhcmRlZFJlZiIsIkRyb3Bkb3duTWVudUl0ZW0iLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Dropdown.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Emoji: () => (/* binding */ Emoji)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _primitives_internal_Emoji_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/internal/Emoji.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/internal/Emoji.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n\n\n\n\nconst Emoji = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({ className, ...props }, forwardedRef) => {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_internal_Emoji_mjs__WEBPACK_IMPORTED_MODULE_1__.Emoji, {\n      className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-emoji\", className),\n      ...props,\n      ref: forwardedRef\n    });\n  }\n);\n\n\n//# sourceMappingURL=Emoji.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0Vtb2ppLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1EO0FBQ29CO0FBQ2Q7O0FBRXpELGNBQWMsaURBQVU7QUFDeEIsS0FBSyxxQkFBcUI7QUFDMUIsMkJBQTJCLGdEQUE0QixDQUFDLGlFQUFPO0FBQy9ELGlCQUFpQixrRUFBVTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvY29tcG9uZW50cy9pbnRlcm5hbC9FbW9qaS5tanM/NTY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVtb2ppIGFzIEVtb2ppJDEgfSBmcm9tICcuLi8uLi9wcmltaXRpdmVzL2ludGVybmFsL0Vtb2ppLm1qcyc7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2xhc3MtbmFtZXMubWpzJztcblxuY29uc3QgRW1vamkgPSBmb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChFbW9qaSQxLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJsYi1lbW9qaVwiLCBjbGFzc05hbWUpLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgIH0pO1xuICB9XG4pO1xuXG5leHBvcnQgeyBFbW9qaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1vamkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/EmojiPicker.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/EmojiPicker.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmojiPicker: () => (/* binding */ EmojiPicker),\n/* harmony export */   EmojiPickerTrigger: () => (/* reexport safe */ _radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_0__.PopoverTrigger)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @radix-ui/react-popover */ \"(ssr)/./node_modules/@radix-ui/react-popover/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../config.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/config.mjs\");\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../constants.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.mjs\");\n/* harmony import */ var _icons_Search_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../icons/Search.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Search.mjs\");\n/* harmony import */ var _icons_Spinner_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../icons/Spinner.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Spinner.mjs\");\n/* harmony import */ var _overrides_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../overrides.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\");\n/* harmony import */ var _primitives_EmojiPicker_index_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../primitives/EmojiPicker/index.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/index.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* harmony import */ var _Emoji_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Emoji.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EmojiPickerLoading({\n  className,\n  ...props\n}) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-emoji-picker-loading\", className),\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_icons_Spinner_mjs__WEBPACK_IMPORTED_MODULE_3__.SpinnerIcon, null));\n}\nfunction EmojiPickerEmpty({\n  className,\n  ...props\n}) {\n  const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_4__.useOverrides)();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-emoji-picker-empty\", className),\n    ...props\n  }, $.EMOJI_PICKER_EMPTY);\n}\nfunction EmojiPickerError({\n  error,\n  className,\n  ...props\n}) {\n  const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_4__.useOverrides)();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-emoji-picker-error\", className),\n    ...props\n  }, $.EMOJI_PICKER_ERROR(error));\n}\nfunction EmojiPickerCategoryHeader({\n  category,\n  className,\n  ...props\n}) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-emoji-picker-category-header\", className),\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"span\", {\n    className: \"lb-emoji-picker-category-header-title\"\n  }, category));\n}\nfunction EmojiPickerGrid({\n  children,\n  className,\n  ...props\n}) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-emoji-picker-grid\", className),\n    ...props\n  }, children);\n}\nfunction EmojiPickerRow({\n  attributes,\n  children,\n  className,\n  ...props\n}) {\n  const isFirstRow = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => attributes.categoryRowIndex === 0,\n    [attributes.categoryRowIndex]\n  );\n  const isLastRow = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => attributes.categoryRowIndex === attributes.categoryRowsCount - 1,\n    [attributes.categoryRowIndex, attributes.categoryRowsCount]\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-emoji-picker-row\", className),\n    \"data-first\": isFirstRow ? \"\" : void 0,\n    \"data-last\": isLastRow ? \"\" : void 0,\n    ...props\n  }, children);\n}\nfunction EmojiPickerEmoji({\n  emoji,\n  className,\n  ...props\n}) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"button\", {\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-emoji-picker-emoji\", className),\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_Emoji_mjs__WEBPACK_IMPORTED_MODULE_5__.Emoji, {\n    emoji\n  }));\n}\nconst EmojiPicker = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ onEmojiSelect, onOpenChange, children, className, ...props }, forwardedRef) => {\n    const [isOpen, setOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { portalContainer } = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_6__.useLiveblocksUIConfig)();\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_4__.useOverrides)();\n    const handleOpenChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n      (isOpen2) => {\n        setOpen(isOpen2);\n        onOpenChange?.(isOpen2);\n      },\n      [onOpenChange]\n    );\n    const handleEmojiSelect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n      (emoji) => {\n        setOpen(false);\n        onEmojiSelect?.(emoji);\n      },\n      [onEmojiSelect]\n    );\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_0__.Root, {\n      open: isOpen,\n      onOpenChange: handleOpenChange\n    }, children, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_0__.Portal, {\n      container: portalContainer\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_popover__WEBPACK_IMPORTED_MODULE_0__.Content, {\n      side: \"top\",\n      align: \"center\",\n      sideOffset: _constants_mjs__WEBPACK_IMPORTED_MODULE_7__.FLOATING_ELEMENT_SIDE_OFFSET,\n      collisionPadding: _constants_mjs__WEBPACK_IMPORTED_MODULE_7__.FLOATING_ELEMENT_COLLISION_PADDING,\n      className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\n        \"lb-root lb-portal lb-elevation lb-emoji-picker\",\n        className\n      ),\n      ...props,\n      ref: forwardedRef\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_primitives_EmojiPicker_index_mjs__WEBPACK_IMPORTED_MODULE_8__.Root, {\n      onEmojiSelect: handleEmojiSelect,\n      locale: $.locale\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n      className: \"lb-emoji-picker-header\"\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n      className: \"lb-emoji-picker-search-container\"\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_primitives_EmojiPicker_index_mjs__WEBPACK_IMPORTED_MODULE_8__.Search, {\n      className: \"lb-emoji-picker-search\",\n      placeholder: $.EMOJI_PICKER_SEARCH_PLACEHOLDER,\n      autoFocus: true\n    }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_icons_Search_mjs__WEBPACK_IMPORTED_MODULE_9__.SearchIcon, {\n      className: \"lb-emoji-picker-search-icon\"\n    }))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_primitives_EmojiPicker_index_mjs__WEBPACK_IMPORTED_MODULE_8__.Content, {\n      className: \"lb-emoji-picker-content\",\n      components: {\n        Loading: EmojiPickerLoading,\n        Empty: EmojiPickerEmpty,\n        Error: EmojiPickerError,\n        CategoryHeader: EmojiPickerCategoryHeader,\n        Grid: EmojiPickerGrid,\n        Row: EmojiPickerRow,\n        Emoji: EmojiPickerEmoji\n      }\n    })))));\n  }\n);\n\n\n//# sourceMappingURL=EmojiPicker.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0Vtb2ppUGlja2VyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDbUI7QUFDSTtBQUMxQjtBQUM4QztBQUNuRDtBQUNFO0FBQ0g7QUFDMEY7QUFDcEY7QUFDckI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUIsZ0RBQTRCO0FBQ3JELGVBQWUsa0VBQVU7QUFDekI7QUFDQSxHQUFHLGtCQUFrQixnREFBNEIsQ0FBQywyREFBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZLDREQUFZO0FBQ3hCLHlCQUF5QixnREFBNEI7QUFDckQsZUFBZSxrRUFBVTtBQUN6QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFlBQVksNERBQVk7QUFDeEIseUJBQXlCLGdEQUE0QjtBQUNyRCxlQUFlLGtFQUFVO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCLGdEQUE0QjtBQUNyRCxlQUFlLGtFQUFVO0FBQ3pCO0FBQ0EsR0FBRyxrQkFBa0IsZ0RBQTRCO0FBQ2pEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCLGdEQUE0QjtBQUNyRCxlQUFlLGtFQUFVO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUIsOENBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBNEI7QUFDckQsZUFBZSxrRUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUIsZ0RBQTRCO0FBQ3JELGVBQWUsa0VBQVU7QUFDekI7QUFDQSxHQUFHLGtCQUFrQixnREFBNEIsQ0FBQyw2Q0FBSztBQUN2RDtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQixpREFBVTtBQUM5QixLQUFLLDREQUE0RDtBQUNqRSw4QkFBOEIsK0NBQVE7QUFDdEMsWUFBWSxrQkFBa0IsRUFBRSxrRUFBcUI7QUFDckQsY0FBYyw0REFBWTtBQUMxQiw2QkFBNkIsa0RBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw4QkFBOEIsa0RBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQTRCLENBQUMseURBQXFCO0FBQzdFO0FBQ0E7QUFDQSxLQUFLLDRCQUE0QixnREFBNEIsQ0FBQywyREFBdUI7QUFDckY7QUFDQSxLQUFLLGtCQUFrQixnREFBNEIsQ0FBQyw0REFBd0I7QUFDNUU7QUFDQTtBQUNBLGtCQUFrQix3RUFBNEI7QUFDOUMsd0JBQXdCLDhFQUFrQztBQUMxRCxpQkFBaUIsa0VBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssa0JBQWtCLGdEQUE0QixDQUFDLG1FQUFlO0FBQ25FO0FBQ0E7QUFDQSxLQUFLLGtCQUFrQixnREFBNEI7QUFDbkQ7QUFDQSxLQUFLLGtCQUFrQixnREFBNEI7QUFDbkQ7QUFDQSxLQUFLLGtCQUFrQixnREFBNEIsQ0FBQyxxRUFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtQkFBbUIsZ0RBQTRCLENBQUMseURBQVU7QUFDL0Q7QUFDQSxLQUFLLHFCQUFxQixnREFBNEIsQ0FBQyxzRUFBa0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0Vtb2ppUGlja2VyLm1qcz83MzZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFBvcG92ZXJQcmltaXRpdmUgZnJvbSAnQHJhZGl4LXVpL3JlYWN0LXBvcG92ZXInO1xuZXhwb3J0IHsgUG9wb3ZlclRyaWdnZXIgYXMgRW1vamlQaWNrZXJUcmlnZ2VyIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LXBvcG92ZXInO1xuaW1wb3J0IFJlYWN0X19kZWZhdWx0LCB7IGZvcndhcmRSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxpdmVibG9ja3NVSUNvbmZpZyB9IGZyb20gJy4uLy4uL2NvbmZpZy5tanMnO1xuaW1wb3J0IHsgRkxPQVRJTkdfRUxFTUVOVF9TSURFX09GRlNFVCwgRkxPQVRJTkdfRUxFTUVOVF9DT0xMSVNJT05fUEFERElORyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgU2VhcmNoSWNvbiB9IGZyb20gJy4uLy4uL2ljb25zL1NlYXJjaC5tanMnO1xuaW1wb3J0IHsgU3Bpbm5lckljb24gfSBmcm9tICcuLi8uLi9pY29ucy9TcGlubmVyLm1qcyc7XG5pbXBvcnQgeyB1c2VPdmVycmlkZXMgfSBmcm9tICcuLi8uLi9vdmVycmlkZXMubWpzJztcbmltcG9ydCB7IFJvb3QgYXMgRW1vamlQaWNrZXJSb290LCBTZWFyY2ggYXMgRW1vamlQaWNrZXJTZWFyY2gsIENvbnRlbnQgYXMgRW1vamlQaWNrZXJDb250ZW50IH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlcy9FbW9qaVBpY2tlci9pbmRleC5tanMnO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gJy4uLy4uL3V0aWxzL2NsYXNzLW5hbWVzLm1qcyc7XG5pbXBvcnQgeyBFbW9qaSB9IGZyb20gJy4vRW1vamkubWpzJztcblxuZnVuY3Rpb24gRW1vamlQaWNrZXJMb2FkaW5nKHtcbiAgY2xhc3NOYW1lLFxuICAuLi5wcm9wc1xufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhcImxiLWVtb2ppLXBpY2tlci1sb2FkaW5nXCIsIGNsYXNzTmFtZSksXG4gICAgLi4ucHJvcHNcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3Bpbm5lckljb24sIG51bGwpKTtcbn1cbmZ1bmN0aW9uIEVtb2ppUGlja2VyRW1wdHkoe1xuICBjbGFzc05hbWUsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0ICQgPSB1c2VPdmVycmlkZXMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJsYi1lbW9qaS1waWNrZXItZW1wdHlcIiwgY2xhc3NOYW1lKSxcbiAgICAuLi5wcm9wc1xuICB9LCAkLkVNT0pJX1BJQ0tFUl9FTVBUWSk7XG59XG5mdW5jdGlvbiBFbW9qaVBpY2tlckVycm9yKHtcbiAgZXJyb3IsXG4gIGNsYXNzTmFtZSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgY29uc3QgJCA9IHVzZU92ZXJyaWRlcygpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhcImxiLWVtb2ppLXBpY2tlci1lcnJvclwiLCBjbGFzc05hbWUpLFxuICAgIC4uLnByb3BzXG4gIH0sICQuRU1PSklfUElDS0VSX0VSUk9SKGVycm9yKSk7XG59XG5mdW5jdGlvbiBFbW9qaVBpY2tlckNhdGVnb3J5SGVhZGVyKHtcbiAgY2F0ZWdvcnksXG4gIGNsYXNzTmFtZSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJsYi1lbW9qaS1waWNrZXItY2F0ZWdvcnktaGVhZGVyXCIsIGNsYXNzTmFtZSksXG4gICAgLi4ucHJvcHNcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibGItZW1vamktcGlja2VyLWNhdGVnb3J5LWhlYWRlci10aXRsZVwiXG4gIH0sIGNhdGVnb3J5KSk7XG59XG5mdW5jdGlvbiBFbW9qaVBpY2tlckdyaWQoe1xuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lLFxuICAuLi5wcm9wc1xufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhcImxiLWVtb2ppLXBpY2tlci1ncmlkXCIsIGNsYXNzTmFtZSksXG4gICAgLi4ucHJvcHNcbiAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gRW1vamlQaWNrZXJSb3coe1xuICBhdHRyaWJ1dGVzLFxuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCBpc0ZpcnN0Um93ID0gdXNlTWVtbyhcbiAgICAoKSA9PiBhdHRyaWJ1dGVzLmNhdGVnb3J5Um93SW5kZXggPT09IDAsXG4gICAgW2F0dHJpYnV0ZXMuY2F0ZWdvcnlSb3dJbmRleF1cbiAgKTtcbiAgY29uc3QgaXNMYXN0Um93ID0gdXNlTWVtbyhcbiAgICAoKSA9PiBhdHRyaWJ1dGVzLmNhdGVnb3J5Um93SW5kZXggPT09IGF0dHJpYnV0ZXMuY2F0ZWdvcnlSb3dzQ291bnQgLSAxLFxuICAgIFthdHRyaWJ1dGVzLmNhdGVnb3J5Um93SW5kZXgsIGF0dHJpYnV0ZXMuY2F0ZWdvcnlSb3dzQ291bnRdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKFwibGItZW1vamktcGlja2VyLXJvd1wiLCBjbGFzc05hbWUpLFxuICAgIFwiZGF0YS1maXJzdFwiOiBpc0ZpcnN0Um93ID8gXCJcIiA6IHZvaWQgMCxcbiAgICBcImRhdGEtbGFzdFwiOiBpc0xhc3RSb3cgPyBcIlwiIDogdm9pZCAwLFxuICAgIC4uLnByb3BzXG4gIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIEVtb2ppUGlja2VyRW1vamkoe1xuICBlbW9qaSxcbiAgY2xhc3NOYW1lLFxuICAuLi5wcm9wc1xufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhcImxiLWVtb2ppLXBpY2tlci1lbW9qaVwiLCBjbGFzc05hbWUpLFxuICAgIC4uLnByb3BzXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEVtb2ppLCB7XG4gICAgZW1vamlcbiAgfSkpO1xufVxuY29uc3QgRW1vamlQaWNrZXIgPSBmb3J3YXJkUmVmKFxuICAoeyBvbkVtb2ppU2VsZWN0LCBvbk9wZW5DaGFuZ2UsIGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IFtpc09wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgcG9ydGFsQ29udGFpbmVyIH0gPSB1c2VMaXZlYmxvY2tzVUlDb25maWcoKTtcbiAgICBjb25zdCAkID0gdXNlT3ZlcnJpZGVzKCk7XG4gICAgY29uc3QgaGFuZGxlT3BlbkNoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGlzT3BlbjIpID0+IHtcbiAgICAgICAgc2V0T3Blbihpc09wZW4yKTtcbiAgICAgICAgb25PcGVuQ2hhbmdlPy4oaXNPcGVuMik7XG4gICAgICB9LFxuICAgICAgW29uT3BlbkNoYW5nZV1cbiAgICApO1xuICAgIGNvbnN0IGhhbmRsZUVtb2ppU2VsZWN0ID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZW1vamkpID0+IHtcbiAgICAgICAgc2V0T3BlbihmYWxzZSk7XG4gICAgICAgIG9uRW1vamlTZWxlY3Q/LihlbW9qaSk7XG4gICAgICB9LFxuICAgICAgW29uRW1vamlTZWxlY3RdXG4gICAgKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUG9wb3ZlclByaW1pdGl2ZS5Sb290LCB7XG4gICAgICBvcGVuOiBpc09wZW4sXG4gICAgICBvbk9wZW5DaGFuZ2U6IGhhbmRsZU9wZW5DaGFuZ2VcbiAgICB9LCBjaGlsZHJlbiwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUG9wb3ZlclByaW1pdGl2ZS5Qb3J0YWwsIHtcbiAgICAgIGNvbnRhaW5lcjogcG9ydGFsQ29udGFpbmVyXG4gICAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUG9wb3ZlclByaW1pdGl2ZS5Db250ZW50LCB7XG4gICAgICBzaWRlOiBcInRvcFwiLFxuICAgICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgICBzaWRlT2Zmc2V0OiBGTE9BVElOR19FTEVNRU5UX1NJREVfT0ZGU0VULFxuICAgICAgY29sbGlzaW9uUGFkZGluZzogRkxPQVRJTkdfRUxFTUVOVF9DT0xMSVNJT05fUEFERElORyxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhcbiAgICAgICAgXCJsYi1yb290IGxiLXBvcnRhbCBsYi1lbGV2YXRpb24gbGItZW1vamktcGlja2VyXCIsXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKSxcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChFbW9qaVBpY2tlclJvb3QsIHtcbiAgICAgIG9uRW1vamlTZWxlY3Q6IGhhbmRsZUVtb2ppU2VsZWN0LFxuICAgICAgbG9jYWxlOiAkLmxvY2FsZVxuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJsYi1lbW9qaS1waWNrZXItaGVhZGVyXCJcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwibGItZW1vamktcGlja2VyLXNlYXJjaC1jb250YWluZXJcIlxuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEVtb2ppUGlja2VyU2VhcmNoLCB7XG4gICAgICBjbGFzc05hbWU6IFwibGItZW1vamktcGlja2VyLXNlYXJjaFwiLFxuICAgICAgcGxhY2Vob2xkZXI6ICQuRU1PSklfUElDS0VSX1NFQVJDSF9QTEFDRUhPTERFUixcbiAgICAgIGF1dG9Gb2N1czogdHJ1ZVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTZWFyY2hJY29uLCB7XG4gICAgICBjbGFzc05hbWU6IFwibGItZW1vamktcGlja2VyLXNlYXJjaC1pY29uXCJcbiAgICB9KSkpLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChFbW9qaVBpY2tlckNvbnRlbnQsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJsYi1lbW9qaS1waWNrZXItY29udGVudFwiLFxuICAgICAgY29tcG9uZW50czoge1xuICAgICAgICBMb2FkaW5nOiBFbW9qaVBpY2tlckxvYWRpbmcsXG4gICAgICAgIEVtcHR5OiBFbW9qaVBpY2tlckVtcHR5LFxuICAgICAgICBFcnJvcjogRW1vamlQaWNrZXJFcnJvcixcbiAgICAgICAgQ2F0ZWdvcnlIZWFkZXI6IEVtb2ppUGlja2VyQ2F0ZWdvcnlIZWFkZXIsXG4gICAgICAgIEdyaWQ6IEVtb2ppUGlja2VyR3JpZCxcbiAgICAgICAgUm93OiBFbW9qaVBpY2tlclJvdyxcbiAgICAgICAgRW1vamk6IEVtb2ppUGlja2VyRW1vamlcbiAgICAgIH1cbiAgICB9KSkpKSk7XG4gIH1cbik7XG5cbmV4cG9ydCB7IEVtb2ppUGlja2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbW9qaVBpY2tlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/EmojiPicker.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ICON_HEIGHT: () => (/* binding */ ICON_HEIGHT),\n/* harmony export */   ICON_WIDTH: () => (/* binding */ ICON_WIDTH),\n/* harmony export */   Icon: () => (/* binding */ Icon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n\n\n\nconst ICON_WIDTH = 20;\nconst ICON_HEIGHT = 20;\nfunction Icon({ children, className, ...props }) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: ICON_WIDTH,\n    height: ICON_HEIGHT,\n    viewBox: `0 0 ${ICON_WIDTH} ${ICON_HEIGHT}`,\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 1.5,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    role: \"presentation\",\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_1__.classNames)(\"lb-icon\", className),\n    ...props\n  }, children);\n}\n\n\n//# sourceMappingURL=Icon.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0ljb24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1DO0FBQ3NCOztBQUV6RDtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyx5QkFBeUIsZ0RBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZLEVBQUUsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtFQUFVO0FBQ3pCO0FBQ0EsR0FBRztBQUNIOztBQUV5QztBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5tanM/NzJhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3RfX2RlZmF1bHQgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gJy4uLy4uL3V0aWxzL2NsYXNzLW5hbWVzLm1qcyc7XG5cbmNvbnN0IElDT05fV0lEVEggPSAyMDtcbmNvbnN0IElDT05fSEVJR0hUID0gMjA7XG5mdW5jdGlvbiBJY29uKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucHJvcHMgfSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgd2lkdGg6IElDT05fV0lEVEgsXG4gICAgaGVpZ2h0OiBJQ09OX0hFSUdIVCxcbiAgICB2aWV3Qm94OiBgMCAwICR7SUNPTl9XSURUSH0gJHtJQ09OX0hFSUdIVH1gLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VXaWR0aDogMS41LFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKFwibGItaWNvblwiLCBjbGFzc05hbWUpLFxuICAgIC4uLnByb3BzXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZXhwb3J0IHsgSUNPTl9IRUlHSFQsIElDT05fV0lEVEgsIEljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUljb24ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/InboxNotificationThread.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/InboxNotificationThread.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INBOX_NOTIFICATION_THREAD_MAX_COMMENTS: () => (/* binding */ INBOX_NOTIFICATION_THREAD_MAX_COMMENTS),\n/* harmony export */   InboxNotificationComment: () => (/* binding */ InboxNotificationComment),\n/* harmony export */   generateInboxNotificationThreadContents: () => (/* binding */ generateInboxNotificationThreadContents)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _overrides_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../overrides.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\");\n/* harmony import */ var _primitives_Comment_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../primitives/Comment/index.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Comment/index.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* harmony import */ var _Comment_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Comment.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/Comment.mjs\");\n/* harmony import */ var _User_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./User.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/User.mjs\");\n\n\n\n\n\n\n\n\nconst INBOX_NOTIFICATION_THREAD_MAX_COMMENTS = 3;\nfunction InboxNotificationComment({\n  comment,\n  showHeader = true,\n  overrides,\n  className,\n  ...props\n}) {\n  const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_1__.useOverrides)(overrides);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\n      \"lb-root lb-inbox-notification-comment lb-comment\",\n      className\n    ),\n    ...props\n  }, showHeader && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"lb-comment-header\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_User_mjs__WEBPACK_IMPORTED_MODULE_3__.User, {\n    className: \"lb-comment-author\",\n    userId: comment.userId\n  })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"lb-comment-content\"\n  }, comment.body ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_primitives_Comment_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Body, {\n    className: \"lb-comment-body\",\n    body: comment.body,\n    components: {\n      Mention: _Comment_mjs__WEBPACK_IMPORTED_MODULE_5__.CommentMention,\n      Link: _Comment_mjs__WEBPACK_IMPORTED_MODULE_5__.CommentNonInteractiveLink\n    }\n  }), comment.reactions.length > 0 && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"lb-comment-reactions\"\n  }, comment.reactions.map((reaction) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Comment_mjs__WEBPACK_IMPORTED_MODULE_5__.CommentNonInteractiveReaction, {\n    key: reaction.emoji,\n    reaction,\n    overrides,\n    disabled: true\n  })))) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"lb-comment-body\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", {\n    className: \"lb-comment-deleted\"\n  }, $.COMMENT_DELETED))));\n}\nfunction findLastCommentWithMentionedId(comments, mentionedId) {\n  for (let i = comments.length - 1; i >= 0; i--) {\n    const comment = comments[i];\n    if (comment.userId === mentionedId) {\n      continue;\n    }\n    if (comment.body) {\n      const mentionedIds = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_6__.getMentionedIdsFromCommentBody)(comment.body);\n      if (mentionedIds.includes(mentionedId)) {\n        return comment;\n      }\n    }\n  }\n  return;\n}\nfunction getUserIdsFromComments(comments) {\n  return Array.from(new Set(comments.map((comment) => comment.userId)));\n}\nfunction generateInboxNotificationThreadContents(inboxNotification, thread, userId) {\n  const unreadComments = thread.comments.filter((comment) => {\n    if (!comment.body) {\n      return false;\n    }\n    return inboxNotification.readAt ? comment.createdAt > inboxNotification.readAt && comment.createdAt <= inboxNotification.notifiedAt : comment.createdAt <= inboxNotification.notifiedAt;\n  });\n  if (unreadComments.length === 0) {\n    const lastComments = thread.comments.filter((comment) => comment.body).slice(-INBOX_NOTIFICATION_THREAD_MAX_COMMENTS);\n    return {\n      type: \"comments\",\n      unread: false,\n      comments: lastComments,\n      userIds: getUserIdsFromComments(lastComments),\n      date: inboxNotification.notifiedAt\n    };\n  }\n  const commentWithMention = findLastCommentWithMentionedId(\n    unreadComments,\n    userId\n  );\n  if (commentWithMention) {\n    return {\n      type: \"mention\",\n      unread: true,\n      comments: [commentWithMention],\n      userIds: [commentWithMention.userId],\n      date: commentWithMention.createdAt\n    };\n  }\n  const lastUnreadComments = unreadComments.slice(\n    -INBOX_NOTIFICATION_THREAD_MAX_COMMENTS\n  );\n  return {\n    type: \"comments\",\n    unread: true,\n    comments: lastUnreadComments,\n    userIds: getUserIdsFromComments(unreadComments),\n    date: inboxNotification.notifiedAt\n  };\n}\n\n\n//# sourceMappingURL=InboxNotificationThread.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0luYm94Tm90aWZpY2F0aW9uVGhyZWFkLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWtFO0FBQy9CO0FBQ2dCO0FBQ3NCO0FBQ2hCO0FBQ2lEO0FBQ3hFOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZLDREQUFZO0FBQ3hCLHlCQUF5QixnREFBNEI7QUFDckQsZUFBZSxrRUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDLGdEQUE0QjtBQUMvRDtBQUNBLEdBQUcsa0JBQWtCLGdEQUE0QixDQUFDLDJDQUFJO0FBQ3REO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixnREFBNEI7QUFDbkQ7QUFDQSxHQUFHLGlDQUFpQyxnREFBNEIsQ0FBQywyQ0FBdUIsd0JBQXdCLGdEQUE0QixDQUFDLCtEQUFXO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQWM7QUFDN0IsWUFBWSxtRUFBeUI7QUFDckM7QUFDQSxHQUFHLG1EQUFtRCxnREFBNEI7QUFDbEY7QUFDQSxHQUFHLHNEQUFzRCxnREFBNEIsQ0FBQyx1RUFBNkI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHVCQUF1QixnREFBNEI7QUFDdEQ7QUFDQSxHQUFHLGtCQUFrQixnREFBNEI7QUFDakQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0ZBQThCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxSDtBQUNySCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2NvbXBvbmVudHMvaW50ZXJuYWwvSW5ib3hOb3RpZmljYXRpb25UaHJlYWQubWpzPzFmOTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5IH0gZnJvbSAnQGxpdmVibG9ja3MvY29yZSc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlT3ZlcnJpZGVzIH0gZnJvbSAnLi4vLi4vb3ZlcnJpZGVzLm1qcyc7XG5pbXBvcnQgeyBCb2R5IGFzIENvbW1lbnRCb2R5IH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlcy9Db21tZW50L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2xhc3MtbmFtZXMubWpzJztcbmltcG9ydCB7IENvbW1lbnRNZW50aW9uLCBDb21tZW50Tm9uSW50ZXJhY3RpdmVMaW5rLCBDb21tZW50Tm9uSW50ZXJhY3RpdmVSZWFjdGlvbiB9IGZyb20gJy4uL0NvbW1lbnQubWpzJztcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuL1VzZXIubWpzJztcblxuY29uc3QgSU5CT1hfTk9USUZJQ0FUSU9OX1RIUkVBRF9NQVhfQ09NTUVOVFMgPSAzO1xuZnVuY3Rpb24gSW5ib3hOb3RpZmljYXRpb25Db21tZW50KHtcbiAgY29tbWVudCxcbiAgc2hvd0hlYWRlciA9IHRydWUsXG4gIG92ZXJyaWRlcyxcbiAgY2xhc3NOYW1lLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCAkID0gdXNlT3ZlcnJpZGVzKG92ZXJyaWRlcyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKFxuICAgICAgXCJsYi1yb290IGxiLWluYm94LW5vdGlmaWNhdGlvbi1jb21tZW50IGxiLWNvbW1lbnRcIixcbiAgICAgIGNsYXNzTmFtZVxuICAgICksXG4gICAgLi4ucHJvcHNcbiAgfSwgc2hvd0hlYWRlciAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcImxiLWNvbW1lbnQtaGVhZGVyXCJcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVXNlciwge1xuICAgIGNsYXNzTmFtZTogXCJsYi1jb21tZW50LWF1dGhvclwiLFxuICAgIHVzZXJJZDogY29tbWVudC51c2VySWRcbiAgfSkpLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcImxiLWNvbW1lbnQtY29udGVudFwiXG4gIH0sIGNvbW1lbnQuYm9keSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21tZW50Qm9keSwge1xuICAgIGNsYXNzTmFtZTogXCJsYi1jb21tZW50LWJvZHlcIixcbiAgICBib2R5OiBjb21tZW50LmJvZHksXG4gICAgY29tcG9uZW50czoge1xuICAgICAgTWVudGlvbjogQ29tbWVudE1lbnRpb24sXG4gICAgICBMaW5rOiBDb21tZW50Tm9uSW50ZXJhY3RpdmVMaW5rXG4gICAgfVxuICB9KSwgY29tbWVudC5yZWFjdGlvbnMubGVuZ3RoID4gMCAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcImxiLWNvbW1lbnQtcmVhY3Rpb25zXCJcbiAgfSwgY29tbWVudC5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29tbWVudE5vbkludGVyYWN0aXZlUmVhY3Rpb24sIHtcbiAgICBrZXk6IHJlYWN0aW9uLmVtb2ppLFxuICAgIHJlYWN0aW9uLFxuICAgIG92ZXJyaWRlcyxcbiAgICBkaXNhYmxlZDogdHJ1ZVxuICB9KSkpKSA6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwibGItY29tbWVudC1ib2R5XCJcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibGItY29tbWVudC1kZWxldGVkXCJcbiAgfSwgJC5DT01NRU5UX0RFTEVURUQpKSkpO1xufVxuZnVuY3Rpb24gZmluZExhc3RDb21tZW50V2l0aE1lbnRpb25lZElkKGNvbW1lbnRzLCBtZW50aW9uZWRJZCkge1xuICBmb3IgKGxldCBpID0gY29tbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gY29tbWVudHNbaV07XG4gICAgaWYgKGNvbW1lbnQudXNlcklkID09PSBtZW50aW9uZWRJZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb21tZW50LmJvZHkpIHtcbiAgICAgIGNvbnN0IG1lbnRpb25lZElkcyA9IGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShjb21tZW50LmJvZHkpO1xuICAgICAgaWYgKG1lbnRpb25lZElkcy5pbmNsdWRlcyhtZW50aW9uZWRJZCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIGdldFVzZXJJZHNGcm9tQ29tbWVudHMoY29tbWVudHMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChjb21tZW50cy5tYXAoKGNvbW1lbnQpID0+IGNvbW1lbnQudXNlcklkKSkpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbmJveE5vdGlmaWNhdGlvblRocmVhZENvbnRlbnRzKGluYm94Tm90aWZpY2F0aW9uLCB0aHJlYWQsIHVzZXJJZCkge1xuICBjb25zdCB1bnJlYWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5maWx0ZXIoKGNvbW1lbnQpID0+IHtcbiAgICBpZiAoIWNvbW1lbnQuYm9keSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb24ucmVhZEF0ID8gY29tbWVudC5jcmVhdGVkQXQgPiBpbmJveE5vdGlmaWNhdGlvbi5yZWFkQXQgJiYgY29tbWVudC5jcmVhdGVkQXQgPD0gaW5ib3hOb3RpZmljYXRpb24ubm90aWZpZWRBdCA6IGNvbW1lbnQuY3JlYXRlZEF0IDw9IGluYm94Tm90aWZpY2F0aW9uLm5vdGlmaWVkQXQ7XG4gIH0pO1xuICBpZiAodW5yZWFkQ29tbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3QgbGFzdENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLmZpbHRlcigoY29tbWVudCkgPT4gY29tbWVudC5ib2R5KS5zbGljZSgtSU5CT1hfTk9USUZJQ0FUSU9OX1RIUkVBRF9NQVhfQ09NTUVOVFMpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbW1lbnRzXCIsXG4gICAgICB1bnJlYWQ6IGZhbHNlLFxuICAgICAgY29tbWVudHM6IGxhc3RDb21tZW50cyxcbiAgICAgIHVzZXJJZHM6IGdldFVzZXJJZHNGcm9tQ29tbWVudHMobGFzdENvbW1lbnRzKSxcbiAgICAgIGRhdGU6IGluYm94Tm90aWZpY2F0aW9uLm5vdGlmaWVkQXRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNvbW1lbnRXaXRoTWVudGlvbiA9IGZpbmRMYXN0Q29tbWVudFdpdGhNZW50aW9uZWRJZChcbiAgICB1bnJlYWRDb21tZW50cyxcbiAgICB1c2VySWRcbiAgKTtcbiAgaWYgKGNvbW1lbnRXaXRoTWVudGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1lbnRpb25cIixcbiAgICAgIHVucmVhZDogdHJ1ZSxcbiAgICAgIGNvbW1lbnRzOiBbY29tbWVudFdpdGhNZW50aW9uXSxcbiAgICAgIHVzZXJJZHM6IFtjb21tZW50V2l0aE1lbnRpb24udXNlcklkXSxcbiAgICAgIGRhdGU6IGNvbW1lbnRXaXRoTWVudGlvbi5jcmVhdGVkQXRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGxhc3RVbnJlYWRDb21tZW50cyA9IHVucmVhZENvbW1lbnRzLnNsaWNlKFxuICAgIC1JTkJPWF9OT1RJRklDQVRJT05fVEhSRUFEX01BWF9DT01NRU5UU1xuICApO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiY29tbWVudHNcIixcbiAgICB1bnJlYWQ6IHRydWUsXG4gICAgY29tbWVudHM6IGxhc3RVbnJlYWRDb21tZW50cyxcbiAgICB1c2VySWRzOiBnZXRVc2VySWRzRnJvbUNvbW1lbnRzKHVucmVhZENvbW1lbnRzKSxcbiAgICBkYXRlOiBpbmJveE5vdGlmaWNhdGlvbi5ub3RpZmllZEF0XG4gIH07XG59XG5cbmV4cG9ydCB7IElOQk9YX05PVElGSUNBVElPTl9USFJFQURfTUFYX0NPTU1FTlRTLCBJbmJveE5vdGlmaWNhdGlvbkNvbW1lbnQsIGdlbmVyYXRlSW5ib3hOb3RpZmljYXRpb25UaHJlYWRDb250ZW50cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5ib3hOb3RpZmljYXRpb25UaHJlYWQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/InboxNotificationThread.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/List.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/List.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   List: () => (/* binding */ List)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _overrides_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../overrides.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* harmony import */ var _utils_intl_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/intl.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/intl.mjs\");\n\n\n\n\n\n\nconst List = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({ values, formatRemaining, truncate, locale, className, asChild, ...props }, forwardedRef) => {\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_1__.Slot : \"span\";\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_2__.useOverrides)();\n    const formatRemainingWithDefault = formatRemaining ?? $.LIST_REMAINING;\n    const formattedList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n      const elements = truncate && truncate < values.length - 1 ? [\n        ...values.slice(0, truncate),\n        formatRemainingWithDefault(values.length - truncate)\n      ] : [...values];\n      const placeholders = Array(elements.length).fill(\".\");\n      const parts = (0,_utils_intl_mjs__WEBPACK_IMPORTED_MODULE_3__.listFormat)(locale).formatToParts(placeholders);\n      return parts.map(\n        (part) => part.type === \"element\" ? elements.shift() : part.value\n      );\n    }, [formatRemainingWithDefault, locale, truncate, values]);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n      className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__.classNames)(\"lb-list\", className),\n      ...props,\n      ref: forwardedRef\n    }, formattedList);\n  }\n);\n\n\n//# sourceMappingURL=List.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0xpc3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE0QztBQUNnQjtBQUNUO0FBQ007QUFDUDs7QUFFbEQsYUFBYSxpREFBVTtBQUN2QixLQUFLLHlFQUF5RTtBQUM5RSxnQ0FBZ0Msc0RBQUk7QUFDcEMsY0FBYyw0REFBWTtBQUMxQjtBQUNBLDBCQUEwQiw4Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsZ0RBQTRCO0FBQ3ZELGlCQUFpQixrRUFBVTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvY29tcG9uZW50cy9pbnRlcm5hbC9MaXN0Lm1qcz80MGM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsb3QgfSBmcm9tICdAcmFkaXgtdWkvcmVhY3Qtc2xvdCc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgZm9yd2FyZFJlZiwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZU92ZXJyaWRlcyB9IGZyb20gJy4uLy4uL292ZXJyaWRlcy5tanMnO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gJy4uLy4uL3V0aWxzL2NsYXNzLW5hbWVzLm1qcyc7XG5pbXBvcnQgeyBsaXN0Rm9ybWF0IH0gZnJvbSAnLi4vLi4vdXRpbHMvaW50bC5tanMnO1xuXG5jb25zdCBMaXN0ID0gZm9yd2FyZFJlZihcbiAgKHsgdmFsdWVzLCBmb3JtYXRSZW1haW5pbmcsIHRydW5jYXRlLCBsb2NhbGUsIGNsYXNzTmFtZSwgYXNDaGlsZCwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gYXNDaGlsZCA/IFNsb3QgOiBcInNwYW5cIjtcbiAgICBjb25zdCAkID0gdXNlT3ZlcnJpZGVzKCk7XG4gICAgY29uc3QgZm9ybWF0UmVtYWluaW5nV2l0aERlZmF1bHQgPSBmb3JtYXRSZW1haW5pbmcgPz8gJC5MSVNUX1JFTUFJTklORztcbiAgICBjb25zdCBmb3JtYXR0ZWRMaXN0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IHRydW5jYXRlICYmIHRydW5jYXRlIDwgdmFsdWVzLmxlbmd0aCAtIDEgPyBbXG4gICAgICAgIC4uLnZhbHVlcy5zbGljZSgwLCB0cnVuY2F0ZSksXG4gICAgICAgIGZvcm1hdFJlbWFpbmluZ1dpdGhEZWZhdWx0KHZhbHVlcy5sZW5ndGggLSB0cnVuY2F0ZSlcbiAgICAgIF0gOiBbLi4udmFsdWVzXTtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IEFycmF5KGVsZW1lbnRzLmxlbmd0aCkuZmlsbChcIi5cIik7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpc3RGb3JtYXQobG9jYWxlKS5mb3JtYXRUb1BhcnRzKHBsYWNlaG9sZGVycyk7XG4gICAgICByZXR1cm4gcGFydHMubWFwKFxuICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImVsZW1lbnRcIiA/IGVsZW1lbnRzLnNoaWZ0KCkgOiBwYXJ0LnZhbHVlXG4gICAgICApO1xuICAgIH0sIFtmb3JtYXRSZW1haW5pbmdXaXRoRGVmYXVsdCwgbG9jYWxlLCB0cnVuY2F0ZSwgdmFsdWVzXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKFwibGItbGlzdFwiLCBjbGFzc05hbWUpLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgIH0sIGZvcm1hdHRlZExpc3QpO1xuICB9XG4pO1xuXG5leHBvcnQgeyBMaXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaXN0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/List.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Room.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Room.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Room: () => (/* binding */ Room)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* __next_internal_client_entry_do_not_use__ Room auto */ \n\n\nfunction Room({ roomId, className, ...props }) {\n    const { info, isLoading } = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_1__.useRoomInfo)(roomId);\n    const resolvedRoomName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return info?.name ?? roomId;\n    }, [\n        info?.name,\n        roomId\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-name lb-room\", className),\n        \"data-loading\": isLoading ? \"\" : void 0,\n        ...props\n    }, isLoading ? null : resolvedRoomName);\n}\n //# sourceMappingURL=Room.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL1Jvb20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFZTyxTQUFBQSxLQUFBLEVBQUFDLE1BQUEsRUFBQUMsU0FBQSxLQUFBQyxPQUFBO0lBQ0wsUUFBQUMsSUFBQSxFQUFBQyxTQUFBLEtBQUFDLDhEQUFBQSxDQUFBTDtJQUNBLE1BQUFNLG1CQUFBQyw4Q0FBQUEsQ0FBQTtRQUNFLE9BQUFKLE1BQUFLLFFBQUFSO0lBQXFCO1FBQUFHLE1BQUFLO1FBQUFSO0tBQUE7SUFHdkIscUNBQUFTLGdEQUFBO1FBQ0dSLFdBQUFVLGtFQUFBQSxDQUFBLG1CQUFBVjtRQUNtRCxnQkFBQUcsWUFBQTtRQUNuQixHQUFBRixLQUFBO0lBQzNCLEdBQUFFLFlBQUEsT0FBQUU7QUFLViIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9pbnRlcm5hbC9Sb29tLnRzeD9hMTNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VSb29tSW5mbyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRQcm9wcyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCIuLi8uLi91dGlscy9jbGFzcy1uYW1lc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvb21Qcm9wcyBleHRlbmRzIENvbXBvbmVudFByb3BzPFwic3BhblwiPiB7XG4gIHJvb21JZDogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUm9vbSh7IHJvb21JZCwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9OiBSb29tUHJvcHMpIHtcbiAgY29uc3QgeyBpbmZvLCBpc0xvYWRpbmcgfSA9IHVzZVJvb21JbmZvKHJvb21JZCk7XG4gIGNvbnN0IHJlc29sdmVkUm9vbU5hbWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gaW5mbz8ubmFtZSA/PyByb29tSWQ7XG4gIH0sIFtpbmZvPy5uYW1lLCByb29tSWRdKTtcblxuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJsYi1uYW1lIGxiLXJvb21cIiwgY2xhc3NOYW1lKX1cbiAgICAgIGRhdGEtbG9hZGluZz17aXNMb2FkaW5nID8gXCJcIiA6IHVuZGVmaW5lZH1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICB7aXNMb2FkaW5nID8gbnVsbCA6IHJlc29sdmVkUm9vbU5hbWV9XG4gICAgPC9zcGFuPlxuICApO1xufVxuIl0sIm5hbWVzIjpbIlJvb20iLCJyb29tSWQiLCJjbGFzc05hbWUiLCJwcm9wcyIsImluZm8iLCJpc0xvYWRpbmciLCJ1c2VSb29tSW5mbyIsInJlc29sdmVkUm9vbU5hbWUiLCJ1c2VNZW1vIiwibmFtZSIsIlJlYWN0X19kZWZhdWx0IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Room.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShortcutTooltip: () => (/* binding */ ShortcutTooltip),\n/* harmony export */   ShortcutTooltipKey: () => (/* binding */ ShortcutTooltipKey),\n/* harmony export */   Tooltip: () => (/* binding */ Tooltip),\n/* harmony export */   TooltipProvider: () => (/* reexport safe */ _radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_0__.TooltipProvider)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @radix-ui/react-tooltip */ \"(ssr)/./node_modules/@radix-ui/react-tooltip/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../config.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/config.mjs\");\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../constants.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* harmony import */ var _utils_is_apple_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/is-apple.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-apple.mjs\");\n/* __next_internal_client_entry_do_not_use__ TooltipProvider,ShortcutTooltip,ShortcutTooltipKey,Tooltip auto */ \n\n\n\n\n\n\nconst KEYS = {\n    alt: ()=>({\n            title: \"Alt\",\n            key: \"\"\n        }),\n    mod: ()=>(0,_utils_is_apple_mjs__WEBPACK_IMPORTED_MODULE_2__.isApple)() ? {\n            title: \"Command\",\n            key: \"\"\n        } : {\n            title: \"Ctrl\",\n            key: \"\"\n        },\n    shift: ()=>{\n        return {\n            title: \"Shift\",\n            key: \"\"\n        };\n    },\n    enter: ()=>{\n        return {\n            title: \"Enter\",\n            key: \"\"\n        };\n    }\n};\nconst Tooltip = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ children, content, multiline, className, ...props }, forwardedRef)=>{\n    const { portalContainer } = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_3__.useLiveblocksUIConfig)();\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_0__.Root, {\n        disableHoverableContent: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_0__.Trigger, {\n        asChild: true,\n        ref: forwardedRef\n    }, children), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_0__.Portal, {\n        container: portalContainer\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_0__.Content, {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_4__.classNames)(\"lb-root lb-portal lb-tooltip\", multiline && \"lb-tooltip:multiline\", className),\n        side: \"top\",\n        align: \"center\",\n        sideOffset: _constants_mjs__WEBPACK_IMPORTED_MODULE_5__.FLOATING_ELEMENT_SIDE_OFFSET,\n        collisionPadding: _constants_mjs__WEBPACK_IMPORTED_MODULE_5__.FLOATING_ELEMENT_COLLISION_PADDING,\n        ...props\n    }, content)));\n});\nconst ShortcutTooltip = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ children, content, shortcut, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Tooltip, {\n        content: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, content, shortcut && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"kbd\", {\n            className: \"lb-tooltip-shortcut\"\n        }, shortcut)),\n        ...props,\n        ref: forwardedRef\n    }, children);\n});\nfunction ShortcutTooltipKey({ name, ...props }) {\n    const { title, key } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>KEYS[name]?.(), [\n        name\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"abbr\", {\n        title,\n        ...props\n    }, key);\n}\n //# sourceMappingURL=Tooltip.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL1Rvb2x0aXAubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBY0EsTUFBQUEsT0FBQTtJQUFhQyxLQUFBO1lBQUFDLE9BQUE7WUFBQUMsS0FBQTtRQUFBO0lBQzBCQyxLQUFBLElBQUFDLDREQUFBQSxLQUFBO1lBQUFILE9BQUE7WUFBQUMsS0FBQTtRQUFBO1lBQUFELE9BQUE7WUFBQUMsS0FBQTtRQUFBO0lBRW9DRyxPQUFBO1FBRXZFO1lBQUFKLE9BQUE7WUFBQUMsS0FBQTtRQUFBO0lBQWtDO0lBQ3BDSSxPQUFBO1FBRUU7WUFBQUwsT0FBQTtZQUFBQyxLQUFBO1FBQUE7SUFBa0M7QUFFdEM7QUFpQk8sTUFBQUssd0JBQUFDLGlEQUFBQSxDQUFnQixHQUFBQyxRQUFBLEVBQUFDLE9BQUEsRUFBQUMsU0FBQSxFQUFBQyxTQUFBLEtBQUFDLE9BQUEsRUFBQUM7SUFFbkIsUUFBQUMsZUFBQSxLQUFBQyxrRUFBQUE7SUFFQSxxQ0FBQUMsZ0RBQUEsQ0FBQUUseURBQUE7UUFDR0UseUJBQUE7SUFBNkMsaUNBQUFKLGdEQUFBLENBQUFFLDREQUFBO1FBQzNDSSxTQUFBO1FBQWdDQyxLQUFBVjtJQUFNLEdBQUFMLFdBQUEsOEJBQUFRLGdEQUFBLENBQUFFLDJEQUFBO1FBR3RDTyxXQUFBWDtJQUFtQyxpQ0FBQUUsZ0RBQUEsQ0FBQUUsNERBQUE7UUFDakNQLFdBQUFnQixrRUFBQUEsQ0FDWSxnQ0FDVGpCLGFBQUEsd0JBQ2FDO1FBRWZpQixNQUFBO1FBQ0tDLE9BQUE7UUFDQ0MsWUFBQUMsd0VBQUFBO1FBQ01DLGtCQUFBQyw4RUFBQUE7UUFDTSxHQUFBckIsS0FBQTtJQUNkLEdBQUFIO0FBS1Y7QUFLTyxNQUFBeUIsZ0NBQUEzQixpREFBQUEsQ0FBQSxHQUFBQyxRQUFBLEVBQUFDLE9BQUEsRUFBQTBCLFFBQUEsS0FBQXZCLE9BQUEsRUFBQUM7SUFJWCxxQ0FBQUcsZ0RBQUEsQ0FBQVYsU0FBQTtRQUNHRyxTQUFBLDhCQUFBTyxnREFBQSxDQUFBQSwyQ0FBQSxRQUFBUCxTQUFBMEIsWUFBQSw4QkFBQW5CLGdEQUFBO1lBSW1CTCxXQUFBO1FBQWMsR0FBQXdCO1FBQzlCLEdBQUF2QixLQUFBO1FBRUVXLEtBQUFWO0lBQ0MsR0FBQUw7QUFLWDtBQUVPLFNBQUE2QixtQkFBQSxFQUE0QkMsSUFBQSxFQUNqQyxHQUFBMUIsT0FFRjtJQUNFLFFBQUFaLEtBQUEsRUFBQUMsR0FBQSxLQUFBc0MsOENBQUFBLENBQUEsSUFBQXpDLElBQUEsQ0FBQXdDLEtBQUE7UUFBQUE7S0FBQTtJQUVBLHFDQUFBdEIsZ0RBQUE7UUFDR2hCO1FBQUssR0FBQVksS0FBQTtJQUFrQixHQUFBWDtBQUk1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9pbnRlcm5hbC9Ub29sdGlwLnRzeD9mYzMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgKiBhcyBUb29sdGlwUHJpbWl0aXZlIGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdG9vbHRpcFwiO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRQcm9wcywgUmVhY3ROb2RlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB1c2VMaXZlYmxvY2tzVUlDb25maWcgfSBmcm9tIFwiLi4vLi4vY29uZmlnXCI7XG5pbXBvcnQge1xuICBGTE9BVElOR19FTEVNRU5UX0NPTExJU0lPTl9QQURESU5HLFxuICBGTE9BVElOR19FTEVNRU5UX1NJREVfT0ZGU0VULFxufSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2NsYXNzLW5hbWVzXCI7XG5pbXBvcnQgeyBpc0FwcGxlIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2lzLWFwcGxlXCI7XG5cbmNvbnN0IEtFWVMgPSB7XG4gIGFsdDogKCkgPT4gKHsgdGl0bGU6IFwiQWx0XCIsIGtleTogXCLijKVcIiB9KSxcbiAgbW9kOiAoKSA9PlxuICAgIGlzQXBwbGUoKSA/IHsgdGl0bGU6IFwiQ29tbWFuZFwiLCBrZXk6IFwi4oyYXCIgfSA6IHsgdGl0bGU6IFwiQ3RybFwiLCBrZXk6IFwi4oyDXCIgfSxcbiAgc2hpZnQ6ICgpID0+IHtcbiAgICByZXR1cm4geyB0aXRsZTogXCJTaGlmdFwiLCBrZXk6IFwi4oenXCIgfTtcbiAgfSxcbiAgZW50ZXI6ICgpID0+IHtcbiAgICByZXR1cm4geyB0aXRsZTogXCJFbnRlclwiLCBrZXk6IFwi4o+OXCIgfTtcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbHRpcFByb3BzXG4gIGV4dGVuZHMgUGljazxUb29sdGlwUHJpbWl0aXZlLlRvb2x0aXBUcmlnZ2VyUHJvcHMsIFwiY2hpbGRyZW5cIj4sXG4gICAgT21pdDxUb29sdGlwUHJpbWl0aXZlLlRvb2x0aXBDb250ZW50UHJvcHMsIFwiY29udGVudFwiPiB7XG4gIGNvbnRlbnQ6IFJlYWN0Tm9kZTtcbiAgbXVsdGlsaW5lPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaG9ydGN1dFRvb2x0aXBQcm9wcyBleHRlbmRzIFRvb2x0aXBQcm9wcyB7XG4gIHNob3J0Y3V0PzogUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNob3J0Y3V0VG9vbHRpcEtleVByb3BzIGV4dGVuZHMgQ29tcG9uZW50UHJvcHM8XCJhYmJyXCI+IHtcbiAgbmFtZToga2V5b2YgdHlwZW9mIEtFWVM7XG59XG5cbmV4cG9ydCBjb25zdCBUb29sdGlwID0gZm9yd2FyZFJlZjxIVE1MQnV0dG9uRWxlbWVudCwgVG9vbHRpcFByb3BzPihcbiAgKHsgY2hpbGRyZW4sIGNvbnRlbnQsIG11bHRpbGluZSwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IHBvcnRhbENvbnRhaW5lciB9ID0gdXNlTGl2ZWJsb2Nrc1VJQ29uZmlnKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFRvb2x0aXBQcmltaXRpdmUuUm9vdCBkaXNhYmxlSG92ZXJhYmxlQ29udGVudD5cbiAgICAgICAgPFRvb2x0aXBQcmltaXRpdmUuVHJpZ2dlciBhc0NoaWxkIHJlZj17Zm9yd2FyZGVkUmVmfT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvVG9vbHRpcFByaW1pdGl2ZS5UcmlnZ2VyPlxuICAgICAgICA8VG9vbHRpcFByaW1pdGl2ZS5Qb3J0YWwgY29udGFpbmVyPXtwb3J0YWxDb250YWluZXJ9PlxuICAgICAgICAgIDxUb29sdGlwUHJpbWl0aXZlLkNvbnRlbnRcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgXCJsYi1yb290IGxiLXBvcnRhbCBsYi10b29sdGlwXCIsXG4gICAgICAgICAgICAgIG11bHRpbGluZSAmJiBcImxiLXRvb2x0aXA6bXVsdGlsaW5lXCIsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHNpZGU9XCJ0b3BcIlxuICAgICAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICAgICAgc2lkZU9mZnNldD17RkxPQVRJTkdfRUxFTUVOVF9TSURFX09GRlNFVH1cbiAgICAgICAgICAgIGNvbGxpc2lvblBhZGRpbmc9e0ZMT0FUSU5HX0VMRU1FTlRfQ09MTElTSU9OX1BBRERJTkd9XG4gICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgPC9Ub29sdGlwUHJpbWl0aXZlLkNvbnRlbnQ+XG4gICAgICAgIDwvVG9vbHRpcFByaW1pdGl2ZS5Qb3J0YWw+XG4gICAgICA8L1Rvb2x0aXBQcmltaXRpdmUuUm9vdD5cbiAgICApO1xuICB9XG4pO1xuXG5leHBvcnQgY29uc3QgU2hvcnRjdXRUb29sdGlwID0gZm9yd2FyZFJlZjxcbiAgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gIFNob3J0Y3V0VG9vbHRpcFByb3BzXG4+KCh7IGNoaWxkcmVuLCBjb250ZW50LCBzaG9ydGN1dCwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPFRvb2x0aXBcbiAgICAgIGNvbnRlbnQ9e1xuICAgICAgICA8PlxuICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgIHtzaG9ydGN1dCAmJiA8a2JkIGNsYXNzTmFtZT1cImxiLXRvb2x0aXAtc2hvcnRjdXRcIj57c2hvcnRjdXR9PC9rYmQ+fVxuICAgICAgICA8Lz5cbiAgICAgIH1cbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1Rvb2x0aXA+XG4gICk7XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIFNob3J0Y3V0VG9vbHRpcEtleSh7XG4gIG5hbWUsXG4gIC4uLnByb3BzXG59OiBTaG9ydGN1dFRvb2x0aXBLZXlQcm9wcykge1xuICBjb25zdCB7IHRpdGxlLCBrZXkgfSA9IHVzZU1lbW8oKCkgPT4gS0VZU1tuYW1lXT8uKCksIFtuYW1lXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8YWJiciB0aXRsZT17dGl0bGV9IHsuLi5wcm9wc30+XG4gICAgICB7a2V5fVxuICAgIDwvYWJicj5cbiAgKTtcbn1cblxuZXhwb3J0IHsgVG9vbHRpcFByb3ZpZGVyIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC10b29sdGlwXCI7XG4iXSwibmFtZXMiOlsiS0VZUyIsImFsdCIsInRpdGxlIiwia2V5IiwibW9kIiwiaXNBcHBsZSIsInNoaWZ0IiwiZW50ZXIiLCJUb29sdGlwIiwiZm9yd2FyZFJlZiIsImNoaWxkcmVuIiwiY29udGVudCIsIm11bHRpbGluZSIsImNsYXNzTmFtZSIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwicG9ydGFsQ29udGFpbmVyIiwidXNlTGl2ZWJsb2Nrc1VJQ29uZmlnIiwiUmVhY3RfX2RlZmF1bHQiLCJjcmVhdGVFbGVtZW50IiwiVG9vbHRpcFByaW1pdGl2ZSIsIlJvb3QiLCJkaXNhYmxlSG92ZXJhYmxlQ29udGVudCIsIlRyaWdnZXIiLCJhc0NoaWxkIiwicmVmIiwiUG9ydGFsIiwiY29udGFpbmVyIiwiQ29udGVudCIsImNsYXNzTmFtZXMiLCJzaWRlIiwiYWxpZ24iLCJzaWRlT2Zmc2V0IiwiRkxPQVRJTkdfRUxFTUVOVF9TSURFX09GRlNFVCIsImNvbGxpc2lvblBhZGRpbmciLCJGTE9BVElOR19FTEVNRU5UX0NPTExJU0lPTl9QQURESU5HIiwiU2hvcnRjdXRUb29sdGlwIiwic2hvcnRjdXQiLCJGcmFnbWVudCIsIlNob3J0Y3V0VG9vbHRpcEtleSIsIm5hbWUiLCJ1c2VNZW1vIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/User.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/User.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   User: () => (/* binding */ User)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _overrides_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../overrides.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\");\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/shared.mjs\");\n/* harmony import */ var _utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/capitalize.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/capitalize.mjs\");\n/* harmony import */ var _utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/class-names.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\");\n/* __next_internal_client_entry_do_not_use__ User auto */ \n\n\n\n\n\nfunction User({ userId, replaceSelf, capitalize: shouldCapitalize, className, ...props }) {\n    const currentId = (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_1__.useCurrentUserId)();\n    const { user, isLoading } = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__._useUser)(userId);\n    const $ = (0,_overrides_mjs__WEBPACK_IMPORTED_MODULE_3__.useOverrides)();\n    const resolvedUserName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const name = replaceSelf && currentId === userId ? $.USER_SELF : user?.name ?? $.USER_UNKNOWN;\n        return shouldCapitalize ? (0,_utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_4__.capitalize)(name) : name;\n    }, [\n        replaceSelf,\n        currentId,\n        userId,\n        $.USER_SELF,\n        $.USER_UNKNOWN,\n        user?.name,\n        shouldCapitalize\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: (0,_utils_class_names_mjs__WEBPACK_IMPORTED_MODULE_5__.classNames)(\"lb-name lb-user\", className),\n        \"data-loading\": isLoading ? \"\" : void 0,\n        ...props\n    }, isLoading ? null : resolvedUserName);\n}\n //# sourceMappingURL=User.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL1VzZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0Qk8sU0FBQUEsS0FBQSxFQUFjQyxNQUFBLEVBQ25CQyxXQUFBLEVBQ0FDLFlBQUFDLGdCQUFBLEVBQ1lDLFNBQUEsRUFDWixHQUFBQyxPQUVGO0lBQ0UsTUFBQUMsWUFBQUMsNkRBQUFBO0lBQ0EsUUFBQUMsSUFBQSxFQUFBQyxTQUFBLEtBQUFDLDJEQUFBQSxDQUFBVjtJQUNBLE1BQUFXLElBQUFDLDREQUFBQTtJQUNBLE1BQUFDLG1CQUFBQyw4Q0FBQUEsQ0FBQTtRQUNFLE1BQUFDLE9BQUFkLGVBQUFLLGNBQUFOLFNBQUFXLEVBQUFLLFNBQUEsR0FBQVIsTUFBQU8sUUFBQUosRUFBQU0sWUFBQTtRQUtBLE9BQUFkLG1CQUFBRCxpRUFBQUEsQ0FBQWEsUUFBQUE7SUFBNkM7UUFDNUNkO1FBQ0RLO1FBQ0FOO1FBQ0FXLEVBQUFLLFNBQUE7UUFDRUwsRUFBQU0sWUFBQTtRQUNBVCxNQUFBTztRQUNJWjtLQUNOO0lBR0YscUNBQUFlLGdEQUFBO1FBQ0dkLFdBQUFnQixrRUFBQUEsQ0FBQSxtQkFBQWhCO1FBQ21ELGdCQUFBSyxZQUFBO1FBQ25CLEdBQUFKLEtBQUE7SUFDM0IsR0FBQUksWUFBQSxPQUFBSTtBQUtWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2ludGVybmFsL1VzZXIudHN4P2U4YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVVzZXIgfSBmcm9tIFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50UHJvcHMgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IHVzZU92ZXJyaWRlcyB9IGZyb20gXCIuLi8uLi9vdmVycmlkZXNcIjtcbmltcG9ydCB7IHVzZUN1cnJlbnRVc2VySWQgfSBmcm9tIFwiLi4vLi4vc2hhcmVkXCI7XG5pbXBvcnQgeyBjYXBpdGFsaXplIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2NhcGl0YWxpemVcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvY2xhc3MtbmFtZXNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VyUHJvcHMgZXh0ZW5kcyBDb21wb25lbnRQcm9wczxcInNwYW5cIj4ge1xuICAvKipcbiAgICogVGhlIHVzZXIgSUQgdG8gZGlzcGxheSB0aGUgdXNlciBuYW1lIGZvci5cbiAgICovXG4gIHVzZXJJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlcGxhY2UgdGhlIHVzZXIgbmFtZSB3aXRoIFwieW91XCIgKCQuVVNFUl9TRUxGKSBmb3IgdGhlIGN1cnJlbnQgdXNlci5cbiAgICovXG4gIHJlcGxhY2VTZWxmPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBjYXBpdGFsaXplIHRoZSB1c2VyIG5hbWUuXG4gICAqL1xuICBjYXBpdGFsaXplPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFVzZXIoe1xuICB1c2VySWQsXG4gIHJlcGxhY2VTZWxmLFxuICBjYXBpdGFsaXplOiBzaG91bGRDYXBpdGFsaXplLFxuICBjbGFzc05hbWUsXG4gIC4uLnByb3BzXG59OiBVc2VyUHJvcHMpIHtcbiAgY29uc3QgY3VycmVudElkID0gdXNlQ3VycmVudFVzZXJJZCgpO1xuICBjb25zdCB7IHVzZXIsIGlzTG9hZGluZyB9ID0gdXNlVXNlcih1c2VySWQpO1xuICBjb25zdCAkID0gdXNlT3ZlcnJpZGVzKCk7XG4gIGNvbnN0IHJlc29sdmVkVXNlck5hbWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBuYW1lID1cbiAgICAgIHJlcGxhY2VTZWxmICYmIGN1cnJlbnRJZCA9PT0gdXNlcklkXG4gICAgICAgID8gJC5VU0VSX1NFTEZcbiAgICAgICAgOiB1c2VyPy5uYW1lID8/ICQuVVNFUl9VTktOT1dOO1xuXG4gICAgcmV0dXJuIHNob3VsZENhcGl0YWxpemUgPyBjYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcbiAgfSwgW1xuICAgIHJlcGxhY2VTZWxmLFxuICAgIGN1cnJlbnRJZCxcbiAgICB1c2VySWQsXG4gICAgJC5VU0VSX1NFTEYsXG4gICAgJC5VU0VSX1VOS05PV04sXG4gICAgdXNlcj8ubmFtZSxcbiAgICBzaG91bGRDYXBpdGFsaXplLFxuICBdKTtcblxuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJsYi1uYW1lIGxiLXVzZXJcIiwgY2xhc3NOYW1lKX1cbiAgICAgIGRhdGEtbG9hZGluZz17aXNMb2FkaW5nID8gXCJcIiA6IHVuZGVmaW5lZH1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICB7aXNMb2FkaW5nID8gbnVsbCA6IHJlc29sdmVkVXNlck5hbWV9XG4gICAgPC9zcGFuPlxuICApO1xufVxuIl0sIm5hbWVzIjpbIlVzZXIiLCJ1c2VySWQiLCJyZXBsYWNlU2VsZiIsImNhcGl0YWxpemUiLCJzaG91bGRDYXBpdGFsaXplIiwiY2xhc3NOYW1lIiwicHJvcHMiLCJjdXJyZW50SWQiLCJ1c2VDdXJyZW50VXNlcklkIiwidXNlciIsImlzTG9hZGluZyIsInVzZVVzZXIiLCIkIiwidXNlT3ZlcnJpZGVzIiwicmVzb2x2ZWRVc2VyTmFtZSIsInVzZU1lbW8iLCJuYW1lIiwiVVNFUl9TRUxGIiwiVVNFUl9VTktOT1dOIiwiUmVhY3RfX2RlZmF1bHQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/User.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/config.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/config.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveblocksUIConfig: () => (/* binding */ LiveblocksUIConfig),\n/* harmony export */   useLiveblocksUIConfig: () => (/* binding */ useLiveblocksUIConfig)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components.mjs\");\n/* harmony import */ var _overrides_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./overrides.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\");\n/* __next_internal_client_entry_do_not_use__ LiveblocksUIConfig,useLiveblocksUIConfig auto */ \n\n\nconst LiveblocksUIConfigContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction useLiveblocksUIConfig() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LiveblocksUIConfigContext);\n}\nfunction LiveblocksUIConfig({ overrides, components, portalContainer, children }) {\n    const liveblocksUIConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            portalContainer\n        }), [\n        portalContainer\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiveblocksUIConfigContext.Provider, {\n        value: liveblocksUIConfig\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_overrides_mjs__WEBPACK_IMPORTED_MODULE_1__.OverridesProvider, {\n        overrides\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentsProvider, {\n        components\n    }, children)));\n}\n //# sourceMappingURL=config.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb25maWcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBOEJBLE1BQUFBLDBDQUFBQyxvREFBQUEsQ0FBQTtBQUVPLFNBQUFDO0lBQ0wsT0FBQUMsaURBQUFBLENBQUFIO0FBQ0Y7QUFVTyxTQUFBSSxtQkFBQSxFQUE0QkMsU0FBQSxFQUNqQ0MsVUFBQSxFQUNBQyxlQUFBLEVBQ0FDLFFBQUEsRUFFRjtJQUNFLE1BQUFDLHFCQUFBQyw4Q0FBQUEsQ0FBMkI7WUFBQUg7UUFBQSxJQUNBO1FBQUFBO0tBQUE7SUFJM0IscUNBQUFJLGdEQUFBLENBQUFYLDBCQUFBYSxRQUFBO1FBQ0dDLE9BQUFMO0lBQTBDLGlDQUFBRSxnREFBQSxDQUFBSSw2REFBQUEsRUFBQTtRQUN4Q1Y7SUFBa0IsaUNBQUFNLGdEQUFBLENBQUFLLCtEQUFBQSxFQUFBO1FBQ2hCVjtJQUFtQixHQUFBRTtBQU01QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uLi9zcmMvY29uZmlnLnRzeD85ZmMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgdHlwZSB7IFByb3BzV2l0aENoaWxkcmVuIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB0eXBlIENvbXBvbmVudHMsIENvbXBvbmVudHNQcm92aWRlciB9IGZyb20gXCIuL2NvbXBvbmVudHNcIjtcbmltcG9ydCB0eXBlIHsgT3ZlcnJpZGVzIH0gZnJvbSBcIi4vb3ZlcnJpZGVzXCI7XG5pbXBvcnQgeyBPdmVycmlkZXNQcm92aWRlciB9IGZyb20gXCIuL292ZXJyaWRlc1wiO1xuXG50eXBlIExpdmVibG9ja3NVSUNvbmZpZ1Byb3BzID0gUHJvcHNXaXRoQ2hpbGRyZW48e1xuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGNvbXBvbmVudHMnIHN0cmluZ3MuXG4gICAqL1xuICBvdmVycmlkZXM/OiBQYXJ0aWFsPE92ZXJyaWRlcz47XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBjb21wb25lbnRzJyBjb21wb25lbnRzLlxuICAgKi9cbiAgY29tcG9uZW50cz86IFBhcnRpYWw8Q29tcG9uZW50cz47XG5cbiAgLyoqXG4gICAqIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHRoZSBwb3J0YWwgaW50by5cbiAgICovXG4gIHBvcnRhbENvbnRhaW5lcj86IEhUTUxFbGVtZW50O1xufT47XG5cbmludGVyZmFjZSBMaXZlYmxvY2tzVUlDb25maWdDb250ZXh0IHtcbiAgcG9ydGFsQ29udGFpbmVyPzogSFRNTEVsZW1lbnQ7XG59XG5cbmNvbnN0IExpdmVibG9ja3NVSUNvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PExpdmVibG9ja3NVSUNvbmZpZ0NvbnRleHQ+KHt9KTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpdmVibG9ja3NVSUNvbmZpZygpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoTGl2ZWJsb2Nrc1VJQ29uZmlnQ29udGV4dCk7XG59XG5cbi8qKlxuICogU2V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYWxsIGNvbXBvbmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxMaXZlYmxvY2tzVUlDb25maWcgb3ZlcnJpZGVzPXt7IGxvY2FsZTogXCJmclwiLCBVU0VSX1VOS05PV046IFwiQW5vbnltZVwiLCAuLi4gfX0+XG4gKiAgIDxBcHAgLz5cbiAqIDwvTGl2ZWJsb2Nrc1VJQ29uZmlnPlxuICovXG5leHBvcnQgZnVuY3Rpb24gTGl2ZWJsb2Nrc1VJQ29uZmlnKHtcbiAgb3ZlcnJpZGVzLFxuICBjb21wb25lbnRzLFxuICBwb3J0YWxDb250YWluZXIsXG4gIGNoaWxkcmVuLFxufTogTGl2ZWJsb2Nrc1VJQ29uZmlnUHJvcHMpIHtcbiAgY29uc3QgbGl2ZWJsb2Nrc1VJQ29uZmlnID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoeyBwb3J0YWxDb250YWluZXIgfSksXG4gICAgW3BvcnRhbENvbnRhaW5lcl1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxMaXZlYmxvY2tzVUlDb25maWdDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtsaXZlYmxvY2tzVUlDb25maWd9PlxuICAgICAgPE92ZXJyaWRlc1Byb3ZpZGVyIG92ZXJyaWRlcz17b3ZlcnJpZGVzfT5cbiAgICAgICAgPENvbXBvbmVudHNQcm92aWRlciBjb21wb25lbnRzPXtjb21wb25lbnRzfT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvQ29tcG9uZW50c1Byb3ZpZGVyPlxuICAgICAgPC9PdmVycmlkZXNQcm92aWRlcj5cbiAgICA8L0xpdmVibG9ja3NVSUNvbmZpZ0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiTGl2ZWJsb2Nrc1VJQ29uZmlnQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VMaXZlYmxvY2tzVUlDb25maWciLCJ1c2VDb250ZXh0IiwiTGl2ZWJsb2Nrc1VJQ29uZmlnIiwib3ZlcnJpZGVzIiwiY29tcG9uZW50cyIsInBvcnRhbENvbnRhaW5lciIsImNoaWxkcmVuIiwibGl2ZWJsb2Nrc1VJQ29uZmlnIiwidXNlTWVtbyIsIlJlYWN0X19kZWZhdWx0IiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiLCJPdmVycmlkZXNQcm92aWRlciIsIkNvbXBvbmVudHNQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/config.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/constants.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMOJI_FONT_FAMILY: () => (/* binding */ EMOJI_FONT_FAMILY),\n/* harmony export */   FLOATING_ELEMENT_COLLISION_PADDING: () => (/* binding */ FLOATING_ELEMENT_COLLISION_PADDING),\n/* harmony export */   FLOATING_ELEMENT_SIDE_OFFSET: () => (/* binding */ FLOATING_ELEMENT_SIDE_OFFSET)\n/* harmony export */ });\nconst FLOATING_ELEMENT_SIDE_OFFSET = 6;\nconst FLOATING_ELEMENT_COLLISION_PADDING = 10;\nconst EMOJI_FONT_FAMILY = \"'Apple Color Emoji', 'Noto Color Emoji', 'Twemoji Mozilla', 'Android Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', EmojiSymbols, sans-serif\";\n\n\n//# sourceMappingURL=constants.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb25zdGFudHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFK0Y7QUFDL0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb25zdGFudHMubWpzPzg0OTYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRkxPQVRJTkdfRUxFTUVOVF9TSURFX09GRlNFVCA9IDY7XG5jb25zdCBGTE9BVElOR19FTEVNRU5UX0NPTExJU0lPTl9QQURESU5HID0gMTA7XG5jb25zdCBFTU9KSV9GT05UX0ZBTUlMWSA9IFwiJ0FwcGxlIENvbG9yIEVtb2ppJywgJ05vdG8gQ29sb3IgRW1vamknLCAnVHdlbW9qaSBNb3ppbGxhJywgJ0FuZHJvaWQgRW1vamknLCAnU2Vnb2UgVUkgRW1vamknLCAnU2Vnb2UgVUkgU3ltYm9sJywgRW1vamlTeW1ib2xzLCBzYW5zLXNlcmlmXCI7XG5cbmV4cG9ydCB7IEVNT0pJX0ZPTlRfRkFNSUxZLCBGTE9BVElOR19FTEVNRU5UX0NPTExJU0lPTl9QQURESU5HLCBGTE9BVElOR19FTEVNRU5UX1NJREVfT0ZGU0VUIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Check.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Check.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckIcon: () => (/* binding */ CheckIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction CheckIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M16 6L8 14L4 10\"\n  }));\n}\n\n\n//# sourceMappingURL=Check.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9DaGVjay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBQ29COztBQUV2RDtBQUNBLHlCQUF5QixnREFBNEIsQ0FBQywrREFBSTtBQUMxRDtBQUNBLEdBQUcsa0JBQWtCLGdEQUE0QjtBQUNqRDtBQUNBLEdBQUc7QUFDSDs7QUFFcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9DaGVjay5tanM/NWU5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3RfX2RlZmF1bHQgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5tanMnO1xuXG5mdW5jdGlvbiBDaGVja0ljb24ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAuLi5wcm9wc1xuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTE2IDZMOCAxNEw0IDEwXCJcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBDaGVja0ljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoZWNrLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Check.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Cross.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Cross.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CrossIcon: () => (/* binding */ CrossIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction CrossIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M15 5L5 15\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M5 5L15 15\"\n  }));\n}\n\n\n//# sourceMappingURL=Cross.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9Dcm9zcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBQ29COztBQUV2RDtBQUNBLHlCQUF5QixnREFBNEIsQ0FBQywrREFBSTtBQUMxRDtBQUNBLEdBQUcsa0JBQWtCLGdEQUE0QjtBQUNqRDtBQUNBLEdBQUcsbUJBQW1CLGdEQUE0QjtBQUNsRDtBQUNBLEdBQUc7QUFDSDs7QUFFcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9Dcm9zcy5tanM/ZTVhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3RfX2RlZmF1bHQgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5tanMnO1xuXG5mdW5jdGlvbiBDcm9zc0ljb24ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAuLi5wcm9wc1xuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTE1IDVMNSAxNVwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTUgNUwxNSAxNVwiXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgQ3Jvc3NJY29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Dcm9zcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Cross.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Delete.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Delete.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeleteIcon: () => (/* binding */ DeleteIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction DeleteIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M4.5 6.5h11M14 6.5V14a1.5 1.5 0 0 1-1.5 1.5h-5A1.5 1.5 0 0 1 6 14V6.5M7.5 6.5V5a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v1.5\"\n  }));\n}\n\n\n//# sourceMappingURL=Delete.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9EZWxldGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtQztBQUNvQjs7QUFFdkQ7QUFDQSx5QkFBeUIsZ0RBQTRCLENBQUMsK0RBQUk7QUFDMUQ7QUFDQSxHQUFHLGtCQUFrQixnREFBNEI7QUFDakQ7QUFDQSxHQUFHO0FBQ0g7O0FBRXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvRGVsZXRlLm1qcz9iZTAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdF9fZGVmYXVsdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbnRlcm5hbC9JY29uLm1qcyc7XG5cbmZ1bmN0aW9uIERlbGV0ZUljb24ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAuLi5wcm9wc1xuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTQuNSA2LjVoMTFNMTQgNi41VjE0YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNUExLjUgMS41IDAgMCAxIDYgMTRWNi41TTcuNSA2LjVWNWExIDEgMCAwIDEgMS0xaDNhMSAxIDAgMCAxIDEgMXYxLjVcIlxuICB9KSk7XG59XG5cbmV4cG9ydCB7IERlbGV0ZUljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlbGV0ZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Delete.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Edit.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Edit.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditIcon: () => (/* binding */ EditIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction EditIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"m11.784 5.797-6.13 6.138a4 4 0 0 0-1.03 1.775L4 16l2.285-.624a4 4 0 0 0 1.776-1.032l6.145-6.152m-2.422-2.395 1.244-1.246c.608-.608 1.826-.81 2.53-.104.7.7.499 1.893-.122 2.515l-1.23 1.23m-2.422-2.395 2.422 2.395\"\n  }));\n}\n\n\n//# sourceMappingURL=Edit.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9FZGl0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFDb0I7O0FBRXZEO0FBQ0EseUJBQXlCLGdEQUE0QixDQUFDLCtEQUFJO0FBQzFEO0FBQ0EsR0FBRyxrQkFBa0IsZ0RBQTRCO0FBQ2pEO0FBQ0EsR0FBRztBQUNIOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0VkaXQubWpzPzMxMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0X19kZWZhdWx0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24ubWpzJztcblxuZnVuY3Rpb24gRWRpdEljb24ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAuLi5wcm9wc1xuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwibTExLjc4NCA1Ljc5Ny02LjEzIDYuMTM4YTQgNCAwIDAgMC0xLjAzIDEuNzc1TDQgMTZsMi4yODUtLjYyNGE0IDQgMCAwIDAgMS43NzYtMS4wMzJsNi4xNDUtNi4xNTJtLTIuNDIyLTIuMzk1IDEuMjQ0LTEuMjQ2Yy42MDgtLjYwOCAxLjgyNi0uODEgMi41My0uMTA0LjcuNy40OTkgMS44OTMtLjEyMiAyLjUxNWwtMS4yMyAxLjIzbS0yLjQyMi0yLjM5NSAyLjQyMiAyLjM5NVwiXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgRWRpdEljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVkaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Edit.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Ellipsis.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Ellipsis.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EllipsisIcon: () => (/* binding */ EllipsisIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction EllipsisIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    fill: \"currentColor\",\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    cx: 5,\n    cy: 10,\n    r: 0.75\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    cx: 10,\n    cy: 10,\n    r: 0.75\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    cx: 15,\n    cy: 10,\n    r: 0.75\n  }));\n}\n\n\n//# sourceMappingURL=Ellipsis.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9FbGxpcHNpcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBQ29COztBQUV2RDtBQUNBLHlCQUF5QixnREFBNEIsQ0FBQywrREFBSTtBQUMxRDtBQUNBO0FBQ0EsR0FBRyxrQkFBa0IsZ0RBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUJBQW1CLGdEQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG1CQUFtQixnREFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0VsbGlwc2lzLm1qcz83OTlkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdF9fZGVmYXVsdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbnRlcm5hbC9JY29uLm1qcyc7XG5cbmZ1bmN0aW9uIEVsbGlwc2lzSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgLi4ucHJvcHNcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGN4OiA1LFxuICAgIGN5OiAxMCxcbiAgICByOiAwLjc1XG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7XG4gICAgY3g6IDEwLFxuICAgIGN5OiAxMCxcbiAgICByOiAwLjc1XG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7XG4gICAgY3g6IDE1LFxuICAgIGN5OiAxMCxcbiAgICByOiAwLjc1XG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgRWxsaXBzaXNJY29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNpcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Ellipsis.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Emoji.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Emoji.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmojiIcon: () => (/* binding */ EmojiIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction EmojiIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14Z\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M7.5 11.5S8.25 13 10 13s2.5-1.5 2.5-1.5M8 8h.007\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M12 8h.007\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    cx: 8,\n    cy: 8,\n    r: 0.25\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    cx: 12,\n    cy: 8,\n    r: 0.25\n  }));\n}\n\n\n//# sourceMappingURL=Emoji.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9FbW9qaS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBQ29COztBQUV2RDtBQUNBLHlCQUF5QixnREFBNEIsQ0FBQywrREFBSTtBQUMxRDtBQUNBLEdBQUcsa0JBQWtCLGdEQUE0QjtBQUNqRDtBQUNBLEdBQUcsbUJBQW1CLGdEQUE0QjtBQUNsRDtBQUNBLEdBQUcsbUJBQW1CLGdEQUE0QjtBQUNsRDtBQUNBLEdBQUcsbUJBQW1CLGdEQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG1CQUFtQixnREFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0Vtb2ppLm1qcz8xMGRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdF9fZGVmYXVsdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbnRlcm5hbC9JY29uLm1qcyc7XG5cbmZ1bmN0aW9uIEVtb2ppSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgIC4uLnByb3BzXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTAgMTdhNyA3IDAgMSAwIDAtMTQgNyA3IDAgMCAwIDAgMTRaXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNy41IDExLjVTOC4yNSAxMyAxMCAxM3MyLjUtMS41IDIuNS0xLjVNOCA4aC4wMDdcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMiA4aC4wMDdcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGN4OiA4LFxuICAgIGN5OiA4LFxuICAgIHI6IDAuMjVcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjeDogMTIsXG4gICAgY3k6IDgsXG4gICAgcjogMC4yNVxuICB9KSk7XG59XG5cbmV4cG9ydCB7IEVtb2ppSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1vamkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Emoji.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/EmojiAdd.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/EmojiAdd.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmojiAddIcon: () => (/* binding */ EmojiAddIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction EmojiAddIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M11 3.07A7 7 0 1 0 16.93 9\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M7.5 11.5S8.25 13 10 13s2.5-1.5 2.5-1.5M8 8h0\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M12 8h0\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M13 5h4m-2-2v4\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    cx: \"8\",\n    cy: \"8\",\n    r: \".25\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    cx: \"12\",\n    cy: \"8\",\n    r: \".25\"\n  }));\n}\n\n\n//# sourceMappingURL=EmojiAdd.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9FbW9qaUFkZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBQ29COztBQUV2RDtBQUNBLHlCQUF5QixnREFBNEIsQ0FBQywrREFBSTtBQUMxRDtBQUNBLEdBQUcsa0JBQWtCLGdEQUE0QjtBQUNqRDtBQUNBLEdBQUcsbUJBQW1CLGdEQUE0QjtBQUNsRDtBQUNBLEdBQUcsbUJBQW1CLGdEQUE0QjtBQUNsRDtBQUNBLEdBQUcsbUJBQW1CLGdEQUE0QjtBQUNsRDtBQUNBLEdBQUcsbUJBQW1CLGdEQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG1CQUFtQixnREFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0Vtb2ppQWRkLm1qcz80MjJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdF9fZGVmYXVsdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbnRlcm5hbC9JY29uLm1qcyc7XG5cbmZ1bmN0aW9uIEVtb2ppQWRkSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgIC4uLnByb3BzXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTEgMy4wN0E3IDcgMCAxIDAgMTYuOTMgOVwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTcuNSAxMS41UzguMjUgMTMgMTAgMTNzMi41LTEuNSAyLjUtMS41TTggOGgwXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTIgOGgwXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTMgNWg0bS0yLTJ2NFwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7XG4gICAgY3g6IFwiOFwiLFxuICAgIGN5OiBcIjhcIixcbiAgICByOiBcIi4yNVwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7XG4gICAgY3g6IFwiMTJcIixcbiAgICBjeTogXCI4XCIsXG4gICAgcjogXCIuMjVcIlxuICB9KSk7XG59XG5cbmV4cG9ydCB7IEVtb2ppQWRkSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1vamlBZGQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/EmojiAdd.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Mention.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Mention.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MentionIcon: () => (/* binding */ MentionIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction MentionIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M10 13a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M13 7v3.7c0 1.105.855 2.1 1.9 2.1a2.12 2.12 0 0 0 2.1-2.1V10a7 7 0 1 0-2.8 5.6\"\n  }));\n}\n\n\n//# sourceMappingURL=Mention.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9NZW50aW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFDb0I7O0FBRXZEO0FBQ0EseUJBQXlCLGdEQUE0QixDQUFDLCtEQUFJO0FBQzFEO0FBQ0EsR0FBRyxrQkFBa0IsZ0RBQTRCO0FBQ2pEO0FBQ0EsR0FBRyxtQkFBbUIsZ0RBQTRCO0FBQ2xEO0FBQ0EsR0FBRztBQUNIOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL01lbnRpb24ubWpzP2U2MWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0X19kZWZhdWx0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24ubWpzJztcblxuZnVuY3Rpb24gTWVudGlvbkljb24ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAuLi5wcm9wc1xuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTEwIDEzYTMgMyAwIDEgMCAwLTYgMyAzIDAgMCAwIDAgNlpcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMyA3djMuN2MwIDEuMTA1Ljg1NSAyLjEgMS45IDIuMWEyLjEyIDIuMTIgMCAwIDAgMi4xLTIuMVYxMGE3IDcgMCAxIDAtMi44IDUuNlwiXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgTWVudGlvbkljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lbnRpb24ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Mention.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Missing.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Missing.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MissingIcon: () => (/* binding */ MissingIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction MissingIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"m3.794 13.526 5.326-9.89a1 1 0 0 1 1.76 0l5.326 9.89a1 1 0 0 1-.88 1.474H4.674a1 1 0 0 1-.88-1.474ZM10 7.5v2m0 2.5h.007\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    cx: 10,\n    cy: 12,\n    r: 0.25\n  }));\n}\n\n\n//# sourceMappingURL=Missing.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9NaXNzaW5nLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFDb0I7O0FBRXZEO0FBQ0EseUJBQXlCLGdEQUE0QixDQUFDLCtEQUFJO0FBQzFEO0FBQ0EsR0FBRyxrQkFBa0IsZ0RBQTRCO0FBQ2pEO0FBQ0EsR0FBRyxtQkFBbUIsZ0RBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9NaXNzaW5nLm1qcz82ZWU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdF9fZGVmYXVsdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbnRlcm5hbC9JY29uLm1qcyc7XG5cbmZ1bmN0aW9uIE1pc3NpbmdJY29uKHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChJY29uLCB7XG4gICAgLi4ucHJvcHNcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIm0zLjc5NCAxMy41MjYgNS4zMjYtOS44OWExIDEgMCAwIDEgMS43NiAwbDUuMzI2IDkuODlhMSAxIDAgMCAxLS44OCAxLjQ3NEg0LjY3NGExIDEgMCAwIDEtLjg4LTEuNDc0Wk0xMCA3LjV2Mm0wIDIuNWguMDA3XCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjeDogMTAsXG4gICAgY3k6IDEyLFxuICAgIHI6IDAuMjVcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBNaXNzaW5nSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWlzc2luZy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Missing.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Search.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Search.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SearchIcon: () => (/* binding */ SearchIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction SearchIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M9 15A6 6 0 1 0 9 3a6 6 0 0 0 0 12Zm7.5 1.5-3.25-3.25\"\n  }));\n}\n\n\n//# sourceMappingURL=Search.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9TZWFyY2gubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtQztBQUNvQjs7QUFFdkQ7QUFDQSx5QkFBeUIsZ0RBQTRCLENBQUMsK0RBQUk7QUFDMUQ7QUFDQSxHQUFHLGtCQUFrQixnREFBNEI7QUFDakQ7QUFDQSxHQUFHO0FBQ0g7O0FBRXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvU2VhcmNoLm1qcz80Y2RkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdF9fZGVmYXVsdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbnRlcm5hbC9JY29uLm1qcyc7XG5cbmZ1bmN0aW9uIFNlYXJjaEljb24ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAuLi5wcm9wc1xuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTkgMTVBNiA2IDAgMSAwIDkgM2E2IDYgMCAwIDAgMCAxMlptNy41IDEuNS0zLjI1LTMuMjVcIlxuICB9KSk7XG59XG5cbmV4cG9ydCB7IFNlYXJjaEljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlYXJjaC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Search.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Send.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Send.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SendIcon: () => (/* binding */ SendIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction SendIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"m5 16 12-6L5 4l2 6-2 6ZM7 10h10\"\n  }));\n}\n\n\n//# sourceMappingURL=Send.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9TZW5kLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFDb0I7O0FBRXZEO0FBQ0EseUJBQXlCLGdEQUE0QixDQUFDLCtEQUFJO0FBQzFEO0FBQ0EsR0FBRyxrQkFBa0IsZ0RBQTRCO0FBQ2pEO0FBQ0EsR0FBRztBQUNIOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL1NlbmQubWpzPzU1MTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0X19kZWZhdWx0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24ubWpzJztcblxuZnVuY3Rpb24gU2VuZEljb24ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAuLi5wcm9wc1xuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwibTUgMTYgMTItNkw1IDRsMiA2LTIgNlpNNyAxMGgxMFwiXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgU2VuZEljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbmQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Send.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Spinner.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Spinner.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpinnerIcon: () => (/* binding */ SpinnerIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.mjs\");\n\n\n\nfunction SpinnerIcon(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M3 10a7 7 0 0 1 7-7\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"animateTransform\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    attributeName: \"transform\",\n    type: \"rotate\",\n    dur: \"0.75s\",\n    values: `0 ${_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.ICON_WIDTH / 2} ${_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.ICON_HEIGHT / 2};360 ${_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.ICON_WIDTH / 2} ${_components_internal_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__.ICON_HEIGHT / 2}`,\n    repeatCount: \"indefinite\"\n  })));\n}\n\n\n//# sourceMappingURL=Spinner.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9TcGlubmVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFDNkM7O0FBRWhGO0FBQ0EseUJBQXlCLGdEQUE0QixDQUFDLCtEQUFJO0FBQzFEO0FBQ0EsR0FBRyxrQkFBa0IsZ0RBQTRCO0FBQ2pEO0FBQ0EsR0FBRyxrQkFBa0IsZ0RBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFVLE1BQU0sRUFBRSxzRUFBVyxNQUFNLE1BQU0scUVBQVUsTUFBTSxFQUFFLHNFQUFXLEtBQUs7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7O0FBRXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvU3Bpbm5lci5tanM/ODJkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3RfX2RlZmF1bHQgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSWNvbiwgSUNPTl9XSURUSCwgSUNPTl9IRUlHSFQgfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24ubWpzJztcblxuZnVuY3Rpb24gU3Bpbm5lckljb24ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAuLi5wcm9wc1xuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTMgMTBhNyA3IDAgMCAxIDctN1wiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYW5pbWF0ZVRyYW5zZm9ybVwiLCB7XG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBhdHRyaWJ1dGVOYW1lOiBcInRyYW5zZm9ybVwiLFxuICAgIHR5cGU6IFwicm90YXRlXCIsXG4gICAgZHVyOiBcIjAuNzVzXCIsXG4gICAgdmFsdWVzOiBgMCAke0lDT05fV0lEVEggLyAyfSAke0lDT05fSEVJR0hUIC8gMn07MzYwICR7SUNPTl9XSURUSCAvIDJ9ICR7SUNPTl9IRUlHSFQgLyAyfWAsXG4gICAgcmVwZWF0Q291bnQ6IFwiaW5kZWZpbml0ZVwiXG4gIH0pKSk7XG59XG5cbmV4cG9ydCB7IFNwaW5uZXJJY29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcGlubmVyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Spinner.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/overrides.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OverridesContext: () => (/* binding */ OverridesContext),\n/* harmony export */   OverridesProvider: () => (/* binding */ OverridesProvider),\n/* harmony export */   defaultOverrides: () => (/* binding */ defaultOverrides),\n/* harmony export */   useOverrides: () => (/* binding */ useOverrides)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Emoji_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/internal/Emoji.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.mjs\");\n/* harmony import */ var _utils_pluralize_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/pluralize.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/pluralize.mjs\");\n/* __next_internal_client_entry_do_not_use__ OverridesContext,OverridesProvider,defaultOverrides,useOverrides auto */ \n\n\n\nconst defaultOverrides = {\n    locale: \"en\",\n    dir: \"ltr\",\n    USER_SELF: \"you\",\n    USER_UNKNOWN: \"Anonymous\",\n    LIST_REMAINING: (count)=>`${count} more`,\n    LIST_REMAINING_USERS: (count)=>`${count} ${(0,_utils_pluralize_mjs__WEBPACK_IMPORTED_MODULE_1__.pluralize)(count, \"other\")}`,\n    LIST_REMAINING_COMMENTS: (count)=>`${count} more ${(0,_utils_pluralize_mjs__WEBPACK_IMPORTED_MODULE_1__.pluralize)(count, \"comment\")}`,\n    EMOJI_PICKER_SEARCH_PLACEHOLDER: \"Search\",\n    EMOJI_PICKER_EMPTY: \"No emoji found.\",\n    EMOJI_PICKER_ERROR: ()=>\"There was an error while getting the list of emoji.\",\n    COMPOSER_INSERT_MENTION: \"Mention someone\",\n    COMPOSER_INSERT_EMOJI: \"Add emoji\",\n    COMPOSER_PLACEHOLDER: \"Write a comment\",\n    COMPOSER_SEND: \"Send\",\n    COMMENT_EDITED: \"(edited)\",\n    COMMENT_DELETED: \"This comment has been deleted.\",\n    COMMENT_MORE: \"More\",\n    COMMENT_EDIT: \"Edit comment\",\n    COMMENT_EDIT_COMPOSER_PLACEHOLDER: \"Edit comment\",\n    COMMENT_EDIT_COMPOSER_CANCEL: \"Cancel\",\n    COMMENT_EDIT_COMPOSER_SAVE: \"Save\",\n    COMMENT_DELETE: \"Delete comment\",\n    COMMENT_ADD_REACTION: \"Add reaction\",\n    COMMENT_REACTION_LIST: (list, emoji)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, list, \" reacted with \", /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_internal_Emoji_mjs__WEBPACK_IMPORTED_MODULE_2__.Emoji, {\n            emoji\n        })),\n    COMMENT_REACTION_DESCRIPTION: (emoji, count)=>`${count} ${(0,_utils_pluralize_mjs__WEBPACK_IMPORTED_MODULE_1__.pluralize)(count, \"reaction\")}, react with ${emoji}`,\n    THREAD_RESOLVE: \"Resolve thread\",\n    THREAD_UNRESOLVE: \"Re-open thread\",\n    THREAD_NEW_INDICATOR: \"New\",\n    THREAD_NEW_INDICATOR_DESCRIPTION: \"New comments\",\n    THREAD_COMPOSER_PLACEHOLDER: \"Reply to thread\",\n    THREAD_COMPOSER_SEND: \"Reply\",\n    INBOX_NOTIFICATION_MORE: \"More\",\n    INBOX_NOTIFICATION_MARK_AS_READ: \"Mark as read\",\n    INBOX_NOTIFICATION_DELETE: \"Delete notification\",\n    INBOX_NOTIFICATION_THREAD_COMMENTS_LIST: (list, room)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, list, \" commented\", room ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \" in \", room) : /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \" in a thread\")),\n    INBOX_NOTIFICATION_THREAD_MENTION: (user, room)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, user, \" mentioned you\", room ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \" in \", room) : null),\n    INBOX_NOTIFICATION_TEXT_MENTION: (user, room)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, user, \" mentioned you\", room ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \" in \", room) : null)\n};\nconst OverridesContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction useOverrides(overrides) {\n    const contextOverrides = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(OverridesContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...defaultOverrides,\n            ...contextOverrides,\n            ...overrides\n        }), [\n        contextOverrides,\n        overrides\n    ]);\n}\nfunction OverridesProvider({ children, overrides: providerOverrides }) {\n    const contextOverrides = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(OverridesContext);\n    const overrides = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...defaultOverrides,\n            ...contextOverrides,\n            ...providerOverrides\n        }), [\n        contextOverrides,\n        providerOverrides\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OverridesContext.Provider, {\n        value: overrides\n    }, children);\n}\n //# sourceMappingURL=overrides.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9vdmVycmlkZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBMEZPLE1BQUFBLG1CQUFBO0lBQW9DQyxRQUFBO0lBQ2pDQyxLQUFBO0lBQ0hDLFdBQUE7SUFDTUMsY0FBQTtJQUNHQyxnQkFBQSxDQUFBQyxRQUFBLEdBQUFBLE1BQUE7SUFDZ0JDLHNCQUFBLENBQUFELFFBQUEsR0FBQUEsTUFBQSxHQUFBRSwrREFBQUEsQ0FBQUYsT0FBQTtJQUN1Q0cseUJBQUEsQ0FBQUgsUUFBQSxHQUFBQSxNQUFBLFFBQUFFLCtEQUFBQSxDQUFBRixPQUFBO0lBRXhCSSxpQ0FBQTtJQUNaQyxvQkFBQTtJQUNiQyxvQkFBQTtJQUVsQkMseUJBQUE7SUFDdUJDLHVCQUFBO0lBQ0ZDLHNCQUFBO0lBQ0RDLGVBQUE7SUFDUEMsZ0JBQUE7SUFDQ0MsaUJBQUE7SUFDQ0MsY0FBQTtJQUNIQyxjQUFBO0lBQ0FDLG1DQUFBO0lBQ3FCQyw4QkFBQTtJQUNMQyw0QkFBQTtJQUNGQyxnQkFBQTtJQUNaQyxzQkFBQTtJQUNNQyx1QkFBQSxDQUFBQyxNQUFBQyxRQUFBLDhCQUFBQyxnREFBQSxDQUFBQSwyQ0FBQSxRQUFBRixNQUFBLGdEQUFBRSxnREFBQSxDQUFBRyxpRUFBQUEsRUFBQTtZQUdHSjtRQUFNO0lBQzdCSyw4QkFBQSxDQUFBTCxPQUFBdEIsUUFBQSxHQUFBQSxNQUFBLEdBQUFFLCtEQUFBQSxDQUFBRixPQUFBLDJCQUFBc0IsTUFBQTtJQUd3RE0sZ0JBQUE7SUFDMUNDLGtCQUFBO0lBQ0VDLHNCQUFBO0lBQ0lDLGtDQUFBO0lBQ1lDLDZCQUFBO0lBQ0xDLHNCQUFBO0lBQ1BDLHlCQUFBO0lBQ0dDLGlDQUFBO0lBQ1FDLDJCQUFBO0lBQ05DLHlDQUFBLENBQUFoQixNQUFBaUIsT0FBQSw4QkFBQWYsZ0RBQUEsQ0FBQUEsMkNBQUEsUUFBQUYsTUFBQSxjQUFBaUIsT0FBQSw4QkFBQWYsZ0RBQUEsQ0FBQUEsMkNBQUEsZ0JBQUFlLFFBQUEsOEJBQUFmLGdEQUFBLENBQUFBLDJDQUFBO0lBUXpCZ0IsbUNBQUEsQ0FBQUMsTUFBQUYsT0FBQSw4QkFBQWYsZ0RBQUEsQ0FBQUEsMkNBQUEsUUFBQWlCLE1BQUEsa0JBQUFGLE9BQUEsOEJBQUFmLGdEQUFBLENBQUFBLDJDQUFBLGdCQUFBZSxRQUFBO0lBS0FHLGlDQUFBLENBQUFELE1BQUFGLE9BQUEsOEJBQUFmLGdEQUFBLENBQUFBLDJDQUFBLFFBQUFpQixNQUFBLGtCQUFBRixPQUFBLDhCQUFBZixnREFBQSxDQUFBQSwyQ0FBQSxnQkFBQWUsUUFBQTtBQU9KO0FBRWEsTUFBQUksaUNBQUFDLG9EQUFBQSxDQUFBO0FBRU4sU0FBQUMsYUFBQUMsU0FBQTtJQUNMLE1BQUFDLG1CQUFBQyxpREFBQUEsQ0FBQUw7SUFFQSxPQUFBTSw4Q0FBQUEsQ0FBTztZQUNFLEdBQUF0RCxnQkFBQTtZQUNGLEdBQUFvRCxnQkFBQTtZQUNBLEdBQUFELFNBQUE7UUFDQSxJQUNMO1FBQUFDO1FBQUFEO0tBQUE7QUFHSjtBQUVPLFNBQUFJLGtCQUFBLEVBQTJCQyxRQUFBLEVBQ2hDTCxXQUFBTSxpQkFBQSxFQUVGO0lBQ0UsTUFBQUwsbUJBQUFDLGlEQUFBQSxDQUFBTDtJQUNBLE1BQUFHLFlBQUFHLDhDQUFBQSxDQUFrQjtZQUNULEdBQUF0RCxnQkFBQTtZQUNGLEdBQUFvRCxnQkFBQTtZQUNBLEdBQUFLLGlCQUFBO1FBQ0EsSUFDTDtRQUFBTDtRQUFBSztLQUFBO0lBSUYscUNBQUE1QixnREFBQSxDQUFBbUIsaUJBQUFVLFFBQUE7UUFDR0MsT0FBQVI7SUFBaUMsR0FBQUs7QUFJdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi4vc3JjL292ZXJyaWRlcy50c3g/MTMxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHR5cGUgeyBQcm9wc1dpdGhDaGlsZHJlbiwgUmVhY3ROb2RlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgRW1vamkgfSBmcm9tIFwiLi9jb21wb25lbnRzL2ludGVybmFsL0Vtb2ppXCI7XG5pbXBvcnQgdHlwZSB7IERpcmVjdGlvbiB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBwbHVyYWxpemUgfSBmcm9tIFwiLi91dGlscy9wbHVyYWxpemVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbGl6YXRpb25PdmVycmlkZXMge1xuICBsb2NhbGU6IHN0cmluZztcbiAgZGlyOiBEaXJlY3Rpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2xvYmFsT3ZlcnJpZGVzIHtcbiAgVVNFUl9TRUxGOiBzdHJpbmc7XG4gIFVTRVJfVU5LTk9XTjogc3RyaW5nO1xuICBMSVNUX1JFTUFJTklORzogKGNvdW50OiBudW1iZXIpID0+IHN0cmluZztcbiAgTElTVF9SRU1BSU5JTkdfVVNFUlM6IChjb3VudDogbnVtYmVyKSA9PiBzdHJpbmc7XG4gIExJU1RfUkVNQUlOSU5HX0NPTU1FTlRTOiAoY291bnQ6IG51bWJlcikgPT4gc3RyaW5nO1xuICBFTU9KSV9QSUNLRVJfU0VBUkNIX1BMQUNFSE9MREVSOiBzdHJpbmc7XG4gIEVNT0pJX1BJQ0tFUl9FTVBUWTogUmVhY3ROb2RlO1xuICBFTU9KSV9QSUNLRVJfRVJST1I6IChlcnJvcjogRXJyb3IpID0+IFJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21tZW50T3ZlcnJpZGVzIHtcbiAgQ09NTUVOVF9FRElURUQ6IFJlYWN0Tm9kZTtcbiAgQ09NTUVOVF9ERUxFVEVEOiBSZWFjdE5vZGU7XG4gIENPTU1FTlRfTU9SRTogc3RyaW5nO1xuICBDT01NRU5UX0VESVQ6IHN0cmluZztcbiAgQ09NTUVOVF9FRElUX0NPTVBPU0VSX1BMQUNFSE9MREVSOiBzdHJpbmc7XG4gIENPTU1FTlRfRURJVF9DT01QT1NFUl9DQU5DRUw6IHN0cmluZztcbiAgQ09NTUVOVF9FRElUX0NPTVBPU0VSX1NBVkU6IHN0cmluZztcbiAgQ09NTUVOVF9ERUxFVEU6IHN0cmluZztcbiAgQ09NTUVOVF9BRERfUkVBQ1RJT046IHN0cmluZztcbiAgQ09NTUVOVF9SRUFDVElPTl9MSVNUOiAoXG4gICAgbGlzdDogUmVhY3ROb2RlLFxuICAgIGVtb2ppOiBzdHJpbmcsXG4gICAgY291bnQ6IG51bWJlclxuICApID0+IFJlYWN0Tm9kZTtcbiAgQ09NTUVOVF9SRUFDVElPTl9ERVNDUklQVElPTjogKGVtb2ppOiBzdHJpbmcsIGNvdW50OiBudW1iZXIpID0+IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb3Nlck92ZXJyaWRlcyB7XG4gIENPTVBPU0VSX0lOU0VSVF9NRU5USU9OOiBzdHJpbmc7XG4gIENPTVBPU0VSX0lOU0VSVF9FTU9KSTogc3RyaW5nO1xuICBDT01QT1NFUl9QTEFDRUhPTERFUjogc3RyaW5nO1xuICBDT01QT1NFUl9TRU5EOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkT3ZlcnJpZGVzIHtcbiAgVEhSRUFEX1JFU09MVkU6IHN0cmluZztcbiAgVEhSRUFEX1VOUkVTT0xWRTogc3RyaW5nO1xuICBUSFJFQURfTkVXX0lORElDQVRPUjogc3RyaW5nO1xuICBUSFJFQURfTkVXX0lORElDQVRPUl9ERVNDUklQVElPTjogc3RyaW5nO1xuICBUSFJFQURfQ09NUE9TRVJfUExBQ0VIT0xERVI6IHN0cmluZztcbiAgVEhSRUFEX0NPTVBPU0VSX1NFTkQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmJveE5vdGlmaWNhdGlvbk92ZXJyaWRlcyB7XG4gIElOQk9YX05PVElGSUNBVElPTl9NT1JFOiBzdHJpbmc7XG4gIElOQk9YX05PVElGSUNBVElPTl9NQVJLX0FTX1JFQUQ6IHN0cmluZztcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX0RFTEVURTogc3RyaW5nO1xuICBJTkJPWF9OT1RJRklDQVRJT05fVEhSRUFEX0NPTU1FTlRTX0xJU1Q6IChcbiAgICBsaXN0OiBSZWFjdE5vZGUsXG4gICAgcm9vbTogUmVhY3ROb2RlIHwgdW5kZWZpbmVkLFxuICAgIGNvdW50OiBudW1iZXJcbiAgKSA9PiBSZWFjdE5vZGU7XG4gIElOQk9YX05PVElGSUNBVElPTl9USFJFQURfTUVOVElPTjogKFxuICAgIHVzZXI6IFJlYWN0Tm9kZSxcbiAgICByb29tOiBSZWFjdE5vZGUgfCB1bmRlZmluZWRcbiAgKSA9PiBSZWFjdE5vZGU7XG4gIElOQk9YX05PVElGSUNBVElPTl9URVhUX01FTlRJT046IChcbiAgICB1c2VyOiBSZWFjdE5vZGUsXG4gICAgcm9vbTogUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gICkgPT4gUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgdHlwZSBPdmVycmlkZXMgPSBMb2NhbGl6YXRpb25PdmVycmlkZXMgJlxuICBHbG9iYWxPdmVycmlkZXMgJlxuICBDb21wb3Nlck92ZXJyaWRlcyAmXG4gIENvbW1lbnRPdmVycmlkZXMgJlxuICBUaHJlYWRPdmVycmlkZXMgJlxuICBJbmJveE5vdGlmaWNhdGlvbk92ZXJyaWRlcztcblxudHlwZSBPdmVycmlkZXNQcm92aWRlclByb3BzID0gUHJvcHNXaXRoQ2hpbGRyZW48e1xuICBvdmVycmlkZXM/OiBQYXJ0aWFsPE92ZXJyaWRlcz47XG59PjtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRPdmVycmlkZXM6IE92ZXJyaWRlcyA9IHtcbiAgbG9jYWxlOiBcImVuXCIsXG4gIGRpcjogXCJsdHJcIixcbiAgVVNFUl9TRUxGOiBcInlvdVwiLFxuICBVU0VSX1VOS05PV046IFwiQW5vbnltb3VzXCIsXG4gIExJU1RfUkVNQUlOSU5HOiAoY291bnQpID0+IGAke2NvdW50fSBtb3JlYCxcbiAgTElTVF9SRU1BSU5JTkdfVVNFUlM6IChjb3VudCkgPT4gYCR7Y291bnR9ICR7cGx1cmFsaXplKGNvdW50LCBcIm90aGVyXCIpfWAsXG4gIExJU1RfUkVNQUlOSU5HX0NPTU1FTlRTOiAoY291bnQpID0+XG4gICAgYCR7Y291bnR9IG1vcmUgJHtwbHVyYWxpemUoY291bnQsIFwiY29tbWVudFwiKX1gLFxuICBFTU9KSV9QSUNLRVJfU0VBUkNIX1BMQUNFSE9MREVSOiBcIlNlYXJjaOKAplwiLFxuICBFTU9KSV9QSUNLRVJfRU1QVFk6IFwiTm8gZW1vamkgZm91bmQuXCIsXG4gIEVNT0pJX1BJQ0tFUl9FUlJPUjogKCkgPT5cbiAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBsaXN0IG9mIGVtb2ppLlwiLFxuICBDT01QT1NFUl9JTlNFUlRfTUVOVElPTjogXCJNZW50aW9uIHNvbWVvbmVcIixcbiAgQ09NUE9TRVJfSU5TRVJUX0VNT0pJOiBcIkFkZCBlbW9qaVwiLFxuICBDT01QT1NFUl9QTEFDRUhPTERFUjogXCJXcml0ZSBhIGNvbW1lbnTigKZcIixcbiAgQ09NUE9TRVJfU0VORDogXCJTZW5kXCIsXG4gIENPTU1FTlRfRURJVEVEOiBcIihlZGl0ZWQpXCIsXG4gIENPTU1FTlRfREVMRVRFRDogXCJUaGlzIGNvbW1lbnQgaGFzIGJlZW4gZGVsZXRlZC5cIixcbiAgQ09NTUVOVF9NT1JFOiBcIk1vcmVcIixcbiAgQ09NTUVOVF9FRElUOiBcIkVkaXQgY29tbWVudFwiLFxuICBDT01NRU5UX0VESVRfQ09NUE9TRVJfUExBQ0VIT0xERVI6IFwiRWRpdCBjb21tZW504oCmXCIsXG4gIENPTU1FTlRfRURJVF9DT01QT1NFUl9DQU5DRUw6IFwiQ2FuY2VsXCIsXG4gIENPTU1FTlRfRURJVF9DT01QT1NFUl9TQVZFOiBcIlNhdmVcIixcbiAgQ09NTUVOVF9ERUxFVEU6IFwiRGVsZXRlIGNvbW1lbnRcIixcbiAgQ09NTUVOVF9BRERfUkVBQ1RJT046IFwiQWRkIHJlYWN0aW9uXCIsXG4gIENPTU1FTlRfUkVBQ1RJT05fTElTVDogKGxpc3QsIGVtb2ppKSA9PiAoXG4gICAgPD5cbiAgICAgIHtsaXN0fSByZWFjdGVkIHdpdGggPEVtb2ppIGVtb2ppPXtlbW9qaX0gLz5cbiAgICA8Lz5cbiAgKSxcbiAgQ09NTUVOVF9SRUFDVElPTl9ERVNDUklQVElPTjogKGVtb2ppLCBjb3VudCkgPT5cbiAgICBgJHtjb3VudH0gJHtwbHVyYWxpemUoY291bnQsIFwicmVhY3Rpb25cIil9LCByZWFjdCB3aXRoICR7ZW1vaml9YCxcbiAgVEhSRUFEX1JFU09MVkU6IFwiUmVzb2x2ZSB0aHJlYWRcIixcbiAgVEhSRUFEX1VOUkVTT0xWRTogXCJSZS1vcGVuIHRocmVhZFwiLFxuICBUSFJFQURfTkVXX0lORElDQVRPUjogXCJOZXdcIixcbiAgVEhSRUFEX05FV19JTkRJQ0FUT1JfREVTQ1JJUFRJT046IFwiTmV3IGNvbW1lbnRzXCIsXG4gIFRIUkVBRF9DT01QT1NFUl9QTEFDRUhPTERFUjogXCJSZXBseSB0byB0aHJlYWTigKZcIixcbiAgVEhSRUFEX0NPTVBPU0VSX1NFTkQ6IFwiUmVwbHlcIixcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX01PUkU6IFwiTW9yZVwiLFxuICBJTkJPWF9OT1RJRklDQVRJT05fTUFSS19BU19SRUFEOiBcIk1hcmsgYXMgcmVhZFwiLFxuICBJTkJPWF9OT1RJRklDQVRJT05fREVMRVRFOiBcIkRlbGV0ZSBub3RpZmljYXRpb25cIixcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX1RIUkVBRF9DT01NRU5UU19MSVNUOiAoXG4gICAgbGlzdDogUmVhY3ROb2RlLFxuICAgIHJvb206IFJlYWN0Tm9kZVxuICApID0+IChcbiAgICA8PlxuICAgICAge2xpc3R9IGNvbW1lbnRlZFxuICAgICAge3Jvb20gPyA8PiBpbiB7cm9vbX08Lz4gOiA8PiBpbiBhIHRocmVhZDwvPn1cbiAgICA8Lz5cbiAgKSxcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX1RIUkVBRF9NRU5USU9OOiAodXNlcjogUmVhY3ROb2RlLCByb29tOiBSZWFjdE5vZGUpID0+IChcbiAgICA8PlxuICAgICAge3VzZXJ9IG1lbnRpb25lZCB5b3V7cm9vbSA/IDw+IGluIHtyb29tfTwvPiA6IG51bGx9XG4gICAgPC8+XG4gICksXG4gIElOQk9YX05PVElGSUNBVElPTl9URVhUX01FTlRJT046ICh1c2VyOiBSZWFjdE5vZGUsIHJvb206IFJlYWN0Tm9kZSkgPT4gKFxuICAgIDw+XG4gICAgICB7dXNlcn0gbWVudGlvbmVkIHlvdXtyb29tID8gPD4gaW4ge3Jvb219PC8+IDogbnVsbH1cbiAgICA8Lz5cbiAgKSxcbn07XG5cbmV4cG9ydCBjb25zdCBPdmVycmlkZXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxPdmVycmlkZXMgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdmVycmlkZXMob3ZlcnJpZGVzPzogUGFydGlhbDxPdmVycmlkZXM+KTogT3ZlcnJpZGVzIHtcbiAgY29uc3QgY29udGV4dE92ZXJyaWRlcyA9IHVzZUNvbnRleHQoT3ZlcnJpZGVzQ29udGV4dCk7XG5cbiAgcmV0dXJuIHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIC4uLmRlZmF1bHRPdmVycmlkZXMsXG4gICAgICAuLi5jb250ZXh0T3ZlcnJpZGVzLFxuICAgICAgLi4ub3ZlcnJpZGVzLFxuICAgIH0pLFxuICAgIFtjb250ZXh0T3ZlcnJpZGVzLCBvdmVycmlkZXNdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPdmVycmlkZXNQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBvdmVycmlkZXM6IHByb3ZpZGVyT3ZlcnJpZGVzLFxufTogT3ZlcnJpZGVzUHJvdmlkZXJQcm9wcykge1xuICBjb25zdCBjb250ZXh0T3ZlcnJpZGVzID0gdXNlQ29udGV4dChPdmVycmlkZXNDb250ZXh0KTtcbiAgY29uc3Qgb3ZlcnJpZGVzID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgLi4uZGVmYXVsdE92ZXJyaWRlcyxcbiAgICAgIC4uLmNvbnRleHRPdmVycmlkZXMsXG4gICAgICAuLi5wcm92aWRlck92ZXJyaWRlcyxcbiAgICB9KSxcbiAgICBbY29udGV4dE92ZXJyaWRlcywgcHJvdmlkZXJPdmVycmlkZXNdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8T3ZlcnJpZGVzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17b3ZlcnJpZGVzfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L092ZXJyaWRlc0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiZGVmYXVsdE92ZXJyaWRlcyIsImxvY2FsZSIsImRpciIsIlVTRVJfU0VMRiIsIlVTRVJfVU5LTk9XTiIsIkxJU1RfUkVNQUlOSU5HIiwiY291bnQiLCJMSVNUX1JFTUFJTklOR19VU0VSUyIsInBsdXJhbGl6ZSIsIkxJU1RfUkVNQUlOSU5HX0NPTU1FTlRTIiwiRU1PSklfUElDS0VSX1NFQVJDSF9QTEFDRUhPTERFUiIsIkVNT0pJX1BJQ0tFUl9FTVBUWSIsIkVNT0pJX1BJQ0tFUl9FUlJPUiIsIkNPTVBPU0VSX0lOU0VSVF9NRU5USU9OIiwiQ09NUE9TRVJfSU5TRVJUX0VNT0pJIiwiQ09NUE9TRVJfUExBQ0VIT0xERVIiLCJDT01QT1NFUl9TRU5EIiwiQ09NTUVOVF9FRElURUQiLCJDT01NRU5UX0RFTEVURUQiLCJDT01NRU5UX01PUkUiLCJDT01NRU5UX0VESVQiLCJDT01NRU5UX0VESVRfQ09NUE9TRVJfUExBQ0VIT0xERVIiLCJDT01NRU5UX0VESVRfQ09NUE9TRVJfQ0FOQ0VMIiwiQ09NTUVOVF9FRElUX0NPTVBPU0VSX1NBVkUiLCJDT01NRU5UX0RFTEVURSIsIkNPTU1FTlRfQUREX1JFQUNUSU9OIiwiQ09NTUVOVF9SRUFDVElPTl9MSVNUIiwibGlzdCIsImVtb2ppIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJFbW9qaSIsIkNPTU1FTlRfUkVBQ1RJT05fREVTQ1JJUFRJT04iLCJUSFJFQURfUkVTT0xWRSIsIlRIUkVBRF9VTlJFU09MVkUiLCJUSFJFQURfTkVXX0lORElDQVRPUiIsIlRIUkVBRF9ORVdfSU5ESUNBVE9SX0RFU0NSSVBUSU9OIiwiVEhSRUFEX0NPTVBPU0VSX1BMQUNFSE9MREVSIiwiVEhSRUFEX0NPTVBPU0VSX1NFTkQiLCJJTkJPWF9OT1RJRklDQVRJT05fTU9SRSIsIklOQk9YX05PVElGSUNBVElPTl9NQVJLX0FTX1JFQUQiLCJJTkJPWF9OT1RJRklDQVRJT05fREVMRVRFIiwiSU5CT1hfTk9USUZJQ0FUSU9OX1RIUkVBRF9DT01NRU5UU19MSVNUIiwicm9vbSIsIklOQk9YX05PVElGSUNBVElPTl9USFJFQURfTUVOVElPTiIsInVzZXIiLCJJTkJPWF9OT1RJRklDQVRJT05fVEVYVF9NRU5USU9OIiwiT3ZlcnJpZGVzQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VPdmVycmlkZXMiLCJvdmVycmlkZXMiLCJjb250ZXh0T3ZlcnJpZGVzIiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJPdmVycmlkZXNQcm92aWRlciIsImNoaWxkcmVuIiwicHJvdmlkZXJPdmVycmlkZXMiLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Comment/index.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/Comment/index.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Body: () => (/* binding */ CommentBody),\n/* harmony export */   Link: () => (/* binding */ CommentLink),\n/* harmony export */   Mention: () => (/* binding */ CommentMention)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../slate/plugins/mentions.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/mentions.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Comment/utils.mjs\");\n\n\n\n\n\nconst COMMENT_MENTION_NAME = \"CommentMention\";\nconst COMMENT_BODY_NAME = \"CommentBody\";\nconst COMMENT_LINK_NAME = \"CommentLink\";\nconst CommentMention = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({ children, asChild, ...props }, forwardedRef) => {\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_1__.Slot : \"span\";\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n      ...props,\n      ref: forwardedRef\n    }, children);\n  }\n);\nconst CommentLink = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({ children, asChild, ...props }, forwardedRef) => {\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_1__.Slot : \"a\";\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n      target: \"_blank\",\n      rel: \"noopener noreferrer nofollow\",\n      ...props,\n      ref: forwardedRef\n    }, children);\n  }\n);\nconst defaultBodyComponents = {\n  Mention: ({ userId }) => {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommentMention, null, _slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_2__.MENTION_CHARACTER, userId);\n  },\n  Link: ({ href, children }) => {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommentLink, {\n      href\n    }, children);\n  }\n};\nconst CommentBody = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({ body, components, style, asChild, ...props }, forwardedRef) => {\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_1__.Slot : \"div\";\n    const { Mention, Link } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n      () => ({ ...defaultBodyComponents, ...components }),\n      [components]\n    );\n    if (!body || !body?.content) {\n      return null;\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n      ...props,\n      style: { whiteSpace: \"break-spaces\", ...style },\n      ref: forwardedRef\n    }, body.content.map((block, index) => {\n      switch (block.type) {\n        case \"paragraph\":\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", {\n            key: index,\n            style: { minHeight: \"1lh\" }\n          }, block.children.map((inline, index2) => {\n            if ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.isCommentBodyMention)(inline)) {\n              return inline.id ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mention, {\n                userId: inline.id,\n                key: index2\n              }) : null;\n            }\n            if ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.isCommentBodyLink)(inline)) {\n              const href = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.toAbsoluteUrl)(inline.url) ?? inline.url;\n              return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, {\n                href,\n                key: index2\n              }, inline.text ?? inline.url);\n            }\n            let children = inline.text;\n            if (inline.bold) {\n              children = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"strong\", {\n                key: index2\n              }, children);\n            }\n            if (inline.italic) {\n              children = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"em\", {\n                key: index2\n              }, children);\n            }\n            if (inline.strikethrough) {\n              children = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"s\", {\n                key: index2\n              }, children);\n            }\n            if (inline.code) {\n              children = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n                key: index2\n              }, children);\n            }\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n              key: index2\n            }, children);\n          }));\n        default:\n          return null;\n      }\n    }));\n  }\n);\nif (true) {\n  CommentBody.displayName = COMMENT_BODY_NAME;\n  CommentMention.displayName = COMMENT_MENTION_NAME;\n  CommentLink.displayName = COMMENT_LINK_NAME;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0NvbW1lbnQvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEM7QUFDZ0I7QUFDUztBQUNnQjs7QUFFckY7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFVO0FBQ2pDLEtBQUssNkJBQTZCO0FBQ2xDLGdDQUFnQyxzREFBSTtBQUNwQywyQkFBMkIsZ0RBQTRCO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQixpREFBVTtBQUM5QixLQUFLLDZCQUE2QjtBQUNsQyxnQ0FBZ0Msc0RBQUk7QUFDcEMsMkJBQTJCLGdEQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsMkJBQTJCLGdEQUE0Qix1QkFBdUIsMEVBQWlCO0FBQy9GLEdBQUc7QUFDSCxXQUFXLGdCQUFnQjtBQUMzQiwyQkFBMkIsZ0RBQTRCO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVU7QUFDOUIsS0FBSyw0Q0FBNEM7QUFDakQsZ0NBQWdDLHNEQUFJO0FBQ3BDLFlBQVksZ0JBQWdCLEVBQUUsOENBQU87QUFDckMsZUFBZSx5Q0FBeUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBNEI7QUFDdkQ7QUFDQSxlQUFlLHNDQUFzQztBQUNyRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUNBQWlDLGdEQUE0QjtBQUM3RDtBQUNBLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1gsZ0JBQWdCLGdFQUFvQjtBQUNwQyxpREFBaUQsZ0RBQTRCO0FBQzdFO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxnQkFBZ0IsNkRBQWlCO0FBQ2pDLDJCQUEyQix5REFBYTtBQUN4QyxxQ0FBcUMsZ0RBQTRCO0FBQ2pFO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdEQUE0QjtBQUNyRTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EseUNBQXlDLGdEQUE0QjtBQUNyRTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EseUNBQXlDLGdEQUE0QjtBQUNyRTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EseUNBQXlDLGdEQUE0QjtBQUNyRTtBQUNBLGVBQWU7QUFDZjtBQUNBLG1DQUFtQyxnREFBNEI7QUFDL0Q7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFK0U7QUFDL0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0NvbW1lbnQvaW5kZXgubWpzPzZjNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2xvdCB9IGZyb20gJ0ByYWRpeC11aS9yZWFjdC1zbG90JztcbmltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyBmb3J3YXJkUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTUVOVElPTl9DSEFSQUNURVIgfSBmcm9tICcuLi8uLi9zbGF0ZS9wbHVnaW5zL21lbnRpb25zLm1qcyc7XG5pbXBvcnQgeyBpc0NvbW1lbnRCb2R5TWVudGlvbiwgaXNDb21tZW50Qm9keUxpbmssIHRvQWJzb2x1dGVVcmwgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmNvbnN0IENPTU1FTlRfTUVOVElPTl9OQU1FID0gXCJDb21tZW50TWVudGlvblwiO1xuY29uc3QgQ09NTUVOVF9CT0RZX05BTUUgPSBcIkNvbW1lbnRCb2R5XCI7XG5jb25zdCBDT01NRU5UX0xJTktfTkFNRSA9IFwiQ29tbWVudExpbmtcIjtcbmNvbnN0IENvbW1lbnRNZW50aW9uID0gZm9yd2FyZFJlZihcbiAgKHsgY2hpbGRyZW4sIGFzQ2hpbGQsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJzcGFuXCI7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgIH0sIGNoaWxkcmVuKTtcbiAgfVxuKTtcbmNvbnN0IENvbW1lbnRMaW5rID0gZm9yd2FyZFJlZihcbiAgKHsgY2hpbGRyZW4sIGFzQ2hpbGQsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJhXCI7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3dcIixcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgICB9LCBjaGlsZHJlbik7XG4gIH1cbik7XG5jb25zdCBkZWZhdWx0Qm9keUNvbXBvbmVudHMgPSB7XG4gIE1lbnRpb246ICh7IHVzZXJJZCB9KSA9PiB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbW1lbnRNZW50aW9uLCBudWxsLCBNRU5USU9OX0NIQVJBQ1RFUiwgdXNlcklkKTtcbiAgfSxcbiAgTGluazogKHsgaHJlZiwgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21tZW50TGluaywge1xuICAgICAgaHJlZlxuICAgIH0sIGNoaWxkcmVuKTtcbiAgfVxufTtcbmNvbnN0IENvbW1lbnRCb2R5ID0gZm9yd2FyZFJlZihcbiAgKHsgYm9keSwgY29tcG9uZW50cywgc3R5bGUsIGFzQ2hpbGQsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJkaXZcIjtcbiAgICBjb25zdCB7IE1lbnRpb24sIExpbmsgfSA9IHVzZU1lbW8oXG4gICAgICAoKSA9PiAoeyAuLi5kZWZhdWx0Qm9keUNvbXBvbmVudHMsIC4uLmNvbXBvbmVudHMgfSksXG4gICAgICBbY29tcG9uZW50c11cbiAgICApO1xuICAgIGlmICghYm9keSB8fCAhYm9keT8uY29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3R5bGU6IHsgd2hpdGVTcGFjZTogXCJicmVhay1zcGFjZXNcIiwgLi4uc3R5bGUgfSxcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmXG4gICAgfSwgYm9keS5jb250ZW50Lm1hcCgoYmxvY2ssIGluZGV4KSA9PiB7XG4gICAgICBzd2l0Y2ggKGJsb2NrLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInBhcmFncmFwaFwiOlxuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBcIiwge1xuICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgIHN0eWxlOiB7IG1pbkhlaWdodDogXCIxbGhcIiB9XG4gICAgICAgICAgfSwgYmxvY2suY2hpbGRyZW4ubWFwKChpbmxpbmUsIGluZGV4MikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlNZW50aW9uKGlubGluZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlubGluZS5pZCA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lbnRpb24sIHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IGlubGluZS5pZCxcbiAgICAgICAgICAgICAgICBrZXk6IGluZGV4MlxuICAgICAgICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICAgICAgICBjb25zdCBocmVmID0gdG9BYnNvbHV0ZVVybChpbmxpbmUudXJsKSA/PyBpbmxpbmUudXJsO1xuICAgICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTGluaywge1xuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAga2V5OiBpbmRleDJcbiAgICAgICAgICAgICAgfSwgaW5saW5lLnRleHQgPz8gaW5saW5lLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBpbmxpbmUudGV4dDtcbiAgICAgICAgICAgIGlmIChpbmxpbmUuYm9sZCkge1xuICAgICAgICAgICAgICBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3Ryb25nXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGluZGV4MlxuICAgICAgICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5saW5lLml0YWxpYykge1xuICAgICAgICAgICAgICBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZW1cIiwge1xuICAgICAgICAgICAgICAgIGtleTogaW5kZXgyXG4gICAgICAgICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmxpbmUuc3RyaWtldGhyb3VnaCkge1xuICAgICAgICAgICAgICBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic1wiLCB7XG4gICAgICAgICAgICAgICAga2V5OiBpbmRleDJcbiAgICAgICAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlubGluZS5jb2RlKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGluZGV4MlxuICAgICAgICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgICAga2V5OiBpbmRleDJcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBDb21tZW50Qm9keS5kaXNwbGF5TmFtZSA9IENPTU1FTlRfQk9EWV9OQU1FO1xuICBDb21tZW50TWVudGlvbi5kaXNwbGF5TmFtZSA9IENPTU1FTlRfTUVOVElPTl9OQU1FO1xuICBDb21tZW50TGluay5kaXNwbGF5TmFtZSA9IENPTU1FTlRfTElOS19OQU1FO1xufVxuXG5leHBvcnQgeyBDb21tZW50Qm9keSBhcyBCb2R5LCBDb21tZW50TGluayBhcyBMaW5rLCBDb21tZW50TWVudGlvbiBhcyBNZW50aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Comment/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Comment/utils.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/Comment/utils.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCommentBodyLink: () => (/* binding */ isCommentBodyLink),\n/* harmony export */   isCommentBodyMention: () => (/* binding */ isCommentBodyMention),\n/* harmony export */   isCommentBodyText: () => (/* binding */ isCommentBodyText),\n/* harmony export */   toAbsoluteUrl: () => (/* binding */ toAbsoluteUrl)\n/* harmony export */ });\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nfunction toAbsoluteUrl(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    return \"https://\" + url;\n  }\n  return;\n}\n\n\n//# sourceMappingURL=utils.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0NvbW1lbnQvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRXFGO0FBQ3JGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvcHJpbWl0aXZlcy9Db21tZW50L3V0aWxzLm1qcz9mMTk5Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzQ29tbWVudEJvZHlUZXh0KGVsZW1lbnQpIHtcbiAgcmV0dXJuICEoXCJ0eXBlXCIgaW4gZWxlbWVudCkgJiYgXCJ0ZXh0XCIgaW4gZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC50ZXh0ID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keU1lbnRpb24oZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keUxpbmsoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibGlua1wiO1xufVxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCB1cmwuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfSBlbHNlIGlmICh1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICByZXR1cm4gXCJodHRwczovL1wiICsgdXJsO1xuICB9XG4gIHJldHVybjtcbn1cblxuZXhwb3J0IHsgaXNDb21tZW50Qm9keUxpbmssIGlzQ29tbWVudEJvZHlNZW50aW9uLCBpc0NvbW1lbnRCb2R5VGV4dCwgdG9BYnNvbHV0ZVVybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Comment/utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/contexts.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/Composer/contexts.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComposerContext: () => (/* binding */ ComposerContext),\n/* harmony export */   ComposerEditorContext: () => (/* binding */ ComposerEditorContext),\n/* harmony export */   ComposerSuggestionsContext: () => (/* binding */ ComposerSuggestionsContext),\n/* harmony export */   useComposer: () => (/* binding */ useComposer),\n/* harmony export */   useComposerEditorContext: () => (/* binding */ useComposerEditorContext),\n/* harmony export */   useComposerSuggestionsContext: () => (/* binding */ useComposerSuggestionsContext)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\nconst ComposerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst ComposerEditorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst ComposerSuggestionsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useComposerEditorContext() {\n  const composerEditorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComposerEditorContext);\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n    composerEditorContext,\n    \"Composer.Form is missing from the React tree.\"\n  );\n}\nfunction useComposer() {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComposerContext);\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(composerContext, \"Composer.Form is missing from the React tree.\");\n}\nfunction useComposerSuggestionsContext(source = \"useComposerSuggestionsContext\") {\n  const composerSuggestionsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComposerSuggestionsContext);\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n    composerSuggestionsContext,\n    `${source} can\\u2019t be used outside of Composer.Editor.`\n  );\n}\n\n\n//# sourceMappingURL=contexts.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0NvbXBvc2VyL2NvbnRleHRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQztBQUNZOztBQUVsRCx3QkFBd0Isb0RBQWE7QUFDckMsOEJBQThCLG9EQUFhO0FBQzNDLG1DQUFtQyxvREFBYTtBQUNoRDtBQUNBLGdDQUFnQyxpREFBVTtBQUMxQyxTQUFTLG9EQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpREFBVTtBQUNwQyxTQUFTLG9EQUFFO0FBQ1g7QUFDQTtBQUNBLHFDQUFxQyxpREFBVTtBQUMvQyxTQUFTLG9EQUFFO0FBQ1g7QUFDQSxPQUFPLFFBQVE7QUFDZjtBQUNBOztBQUVvSjtBQUNwSiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3ByaW1pdGl2ZXMvQ29tcG9zZXIvY29udGV4dHMubWpzP2JiOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm4gfSBmcm9tICdAbGl2ZWJsb2Nrcy9jb3JlJztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IENvbXBvc2VyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBDb21wb3NlckVkaXRvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgQ29tcG9zZXJTdWdnZXN0aW9uc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlQ29tcG9zZXJFZGl0b3JDb250ZXh0KCkge1xuICBjb25zdCBjb21wb3NlckVkaXRvckNvbnRleHQgPSB1c2VDb250ZXh0KENvbXBvc2VyRWRpdG9yQ29udGV4dCk7XG4gIHJldHVybiBubihcbiAgICBjb21wb3NlckVkaXRvckNvbnRleHQsXG4gICAgXCJDb21wb3Nlci5Gb3JtIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIlxuICApO1xufVxuZnVuY3Rpb24gdXNlQ29tcG9zZXIoKSB7XG4gIGNvbnN0IGNvbXBvc2VyQ29udGV4dCA9IHVzZUNvbnRleHQoQ29tcG9zZXJDb250ZXh0KTtcbiAgcmV0dXJuIG5uKGNvbXBvc2VyQ29udGV4dCwgXCJDb21wb3Nlci5Gb3JtIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG59XG5mdW5jdGlvbiB1c2VDb21wb3NlclN1Z2dlc3Rpb25zQ29udGV4dChzb3VyY2UgPSBcInVzZUNvbXBvc2VyU3VnZ2VzdGlvbnNDb250ZXh0XCIpIHtcbiAgY29uc3QgY29tcG9zZXJTdWdnZXN0aW9uc0NvbnRleHQgPSB1c2VDb250ZXh0KENvbXBvc2VyU3VnZ2VzdGlvbnNDb250ZXh0KTtcbiAgcmV0dXJuIG5uKFxuICAgIGNvbXBvc2VyU3VnZ2VzdGlvbnNDb250ZXh0LFxuICAgIGAke3NvdXJjZX0gY2FuXFx1MjAxOXQgYmUgdXNlZCBvdXRzaWRlIG9mIENvbXBvc2VyLkVkaXRvci5gXG4gICk7XG59XG5cbmV4cG9ydCB7IENvbXBvc2VyQ29udGV4dCwgQ29tcG9zZXJFZGl0b3JDb250ZXh0LCBDb21wb3NlclN1Z2dlc3Rpb25zQ29udGV4dCwgdXNlQ29tcG9zZXIsIHVzZUNvbXBvc2VyRWRpdG9yQ29udGV4dCwgdXNlQ29tcG9zZXJTdWdnZXN0aW9uc0NvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHRzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/contexts.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/index.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/Composer/index.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ ComposerEditor),\n/* harmony export */   Form: () => (/* binding */ ComposerForm),\n/* harmony export */   Link: () => (/* binding */ ComposerLink),\n/* harmony export */   Mention: () => (/* binding */ ComposerMention),\n/* harmony export */   Submit: () => (/* binding */ ComposerSubmit),\n/* harmony export */   Suggestions: () => (/* binding */ ComposerSuggestions),\n/* harmony export */   SuggestionsList: () => (/* binding */ ComposerSuggestionsList),\n/* harmony export */   SuggestionsListItem: () => (/* binding */ ComposerSuggestionsListItem)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs\");\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_history__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate-history */ \"(ssr)/./node_modules/slate-history/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../config.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/config.mjs\");\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../constants.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.mjs\");\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../shared.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/shared.mjs\");\n/* harmony import */ var _slate_plugins_auto_formatting_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../slate/plugins/auto-formatting.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/auto-formatting.mjs\");\n/* harmony import */ var _slate_plugins_auto_links_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../slate/plugins/auto-links.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/auto-links.mjs\");\n/* harmony import */ var _slate_plugins_custom_links_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../slate/plugins/custom-links.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/custom-links.mjs\");\n/* harmony import */ var _slate_plugins_empty_clear_formatting_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../slate/plugins/empty-clear-formatting.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/empty-clear-formatting.mjs\");\n/* harmony import */ var _slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../slate/plugins/mentions.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/mentions.mjs\");\n/* harmony import */ var _slate_plugins_paste_html_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../slate/plugins/paste-html.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/paste-html.mjs\");\n/* harmony import */ var _slate_utils_get_dom_range_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../slate/utils/get-dom-range.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-dom-range.mjs\");\n/* harmony import */ var _slate_utils_is_empty_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../../slate/utils/is-empty.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty.mjs\");\n/* harmony import */ var _slate_utils_marks_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../../slate/utils/marks.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/marks.mjs\");\n/* harmony import */ var _utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../utils/is-key.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-key.mjs\");\n/* harmony import */ var _utils_Persist_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utils/Persist.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/Persist.mjs\");\n/* harmony import */ var _utils_Portal_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../utils/Portal.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/Portal.mjs\");\n/* harmony import */ var _utils_request_submit_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../../utils/request-submit.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/request-submit.mjs\");\n/* harmony import */ var _utils_use_id_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../utils/use-id.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-id.mjs\");\n/* harmony import */ var _utils_use_index_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../../utils/use-index.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-index.mjs\");\n/* harmony import */ var _utils_use_initial_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../../utils/use-initial.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-initial.mjs\");\n/* harmony import */ var _utils_use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utils/use-layout-effect.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-layout-effect.mjs\");\n/* harmony import */ var _utils_use_refs_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../utils/use-refs.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-refs.mjs\");\n/* harmony import */ var _Comment_utils_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Comment/utils.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Comment/utils.mjs\");\n/* harmony import */ var _contexts_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contexts.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/contexts.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/utils.mjs\");\n/* __next_internal_client_entry_do_not_use__ Editor,Form,Link,Mention,Submit,Suggestions,SuggestionsList,SuggestionsListItem auto */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst MENTION_SUGGESTIONS_POSITION = \"top\";\nconst COMPOSER_MENTION_NAME = \"ComposerMention\";\nconst COMPOSER_LINK_NAME = \"ComposerLink\";\nconst COMPOSER_SUGGESTIONS_NAME = \"ComposerSuggestions\";\nconst COMPOSER_SUGGESTIONS_LIST_NAME = \"ComposerSuggestionsList\";\nconst COMPOSER_SUGGESTIONS_LIST_ITEM_NAME = \"ComposerSuggestionsListItem\";\nconst COMPOSER_SUBMIT_NAME = \"ComposerSubmit\";\nconst COMPOSER_EDITOR_NAME = \"ComposerEditor\";\nconst COMPOSER_FORM_NAME = \"ComposerForm\";\nconst emptyCommentBody = {\n    version: 1,\n    content: [\n        {\n            type: \"paragraph\",\n            children: [\n                {\n                    text: \"\"\n                }\n            ]\n        }\n    ]\n};\nfunction createComposerEditor() {\n    return (0,_slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_1__.withMentions)((0,_slate_plugins_custom_links_mjs__WEBPACK_IMPORTED_MODULE_2__.withCustomLinks)((0,_slate_plugins_auto_links_mjs__WEBPACK_IMPORTED_MODULE_3__.withAutoLinks)((0,_slate_plugins_auto_formatting_mjs__WEBPACK_IMPORTED_MODULE_4__.withAutoFormatting)((0,_slate_plugins_empty_clear_formatting_mjs__WEBPACK_IMPORTED_MODULE_5__.withEmptyClearFormatting)((0,_slate_plugins_paste_html_mjs__WEBPACK_IMPORTED_MODULE_6__.withPasteHtml)((0,slate_history__WEBPACK_IMPORTED_MODULE_7__.withHistory)((0,slate_react__WEBPACK_IMPORTED_MODULE_8__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_9__.createEditor)()))))))));\n}\nfunction ComposerEditorMentionWrapper({ Mention, attributes, children, element }) {\n    const isSelected = (0,slate_react__WEBPACK_IMPORTED_MODULE_8__.useSelected)();\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        ...attributes\n    }, element.id ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mention, {\n        userId: element.id,\n        isSelected\n    }) : null, children);\n}\nfunction ComposerEditorLinkWrapper({ Link, attributes, element, children }) {\n    const href = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_Comment_utils_mjs__WEBPACK_IMPORTED_MODULE_10__.toAbsoluteUrl)(element.url) ?? element.url, [\n        element.url\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        ...attributes\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, {\n        href\n    }, children));\n}\nfunction ComposerEditorMentionSuggestionsWrapper({ id, itemId, userIds, selectedUserId, setSelectedUserId, mentionDraft, onItemSelect, position = MENTION_SUGGESTIONS_POSITION, dir, MentionSuggestions }) {\n    const editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_8__.useSlateStatic)();\n    const { isFocused } = (0,_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.useComposer)();\n    const [content, setContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contentZIndex, setContentZIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const contentRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(setContent, [\n        setContent\n    ]);\n    const { portalContainer } = (0,_config_mjs__WEBPACK_IMPORTED_MODULE_12__.useLiveblocksUIConfig)();\n    const floatingOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const detectOverflowOptions = {\n            padding: _constants_mjs__WEBPACK_IMPORTED_MODULE_13__.FLOATING_ELEMENT_COLLISION_PADDING\n        };\n        return {\n            strategy: \"fixed\",\n            placement: (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_14__.getPlacementFromPosition)(position, dir),\n            middleware: [\n                (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_15__.flip)({\n                    ...detectOverflowOptions,\n                    crossAxis: false\n                }),\n                (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_15__.hide)(detectOverflowOptions),\n                (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_15__.shift)({\n                    ...detectOverflowOptions,\n                    limiter: (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_15__.limitShift)()\n                }),\n                (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_15__.size)({\n                    ...detectOverflowOptions,\n                    apply ({ availableWidth, availableHeight, elements }) {\n                        elements.floating.style.setProperty(\"--lb-composer-suggestions-available-width\", `${availableWidth}px`);\n                        elements.floating.style.setProperty(\"--lb-composer-suggestions-available-height\", `${availableHeight}px`);\n                    }\n                })\n            ],\n            whileElementsMounted: _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_16__.autoUpdate\n        };\n    }, [\n        position,\n        dir\n    ]);\n    const { refs: { setReference, setFloating }, strategy, isPositioned, placement, x, y } = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_15__.useFloating)(floatingOptions);\n    (0,_utils_use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_17__.useLayoutEffect)(()=>{\n        if (content) {\n            setContentZIndex(window.getComputedStyle(content).zIndex);\n        }\n    }, [\n        content\n    ]);\n    (0,_utils_use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_17__.useLayoutEffect)(()=>{\n        if (!mentionDraft) {\n            return;\n        }\n        const domRange = (0,_slate_utils_get_dom_range_mjs__WEBPACK_IMPORTED_MODULE_18__.getDOMRange)(editor, mentionDraft.range);\n        if (domRange) {\n            setReference({\n                getBoundingClientRect: ()=>domRange.getBoundingClientRect(),\n                getClientRects: ()=>domRange.getClientRects()\n            });\n        }\n    }, [\n        setReference,\n        editor,\n        mentionDraft\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils_Persist_mjs__WEBPACK_IMPORTED_MODULE_19__.Persist, null, mentionDraft?.range && isFocused && userIds ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.ComposerSuggestionsContext.Provider, {\n        value: {\n            id,\n            itemId,\n            selectedValue: selectedUserId,\n            setSelectedValue: setSelectedUserId,\n            onItemSelect,\n            placement,\n            dir,\n            ref: contentRef\n        }\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils_Portal_mjs__WEBPACK_IMPORTED_MODULE_20__.Portal, {\n        ref: setFloating,\n        container: portalContainer,\n        style: {\n            position: strategy,\n            top: 0,\n            left: 0,\n            transform: isPositioned ? `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)` : \"translate3d(0, -200%, 0)\",\n            minWidth: \"max-content\",\n            zIndex: contentZIndex\n        }\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MentionSuggestions, {\n        userIds,\n        selectedUserId\n    }))) : null);\n}\nfunction ComposerEditorElement({ Mention, Link, ...props }) {\n    const { attributes, children, element } = props;\n    switch(element.type){\n        case \"mention\":\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerEditorMentionWrapper, {\n                Mention,\n                ...props\n            });\n        case \"auto-link\":\n        case \"custom-link\":\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerEditorLinkWrapper, {\n                Link,\n                ...props\n            });\n        case \"paragraph\":\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", {\n                ...attributes,\n                style: {\n                    position: \"relative\"\n                }\n            }, children);\n        default:\n            return null;\n    }\n}\nfunction ComposerEditorLeaf({ attributes, children, leaf }) {\n    if (leaf.bold) {\n        children = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"strong\", null, children);\n    }\n    if (leaf.italic) {\n        children = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"em\", null, children);\n    }\n    if (leaf.strikethrough) {\n        children = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"s\", null, children);\n    }\n    if (leaf.code) {\n        children = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, children);\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        ...attributes\n    }, children);\n}\nfunction ComposerEditorPlaceholder({ attributes, children }) {\n    const { opacity: _opacity, ...style } = attributes.style;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        ...attributes,\n        style,\n        \"data-placeholder\": \"\"\n    }, children);\n}\nconst ComposerMention = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, asChild, ...props }, forwardedRef)=>{\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_21__.Slot : \"span\";\n    const isSelected = (0,slate_react__WEBPACK_IMPORTED_MODULE_8__.useSelected)();\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        \"data-selected\": isSelected || void 0,\n        ...props,\n        ref: forwardedRef\n    }, children);\n});\nconst ComposerLink = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, asChild, ...props }, forwardedRef)=>{\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_21__.Slot : \"a\";\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        target: \"_blank\",\n        rel: \"noopener noreferrer nofollow\",\n        ...props,\n        ref: forwardedRef\n    }, children);\n});\nconst ComposerSuggestions = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, style, asChild, ...props }, forwardedRef)=>{\n    const [isPresent] = (0,_utils_Persist_mjs__WEBPACK_IMPORTED_MODULE_19__.usePersist)();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { ref: contentRef, placement, dir } = (0,_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.useComposerSuggestionsContext)(COMPOSER_SUGGESTIONS_NAME);\n    const mergedRefs = (0,_utils_use_refs_mjs__WEBPACK_IMPORTED_MODULE_22__.useRefs)(forwardedRef, contentRef, ref);\n    const [side, align] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_14__.getSideAndAlignFromPlacement)(placement), [\n        placement\n    ]);\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_21__.Slot : \"div\";\n    (0,_utils_Persist_mjs__WEBPACK_IMPORTED_MODULE_19__.useAnimationPersist)(ref);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        dir,\n        ...props,\n        \"data-state\": isPresent ? \"open\" : \"closed\",\n        \"data-side\": side,\n        \"data-align\": align,\n        style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            maxHeight: \"var(--lb-composer-suggestions-available-height)\",\n            overflowY: \"auto\",\n            ...style\n        },\n        ref: mergedRefs\n    }, children);\n});\nconst ComposerSuggestionsList = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, asChild, ...props }, forwardedRef)=>{\n    const { id } = (0,_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.useComposerSuggestionsContext)(COMPOSER_SUGGESTIONS_LIST_NAME);\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_21__.Slot : \"ul\";\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        role: \"listbox\",\n        id,\n        \"aria-label\": \"Suggestions list\",\n        ...props,\n        ref: forwardedRef\n    }, children);\n});\nconst ComposerSuggestionsListItem = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ value, children, onPointerMove, onPointerDown, asChild, ...props }, forwardedRef)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const mergedRefs = (0,_utils_use_refs_mjs__WEBPACK_IMPORTED_MODULE_22__.useRefs)(forwardedRef, ref);\n    const { selectedValue, setSelectedValue, itemId, onItemSelect } = (0,_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.useComposerSuggestionsContext)(COMPOSER_SUGGESTIONS_LIST_ITEM_NAME);\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_21__.Slot : \"li\";\n    const isSelected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectedValue === value, [\n        selectedValue,\n        value\n    ]);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>itemId(value), [\n        itemId,\n        value\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (ref?.current && isSelected) {\n            ref.current.scrollIntoView({\n                block: \"nearest\"\n            });\n        }\n    }, [\n        isSelected\n    ]);\n    const handlePointerMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onPointerMove?.(event);\n        if (!event.isDefaultPrevented()) {\n            setSelectedValue(value);\n        }\n    }, [\n        onPointerMove,\n        setSelectedValue,\n        value\n    ]);\n    const handlePointerDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onPointerDown?.(event);\n        if (!event.isDefaultPrevented()) {\n            const target = event.target;\n            if (target.hasPointerCapture(event.pointerId)) {\n                target.releasePointerCapture(event.pointerId);\n            }\n            if (event.button === 0 && event.ctrlKey === false) {\n                onItemSelect(value);\n                event.preventDefault();\n            }\n        }\n    }, [\n        onItemSelect,\n        onPointerDown,\n        value\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        role: \"option\",\n        id,\n        \"data-selected\": isSelected || void 0,\n        \"aria-selected\": isSelected || void 0,\n        onPointerMove: handlePointerMove,\n        onPointerDown: handlePointerDown,\n        ...props,\n        ref: mergedRefs\n    }, children);\n});\nconst defaultEditorComponents = {\n    Link: ({ href, children })=>{\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerLink, {\n            href\n        }, children);\n    },\n    Mention: ({ userId })=>{\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerMention, null, _slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_1__.MENTION_CHARACTER, userId);\n    },\n    MentionSuggestions: ({ userIds })=>{\n        return userIds.length > 0 ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerSuggestions, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerSuggestionsList, null, userIds.map((userId)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerSuggestionsListItem, {\n                key: userId,\n                value: userId\n            }, userId)))) : null;\n    }\n};\nconst ComposerEditor = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ defaultValue, onKeyDown, onFocus, onBlur, disabled, autoFocus, components, dir, ...props }, forwardedRef)=>{\n    const self = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_23__._useSelf)();\n    const isDisabled = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>disabled || !self?.canComment, [\n        disabled,\n        self?.canComment\n    ]);\n    const { editor, validate, setFocused } = (0,_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.useComposerEditorContext)();\n    const { submit, focus, select, isEmpty, isFocused } = (0,_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.useComposer)();\n    const initialBody = (0,_utils_use_initial_mjs__WEBPACK_IMPORTED_MODULE_24__.useInitial)(defaultValue ?? emptyCommentBody);\n    const initialEditorValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_14__.commentBodyToComposerBody)(initialBody);\n    }, [\n        initialBody\n    ]);\n    const { Link, Mention, MentionSuggestions } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...defaultEditorComponents,\n            ...components\n        }), [\n        components\n    ]);\n    const [mentionDraft, setMentionDraft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const mentionSuggestions = (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_25__.useMentionSuggestions)(mentionDraft?.text);\n    const [selectedMentionSuggestionIndex, setPreviousSelectedMentionSuggestionIndex, setNextSelectedMentionSuggestionIndex, setSelectedMentionSuggestionIndex] = (0,_utils_use_index_mjs__WEBPACK_IMPORTED_MODULE_26__.useIndex)(0, mentionSuggestions?.length ?? 0);\n    const id = (0,_utils_use_id_mjs__WEBPACK_IMPORTED_MODULE_27__.useId)();\n    const suggestionsListId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`liveblocks-suggestions-list-${id}`, [\n        id\n    ]);\n    const suggestionsListItemId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((userId)=>userId ? `liveblocks-suggestions-list-item-${id}-${userId}` : void 0, [\n        id\n    ]);\n    const renderElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((props2)=>{\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerEditorElement, {\n            Mention,\n            Link,\n            ...props2\n        });\n    }, [\n        Link,\n        Mention\n    ]);\n    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>{\n        validate(value);\n        setMentionDraft((0,_slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_1__.getMentionDraftAtSelection)(editor));\n    }, [\n        editor,\n        validate\n    ]);\n    const createMention = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((userId)=>{\n        if (!mentionDraft || !userId) {\n            return;\n        }\n        slate__WEBPACK_IMPORTED_MODULE_9__.Transforms.select(editor, mentionDraft.range);\n        (0,_slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_1__.insertMention)(editor, userId);\n        setMentionDraft(void 0);\n        setSelectedMentionSuggestionIndex(0);\n    }, [\n        editor,\n        mentionDraft,\n        setSelectedMentionSuggestionIndex\n    ]);\n    const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onKeyDown?.(event);\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"ArrowLeft\")) {\n            (0,_slate_utils_marks_mjs__WEBPACK_IMPORTED_MODULE_29__.leaveMarkEdge)(editor, \"start\");\n        }\n        if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"ArrowRight\")) {\n            (0,_slate_utils_marks_mjs__WEBPACK_IMPORTED_MODULE_29__.leaveMarkEdge)(editor, \"end\");\n        }\n        if (mentionDraft && mentionSuggestions?.length) {\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"ArrowDown\")) {\n                event.preventDefault();\n                setNextSelectedMentionSuggestionIndex();\n            }\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"ArrowUp\")) {\n                event.preventDefault();\n                setPreviousSelectedMentionSuggestionIndex();\n            }\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"Enter\") || (0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"Tab\")) {\n                event.preventDefault();\n                const userId = mentionSuggestions?.[selectedMentionSuggestionIndex];\n                createMention(userId);\n            }\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"Escape\")) {\n                event.preventDefault();\n                setMentionDraft(void 0);\n                setSelectedMentionSuggestionIndex(0);\n            }\n        } else {\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"Escape\")) {\n                event.preventDefault();\n                slate_react__WEBPACK_IMPORTED_MODULE_8__.ReactEditor.blur(editor);\n            }\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"Enter\", {\n                shift: false\n            }) && !isEmpty) {\n                event.preventDefault();\n                submit();\n            }\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"Enter\", {\n                shift: true\n            })) {\n                event.preventDefault();\n                editor.insertBreak();\n            }\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"b\", {\n                mod: true\n            })) {\n                event.preventDefault();\n                (0,_slate_utils_marks_mjs__WEBPACK_IMPORTED_MODULE_29__.toggleMark)(editor, \"bold\");\n            }\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"i\", {\n                mod: true\n            })) {\n                event.preventDefault();\n                (0,_slate_utils_marks_mjs__WEBPACK_IMPORTED_MODULE_29__.toggleMark)(editor, \"italic\");\n            }\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"s\", {\n                mod: true,\n                shift: true\n            })) {\n                event.preventDefault();\n                (0,_slate_utils_marks_mjs__WEBPACK_IMPORTED_MODULE_29__.toggleMark)(editor, \"strikethrough\");\n            }\n            if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_28__.isKey)(event, \"e\", {\n                mod: true\n            })) {\n                event.preventDefault();\n                (0,_slate_utils_marks_mjs__WEBPACK_IMPORTED_MODULE_29__.toggleMark)(editor, \"code\");\n            }\n        }\n    }, [\n        createMention,\n        editor,\n        isEmpty,\n        mentionDraft,\n        mentionSuggestions,\n        selectedMentionSuggestionIndex,\n        onKeyDown,\n        setNextSelectedMentionSuggestionIndex,\n        setPreviousSelectedMentionSuggestionIndex,\n        setSelectedMentionSuggestionIndex,\n        submit\n    ]);\n    const handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onFocus?.(event);\n        if (!event.isDefaultPrevented()) {\n            setFocused(true);\n        }\n    }, [\n        onFocus,\n        setFocused\n    ]);\n    const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onBlur?.(event);\n        if (!event.isDefaultPrevented()) {\n            setFocused(false);\n        }\n    }, [\n        onBlur,\n        setFocused\n    ]);\n    const selectedMentionSuggestionUserId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>mentionSuggestions?.[selectedMentionSuggestionIndex], [\n        selectedMentionSuggestionIndex,\n        mentionSuggestions\n    ]);\n    const setSelectedMentionSuggestionUserId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((userId)=>{\n        const index = mentionSuggestions?.indexOf(userId);\n        if (index !== void 0 && index >= 0) {\n            setSelectedMentionSuggestionIndex(index);\n        }\n    }, [\n        setSelectedMentionSuggestionIndex,\n        mentionSuggestions\n    ]);\n    const propsWhileSuggesting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>mentionDraft ? {\n            role: \"combobox\",\n            \"aria-autocomplete\": \"list\",\n            \"aria-expanded\": true,\n            \"aria-controls\": suggestionsListId,\n            \"aria-activedescendant\": suggestionsListItemId(selectedMentionSuggestionUserId)\n        } : {}, [\n        mentionDraft,\n        suggestionsListId,\n        suggestionsListItemId,\n        selectedMentionSuggestionUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(forwardedRef, ()=>{\n        return slate_react__WEBPACK_IMPORTED_MODULE_8__.ReactEditor.toDOMNode(editor, editor);\n    }, [\n        editor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoFocus) {\n            focus();\n        }\n    }, [\n        autoFocus,\n        editor,\n        focus\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isFocused && editor.selection === null) {\n            select();\n        }\n    }, [\n        editor,\n        select,\n        isFocused\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(slate_react__WEBPACK_IMPORTED_MODULE_8__.Slate, {\n        editor,\n        initialValue: initialEditorValue,\n        onChange: handleChange\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(slate_react__WEBPACK_IMPORTED_MODULE_8__.Editable, {\n        dir,\n        enterKeyHint: mentionDraft ? \"enter\" : \"send\",\n        autoCapitalize: \"sentences\",\n        \"aria-label\": \"Composer editor\",\n        \"data-focused\": isFocused || void 0,\n        \"data-disabled\": isDisabled || void 0,\n        ...propsWhileSuggesting,\n        ...props,\n        readOnly: isDisabled,\n        disabled: isDisabled,\n        onKeyDown: handleKeyDown,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        renderElement,\n        renderLeaf: ComposerEditorLeaf,\n        renderPlaceholder: ComposerEditorPlaceholder\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComposerEditorMentionSuggestionsWrapper, {\n        dir,\n        mentionDraft,\n        selectedUserId: selectedMentionSuggestionUserId,\n        setSelectedUserId: setSelectedMentionSuggestionUserId,\n        userIds: mentionSuggestions,\n        id: suggestionsListId,\n        itemId: suggestionsListItemId,\n        onItemSelect: createMention,\n        MentionSuggestions\n    }));\n});\nconst ComposerForm = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, onSubmit, onComposerSubmit, asChild, ...props }, forwardedRef)=>{\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_21__.Slot : \"form\";\n    const editor = (0,_utils_use_initial_mjs__WEBPACK_IMPORTED_MODULE_24__.useInitial)(createComposerEditor);\n    const [isEmpty$1, setEmpty] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [isFocused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const mergedRefs = (0,_utils_use_refs_mjs__WEBPACK_IMPORTED_MODULE_22__.useRefs)(forwardedRef, ref);\n    const validate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>{\n        setEmpty((0,_slate_utils_is_empty_mjs__WEBPACK_IMPORTED_MODULE_30__.isEmpty)(editor, value));\n    }, [\n        editor\n    ]);\n    const submit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        requestAnimationFrame(()=>{\n            if (ref.current) {\n                (0,_utils_request_submit_mjs__WEBPACK_IMPORTED_MODULE_31__.requestSubmit)(ref.current);\n            }\n        });\n    }, []);\n    const clear = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        slate__WEBPACK_IMPORTED_MODULE_9__.Transforms.delete(editor, {\n            at: {\n                anchor: slate__WEBPACK_IMPORTED_MODULE_9__.Editor.start(editor, []),\n                focus: slate__WEBPACK_IMPORTED_MODULE_9__.Editor.end(editor, [])\n            }\n        });\n    }, [\n        editor\n    ]);\n    const select = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        slate__WEBPACK_IMPORTED_MODULE_9__.Transforms.select(editor, {\n            anchor: slate__WEBPACK_IMPORTED_MODULE_9__.Editor.end(editor, []),\n            focus: slate__WEBPACK_IMPORTED_MODULE_9__.Editor.end(editor, [])\n        });\n    }, [\n        editor\n    ]);\n    const focus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((resetSelection = true)=>{\n        if (!slate_react__WEBPACK_IMPORTED_MODULE_8__.ReactEditor.isFocused(editor)) {\n            slate__WEBPACK_IMPORTED_MODULE_9__.Transforms.select(editor, resetSelection || !editor.selection ? slate__WEBPACK_IMPORTED_MODULE_9__.Editor.end(editor, []) : editor.selection);\n            slate_react__WEBPACK_IMPORTED_MODULE_8__.ReactEditor.focus(editor);\n        }\n    }, [\n        editor\n    ]);\n    const blur = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        slate_react__WEBPACK_IMPORTED_MODULE_8__.ReactEditor.blur(editor);\n    }, [\n        editor\n    ]);\n    const onSubmitEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        clear();\n        blur();\n    }, [\n        blur,\n        clear\n    ]);\n    const createMention = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        focus();\n        (0,_slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_1__.insertMentionCharacter)(editor);\n    }, [\n        editor,\n        focus\n    ]);\n    const insertText$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((text)=>{\n        focus(false);\n        (0,slate__WEBPACK_IMPORTED_MODULE_9__.insertText)(editor, text);\n    }, [\n        editor,\n        focus\n    ]);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        const isEmpty2 = (0,_slate_utils_is_empty_mjs__WEBPACK_IMPORTED_MODULE_30__.isEmpty)(editor, editor.children);\n        if (isEmpty2) {\n            event.preventDefault();\n            return;\n        }\n        onSubmit?.(event);\n        if (!onComposerSubmit || event.isDefaultPrevented()) {\n            event.preventDefault();\n            return;\n        }\n        const body = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_14__.composerBodyToCommentBody)(editor.children);\n        const comment = {\n            body\n        };\n        const promise = onComposerSubmit(comment, event);\n        event.preventDefault();\n        if (promise) {\n            promise.then(onSubmitEnd);\n        } else {\n            onSubmitEnd();\n        }\n    }, [\n        editor,\n        onComposerSubmit,\n        onSubmit,\n        onSubmitEnd\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.ComposerEditorContext.Provider, {\n        value: {\n            editor,\n            validate,\n            setFocused\n        }\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.ComposerContext.Provider, {\n        value: {\n            isFocused,\n            isEmpty: isEmpty$1,\n            submit,\n            clear,\n            select,\n            focus,\n            blur,\n            createMention,\n            insertText: insertText$1\n        }\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        ...props,\n        onSubmit: handleSubmit,\n        ref: mergedRefs\n    }, children)));\n});\nconst ComposerSubmit = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, disabled, asChild, ...props }, forwardedRef)=>{\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_21__.Slot : \"button\";\n    const { isEmpty } = (0,_contexts_mjs__WEBPACK_IMPORTED_MODULE_11__.useComposer)();\n    const self = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_23__._useSelf)();\n    const isDisabled = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>disabled || isEmpty || !self?.canComment, [\n        disabled,\n        isEmpty,\n        self?.canComment\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        type: \"submit\",\n        ...props,\n        ref: forwardedRef,\n        disabled: isDisabled\n    }, children);\n});\nif (true) {\n    ComposerEditor.displayName = COMPOSER_EDITOR_NAME;\n    ComposerForm.displayName = COMPOSER_FORM_NAME;\n    ComposerMention.displayName = COMPOSER_MENTION_NAME;\n    ComposerLink.displayName = COMPOSER_LINK_NAME;\n    ComposerSubmit.displayName = COMPOSER_SUBMIT_NAME;\n    ComposerSuggestions.displayName = COMPOSER_SUGGESTIONS_NAME;\n    ComposerSuggestionsList.displayName = COMPOSER_SUGGESTIONS_LIST_NAME;\n    ComposerSuggestionsListItem.displayName = COMPOSER_SUGGESTIONS_LIST_ITEM_NAME;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0NvbXBvc2VyL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThIQSxNQUFBQSwrQkFBQTtBQUVBLE1BQUFDLHdCQUFBO0FBQ0EsTUFBQUMscUJBQUE7QUFDQSxNQUFBQyw0QkFBQTtBQUNBLE1BQUFDLGlDQUFBO0FBQ0EsTUFBQUMsc0NBQUE7QUFDQSxNQUFBQyx1QkFBQTtBQUNBLE1BQUFDLHVCQUFBO0FBQ0EsTUFBQUMscUJBQUE7QUFFQSxNQUFBQyxtQkFBQTtJQUFzQ0MsU0FBQTtJQUMzQkMsU0FBQTtRQUFBO1lBQUFDLE1BQUE7WUFBQUMsVUFBQTtnQkFBQTtvQkFBQUMsTUFBQTtnQkFBQTthQUFBO1FBQUE7S0FBQTtBQUVYO0FBRUEsU0FBQUM7SUFDRSxPQUFBQyx5RUFBQUEsQ0FBT0MsZ0ZBQUFBLENBQ0xDLDRFQUFBQSxDQUNFQyxzRkFBQUEsQ0FDRUMsbUdBQUFBLENBQ0VDLDRFQUFBQSxDQUFBQywwREFBQUEsQ0FBQUMsc0RBQUFBLENBQUFDLG1EQUFBQTtBQU9WO0FBRUEsU0FBQUMsNkJBQUEsRUFBc0NDLE9BQUEsRUFDcENDLFVBQUEsRUFDQWQsUUFBQSxFQUNBZSxPQUFBLEVBRUY7SUFDRSxNQUFBQyxhQUFBQyx3REFBQUE7SUFFQSxxQ0FBQUMsZ0RBQUE7UUFDRyxHQUFBSixVQUFBO0lBQVMsR0FBQUMsUUFBQUssRUFBQSxpQ0FBQUYsZ0RBQUEsQ0FBQUwsU0FBQTtRQUVMUSxRQUFBTixRQUFBSyxFQUFBO1FBQXdCSjtJQUFJLFdBQUFoQjtBQUtyQztBQUVBLFNBQUFzQiwwQkFBQSxFQUFtQ0MsSUFBQSxFQUNqQ1QsVUFBQSxFQUNBQyxPQUFBLEVBQ0FmLFFBQUEsRUFFRjtJQUNFLE1BQUF3QixPQUFBQyw4Q0FB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QWtHLFdBQUEsR0FBQTVRO0lBQ0E4TyxhQUFBOEIsV0FBQSxHQUFBM1E7SUFDQXlILGdCQUFBa0osV0FBQSxHQUFBbFI7SUFDQXNJLGFBQUE0SSxXQUFBLEdBQUFqUjtJQUNBK1EsZUFBQUUsV0FBQSxHQUFBN1E7SUFDQW9JLG9CQUFBeUksV0FBQSxHQUFBaFI7SUFDQXNKLHdCQUFBMEgsV0FBQSxHQUFBL1E7SUFDQXVKLDRCQUFBd0gsV0FBQSxHQUFBOVE7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uLi8uLi8uLi9zcmMvcHJpbWl0aXZlcy9Db21wb3Nlci9pbmRleC50c3g/ZGQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHR5cGUge1xuICBEZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gIFVzZUZsb2F0aW5nT3B0aW9ucyxcbn0gZnJvbSBcIkBmbG9hdGluZy11aS9yZWFjdC1kb21cIjtcbmltcG9ydCB7XG4gIGF1dG9VcGRhdGUsXG4gIGZsaXAsXG4gIGhpZGUsXG4gIGxpbWl0U2hpZnQsXG4gIHNoaWZ0LFxuICBzaXplLFxuICB1c2VGbG9hdGluZyxcbn0gZnJvbSBcIkBmbG9hdGluZy11aS9yZWFjdC1kb21cIjtcbmltcG9ydCB0eXBlIHsgQ29tbWVudEJvZHkgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHsgdXNlU2VsZiB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xuaW1wb3J0IHsgU2xvdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3Qtc2xvdFwiO1xuaW1wb3J0IHR5cGUge1xuICBBcmlhQXR0cmlidXRlcyxcbiAgRm9jdXNFdmVudCxcbiAgRm9ybUV2ZW50LFxuICBLZXlib2FyZEV2ZW50LFxuICBQb2ludGVyRXZlbnQsXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0LCB7XG4gIGZvcndhcmRSZWYsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZU1lbW8sXG4gIHVzZVJlZixcbiAgdXNlU3RhdGUsXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBEZXNjZW5kYW50IGFzIFNsYXRlRGVzY2VuZGFudCxcbiAgRWxlbWVudCBhcyBTbGF0ZUVsZW1lbnQsXG59IGZyb20gXCJzbGF0ZVwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlRWRpdG9yLFxuICBFZGl0b3IgYXMgU2xhdGVFZGl0b3IsXG4gIGluc2VydFRleHQgYXMgaW5zZXJ0U2xhdGVUZXh0LFxuICBUcmFuc2Zvcm1zIGFzIFNsYXRlVHJhbnNmb3Jtcyxcbn0gZnJvbSBcInNsYXRlXCI7XG5pbXBvcnQgeyB3aXRoSGlzdG9yeSB9IGZyb20gXCJzbGF0ZS1oaXN0b3J5XCI7XG5pbXBvcnQgdHlwZSB7XG4gIFJlbmRlckVsZW1lbnRQcm9wcyxcbiAgUmVuZGVyRWxlbWVudFNwZWNpZmljUHJvcHMsXG4gIFJlbmRlckxlYWZQcm9wcyxcbiAgUmVuZGVyUGxhY2Vob2xkZXJQcm9wcyxcbn0gZnJvbSBcInNsYXRlLXJlYWN0XCI7XG5pbXBvcnQge1xuICBFZGl0YWJsZSxcbiAgUmVhY3RFZGl0b3IsXG4gIFNsYXRlLFxuICB1c2VTZWxlY3RlZCxcbiAgdXNlU2xhdGVTdGF0aWMsXG4gIHdpdGhSZWFjdCxcbn0gZnJvbSBcInNsYXRlLXJlYWN0XCI7XG5cbmltcG9ydCB7IHVzZUxpdmVibG9ja3NVSUNvbmZpZyB9IGZyb20gXCIuLi8uLi9jb25maWdcIjtcbmltcG9ydCB7IEZMT0FUSU5HX0VMRU1FTlRfQ09MTElTSU9OX1BBRERJTkcgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyB1c2VNZW50aW9uU3VnZ2VzdGlvbnMgfSBmcm9tIFwiLi4vLi4vc2hhcmVkXCI7XG5pbXBvcnQgeyB3aXRoQXV0b0Zvcm1hdHRpbmcgfSBmcm9tIFwiLi4vLi4vc2xhdGUvcGx1Z2lucy9hdXRvLWZvcm1hdHRpbmdcIjtcbmltcG9ydCB7IHdpdGhBdXRvTGlua3MgfSBmcm9tIFwiLi4vLi4vc2xhdGUvcGx1Z2lucy9hdXRvLWxpbmtzXCI7XG5pbXBvcnQgeyB3aXRoQ3VzdG9tTGlua3MgfSBmcm9tIFwiLi4vLi4vc2xhdGUvcGx1Z2lucy9jdXN0b20tbGlua3NcIjtcbmltcG9ydCB7IHdpdGhFbXB0eUNsZWFyRm9ybWF0dGluZyB9IGZyb20gXCIuLi8uLi9zbGF0ZS9wbHVnaW5zL2VtcHR5LWNsZWFyLWZvcm1hdHRpbmdcIjtcbmltcG9ydCB0eXBlIHsgTWVudGlvbkRyYWZ0IH0gZnJvbSBcIi4uLy4uL3NsYXRlL3BsdWdpbnMvbWVudGlvbnNcIjtcbmltcG9ydCB7XG4gIGdldE1lbnRpb25EcmFmdEF0U2VsZWN0aW9uLFxuICBpbnNlcnRNZW50aW9uLFxuICBpbnNlcnRNZW50aW9uQ2hhcmFjdGVyLFxuICBNRU5USU9OX0NIQVJBQ1RFUixcbiAgd2l0aE1lbnRpb25zLFxufSBmcm9tIFwiLi4vLi4vc2xhdGUvcGx1Z2lucy9tZW50aW9uc1wiO1xuaW1wb3J0IHsgd2l0aFBhc3RlSHRtbCB9IGZyb20gXCIuLi8uLi9zbGF0ZS9wbHVnaW5zL3Bhc3RlLWh0bWxcIjtcbmltcG9ydCB7IGdldERPTVJhbmdlIH0gZnJvbSBcIi4uLy4uL3NsYXRlL3V0aWxzL2dldC1kb20tcmFuZ2VcIjtcbmltcG9ydCB7IGlzRW1wdHkgYXMgaXNFZGl0b3JFbXB0eSB9IGZyb20gXCIuLi8uLi9zbGF0ZS91dGlscy9pcy1lbXB0eVwiO1xuaW1wb3J0IHsgbGVhdmVNYXJrRWRnZSwgdG9nZ2xlTWFyayB9IGZyb20gXCIuLi8uLi9zbGF0ZS91dGlscy9tYXJrc1wiO1xuaW1wb3J0IHR5cGUge1xuICBDb21wb3NlckJvZHkgYXMgQ29tcG9zZXJCb2R5RGF0YSxcbiAgQ29tcG9zZXJCb2R5QXV0b0xpbmssXG4gIENvbXBvc2VyQm9keUN1c3RvbUxpbmssXG4gIENvbXBvc2VyQm9keU1lbnRpb24sXG59IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgaXNLZXkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaXMta2V5XCI7XG5pbXBvcnQgeyBQZXJzaXN0LCB1c2VBbmltYXRpb25QZXJzaXN0LCB1c2VQZXJzaXN0IH0gZnJvbSBcIi4uLy4uL3V0aWxzL1BlcnNpc3RcIjtcbmltcG9ydCB7IFBvcnRhbCB9IGZyb20gXCIuLi8uLi91dGlscy9Qb3J0YWxcIjtcbmltcG9ydCB7IHJlcXVlc3RTdWJtaXQgfSBmcm9tIFwiLi4vLi4vdXRpbHMvcmVxdWVzdC1zdWJtaXRcIjtcbmltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3VzZS1pZFwiO1xuaW1wb3J0IHsgdXNlSW5kZXggfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXNlLWluZGV4XCI7XG5pbXBvcnQgeyB1c2VJbml0aWFsIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3VzZS1pbml0aWFsXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZVJlZnMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXNlLXJlZnNcIjtcbmltcG9ydCB7IHRvQWJzb2x1dGVVcmwgfSBmcm9tIFwiLi4vQ29tbWVudC91dGlsc1wiO1xuaW1wb3J0IHtcbiAgQ29tcG9zZXJDb250ZXh0LFxuICBDb21wb3NlckVkaXRvckNvbnRleHQsXG4gIENvbXBvc2VyU3VnZ2VzdGlvbnNDb250ZXh0LFxuICB1c2VDb21wb3NlcixcbiAgdXNlQ29tcG9zZXJFZGl0b3JDb250ZXh0LFxuICB1c2VDb21wb3NlclN1Z2dlc3Rpb25zQ29udGV4dCxcbn0gZnJvbSBcIi4vY29udGV4dHNcIjtcbmltcG9ydCB0eXBlIHtcbiAgQ29tcG9zZXJFZGl0b3JDb21wb25lbnRzLFxuICBDb21wb3NlckVkaXRvckVsZW1lbnRQcm9wcyxcbiAgQ29tcG9zZXJFZGl0b3JMaW5rV3JhcHBlclByb3BzLFxuICBDb21wb3NlckVkaXRvck1lbnRpb25TdWdnZXN0aW9uc1dyYXBwZXJQcm9wcyxcbiAgQ29tcG9zZXJFZGl0b3JNZW50aW9uV3JhcHBlclByb3BzLFxuICBDb21wb3NlckVkaXRvclByb3BzLFxuICBDb21wb3NlckZvcm1Qcm9wcyxcbiAgQ29tcG9zZXJMaW5rUHJvcHMsXG4gIENvbXBvc2VyTWVudGlvblByb3BzLFxuICBDb21wb3NlclN1Ym1pdFByb3BzLFxuICBDb21wb3NlclN1Z2dlc3Rpb25zTGlzdEl0ZW1Qcm9wcyxcbiAgQ29tcG9zZXJTdWdnZXN0aW9uc0xpc3RQcm9wcyxcbiAgQ29tcG9zZXJTdWdnZXN0aW9uc1Byb3BzLFxuICBTdWdnZXN0aW9uc1Bvc2l0aW9uLFxufSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHtcbiAgY29tbWVudEJvZHlUb0NvbXBvc2VyQm9keSxcbiAgY29tcG9zZXJCb2R5VG9Db21tZW50Qm9keSxcbiAgZ2V0UGxhY2VtZW50RnJvbVBvc2l0aW9uLFxuICBnZXRTaWRlQW5kQWxpZ25Gcm9tUGxhY2VtZW50LFxufSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCBNRU5USU9OX1NVR0dFU1RJT05TX1BPU0lUSU9OOiBTdWdnZXN0aW9uc1Bvc2l0aW9uID0gXCJ0b3BcIjtcblxuY29uc3QgQ09NUE9TRVJfTUVOVElPTl9OQU1FID0gXCJDb21wb3Nlck1lbnRpb25cIjtcbmNvbnN0IENPTVBPU0VSX0xJTktfTkFNRSA9IFwiQ29tcG9zZXJMaW5rXCI7XG5jb25zdCBDT01QT1NFUl9TVUdHRVNUSU9OU19OQU1FID0gXCJDb21wb3NlclN1Z2dlc3Rpb25zXCI7XG5jb25zdCBDT01QT1NFUl9TVUdHRVNUSU9OU19MSVNUX05BTUUgPSBcIkNvbXBvc2VyU3VnZ2VzdGlvbnNMaXN0XCI7XG5jb25zdCBDT01QT1NFUl9TVUdHRVNUSU9OU19MSVNUX0lURU1fTkFNRSA9IFwiQ29tcG9zZXJTdWdnZXN0aW9uc0xpc3RJdGVtXCI7XG5jb25zdCBDT01QT1NFUl9TVUJNSVRfTkFNRSA9IFwiQ29tcG9zZXJTdWJtaXRcIjtcbmNvbnN0IENPTVBPU0VSX0VESVRPUl9OQU1FID0gXCJDb21wb3NlckVkaXRvclwiO1xuY29uc3QgQ09NUE9TRVJfRk9STV9OQU1FID0gXCJDb21wb3NlckZvcm1cIjtcblxuY29uc3QgZW1wdHlDb21tZW50Qm9keTogQ29tbWVudEJvZHkgPSB7XG4gIHZlcnNpb246IDEsXG4gIGNvbnRlbnQ6IFt7IHR5cGU6IFwicGFyYWdyYXBoXCIsIGNoaWxkcmVuOiBbeyB0ZXh0OiBcIlwiIH1dIH1dLFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9zZXJFZGl0b3IoKSB7XG4gIHJldHVybiB3aXRoTWVudGlvbnMoXG4gICAgd2l0aEN1c3RvbUxpbmtzKFxuICAgICAgd2l0aEF1dG9MaW5rcyhcbiAgICAgICAgd2l0aEF1dG9Gb3JtYXR0aW5nKFxuICAgICAgICAgIHdpdGhFbXB0eUNsZWFyRm9ybWF0dGluZyhcbiAgICAgICAgICAgIHdpdGhQYXN0ZUh0bWwod2l0aEhpc3Rvcnkod2l0aFJlYWN0KGNyZWF0ZUVkaXRvcigpKSkpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuICApO1xufVxuXG5mdW5jdGlvbiBDb21wb3NlckVkaXRvck1lbnRpb25XcmFwcGVyKHtcbiAgTWVudGlvbixcbiAgYXR0cmlidXRlcyxcbiAgY2hpbGRyZW4sXG4gIGVsZW1lbnQsXG59OiBDb21wb3NlckVkaXRvck1lbnRpb25XcmFwcGVyUHJvcHMpIHtcbiAgY29uc3QgaXNTZWxlY3RlZCA9IHVzZVNlbGVjdGVkKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8c3BhbiB7Li4uYXR0cmlidXRlc30+XG4gICAgICB7ZWxlbWVudC5pZCA/IChcbiAgICAgICAgPE1lbnRpb24gdXNlcklkPXtlbGVtZW50LmlkfSBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfSAvPlxuICAgICAgKSA6IG51bGx9XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9zcGFuPlxuICApO1xufVxuXG5mdW5jdGlvbiBDb21wb3NlckVkaXRvckxpbmtXcmFwcGVyKHtcbiAgTGluayxcbiAgYXR0cmlidXRlcyxcbiAgZWxlbWVudCxcbiAgY2hpbGRyZW4sXG59OiBDb21wb3NlckVkaXRvckxpbmtXcmFwcGVyUHJvcHMpIHtcbiAgY29uc3QgaHJlZiA9IHVzZU1lbW8oXG4gICAgKCkgPT4gdG9BYnNvbHV0ZVVybChlbGVtZW50LnVybCkgPz8gZWxlbWVudC51cmwsXG4gICAgW2VsZW1lbnQudXJsXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPHNwYW4gey4uLmF0dHJpYnV0ZXN9PlxuICAgICAgPExpbmsgaHJlZj17aHJlZn0+e2NoaWxkcmVufTwvTGluaz5cbiAgICA8L3NwYW4+XG4gICk7XG59XG5cbmZ1bmN0aW9uIENvbXBvc2VyRWRpdG9yTWVudGlvblN1Z2dlc3Rpb25zV3JhcHBlcih7XG4gIGlkLFxuICBpdGVtSWQsXG4gIHVzZXJJZHMsXG4gIHNlbGVjdGVkVXNlcklkLFxuICBzZXRTZWxlY3RlZFVzZXJJZCxcbiAgbWVudGlvbkRyYWZ0LFxuICBvbkl0ZW1TZWxlY3QsXG4gIHBvc2l0aW9uID0gTUVOVElPTl9TVUdHRVNUSU9OU19QT1NJVElPTixcbiAgZGlyLFxuICBNZW50aW9uU3VnZ2VzdGlvbnMsXG59OiBDb21wb3NlckVkaXRvck1lbnRpb25TdWdnZXN0aW9uc1dyYXBwZXJQcm9wcykge1xuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICBjb25zdCB7IGlzRm9jdXNlZCB9ID0gdXNlQ29tcG9zZXIoKTtcbiAgY29uc3QgW2NvbnRlbnQsIHNldENvbnRlbnRdID0gdXNlU3RhdGU8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2NvbnRlbnRaSW5kZXgsIHNldENvbnRlbnRaSW5kZXhdID0gdXNlU3RhdGU8c3RyaW5nPigpO1xuICBjb25zdCBjb250ZW50UmVmID0gdXNlQ2FsbGJhY2soc2V0Q29udGVudCwgW3NldENvbnRlbnRdKTtcbiAgY29uc3QgeyBwb3J0YWxDb250YWluZXIgfSA9IHVzZUxpdmVibG9ja3NVSUNvbmZpZygpO1xuICBjb25zdCBmbG9hdGluZ09wdGlvbnM6IFVzZUZsb2F0aW5nT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGRldGVjdE92ZXJmbG93T3B0aW9uczogRGV0ZWN0T3ZlcmZsb3dPcHRpb25zID0ge1xuICAgICAgcGFkZGluZzogRkxPQVRJTkdfRUxFTUVOVF9DT0xMSVNJT05fUEFERElORyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmF0ZWd5OiBcImZpeGVkXCIsXG4gICAgICBwbGFjZW1lbnQ6IGdldFBsYWNlbWVudEZyb21Qb3NpdGlvbihwb3NpdGlvbiwgZGlyKSxcbiAgICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgICAgZmxpcCh7IC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucywgY3Jvc3NBeGlzOiBmYWxzZSB9KSxcbiAgICAgICAgaGlkZShkZXRlY3RPdmVyZmxvd09wdGlvbnMpLFxuICAgICAgICBzaGlmdCh7XG4gICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgIGxpbWl0ZXI6IGxpbWl0U2hpZnQoKSxcbiAgICAgICAgfSksXG4gICAgICAgIHNpemUoe1xuICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICBhcHBseSh7IGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQsIGVsZW1lbnRzIH0pIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZsb2F0aW5nLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICBcIi0tbGItY29tcG9zZXItc3VnZ2VzdGlvbnMtYXZhaWxhYmxlLXdpZHRoXCIsXG4gICAgICAgICAgICAgIGAke2F2YWlsYWJsZVdpZHRofXB4YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZsb2F0aW5nLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICBcIi0tbGItY29tcG9zZXItc3VnZ2VzdGlvbnMtYXZhaWxhYmxlLWhlaWdodFwiLFxuICAgICAgICAgICAgICBgJHthdmFpbGFibGVIZWlnaHR9cHhgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgXSxcbiAgICAgIHdoaWxlRWxlbWVudHNNb3VudGVkOiBhdXRvVXBkYXRlLFxuICAgIH07XG4gIH0sIFtwb3NpdGlvbiwgZGlyXSk7XG4gIGNvbnN0IHtcbiAgICByZWZzOiB7IHNldFJlZmVyZW5jZSwgc2V0RmxvYXRpbmcgfSxcbiAgICBzdHJhdGVneSxcbiAgICBpc1Bvc2l0aW9uZWQsXG4gICAgcGxhY2VtZW50LFxuICAgIHgsXG4gICAgeSxcbiAgfSA9IHVzZUZsb2F0aW5nKGZsb2F0aW5nT3B0aW9ucyk7XG5cbiAgLy8gQ29weSBgei1pbmRleGAgZnJvbSBjb250ZW50IHRvIHdyYXBwZXIuXG4gIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWRpeC11aS9wcmltaXRpdmVzL2Jsb2IvbWFpbi9wYWNrYWdlcy9yZWFjdC9wb3BwZXIvc3JjL1BvcHBlci50c3hcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgc2V0Q29udGVudFpJbmRleCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50KS56SW5kZXgpO1xuICAgIH1cbiAgfSwgW2NvbnRlbnRdKTtcblxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWVudGlvbkRyYWZ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZG9tUmFuZ2UgPSBnZXRET01SYW5nZShlZGl0b3IsIG1lbnRpb25EcmFmdC5yYW5nZSk7XG5cbiAgICBpZiAoZG9tUmFuZ2UpIHtcbiAgICAgIHNldFJlZmVyZW5jZSh7XG4gICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogKCkgPT4gZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGdldENsaWVudFJlY3RzOiAoKSA9PiBkb21SYW5nZS5nZXRDbGllbnRSZWN0cygpLFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc2V0UmVmZXJlbmNlLCBlZGl0b3IsIG1lbnRpb25EcmFmdF0pO1xuXG4gIHJldHVybiAoXG4gICAgPFBlcnNpc3Q+XG4gICAgICB7bWVudGlvbkRyYWZ0Py5yYW5nZSAmJiBpc0ZvY3VzZWQgJiYgdXNlcklkcyA/IChcbiAgICAgICAgPENvbXBvc2VyU3VnZ2VzdGlvbnNDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgaXRlbUlkLFxuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRVc2VySWQsXG4gICAgICAgICAgICBzZXRTZWxlY3RlZFZhbHVlOiBzZXRTZWxlY3RlZFVzZXJJZCxcbiAgICAgICAgICAgIG9uSXRlbVNlbGVjdCxcbiAgICAgICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgIHJlZjogY29udGVudFJlZixcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPFBvcnRhbFxuICAgICAgICAgICAgcmVmPXtzZXRGbG9hdGluZ31cbiAgICAgICAgICAgIGNvbnRhaW5lcj17cG9ydGFsQ29udGFpbmVyfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogaXNQb3NpdGlvbmVkXG4gICAgICAgICAgICAgICAgPyBgdHJhbnNsYXRlM2QoJHtNYXRoLnJvdW5kKHgpfXB4LCAke01hdGgucm91bmQoeSl9cHgsIDApYFxuICAgICAgICAgICAgICAgIDogXCJ0cmFuc2xhdGUzZCgwLCAtMjAwJSwgMClcIixcbiAgICAgICAgICAgICAgbWluV2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgICAgICAgekluZGV4OiBjb250ZW50WkluZGV4LFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8TWVudGlvblN1Z2dlc3Rpb25zXG4gICAgICAgICAgICAgIHVzZXJJZHM9e3VzZXJJZHN9XG4gICAgICAgICAgICAgIHNlbGVjdGVkVXNlcklkPXtzZWxlY3RlZFVzZXJJZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9Qb3J0YWw+XG4gICAgICAgIDwvQ29tcG9zZXJTdWdnZXN0aW9uc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICApIDogbnVsbH1cbiAgICA8L1BlcnNpc3Q+XG4gICk7XG59XG5cbmZ1bmN0aW9uIENvbXBvc2VyRWRpdG9yRWxlbWVudCh7XG4gIE1lbnRpb24sXG4gIExpbmssXG4gIC4uLnByb3BzXG59OiBDb21wb3NlckVkaXRvckVsZW1lbnRQcm9wcykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gIGNvbnN0IHsgYXR0cmlidXRlcywgY2hpbGRyZW4sIGVsZW1lbnQgfSA9IHByb3BzO1xuXG4gIHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XG4gICAgY2FzZSBcIm1lbnRpb25cIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDb21wb3NlckVkaXRvck1lbnRpb25XcmFwcGVyXG4gICAgICAgICAgTWVudGlvbj17TWVudGlvbn1cbiAgICAgICAgICB7Li4uKHByb3BzIGFzIFJlbmRlckVsZW1lbnRTcGVjaWZpY1Byb3BzPENvbXBvc2VyQm9keU1lbnRpb24+KX1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgY2FzZSBcImF1dG8tbGlua1wiOlxuICAgIGNhc2UgXCJjdXN0b20tbGlua1wiOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPENvbXBvc2VyRWRpdG9yTGlua1dyYXBwZXJcbiAgICAgICAgICBMaW5rPXtMaW5rfVxuICAgICAgICAgIHsuLi4ocHJvcHMgYXMgUmVuZGVyRWxlbWVudFNwZWNpZmljUHJvcHM8XG4gICAgICAgICAgICBDb21wb3NlckJvZHlBdXRvTGluayB8IENvbXBvc2VyQm9keUN1c3RvbUxpbmtcbiAgICAgICAgICA+KX1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgY2FzZSBcInBhcmFncmFwaFwiOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPHAgey4uLmF0dHJpYnV0ZXN9IHN0eWxlPXt7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfX0+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L3A+XG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyA8Y29kZT48cz48ZW0+PHN0cm9uZz50ZXh0PC9zdHJvbmc+PC9zPjwvZW0+PC9jb2RlPlxuZnVuY3Rpb24gQ29tcG9zZXJFZGl0b3JMZWFmKHsgYXR0cmlidXRlcywgY2hpbGRyZW4sIGxlYWYgfTogUmVuZGVyTGVhZlByb3BzKSB7XG4gIGlmIChsZWFmLmJvbGQpIHtcbiAgICBjaGlsZHJlbiA9IDxzdHJvbmc+e2NoaWxkcmVufTwvc3Ryb25nPjtcbiAgfVxuXG4gIGlmIChsZWFmLml0YWxpYykge1xuICAgIGNoaWxkcmVuID0gPGVtPntjaGlsZHJlbn08L2VtPjtcbiAgfVxuXG4gIGlmIChsZWFmLnN0cmlrZXRocm91Z2gpIHtcbiAgICBjaGlsZHJlbiA9IDxzPntjaGlsZHJlbn08L3M+O1xuICB9XG5cbiAgaWYgKGxlYWYuY29kZSkge1xuICAgIGNoaWxkcmVuID0gPGNvZGU+e2NoaWxkcmVufTwvY29kZT47XG4gIH1cblxuICByZXR1cm4gPHNwYW4gey4uLmF0dHJpYnV0ZXN9PntjaGlsZHJlbn08L3NwYW4+O1xufVxuXG5mdW5jdGlvbiBDb21wb3NlckVkaXRvclBsYWNlaG9sZGVyKHtcbiAgYXR0cmlidXRlcyxcbiAgY2hpbGRyZW4sXG59OiBSZW5kZXJQbGFjZWhvbGRlclByb3BzKSB7XG4gIGNvbnN0IHsgb3BhY2l0eTogX29wYWNpdHksIC4uLnN0eWxlIH0gPSBhdHRyaWJ1dGVzLnN0eWxlO1xuXG4gIHJldHVybiAoXG4gICAgPHNwYW4gey4uLmF0dHJpYnV0ZXN9IHN0eWxlPXtzdHlsZX0gZGF0YS1wbGFjZWhvbGRlcj1cIlwiPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5cyBtZW50aW9ucyB3aXRoaW4gYENvbXBvc2VyLkVkaXRvcmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxDb21wb3Nlci5NZW50aW9uPkB7dXNlcklkfTwvQ29tcG9zZXIuTWVudGlvbj5cbiAqL1xuY29uc3QgQ29tcG9zZXJNZW50aW9uID0gZm9yd2FyZFJlZjxIVE1MU3BhbkVsZW1lbnQsIENvbXBvc2VyTWVudGlvblByb3BzPihcbiAgKHsgY2hpbGRyZW4sIGFzQ2hpbGQsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJzcGFuXCI7XG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IHVzZVNlbGVjdGVkKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENvbXBvbmVudFxuICAgICAgICBkYXRhLXNlbGVjdGVkPXtpc1NlbGVjdGVkIHx8IHVuZGVmaW5lZH1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9Db21wb25lbnQ+XG4gICAgKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBEaXNwbGF5cyBsaW5rcyB3aXRoaW4gYENvbXBvc2VyLkVkaXRvcmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxDb21wb3Nlci5MaW5rIGhyZWY9e2hyZWZ9PntjaGlsZHJlbn08L0NvbXBvc2VyLkxpbms+XG4gKi9cbmNvbnN0IENvbXBvc2VyTGluayA9IGZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIENvbXBvc2VyTGlua1Byb3BzPihcbiAgKHsgY2hpbGRyZW4sIGFzQ2hpbGQsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJhXCI7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENvbXBvbmVudFxuICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICByZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCJcbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9Db21wb25lbnQ+XG4gICAgKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBDb250YWlucyBzdWdnZXN0aW9ucyB3aXRoaW4gYENvbXBvc2VyLkVkaXRvcmAuXG4gKi9cbmNvbnN0IENvbXBvc2VyU3VnZ2VzdGlvbnMgPSBmb3J3YXJkUmVmPFxuICBIVE1MRGl2RWxlbWVudCxcbiAgQ29tcG9zZXJTdWdnZXN0aW9uc1Byb3BzXG4+KCh7IGNoaWxkcmVuLCBzdHlsZSwgYXNDaGlsZCwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IFtpc1ByZXNlbnRdID0gdXNlUGVyc2lzdCgpO1xuICBjb25zdCByZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCB7XG4gICAgcmVmOiBjb250ZW50UmVmLFxuICAgIHBsYWNlbWVudCxcbiAgICBkaXIsXG4gIH0gPSB1c2VDb21wb3NlclN1Z2dlc3Rpb25zQ29udGV4dChDT01QT1NFUl9TVUdHRVNUSU9OU19OQU1FKTtcbiAgY29uc3QgbWVyZ2VkUmVmcyA9IHVzZVJlZnMoZm9yd2FyZGVkUmVmLCBjb250ZW50UmVmLCByZWYpO1xuICBjb25zdCBbc2lkZSwgYWxpZ25dID0gdXNlTWVtbyhcbiAgICAoKSA9PiBnZXRTaWRlQW5kQWxpZ25Gcm9tUGxhY2VtZW50KHBsYWNlbWVudCksXG4gICAgW3BsYWNlbWVudF1cbiAgKTtcbiAgY29uc3QgQ29tcG9uZW50ID0gYXNDaGlsZCA/IFNsb3QgOiBcImRpdlwiO1xuICB1c2VBbmltYXRpb25QZXJzaXN0KHJlZik7XG5cbiAgcmV0dXJuIChcbiAgICA8Q29tcG9uZW50XG4gICAgICBkaXI9e2Rpcn1cbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIGRhdGEtc3RhdGU9e2lzUHJlc2VudCA/IFwib3BlblwiIDogXCJjbG9zZWRcIn1cbiAgICAgIGRhdGEtc2lkZT17c2lkZX1cbiAgICAgIGRhdGEtYWxpZ249e2FsaWdufVxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgIG1heEhlaWdodDogXCJ2YXIoLS1sYi1jb21wb3Nlci1zdWdnZXN0aW9ucy1hdmFpbGFibGUtaGVpZ2h0KVwiLFxuICAgICAgICBvdmVyZmxvd1k6IFwiYXV0b1wiLFxuICAgICAgICAuLi5zdHlsZSxcbiAgICAgIH19XG4gICAgICByZWY9e21lcmdlZFJlZnN9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQ29tcG9uZW50PlxuICApO1xufSk7XG5cbi8qKlxuICogRGlzcGxheXMgYSBsaXN0IG9mIHN1Z2dlc3Rpb25zIHdpdGhpbiBgQ29tcG9zZXIuRWRpdG9yYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogPENvbXBvc2VyLlN1Z2dlc3Rpb25zTGlzdD5cbiAqICAge3VzZXJJZHMubWFwKCh1c2VySWQpID0+IChcbiAqICAgICA8Q29tcG9zZXIuU3VnZ2VzdGlvbnNMaXN0SXRlbSBrZXk9e3VzZXJJZH0gdmFsdWU9e3VzZXJJZH0+XG4gKiAgICAgICBAe3VzZXJJZH1cbiAqICAgICA8L0NvbXBvc2VyLlN1Z2dlc3Rpb25zTGlzdEl0ZW0+XG4gKiAgICkpfVxuICogPC9Db21wb3Nlci5TdWdnZXN0aW9uc0xpc3Q+XG4gKi9cbmNvbnN0IENvbXBvc2VyU3VnZ2VzdGlvbnNMaXN0ID0gZm9yd2FyZFJlZjxcbiAgSFRNTFVMaXN0RWxlbWVudCxcbiAgQ29tcG9zZXJTdWdnZXN0aW9uc0xpc3RQcm9wc1xuPigoeyBjaGlsZHJlbiwgYXNDaGlsZCwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgaWQgfSA9IHVzZUNvbXBvc2VyU3VnZ2VzdGlvbnNDb250ZXh0KENPTVBPU0VSX1NVR0dFU1RJT05TX0xJU1RfTkFNRSk7XG4gIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJ1bFwiO1xuXG4gIHJldHVybiAoXG4gICAgPENvbXBvbmVudFxuICAgICAgcm9sZT1cImxpc3Rib3hcIlxuICAgICAgaWQ9e2lkfVxuICAgICAgYXJpYS1sYWJlbD1cIlN1Z2dlc3Rpb25zIGxpc3RcIlxuICAgICAgey4uLnByb3BzfVxuICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQ29tcG9uZW50PlxuICApO1xufSk7XG5cbi8qKlxuICogRGlzcGxheXMgYSBzdWdnZXN0aW9uIHdpdGhpbiBgQ29tcG9zZXIuU3VnZ2VzdGlvbnNMaXN0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogPENvbXBvc2VyLlN1Z2dlc3Rpb25zTGlzdEl0ZW0ga2V5PXt1c2VySWR9IHZhbHVlPXt1c2VySWR9PlxuICogICBAe3VzZXJJZH1cbiAqIDwvQ29tcG9zZXIuU3VnZ2VzdGlvbnNMaXN0SXRlbT5cbiAqL1xuY29uc3QgQ29tcG9zZXJTdWdnZXN0aW9uc0xpc3RJdGVtID0gZm9yd2FyZFJlZjxcbiAgSFRNTExJRWxlbWVudCxcbiAgQ29tcG9zZXJTdWdnZXN0aW9uc0xpc3RJdGVtUHJvcHNcbj4oXG4gIChcbiAgICB7IHZhbHVlLCBjaGlsZHJlbiwgb25Qb2ludGVyTW92ZSwgb25Qb2ludGVyRG93biwgYXNDaGlsZCwgLi4ucHJvcHMgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSA9PiB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmPEhUTUxMSUVsZW1lbnQ+KG51bGwpO1xuICAgIGNvbnN0IG1lcmdlZFJlZnMgPSB1c2VSZWZzKGZvcndhcmRlZFJlZiwgcmVmKTtcbiAgICBjb25zdCB7IHNlbGVjdGVkVmFsdWUsIHNldFNlbGVjdGVkVmFsdWUsIGl0ZW1JZCwgb25JdGVtU2VsZWN0IH0gPVxuICAgICAgdXNlQ29tcG9zZXJTdWdnZXN0aW9uc0NvbnRleHQoQ09NUE9TRVJfU1VHR0VTVElPTlNfTElTVF9JVEVNX05BTUUpO1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJsaVwiO1xuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB1c2VNZW1vKFxuICAgICAgKCkgPT4gc2VsZWN0ZWRWYWx1ZSA9PT0gdmFsdWUsXG4gICAgICBbc2VsZWN0ZWRWYWx1ZSwgdmFsdWVdXG4gICAgKTtcbiAgICAvLyBUT0RPOiBTdXBwb3J0IHByb3BzLmlkIGlmIHByb3ZpZGVkLCBpdCB3aWxsIG5lZWQgdG8gYmUgc2VudCB1cCB0byBDb21wb3Nlci5FZGl0b3IgdG8gdXNlIGl0IGluIGFyaWEtYWN0aXZlZGVzY2VuZGFudFxuICAgIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBpdGVtSWQodmFsdWUpLCBbaXRlbUlkLCB2YWx1ZV0pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChyZWY/LmN1cnJlbnQgJiYgaXNTZWxlY3RlZCkge1xuICAgICAgICByZWYuY3VycmVudC5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiBcIm5lYXJlc3RcIiB9KTtcbiAgICAgIH1cbiAgICB9LCBbaXNTZWxlY3RlZF0pO1xuXG4gICAgY29uc3QgaGFuZGxlUG9pbnRlck1vdmUgPSB1c2VDYWxsYmFjayhcbiAgICAgIChldmVudDogUG9pbnRlckV2ZW50PEhUTUxMSUVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIG9uUG9pbnRlck1vdmU/LihldmVudCk7XG5cbiAgICAgICAgaWYgKCFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHNldFNlbGVjdGVkVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW29uUG9pbnRlck1vdmUsIHNldFNlbGVjdGVkVmFsdWUsIHZhbHVlXVxuICAgICk7XG5cbiAgICBjb25zdCBoYW5kbGVQb2ludGVyRG93biA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGV2ZW50OiBQb2ludGVyRXZlbnQ8SFRNTExJRWxlbWVudD4pID0+IHtcbiAgICAgICAgb25Qb2ludGVyRG93bj8uKGV2ZW50KTtcblxuICAgICAgICBpZiAoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKHRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiBldmVudC5jdHJsS2V5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb25JdGVtU2VsZWN0KHZhbHVlKTtcblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbb25JdGVtU2VsZWN0LCBvblBvaW50ZXJEb3duLCB2YWx1ZV1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb21wb25lbnRcbiAgICAgICAgcm9sZT1cIm9wdGlvblwiXG4gICAgICAgIGlkPXtpZH1cbiAgICAgICAgZGF0YS1zZWxlY3RlZD17aXNTZWxlY3RlZCB8fCB1bmRlZmluZWR9XG4gICAgICAgIGFyaWEtc2VsZWN0ZWQ9e2lzU2VsZWN0ZWQgfHwgdW5kZWZpbmVkfVxuICAgICAgICBvblBvaW50ZXJNb3ZlPXtoYW5kbGVQb2ludGVyTW92ZX1cbiAgICAgICAgb25Qb2ludGVyRG93bj17aGFuZGxlUG9pbnRlckRvd259XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgcmVmPXttZXJnZWRSZWZzfVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0NvbXBvbmVudD5cbiAgICApO1xuICB9XG4pO1xuXG5jb25zdCBkZWZhdWx0RWRpdG9yQ29tcG9uZW50czogQ29tcG9zZXJFZGl0b3JDb21wb25lbnRzID0ge1xuICBMaW5rOiAoeyBocmVmLCBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIDxDb21wb3NlckxpbmsgaHJlZj17aHJlZn0+e2NoaWxkcmVufTwvQ29tcG9zZXJMaW5rPjtcbiAgfSxcbiAgTWVudGlvbjogKHsgdXNlcklkIH0pID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPENvbXBvc2VyTWVudGlvbj5cbiAgICAgICAge01FTlRJT05fQ0hBUkFDVEVSfVxuICAgICAgICB7dXNlcklkfVxuICAgICAgPC9Db21wb3Nlck1lbnRpb24+XG4gICAgKTtcbiAgfSxcbiAgTWVudGlvblN1Z2dlc3Rpb25zOiAoeyB1c2VySWRzIH0pID0+IHtcbiAgICByZXR1cm4gdXNlcklkcy5sZW5ndGggPiAwID8gKFxuICAgICAgPENvbXBvc2VyU3VnZ2VzdGlvbnM+XG4gICAgICAgIDxDb21wb3NlclN1Z2dlc3Rpb25zTGlzdD5cbiAgICAgICAgICB7dXNlcklkcy5tYXAoKHVzZXJJZCkgPT4gKFxuICAgICAgICAgICAgPENvbXBvc2VyU3VnZ2VzdGlvbnNMaXN0SXRlbSBrZXk9e3VzZXJJZH0gdmFsdWU9e3VzZXJJZH0+XG4gICAgICAgICAgICAgIHt1c2VySWR9XG4gICAgICAgICAgICA8L0NvbXBvc2VyU3VnZ2VzdGlvbnNMaXN0SXRlbT5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9Db21wb3NlclN1Z2dlc3Rpb25zTGlzdD5cbiAgICAgIDwvQ29tcG9zZXJTdWdnZXN0aW9ucz5cbiAgICApIDogbnVsbDtcbiAgfSxcbn07XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGNvbXBvc2VyJ3MgZWRpdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiA8Q29tcG9zZXIuRWRpdG9yIHBsYWNlaG9sZGVyPVwiV3JpdGUgYSBjb21tZW504oCmXCIgLz5cbiAqL1xuY29uc3QgQ29tcG9zZXJFZGl0b3IgPSBmb3J3YXJkUmVmPEhUTUxEaXZFbGVtZW50LCBDb21wb3NlckVkaXRvclByb3BzPihcbiAgKFxuICAgIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgIG9uS2V5RG93bixcbiAgICAgIG9uRm9jdXMsXG4gICAgICBvbkJsdXIsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGF1dG9Gb2N1cyxcbiAgICAgIGNvbXBvbmVudHMsXG4gICAgICBkaXIsXG4gICAgICAuLi5wcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGNvbnN0IHNlbGYgPSB1c2VTZWxmKCk7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IHVzZU1lbW8oXG4gICAgICAoKSA9PiBkaXNhYmxlZCB8fCAhc2VsZj8uY2FuQ29tbWVudCxcbiAgICAgIFtkaXNhYmxlZCwgc2VsZj8uY2FuQ29tbWVudF1cbiAgICApO1xuICAgIGNvbnN0IHsgZWRpdG9yLCB2YWxpZGF0ZSwgc2V0Rm9jdXNlZCB9ID0gdXNlQ29tcG9zZXJFZGl0b3JDb250ZXh0KCk7XG4gICAgY29uc3QgeyBzdWJtaXQsIGZvY3VzLCBzZWxlY3QsIGlzRW1wdHksIGlzRm9jdXNlZCB9ID0gdXNlQ29tcG9zZXIoKTtcbiAgICBjb25zdCBpbml0aWFsQm9keSA9IHVzZUluaXRpYWwoZGVmYXVsdFZhbHVlID8/IGVtcHR5Q29tbWVudEJvZHkpO1xuICAgIGNvbnN0IGluaXRpYWxFZGl0b3JWYWx1ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgcmV0dXJuIGNvbW1lbnRCb2R5VG9Db21wb3NlckJvZHkoaW5pdGlhbEJvZHkpO1xuICAgIH0sIFtpbml0aWFsQm9keV0pO1xuICAgIGNvbnN0IHsgTGluaywgTWVudGlvbiwgTWVudGlvblN1Z2dlc3Rpb25zIH0gPSB1c2VNZW1vKFxuICAgICAgKCkgPT4gKHsgLi4uZGVmYXVsdEVkaXRvckNvbXBvbmVudHMsIC4uLmNvbXBvbmVudHMgfSksXG4gICAgICBbY29tcG9uZW50c11cbiAgICApO1xuXG4gICAgY29uc3QgW21lbnRpb25EcmFmdCwgc2V0TWVudGlvbkRyYWZ0XSA9IHVzZVN0YXRlPE1lbnRpb25EcmFmdD4oKTtcbiAgICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnMgPSB1c2VNZW50aW9uU3VnZ2VzdGlvbnMobWVudGlvbkRyYWZ0Py50ZXh0KTtcbiAgICBjb25zdCBbXG4gICAgICBzZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgsXG4gICAgICBzZXRQcmV2aW91c1NlbGVjdGVkTWVudGlvblN1Z2dlc3Rpb25JbmRleCxcbiAgICAgIHNldE5leHRTZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgsXG4gICAgICBzZXRTZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgsXG4gICAgXSA9IHVzZUluZGV4KDAsIG1lbnRpb25TdWdnZXN0aW9ucz8ubGVuZ3RoID8/IDApO1xuICAgIGNvbnN0IGlkID0gdXNlSWQoKTtcbiAgICBjb25zdCBzdWdnZXN0aW9uc0xpc3RJZCA9IHVzZU1lbW8oXG4gICAgICAoKSA9PiBgbGl2ZWJsb2Nrcy1zdWdnZXN0aW9ucy1saXN0LSR7aWR9YCxcbiAgICAgIFtpZF1cbiAgICApO1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zTGlzdEl0ZW1JZCA9IHVzZUNhbGxiYWNrKFxuICAgICAgKHVzZXJJZD86IHN0cmluZykgPT5cbiAgICAgICAgdXNlcklkID8gYGxpdmVibG9ja3Mtc3VnZ2VzdGlvbnMtbGlzdC1pdGVtLSR7aWR9LSR7dXNlcklkfWAgOiB1bmRlZmluZWQsXG4gICAgICBbaWRdXG4gICAgKTtcbiAgICBjb25zdCByZW5kZXJFbGVtZW50ID0gdXNlQ2FsbGJhY2soXG4gICAgICAocHJvcHM6IFJlbmRlckVsZW1lbnRQcm9wcykgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxDb21wb3NlckVkaXRvckVsZW1lbnQgTWVudGlvbj17TWVudGlvbn0gTGluaz17TGlua30gey4uLnByb3BzfSAvPlxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtMaW5rLCBNZW50aW9uXVxuICAgICk7XG5cbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAgICh2YWx1ZTogU2xhdGVEZXNjZW5kYW50W10pID0+IHtcbiAgICAgICAgdmFsaWRhdGUodmFsdWUgYXMgU2xhdGVFbGVtZW50W10pO1xuXG4gICAgICAgIHNldE1lbnRpb25EcmFmdChnZXRNZW50aW9uRHJhZnRBdFNlbGVjdGlvbihlZGl0b3IpKTtcbiAgICAgIH0sXG4gICAgICBbZWRpdG9yLCB2YWxpZGF0ZV1cbiAgICApO1xuXG4gICAgY29uc3QgY3JlYXRlTWVudGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgICAgKHVzZXJJZD86IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIW1lbnRpb25EcmFmdCB8fCAhdXNlcklkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgU2xhdGVUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIG1lbnRpb25EcmFmdC5yYW5nZSk7XG4gICAgICAgIGluc2VydE1lbnRpb24oZWRpdG9yLCB1c2VySWQpO1xuICAgICAgICBzZXRNZW50aW9uRHJhZnQodW5kZWZpbmVkKTtcbiAgICAgICAgc2V0U2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvbkluZGV4KDApO1xuICAgICAgfSxcbiAgICAgIFtlZGl0b3IsIG1lbnRpb25EcmFmdCwgc2V0U2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvbkluZGV4XVxuICAgICk7XG5cbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZXZlbnQ6IEtleWJvYXJkRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIG9uS2V5RG93bj8uKGV2ZW50KTtcblxuICAgICAgICBpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBsZWF2aW5nIG1hcmtzIHdpdGggQXJyb3dMZWZ0XG4gICAgICAgIGlmIChpc0tleShldmVudCwgXCJBcnJvd0xlZnRcIikpIHtcbiAgICAgICAgICBsZWF2ZU1hcmtFZGdlKGVkaXRvciwgXCJzdGFydFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IGxlYXZpbmcgbWFya3Mgd2l0aCBBcnJvd1JpZ2h0XG4gICAgICAgIGlmIChpc0tleShldmVudCwgXCJBcnJvd1JpZ2h0XCIpKSB7XG4gICAgICAgICAgbGVhdmVNYXJrRWRnZShlZGl0b3IsIFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lbnRpb25EcmFmdCAmJiBtZW50aW9uU3VnZ2VzdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIFNlbGVjdCB0aGUgbmV4dCBtZW50aW9uIHN1Z2dlc3Rpb24gb24gQXJyb3dEb3duXG4gICAgICAgICAgaWYgKGlzS2V5KGV2ZW50LCBcIkFycm93RG93blwiKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNldE5leHRTZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWxlY3QgdGhlIHByZXZpb3VzIG1lbnRpb24gc3VnZ2VzdGlvbiBvbiBBcnJvd1VwXG4gICAgICAgICAgaWYgKGlzS2V5KGV2ZW50LCBcIkFycm93VXBcIikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZXRQcmV2aW91c1NlbGVjdGVkTWVudGlvblN1Z2dlc3Rpb25JbmRleCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBhIG1lbnRpb24gb24gRW50ZXIvVGFiXG4gICAgICAgICAgaWYgKGlzS2V5KGV2ZW50LCBcIkVudGVyXCIpIHx8IGlzS2V5KGV2ZW50LCBcIlRhYlwiKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgY29uc3QgdXNlcklkID0gbWVudGlvblN1Z2dlc3Rpb25zPy5bc2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvbkluZGV4XTtcbiAgICAgICAgICAgIGNyZWF0ZU1lbnRpb24odXNlcklkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDbG9zZSB0aGUgc3VnZ2VzdGlvbnMgb24gRXNjYXBlXG4gICAgICAgICAgaWYgKGlzS2V5KGV2ZW50LCBcIkVzY2FwZVwiKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNldE1lbnRpb25EcmFmdCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvbkluZGV4KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBCbHVyIHRoZSBlZGl0b3Igb24gRXNjYXBlXG4gICAgICAgICAgaWYgKGlzS2V5KGV2ZW50LCBcIkVzY2FwZVwiKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIFJlYWN0RWRpdG9yLmJsdXIoZWRpdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdWJtaXQgdGhlIGVkaXRvciBvbiBFbnRlclxuICAgICAgICAgIGlmIChpc0tleShldmVudCwgXCJFbnRlclwiLCB7IHNoaWZ0OiBmYWxzZSB9KSAmJiAhaXNFbXB0eSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHN1Ym1pdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsaW5lIG9uIFNoaWZ0ICsgRW50ZXJcbiAgICAgICAgICBpZiAoaXNLZXkoZXZlbnQsIFwiRW50ZXJcIiwgeyBzaGlmdDogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnRCcmVhaygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRvZ2dsZSBib2xkIG9uIENvbW1hbmQvQ29udHJvbCArIEJcbiAgICAgICAgICBpZiAoaXNLZXkoZXZlbnQsIFwiYlwiLCB7IG1vZDogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRvZ2dsZU1hcmsoZWRpdG9yLCBcImJvbGRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVG9nZ2xlIGl0YWxpYyBvbiBDb21tYW5kL0NvbnRyb2wgKyBJXG4gICAgICAgICAgaWYgKGlzS2V5KGV2ZW50LCBcImlcIiwgeyBtb2Q6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0b2dnbGVNYXJrKGVkaXRvciwgXCJpdGFsaWNcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVG9nZ2xlIHN0cmlrZXRocm91Z2ggb24gQ29tbWFuZC9Db250cm9sICsgU2hpZnQgKyBTXG4gICAgICAgICAgaWYgKGlzS2V5KGV2ZW50LCBcInNcIiwgeyBtb2Q6IHRydWUsIHNoaWZ0OiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdG9nZ2xlTWFyayhlZGl0b3IsIFwic3RyaWtldGhyb3VnaFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUb2dnbGUgY29kZSBvbiBDb21tYW5kL0NvbnRyb2wgKyBFXG4gICAgICAgICAgaWYgKGlzS2V5KGV2ZW50LCBcImVcIiwgeyBtb2Q6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0b2dnbGVNYXJrKGVkaXRvciwgXCJjb2RlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgY3JlYXRlTWVudGlvbixcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBpc0VtcHR5LFxuICAgICAgICBtZW50aW9uRHJhZnQsXG4gICAgICAgIG1lbnRpb25TdWdnZXN0aW9ucyxcbiAgICAgICAgc2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvbkluZGV4LFxuICAgICAgICBvbktleURvd24sXG4gICAgICAgIHNldE5leHRTZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgsXG4gICAgICAgIHNldFByZXZpb3VzU2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvbkluZGV4LFxuICAgICAgICBzZXRTZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgsXG4gICAgICAgIHN1Ym1pdCxcbiAgICAgIF1cbiAgICApO1xuXG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjayhcbiAgICAgIChldmVudDogRm9jdXNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICAgICAgb25Gb2N1cz8uKGV2ZW50KTtcblxuICAgICAgICBpZiAoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgc2V0Rm9jdXNlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtvbkZvY3VzLCBzZXRGb2N1c2VkXVxuICAgICk7XG5cbiAgICBjb25zdCBoYW5kbGVCbHVyID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZXZlbnQ6IEZvY3VzRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIG9uQmx1cj8uKGV2ZW50KTtcblxuICAgICAgICBpZiAoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbb25CbHVyLCBzZXRGb2N1c2VkXVxuICAgICk7XG5cbiAgICBjb25zdCBzZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uVXNlcklkID0gdXNlTWVtbyhcbiAgICAgICgpID0+IG1lbnRpb25TdWdnZXN0aW9ucz8uW3NlbGVjdGVkTWVudGlvblN1Z2dlc3Rpb25JbmRleF0sXG4gICAgICBbc2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvbkluZGV4LCBtZW50aW9uU3VnZ2VzdGlvbnNdXG4gICAgKTtcbiAgICBjb25zdCBzZXRTZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uVXNlcklkID0gdXNlQ2FsbGJhY2soXG4gICAgICAodXNlcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBtZW50aW9uU3VnZ2VzdGlvbnM/LmluZGV4T2YodXNlcklkKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvbkluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtzZXRTZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgsIG1lbnRpb25TdWdnZXN0aW9uc11cbiAgICApO1xuXG4gICAgY29uc3QgcHJvcHNXaGlsZVN1Z2dlc3Rpbmc6IEFyaWFBdHRyaWJ1dGVzID0gdXNlTWVtbyhcbiAgICAgICgpID0+XG4gICAgICAgIG1lbnRpb25EcmFmdFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICByb2xlOiBcImNvbWJvYm94XCIsXG4gICAgICAgICAgICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICBcImFyaWEtY29udHJvbHNcIjogc3VnZ2VzdGlvbnNMaXN0SWQsXG4gICAgICAgICAgICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IHN1Z2dlc3Rpb25zTGlzdEl0ZW1JZChcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uVXNlcklkXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSxcbiAgICAgIFtcbiAgICAgICAgbWVudGlvbkRyYWZ0LFxuICAgICAgICBzdWdnZXN0aW9uc0xpc3RJZCxcbiAgICAgICAgc3VnZ2VzdGlvbnNMaXN0SXRlbUlkLFxuICAgICAgICBzZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uVXNlcklkLFxuICAgICAgXVxuICAgICk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4ge1xuICAgICAgcmV0dXJuIFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcikgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgfSwgW2VkaXRvcl0pO1xuXG4gICAgLy8gTWFudWFsbHkgZm9jdXMgdGhlIGVkaXRvciB3aGVuIGBhdXRvRm9jdXNgIGlzIHRydWVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKGF1dG9Gb2N1cykge1xuICAgICAgICBmb2N1cygpO1xuICAgICAgfVxuICAgIH0sIFthdXRvRm9jdXMsIGVkaXRvciwgZm9jdXNdKTtcblxuICAgIC8vIE1hbnVhbGx5IGFkZCBhIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGlmIHRoZSBzZWxlY3Rpb25cbiAgICAvLyBpcyBzdGlsbCBlbXB0eSBhZnRlciBiZWluZyBmb2N1c2VkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpc0ZvY3VzZWQgJiYgZWRpdG9yLnNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICBzZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9LCBbZWRpdG9yLCBzZWxlY3QsIGlzRm9jdXNlZF0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxTbGF0ZVxuICAgICAgICBlZGl0b3I9e2VkaXRvcn1cbiAgICAgICAgaW5pdGlhbFZhbHVlPXtpbml0aWFsRWRpdG9yVmFsdWV9XG4gICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XG4gICAgICA+XG4gICAgICAgIDxFZGl0YWJsZVxuICAgICAgICAgIGRpcj17ZGlyfVxuICAgICAgICAgIGVudGVyS2V5SGludD17bWVudGlvbkRyYWZ0ID8gXCJlbnRlclwiIDogXCJzZW5kXCJ9XG4gICAgICAgICAgYXV0b0NhcGl0YWxpemU9XCJzZW50ZW5jZXNcIlxuICAgICAgICAgIGFyaWEtbGFiZWw9XCJDb21wb3NlciBlZGl0b3JcIlxuICAgICAgICAgIGRhdGEtZm9jdXNlZD17aXNGb2N1c2VkIHx8IHVuZGVmaW5lZH1cbiAgICAgICAgICBkYXRhLWRpc2FibGVkPXtpc0Rpc2FibGVkIHx8IHVuZGVmaW5lZH1cbiAgICAgICAgICB7Li4ucHJvcHNXaGlsZVN1Z2dlc3Rpbmd9XG4gICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgIHJlYWRPbmx5PXtpc0Rpc2FibGVkfVxuICAgICAgICAgIGRpc2FibGVkPXtpc0Rpc2FibGVkfVxuICAgICAgICAgIG9uS2V5RG93bj17aGFuZGxlS2V5RG93bn1cbiAgICAgICAgICBvbkZvY3VzPXtoYW5kbGVGb2N1c31cbiAgICAgICAgICBvbkJsdXI9e2hhbmRsZUJsdXJ9XG4gICAgICAgICAgcmVuZGVyRWxlbWVudD17cmVuZGVyRWxlbWVudH1cbiAgICAgICAgICByZW5kZXJMZWFmPXtDb21wb3NlckVkaXRvckxlYWZ9XG4gICAgICAgICAgcmVuZGVyUGxhY2Vob2xkZXI9e0NvbXBvc2VyRWRpdG9yUGxhY2Vob2xkZXJ9XG4gICAgICAgIC8+XG4gICAgICAgIDxDb21wb3NlckVkaXRvck1lbnRpb25TdWdnZXN0aW9uc1dyYXBwZXJcbiAgICAgICAgICBkaXI9e2Rpcn1cbiAgICAgICAgICBtZW50aW9uRHJhZnQ9e21lbnRpb25EcmFmdH1cbiAgICAgICAgICBzZWxlY3RlZFVzZXJJZD17c2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvblVzZXJJZH1cbiAgICAgICAgICBzZXRTZWxlY3RlZFVzZXJJZD17c2V0U2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvblVzZXJJZH1cbiAgICAgICAgICB1c2VySWRzPXttZW50aW9uU3VnZ2VzdGlvbnN9XG4gICAgICAgICAgaWQ9e3N1Z2dlc3Rpb25zTGlzdElkfVxuICAgICAgICAgIGl0ZW1JZD17c3VnZ2VzdGlvbnNMaXN0SXRlbUlkfVxuICAgICAgICAgIG9uSXRlbVNlbGVjdD17Y3JlYXRlTWVudGlvbn1cbiAgICAgICAgICBNZW50aW9uU3VnZ2VzdGlvbnM9e01lbnRpb25TdWdnZXN0aW9uc31cbiAgICAgICAgLz5cbiAgICAgIDwvU2xhdGU+XG4gICAgKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBTdXJyb3VuZHMgdGhlIGNvbXBvc2VyJ3MgY29udGVudCBhbmQgaGFuZGxlcyBzdWJtaXNzaW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogPENvbXBvc2VyLkZvcm0gb25Db21wb3NlclN1Ym1pdD17KHsgYm9keSB9KSA9PiB7fX0+XG4gKlx0IDxDb21wb3Nlci5FZGl0b3IgLz5cbiAqICAgPENvbXBvc2VyLlN1Ym1pdCAvPlxuICogPC9Db21wb3Nlci5Gb3JtPlxuICovXG5jb25zdCBDb21wb3NlckZvcm0gPSBmb3J3YXJkUmVmPEhUTUxGb3JtRWxlbWVudCwgQ29tcG9zZXJGb3JtUHJvcHM+KFxuICAoXG4gICAgeyBjaGlsZHJlbiwgb25TdWJtaXQsIG9uQ29tcG9zZXJTdWJtaXQsIGFzQ2hpbGQsIC4uLnByb3BzIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJmb3JtXCI7XG4gICAgY29uc3QgZWRpdG9yID0gdXNlSW5pdGlhbChjcmVhdGVDb21wb3NlckVkaXRvcik7XG4gICAgY29uc3QgW2lzRW1wdHksIHNldEVtcHR5XSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtpc0ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxIVE1MRm9ybUVsZW1lbnQ+KG51bGwpO1xuICAgIGNvbnN0IG1lcmdlZFJlZnMgPSB1c2VSZWZzKGZvcndhcmRlZFJlZiwgcmVmKTtcblxuICAgIGNvbnN0IHZhbGlkYXRlID0gdXNlQ2FsbGJhY2soXG4gICAgICAodmFsdWU6IFNsYXRlRWxlbWVudFtdKSA9PiB7XG4gICAgICAgIHNldEVtcHR5KGlzRWRpdG9yRW1wdHkoZWRpdG9yLCB2YWx1ZSkpO1xuICAgICAgfSxcbiAgICAgIFtlZGl0b3JdXG4gICAgKTtcblxuICAgIGNvbnN0IHN1Ym1pdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgZnJhbWUgaW4gc29tZSBjYXNlcyBsaWtlIHdoZW4gY29tcG9zaW5nIGRpYWNyaXRpY3MsXG4gICAgICAvLyB3ZSB3YW50IGFueSBuYXRpdmUgaGFuZGxpbmcgdG8gYmUgZG9uZSBmaXJzdCB3aGlsZSBzdGlsbCBiZWluZyBoYW5kbGVkIG9uIGBrZXlkb3duYC5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgICAgIHJlcXVlc3RTdWJtaXQocmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjbGVhciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIFNsYXRlVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiB7XG4gICAgICAgICAgYW5jaG9yOiBTbGF0ZUVkaXRvci5zdGFydChlZGl0b3IsIFtdKSxcbiAgICAgICAgICBmb2N1czogU2xhdGVFZGl0b3IuZW5kKGVkaXRvciwgW10pLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSwgW2VkaXRvcl0pO1xuXG4gICAgY29uc3Qgc2VsZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgU2xhdGVUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgICAgYW5jaG9yOiBTbGF0ZUVkaXRvci5lbmQoZWRpdG9yLCBbXSksXG4gICAgICAgIGZvY3VzOiBTbGF0ZUVkaXRvci5lbmQoZWRpdG9yLCBbXSksXG4gICAgICB9KTtcbiAgICB9LCBbZWRpdG9yXSk7XG5cbiAgICBjb25zdCBmb2N1cyA9IHVzZUNhbGxiYWNrKFxuICAgICAgKHJlc2V0U2VsZWN0aW9uID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKSB7XG4gICAgICAgICAgU2xhdGVUcmFuc2Zvcm1zLnNlbGVjdChcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uIHx8ICFlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICAgICAgICAgID8gU2xhdGVFZGl0b3IuZW5kKGVkaXRvciwgW10pXG4gICAgICAgICAgICAgIDogZWRpdG9yLnNlbGVjdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgUmVhY3RFZGl0b3IuZm9jdXMoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtlZGl0b3JdXG4gICAgKTtcblxuICAgIGNvbnN0IGJsdXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBSZWFjdEVkaXRvci5ibHVyKGVkaXRvcik7XG4gICAgfSwgW2VkaXRvcl0pO1xuXG4gICAgY29uc3Qgb25TdWJtaXRFbmQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBjbGVhcigpO1xuICAgICAgYmx1cigpO1xuICAgIH0sIFtibHVyLCBjbGVhcl0pO1xuXG4gICAgY29uc3QgY3JlYXRlTWVudGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGZvY3VzKCk7XG4gICAgICBpbnNlcnRNZW50aW9uQ2hhcmFjdGVyKGVkaXRvcik7XG4gICAgfSwgW2VkaXRvciwgZm9jdXNdKTtcblxuICAgIGNvbnN0IGluc2VydFRleHQgPSB1c2VDYWxsYmFjayhcbiAgICAgICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgZm9jdXMoZmFsc2UpO1xuICAgICAgICBpbnNlcnRTbGF0ZVRleHQoZWRpdG9yLCB0ZXh0KTtcbiAgICAgIH0sXG4gICAgICBbZWRpdG9yLCBmb2N1c11cbiAgICApO1xuXG4gICAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZXZlbnQ6IEZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIC8vIEluIHNvbWUgc2l0dWF0aW9ucyAoZS5nLiBwcmVzc2luZyBFbnRlciB3aGlsZSBjb21wb3NpbmcgZGlhY3JpdGljcyksIGl0J3MgcG9zc2libGVcbiAgICAgICAgLy8gZm9yIHRoZSBmb3JtIHRvIGJlIHN1Ym1pdHRlZCBhcyBlbXB0eSBldmVuIHRob3VnaCB3ZSBhbHJlYWR5IGNoZWNrZWQgd2hldGhlciB0aGVcbiAgICAgICAgLy8gZWRpdG9yIHdhcyBlbXB0eSB3aGVuIGhhbmRsaW5nIHRoZSBrZXkgcHJlc3MuXG4gICAgICAgIGNvbnN0IGlzRW1wdHkgPSBpc0VkaXRvckVtcHR5KGVkaXRvciwgZWRpdG9yLmNoaWxkcmVuKTtcblxuICAgICAgICAvLyBXZSBldmVuIHByZXZlbnQgdGhlIHVzZXIncyBgb25TdWJtaXRgIGhhbmRsZXIgZnJvbSBiZWluZyBjYWxsZWQgaWYgdGhlIGVkaXRvciBpcyBlbXB0eS5cbiAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb25TdWJtaXQ/LihldmVudCk7XG5cbiAgICAgICAgaWYgKCFvbkNvbXBvc2VyU3VibWl0IHx8IGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJvZHkgPSBjb21wb3NlckJvZHlUb0NvbW1lbnRCb2R5KFxuICAgICAgICAgIGVkaXRvci5jaGlsZHJlbiBhcyBDb21wb3NlckJvZHlEYXRhXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNvbW1lbnQgPSB7IGJvZHkgfTtcblxuICAgICAgICBjb25zdCBwcm9taXNlID0gb25Db21wb3NlclN1Ym1pdChjb21tZW50LCBldmVudCk7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UudGhlbihvblN1Ym1pdEVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25TdWJtaXRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtlZGl0b3IsIG9uQ29tcG9zZXJTdWJtaXQsIG9uU3VibWl0LCBvblN1Ym1pdEVuZF1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb21wb3NlckVkaXRvckNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgdmFsaWRhdGUsXG4gICAgICAgICAgc2V0Rm9jdXNlZCxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPENvbXBvc2VyQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgICBpc0ZvY3VzZWQsXG4gICAgICAgICAgICBpc0VtcHR5LFxuICAgICAgICAgICAgc3VibWl0LFxuICAgICAgICAgICAgY2xlYXIsXG4gICAgICAgICAgICBzZWxlY3QsXG4gICAgICAgICAgICBmb2N1cyxcbiAgICAgICAgICAgIGJsdXIsXG4gICAgICAgICAgICBjcmVhdGVNZW50aW9uLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dCxcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPENvbXBvbmVudCB7Li4ucHJvcHN9IG9uU3VibWl0PXtoYW5kbGVTdWJtaXR9IHJlZj17bWVyZ2VkUmVmc30+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgPC9Db21wb25lbnQ+XG4gICAgICAgIDwvQ29tcG9zZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9Db21wb3NlckVkaXRvckNvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBBIGJ1dHRvbiB0byBzdWJtaXQgdGhlIGNvbXBvc2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiA8Q29tcG9zZXIuU3VibWl0PlNlbmQ8L0NvbXBvc2VyLlN1Ym1pdD5cbiAqL1xuY29uc3QgQ29tcG9zZXJTdWJtaXQgPSBmb3J3YXJkUmVmPEhUTUxCdXR0b25FbGVtZW50LCBDb21wb3NlclN1Ym1pdFByb3BzPihcbiAgKHsgY2hpbGRyZW4sIGRpc2FibGVkLCBhc0NoaWxkLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBhc0NoaWxkID8gU2xvdCA6IFwiYnV0dG9uXCI7XG4gICAgY29uc3QgeyBpc0VtcHR5IH0gPSB1c2VDb21wb3NlcigpO1xuICAgIGNvbnN0IHNlbGYgPSB1c2VTZWxmKCk7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IHVzZU1lbW8oXG4gICAgICAoKSA9PiBkaXNhYmxlZCB8fCBpc0VtcHR5IHx8ICFzZWxmPy5jYW5Db21tZW50LFxuICAgICAgW2Rpc2FibGVkLCBpc0VtcHR5LCBzZWxmPy5jYW5Db21tZW50XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENvbXBvbmVudFxuICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgICAgZGlzYWJsZWQ9e2lzRGlzYWJsZWR9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvQ29tcG9uZW50PlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgQ29tcG9zZXJFZGl0b3IuZGlzcGxheU5hbWUgPSBDT01QT1NFUl9FRElUT1JfTkFNRTtcbiAgQ29tcG9zZXJGb3JtLmRpc3BsYXlOYW1lID0gQ09NUE9TRVJfRk9STV9OQU1FO1xuICBDb21wb3Nlck1lbnRpb24uZGlzcGxheU5hbWUgPSBDT01QT1NFUl9NRU5USU9OX05BTUU7XG4gIENvbXBvc2VyTGluay5kaXNwbGF5TmFtZSA9IENPTVBPU0VSX0xJTktfTkFNRTtcbiAgQ29tcG9zZXJTdWJtaXQuZGlzcGxheU5hbWUgPSBDT01QT1NFUl9TVUJNSVRfTkFNRTtcbiAgQ29tcG9zZXJTdWdnZXN0aW9ucy5kaXNwbGF5TmFtZSA9IENPTVBPU0VSX1NVR0dFU1RJT05TX05BTUU7XG4gIENvbXBvc2VyU3VnZ2VzdGlvbnNMaXN0LmRpc3BsYXlOYW1lID0gQ09NUE9TRVJfU1VHR0VTVElPTlNfTElTVF9OQU1FO1xuICBDb21wb3NlclN1Z2dlc3Rpb25zTGlzdEl0ZW0uZGlzcGxheU5hbWUgPSBDT01QT1NFUl9TVUdHRVNUSU9OU19MSVNUX0lURU1fTkFNRTtcbn1cblxuLy8gTk9URTogRXZlcnkgZXhwb3J0IGZyb20gdGhpcyBmaWxlIHdpbGwgYmUgYXZhaWxhYmxlIHB1YmxpY2x5IGFzIENvbXBvc2VyLipcbmV4cG9ydCB7XG4gIENvbXBvc2VyRWRpdG9yIGFzIEVkaXRvcixcbiAgQ29tcG9zZXJGb3JtIGFzIEZvcm0sXG4gIENvbXBvc2VyTGluayBhcyBMaW5rLFxuICBDb21wb3Nlck1lbnRpb24gYXMgTWVudGlvbixcbiAgQ29tcG9zZXJTdWJtaXQgYXMgU3VibWl0LFxuICBDb21wb3NlclN1Z2dlc3Rpb25zIGFzIFN1Z2dlc3Rpb25zLFxuICBDb21wb3NlclN1Z2dlc3Rpb25zTGlzdCBhcyBTdWdnZXN0aW9uc0xpc3QsXG4gIENvbXBvc2VyU3VnZ2VzdGlvbnNMaXN0SXRlbSBhcyBTdWdnZXN0aW9uc0xpc3RJdGVtLFxufTtcbiJdLCJuYW1lcyI6WyJNRU5USU9OX1NVR0dFU1RJT05TX1BPU0lUSU9OIiwiQ09NUE9TRVJfTUVOVElPTl9OQU1FIiwiQ09NUE9TRVJfTElOS19OQU1FIiwiQ09NUE9TRVJfU1VHR0VTVElPTlNfTkFNRSIsIkNPTVBPU0VSX1NVR0dFU1RJT05TX0xJU1RfTkFNRSIsIkNPTVBPU0VSX1NVR0dFU1RJT05TX0xJU1RfSVRFTV9OQU1FIiwiQ09NUE9TRVJfU1VCTUlUX05BTUUiLCJDT01QT1NFUl9FRElUT1JfTkFNRSIsIkNPTVBPU0VSX0ZPUk1fTkFNRSIsImVtcHR5Q29tbWVudEJvZHkiLCJ2ZXJzaW9uIiwiY29udGVudCIsInR5cGUiLCJjaGlsZHJlbiIsInRleHQiLCJjcmVhdGVDb21wb3NlckVkaXRvciIsIndpdGhNZW50aW9ucyIsIndpdGhDdXN0b21MaW5rcyIsIndpdGhBdXRvTGlua3MiLCJ3aXRoQXV0b0Zvcm1hdHRpbmciLCJ3aXRoRW1wdHlDbGVhckZvcm1hdHRpbmciLCJ3aXRoUGFzdGVIdG1sIiwid2l0aEhpc3RvcnkiLCJ3aXRoUmVhY3QiLCJjcmVhdGVFZGl0b3IiLCJDb21wb3NlckVkaXRvck1lbnRpb25XcmFwcGVyIiwiTWVudGlvbiIsImF0dHJpYnV0ZXMiLCJlbGVtZW50IiwiaXNTZWxlY3RlZCIsInVzZVNlbGVjdGVkIiwiUmVhY3RfX2RlZmF1bHQiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJ1c2VySWQiLCJDb21wb3NlckVkaXRvckxpbmtXcmFwcGVyIiwiTGluayIsImhyZWYiLCJ1c2VNZW1vIiwidG9BYnNvbHV0ZVVybCIsInVybCIsIkNvbXBvc2VyRWRpdG9yTWVudGlvblN1Z2dlc3Rpb25zV3JhcHBlciIsIml0ZW1JZCIsInVzZXJJZHMiLCJzZWxlY3RlZFVzZXJJZCIsInNldFNlbGVjdGVkVXNlcklkIiwibWVudGlvbkRyYWZ0Iiwib25JdGVtU2VsZWN0IiwicG9zaXRpb24iLCJkaXIiLCJNZW50aW9uU3VnZ2VzdGlvbnMiLCJlZGl0b3IiLCJ1c2VTbGF0ZVN0YXRpYyIsImlzRm9jdXNlZCIsInVzZUNvbXBvc2VyIiwic2V0Q29udGVudCIsInVzZVN0YXRlIiwiY29udGVudFpJbmRleCIsInNldENvbnRlbnRaSW5kZXgiLCJjb250ZW50UmVmIiwidXNlQ2FsbGJhY2siLCJwb3J0YWxDb250YWluZXIiLCJ1c2VMaXZlYmxvY2tzVUlDb25maWciLCJmbG9hdGluZ09wdGlvbnMiLCJkZXRlY3RPdmVyZmxvd09wdGlvbnMiLCJwYWRkaW5nIiwiRkxPQVRJTkdfRUxFTUVOVF9DT0xMSVNJT05fUEFERElORyIsInN0cmF0ZWd5IiwicGxhY2VtZW50IiwiZ2V0UGxhY2VtZW50RnJvbVBvc2l0aW9uIiwibWlkZGxld2FyZSIsImZsaXAiLCJjcm9zc0F4aXMiLCJoaWRlIiwic2hpZnQiLCJsaW1pdGVyIiwibGltaXRTaGlmdCIsInNpemUiLCJhcHBseSIsImF2YWlsYWJsZVdpZHRoIiwiYXZhaWxhYmxlSGVpZ2h0IiwiZWxlbWVudHMiLCJmbG9hdGluZyIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJ3aGlsZUVsZW1lbnRzTW91bnRlZCIsImF1dG9VcGRhdGUiLCJyZWZzIiwic2V0UmVmZXJlbmNlIiwic2V0RmxvYXRpbmciLCJpc1Bvc2l0aW9uZWQiLCJ4IiwieSIsInVzZUZsb2F0aW5nIiwidXNlTGF5b3V0RWZmZWN0Iiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInpJbmRleCIsImRvbVJhbmdlIiwiZ2V0RE9NUmFuZ2UiLCJyYW5nZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENsaWVudFJlY3RzIiwiUGVyc2lzdCIsIkNvbXBvc2VyU3VnZ2VzdGlvbnNDb250ZXh0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInNlbGVjdGVkVmFsdWUiLCJzZXRTZWxlY3RlZFZhbHVlIiwicmVmIiwiUG9ydGFsIiwiY29udGFpbmVyIiwidG9wIiwibGVmdCIsInRyYW5zZm9ybSIsIk1hdGgiLCJyb3VuZCIsIm1pbldpZHRoIiwiQ29tcG9zZXJFZGl0b3JFbGVtZW50IiwicHJvcHMiLCJDb21wb3NlckVkaXRvckxlYWYiLCJsZWFmIiwiYm9sZCIsIml0YWxpYyIsInN0cmlrZXRocm91Z2giLCJjb2RlIiwiQ29tcG9zZXJFZGl0b3JQbGFjZWhvbGRlciIsIm9wYWNpdHkiLCJfb3BhY2l0eSIsIkNvbXBvc2VyTWVudGlvbiIsImZvcndhcmRSZWYiLCJhc0NoaWxkIiwiZm9yd2FyZGVkUmVmIiwiQ29tcG9uZW50IiwiU2xvdCIsIkNvbXBvc2VyTGluayIsInRhcmdldCIsInJlbCIsIkNvbXBvc2VyU3VnZ2VzdGlvbnMiLCJpc1ByZXNlbnQiLCJ1c2VQZXJzaXN0IiwidXNlUmVmIiwidXNlQ29tcG9zZXJTdWdnZXN0aW9uc0NvbnRleHQiLCJtZXJnZWRSZWZzIiwidXNlUmVmcyIsInNpZGUiLCJhbGlnbiIsImdldFNpZGVBbmRBbGlnbkZyb21QbGFjZW1lbnQiLCJ1c2VBbmltYXRpb25QZXJzaXN0IiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJtYXhIZWlnaHQiLCJvdmVyZmxvd1kiLCJDb21wb3NlclN1Z2dlc3Rpb25zTGlzdCIsInJvbGUiLCJDb21wb3NlclN1Z2dlc3Rpb25zTGlzdEl0ZW0iLCJvblBvaW50ZXJNb3ZlIiwib25Qb2ludGVyRG93biIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJldmVudCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImhhbmRsZVBvaW50ZXJEb3duIiwiaGFzUG9pbnRlckNhcHR1cmUiLCJwb2ludGVySWQiLCJyZWxlYXNlUG9pbnRlckNhcHR1cmUiLCJidXR0b24iLCJjdHJsS2V5IiwicHJldmVudERlZmF1bHQiLCJkZWZhdWx0RWRpdG9yQ29tcG9uZW50cyIsIk1FTlRJT05fQ0hBUkFDVEVSIiwibGVuZ3RoIiwibWFwIiwia2V5IiwiQ29tcG9zZXJFZGl0b3IiLCJkZWZhdWx0VmFsdWUiLCJvbktleURvd24iLCJvbkZvY3VzIiwib25CbHVyIiwiZGlzYWJsZWQiLCJhdXRvRm9jdXMiLCJjb21wb25lbnRzIiwic2VsZiIsInVzZVNlbGYiLCJpc0Rpc2FibGVkIiwiY2FuQ29tbWVudCIsInZhbGlkYXRlIiwic2V0Rm9jdXNlZCIsInVzZUNvbXBvc2VyRWRpdG9yQ29udGV4dCIsInN1Ym1pdCIsImZvY3VzIiwic2VsZWN0IiwiaXNFbXB0eSIsImluaXRpYWxCb2R5IiwidXNlSW5pdGlhbCIsImluaXRpYWxFZGl0b3JWYWx1ZSIsImNvbW1lbnRCb2R5VG9Db21wb3NlckJvZHkiLCJzZXRNZW50aW9uRHJhZnQiLCJtZW50aW9uU3VnZ2VzdGlvbnMiLCJ1c2VNZW50aW9uU3VnZ2VzdGlvbnMiLCJzZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgiLCJzZXRQcmV2aW91c1NlbGVjdGVkTWVudGlvblN1Z2dlc3Rpb25JbmRleCIsInNldE5leHRTZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgiLCJzZXRTZWxlY3RlZE1lbnRpb25TdWdnZXN0aW9uSW5kZXgiLCJ1c2VJbmRleCIsInVzZUlkIiwic3VnZ2VzdGlvbnNMaXN0SWQiLCJzdWdnZXN0aW9uc0xpc3RJdGVtSWQiLCJyZW5kZXJFbGVtZW50IiwicHJvcHMyIiwiaGFuZGxlQ2hhbmdlIiwiZ2V0TWVudGlvbkRyYWZ0QXRTZWxlY3Rpb24iLCJjcmVhdGVNZW50aW9uIiwiVHJhbnNmb3JtcyIsImluc2VydE1lbnRpb24iLCJoYW5kbGVLZXlEb3duIiwiaXNLZXkiLCJsZWF2ZU1hcmtFZGdlIiwiUmVhY3RFZGl0b3IiLCJibHVyIiwiaW5zZXJ0QnJlYWsiLCJtb2QiLCJ0b2dnbGVNYXJrIiwiaGFuZGxlRm9jdXMiLCJoYW5kbGVCbHVyIiwic2VsZWN0ZWRNZW50aW9uU3VnZ2VzdGlvblVzZXJJZCIsInNldFNlbGVjdGVkTWVudGlvblN1Z2dlc3Rpb25Vc2VySWQiLCJpbmRleCIsImluZGV4T2YiLCJwcm9wc1doaWxlU3VnZ2VzdGluZyIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ0b0RPTU5vZGUiLCJzZWxlY3Rpb24iLCJTbGF0ZSIsImluaXRpYWxWYWx1ZSIsIm9uQ2hhbmdlIiwiRWRpdGFibGUiLCJlbnRlcktleUhpbnQiLCJhdXRvQ2FwaXRhbGl6ZSIsInJlYWRPbmx5IiwicmVuZGVyTGVhZiIsInJlbmRlclBsYWNlaG9sZGVyIiwiQ29tcG9zZXJGb3JtIiwib25TdWJtaXQiLCJvbkNvbXBvc2VyU3VibWl0IiwiaXNFbXB0eSQxIiwic2V0RW1wdHkiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0U3VibWl0IiwiY2xlYXIiLCJkZWxldGUiLCJhdCIsImFuY2hvciIsIkVkaXRvciIsInN0YXJ0IiwiZW5kIiwicmVzZXRTZWxlY3Rpb24iLCJvblN1Ym1pdEVuZCIsImluc2VydE1lbnRpb25DaGFyYWN0ZXIiLCJpbnNlcnRUZXh0JDEiLCJpbnNlcnRUZXh0IiwiaGFuZGxlU3VibWl0IiwiaXNFbXB0eTIiLCJib2R5IiwiY29tcG9zZXJCb2R5VG9Db21tZW50Qm9keSIsImNvbW1lbnQiLCJwcm9taXNlIiwidGhlbiIsIkNvbXBvc2VyRWRpdG9yQ29udGV4dCIsIkNvbXBvc2VyQ29udGV4dCIsIkNvbXBvc2VyU3VibWl0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/utils.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/Composer/utils.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   commentBodyLinkToComposerBodyLink: () => (/* binding */ commentBodyLinkToComposerBodyLink),\n/* harmony export */   commentBodyMentionToComposerBodyMention: () => (/* binding */ commentBodyMentionToComposerBodyMention),\n/* harmony export */   commentBodyToComposerBody: () => (/* binding */ commentBodyToComposerBody),\n/* harmony export */   composerBodyAutoLinkToCommentBodyLink: () => (/* binding */ composerBodyAutoLinkToCommentBodyLink),\n/* harmony export */   composerBodyCustomLinkToCommentBodyLink: () => (/* binding */ composerBodyCustomLinkToCommentBodyLink),\n/* harmony export */   composerBodyMentionToCommentBodyMention: () => (/* binding */ composerBodyMentionToCommentBodyMention),\n/* harmony export */   composerBodyToCommentBody: () => (/* binding */ composerBodyToCommentBody),\n/* harmony export */   getPlacementFromPosition: () => (/* binding */ getPlacementFromPosition),\n/* harmony export */   getSideAndAlignFromPlacement: () => (/* binding */ getSideAndAlignFromPlacement)\n/* harmony export */ });\n/* harmony import */ var _slate_plugins_auto_links_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../slate/plugins/auto-links.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/auto-links.mjs\");\n/* harmony import */ var _slate_plugins_custom_links_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../slate/plugins/custom-links.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/custom-links.mjs\");\n/* harmony import */ var _slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../slate/plugins/mentions.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/mentions.mjs\");\n/* harmony import */ var _slate_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../slate/utils/is-text.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-text.mjs\");\n/* harmony import */ var _utils_exists_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/exists.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/exists.mjs\");\n/* harmony import */ var _Comment_utils_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Comment/utils.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Comment/utils.mjs\");\n\n\n\n\n\n\n\nfunction composerBodyMentionToCommentBodyMention(mention) {\n  return {\n    type: \"mention\",\n    id: mention.id\n  };\n}\nfunction composerBodyAutoLinkToCommentBodyLink(link) {\n  return {\n    type: \"link\",\n    url: link.url\n  };\n}\nfunction composerBodyCustomLinkToCommentBodyLink(link) {\n  return {\n    type: \"link\",\n    url: link.url,\n    text: link.children.map((child) => child.text).join(\"\")\n  };\n}\nfunction commentBodyMentionToComposerBodyMention(mention) {\n  return {\n    type: \"mention\",\n    id: mention.id,\n    children: [{ text: \"\" }]\n  };\n}\nfunction commentBodyLinkToComposerBodyLink(link) {\n  if (link.text) {\n    return {\n      type: \"custom-link\",\n      url: link.url,\n      children: [{ text: link.text }]\n    };\n  } else {\n    return {\n      type: \"auto-link\",\n      url: link.url,\n      children: [{ text: link.url }]\n    };\n  }\n}\nfunction composerBodyToCommentBody(body) {\n  return {\n    version: 1,\n    content: body.map((block) => {\n      if (block.type !== \"paragraph\") {\n        return null;\n      }\n      const children = block.children.map((inline) => {\n        if ((0,_slate_plugins_mentions_mjs__WEBPACK_IMPORTED_MODULE_0__.isComposerBodyMention)(inline)) {\n          return composerBodyMentionToCommentBodyMention(inline);\n        }\n        if ((0,_slate_plugins_auto_links_mjs__WEBPACK_IMPORTED_MODULE_1__.isComposerBodyAutoLink)(inline)) {\n          return composerBodyAutoLinkToCommentBodyLink(inline);\n        }\n        if ((0,_slate_plugins_custom_links_mjs__WEBPACK_IMPORTED_MODULE_2__.isComposerBodyCustomLink)(inline)) {\n          return composerBodyCustomLinkToCommentBodyLink(inline);\n        }\n        if ((0,_slate_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_3__.isText)(inline)) {\n          return inline;\n        }\n        return null;\n      }).filter(_utils_exists_mjs__WEBPACK_IMPORTED_MODULE_4__.exists);\n      return {\n        ...block,\n        children\n      };\n    }).filter(_utils_exists_mjs__WEBPACK_IMPORTED_MODULE_4__.exists)\n  };\n}\nconst emptyComposerBody = [];\nfunction commentBodyToComposerBody(body) {\n  if (!body || !body?.content) {\n    return emptyComposerBody;\n  }\n  return body.content.map((block) => {\n    if (block.type !== \"paragraph\") {\n      return null;\n    }\n    const children = block.children.map((inline) => {\n      if ((0,_Comment_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.isCommentBodyMention)(inline)) {\n        return commentBodyMentionToComposerBodyMention(inline);\n      }\n      if ((0,_Comment_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.isCommentBodyLink)(inline)) {\n        return commentBodyLinkToComposerBodyLink(inline);\n      }\n      if ((0,_Comment_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.isCommentBodyText)(inline)) {\n        return inline;\n      }\n      return null;\n    }).filter(_utils_exists_mjs__WEBPACK_IMPORTED_MODULE_4__.exists);\n    return {\n      ...block,\n      children\n    };\n  }).filter(_utils_exists_mjs__WEBPACK_IMPORTED_MODULE_4__.exists);\n}\nfunction getPlacementFromPosition(position, direction = \"ltr\") {\n  return `${position}-${direction === \"rtl\" ? \"end\" : \"start\"}`;\n}\nfunction getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [side, align];\n}\n\n\n//# sourceMappingURL=utils.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0NvbXBvc2VyL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEU7QUFDSTtBQUNQO0FBQ2xCO0FBQ1A7QUFDa0Q7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRkFBcUI7QUFDakM7QUFDQTtBQUNBLFlBQVkscUZBQXNCO0FBQ2xDO0FBQ0E7QUFDQSxZQUFZLHlGQUF3QjtBQUNwQztBQUNBO0FBQ0EsWUFBWSxnRUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVMscURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFNBQVMscURBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3RUFBb0I7QUFDOUI7QUFDQTtBQUNBLFVBQVUscUVBQWlCO0FBQzNCO0FBQ0E7QUFDQSxVQUFVLHFFQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFNBQVMscURBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMscURBQU07QUFDbEI7QUFDQTtBQUNBLFlBQVksU0FBUyxHQUFHLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2VDtBQUM3VCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3ByaW1pdGl2ZXMvQ29tcG9zZXIvdXRpbHMubWpzP2I2OWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNDb21wb3NlckJvZHlBdXRvTGluayB9IGZyb20gJy4uLy4uL3NsYXRlL3BsdWdpbnMvYXV0by1saW5rcy5tanMnO1xuaW1wb3J0IHsgaXNDb21wb3NlckJvZHlDdXN0b21MaW5rIH0gZnJvbSAnLi4vLi4vc2xhdGUvcGx1Z2lucy9jdXN0b20tbGlua3MubWpzJztcbmltcG9ydCB7IGlzQ29tcG9zZXJCb2R5TWVudGlvbiB9IGZyb20gJy4uLy4uL3NsYXRlL3BsdWdpbnMvbWVudGlvbnMubWpzJztcbmltcG9ydCB7IGlzVGV4dCB9IGZyb20gJy4uLy4uL3NsYXRlL3V0aWxzL2lzLXRleHQubWpzJztcbmltcG9ydCB7IGV4aXN0cyB9IGZyb20gJy4uLy4uL3V0aWxzL2V4aXN0cy5tanMnO1xuaW1wb3J0IHsgaXNDb21tZW50Qm9keU1lbnRpb24sIGlzQ29tbWVudEJvZHlMaW5rLCBpc0NvbW1lbnRCb2R5VGV4dCB9IGZyb20gJy4uL0NvbW1lbnQvdXRpbHMubWpzJztcblxuZnVuY3Rpb24gY29tcG9zZXJCb2R5TWVudGlvblRvQ29tbWVudEJvZHlNZW50aW9uKG1lbnRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1lbnRpb25cIixcbiAgICBpZDogbWVudGlvbi5pZFxuICB9O1xufVxuZnVuY3Rpb24gY29tcG9zZXJCb2R5QXV0b0xpbmtUb0NvbW1lbnRCb2R5TGluayhsaW5rKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJsaW5rXCIsXG4gICAgdXJsOiBsaW5rLnVybFxuICB9O1xufVxuZnVuY3Rpb24gY29tcG9zZXJCb2R5Q3VzdG9tTGlua1RvQ29tbWVudEJvZHlMaW5rKGxpbmspIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImxpbmtcIixcbiAgICB1cmw6IGxpbmsudXJsLFxuICAgIHRleHQ6IGxpbmsuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQudGV4dCkuam9pbihcIlwiKVxuICB9O1xufVxuZnVuY3Rpb24gY29tbWVudEJvZHlNZW50aW9uVG9Db21wb3NlckJvZHlNZW50aW9uKG1lbnRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1lbnRpb25cIixcbiAgICBpZDogbWVudGlvbi5pZCxcbiAgICBjaGlsZHJlbjogW3sgdGV4dDogXCJcIiB9XVxuICB9O1xufVxuZnVuY3Rpb24gY29tbWVudEJvZHlMaW5rVG9Db21wb3NlckJvZHlMaW5rKGxpbmspIHtcbiAgaWYgKGxpbmsudGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImN1c3RvbS1saW5rXCIsXG4gICAgICB1cmw6IGxpbmsudXJsLFxuICAgICAgY2hpbGRyZW46IFt7IHRleHQ6IGxpbmsudGV4dCB9XVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXV0by1saW5rXCIsXG4gICAgICB1cmw6IGxpbmsudXJsLFxuICAgICAgY2hpbGRyZW46IFt7IHRleHQ6IGxpbmsudXJsIH1dXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZXJCb2R5VG9Db21tZW50Qm9keShib2R5KSB7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogMSxcbiAgICBjb250ZW50OiBib2R5Lm1hcCgoYmxvY2spID0+IHtcbiAgICAgIGlmIChibG9jay50eXBlICE9PSBcInBhcmFncmFwaFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5tYXAoKGlubGluZSkgPT4ge1xuICAgICAgICBpZiAoaXNDb21wb3NlckJvZHlNZW50aW9uKGlubGluZSkpIHtcbiAgICAgICAgICByZXR1cm4gY29tcG9zZXJCb2R5TWVudGlvblRvQ29tbWVudEJvZHlNZW50aW9uKGlubGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29tcG9zZXJCb2R5QXV0b0xpbmsoaW5saW5lKSkge1xuICAgICAgICAgIHJldHVybiBjb21wb3NlckJvZHlBdXRvTGlua1RvQ29tbWVudEJvZHlMaW5rKGlubGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29tcG9zZXJCb2R5Q3VzdG9tTGluayhpbmxpbmUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBvc2VyQm9keUN1c3RvbUxpbmtUb0NvbW1lbnRCb2R5TGluayhpbmxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHQoaW5saW5lKSkge1xuICAgICAgICAgIHJldHVybiBpbmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KS5maWx0ZXIoZXhpc3RzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmJsb2NrLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfTtcbiAgICB9KS5maWx0ZXIoZXhpc3RzKVxuICB9O1xufVxuY29uc3QgZW1wdHlDb21wb3NlckJvZHkgPSBbXTtcbmZ1bmN0aW9uIGNvbW1lbnRCb2R5VG9Db21wb3NlckJvZHkoYm9keSkge1xuICBpZiAoIWJvZHkgfHwgIWJvZHk/LmNvbnRlbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb21wb3NlckJvZHk7XG4gIH1cbiAgcmV0dXJuIGJvZHkuY29udGVudC5tYXAoKGJsb2NrKSA9PiB7XG4gICAgaWYgKGJsb2NrLnR5cGUgIT09IFwicGFyYWdyYXBoXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcCgoaW5saW5lKSA9PiB7XG4gICAgICBpZiAoaXNDb21tZW50Qm9keU1lbnRpb24oaW5saW5lKSkge1xuICAgICAgICByZXR1cm4gY29tbWVudEJvZHlNZW50aW9uVG9Db21wb3NlckJvZHlNZW50aW9uKGlubGluZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICByZXR1cm4gY29tbWVudEJvZHlMaW5rVG9Db21wb3NlckJvZHlMaW5rKGlubGluZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tZW50Qm9keVRleHQoaW5saW5lKSkge1xuICAgICAgICByZXR1cm4gaW5saW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKGV4aXN0cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJsb2NrLFxuICAgICAgY2hpbGRyZW5cbiAgICB9O1xuICB9KS5maWx0ZXIoZXhpc3RzKTtcbn1cbmZ1bmN0aW9uIGdldFBsYWNlbWVudEZyb21Qb3NpdGlvbihwb3NpdGlvbiwgZGlyZWN0aW9uID0gXCJsdHJcIikge1xuICByZXR1cm4gYCR7cG9zaXRpb259LSR7ZGlyZWN0aW9uID09PSBcInJ0bFwiID8gXCJlbmRcIiA6IFwic3RhcnRcIn1gO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUFuZEFsaWduRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgY29uc3QgW3NpZGUsIGFsaWduID0gXCJjZW50ZXJcIl0gPSBwbGFjZW1lbnQuc3BsaXQoXCItXCIpO1xuICByZXR1cm4gW3NpZGUsIGFsaWduXTtcbn1cblxuZXhwb3J0IHsgY29tbWVudEJvZHlMaW5rVG9Db21wb3NlckJvZHlMaW5rLCBjb21tZW50Qm9keU1lbnRpb25Ub0NvbXBvc2VyQm9keU1lbnRpb24sIGNvbW1lbnRCb2R5VG9Db21wb3NlckJvZHksIGNvbXBvc2VyQm9keUF1dG9MaW5rVG9Db21tZW50Qm9keUxpbmssIGNvbXBvc2VyQm9keUN1c3RvbUxpbmtUb0NvbW1lbnRCb2R5TGluaywgY29tcG9zZXJCb2R5TWVudGlvblRvQ29tbWVudEJvZHlNZW50aW9uLCBjb21wb3NlckJvZHlUb0NvbW1lbnRCb2R5LCBnZXRQbGFjZW1lbnRGcm9tUG9zaXRpb24sIGdldFNpZGVBbmRBbGlnbkZyb21QbGFjZW1lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Composer/utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/contexts.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/contexts.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmojiPickerContext: () => (/* binding */ EmojiPickerContext),\n/* harmony export */   useEmojiPicker: () => (/* binding */ useEmojiPicker)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\nconst EmojiPickerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(\n  null\n);\nfunction useEmojiPicker() {\n  const emojiPickerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmojiPickerContext);\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n    emojiPickerContext,\n    \"EmojiPicker.Root is missing from the React tree.\"\n  );\n}\n\n\n//# sourceMappingURL=contexts.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0Vtb2ppUGlja2VyL2NvbnRleHRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNDO0FBQ1k7O0FBRWxELDJCQUEyQixvREFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaURBQVU7QUFDdkMsU0FBUyxvREFBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUU4QztBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3ByaW1pdGl2ZXMvRW1vamlQaWNrZXIvY29udGV4dHMubWpzPzBiZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm4gfSBmcm9tICdAbGl2ZWJsb2Nrcy9jb3JlJztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IEVtb2ppUGlja2VyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoXG4gIG51bGxcbik7XG5mdW5jdGlvbiB1c2VFbW9qaVBpY2tlcigpIHtcbiAgY29uc3QgZW1vamlQaWNrZXJDb250ZXh0ID0gdXNlQ29udGV4dChFbW9qaVBpY2tlckNvbnRleHQpO1xuICByZXR1cm4gbm4oXG4gICAgZW1vamlQaWNrZXJDb250ZXh0LFxuICAgIFwiRW1vamlQaWNrZXIuUm9vdCBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCJcbiAgKTtcbn1cblxuZXhwb3J0IHsgRW1vamlQaWNrZXJDb250ZXh0LCB1c2VFbW9qaVBpY2tlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/contexts.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/index.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/index.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Content: () => (/* binding */ EmojiPickerContent),\n/* harmony export */   Root: () => (/* binding */ EmojiPickerRoot),\n/* harmony export */   Search: () => (/* binding */ EmojiPickerSearch)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_virtuoso__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-virtuoso */ \"(ssr)/./node_modules/react-virtuoso/dist/index.mjs\");\n/* harmony import */ var _utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/is-key.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-key.mjs\");\n/* harmony import */ var _utils_request_idle_callback_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/request-idle-callback.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/request-idle-callback.mjs\");\n/* harmony import */ var _utils_use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utils/use-layout-effect.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-layout-effect.mjs\");\n/* harmony import */ var _utils_use_transition_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/use-transition.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-transition.mjs\");\n/* harmony import */ var _utils_visually_hidden_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utils/visually-hidden.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/visually-hidden.mjs\");\n/* harmony import */ var _internal_Emoji_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../internal/Emoji.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/internal/Emoji.mjs\");\n/* harmony import */ var _contexts_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contexts.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/contexts.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/utils.mjs\");\n/* __next_internal_client_entry_do_not_use__ Content,Root,Search auto */ \n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLUMNS = 10;\nconst DEFAULT_LOCALE = \"en\";\nconst LOADING_MINIMUM_TIMEOUT = 100;\nconst EMOJIPICKER_ROOT_NAME = \"EmojiPickerRoot\";\nconst EMOJIPICKER_CONTENT_NAME = \"EmojiPickerContent\";\nconst EMOJIPICKER_SEARCH_NAME = \"EmojiPickerSearch\";\nfunction EmojiPickerRoot({ columns = DEFAULT_COLUMNS, locale = DEFAULT_LOCALE, onEmojiSelect, children }) {\n    const emojiData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const search = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\n    const [, startEmojisTransition] = (0,_utils_use_transition_mjs__WEBPACK_IMPORTED_MODULE_1__.useTransition)();\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const [selectedColumnIndex, setSelectedColumnIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [selectedRowIndex, setSelectedRowIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [interaction, setInteraction] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"none\");\n    const selectCurrentEmoji = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (onEmojiSelect) {\n            const emoji = data?.rows[selectedRowIndex]?.[selectedColumnIndex];\n            if (emoji) {\n                onEmojiSelect(emoji.emoji);\n            }\n        }\n    }, [\n        data?.rows,\n        onEmojiSelect,\n        selectedColumnIndex,\n        selectedRowIndex\n    ]);\n    const resetSelection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setSelectedColumnIndex(0);\n        setSelectedRowIndex(0);\n    }, []);\n    const setPointerSelection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((columnIndex, rowIndex)=>{\n        setInteraction(\"pointer\");\n        setSelectedColumnIndex(columnIndex);\n        setSelectedRowIndex(rowIndex);\n    }, []);\n    const moveSelection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((direction, event)=>{\n        if (!data) {\n            return;\n        }\n        event.preventDefault();\n        if (interaction === \"none\") {\n            setInteraction(\"keyboard\");\n            return;\n        }\n        setInteraction(\"keyboard\");\n        switch(direction){\n            case \"left\":\n                {\n                    if (selectedColumnIndex === 0) {\n                        const previousRowIndex = selectedRowIndex - 1;\n                        const previousRow = data.rows[previousRowIndex];\n                        if (previousRow) {\n                            setSelectedRowIndex(previousRowIndex);\n                            setSelectedColumnIndex(previousRow.length - 1);\n                        }\n                    } else {\n                        setSelectedColumnIndex(selectedColumnIndex - 1);\n                    }\n                    break;\n                }\n            case \"right\":\n                {\n                    const currentRow = data.rows[selectedRowIndex];\n                    if (selectedColumnIndex === currentRow.length - 1) {\n                        const nextRowIndex = selectedRowIndex + 1;\n                        const nextRow = data.rows[nextRowIndex];\n                        if (nextRow) {\n                            setSelectedRowIndex(nextRowIndex);\n                            setSelectedColumnIndex(0);\n                        }\n                    } else {\n                        setSelectedColumnIndex(selectedColumnIndex + 1);\n                    }\n                    break;\n                }\n            case \"up\":\n                {\n                    const previousRow = data.rows[selectedRowIndex - 1];\n                    if (previousRow) {\n                        setSelectedRowIndex(selectedRowIndex - 1);\n                        if (!previousRow[selectedColumnIndex]) {\n                            setSelectedColumnIndex(previousRow.length - 1);\n                        }\n                    }\n                    break;\n                }\n            case \"down\":\n                {\n                    const nextRow = data.rows[selectedRowIndex + 1];\n                    if (nextRow) {\n                        setSelectedRowIndex(selectedRowIndex + 1);\n                        if (!nextRow[selectedColumnIndex]) {\n                            setSelectedColumnIndex(nextRow.length - 1);\n                        }\n                    }\n                    break;\n                }\n        }\n    }, [\n        data,\n        interaction,\n        selectedColumnIndex,\n        selectedRowIndex\n    ]);\n    const updateEmojis = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!emojiData.current) {\n            return;\n        }\n        startEmojisTransition(()=>{\n            setData(()=>{\n                if (!emojiData.current) {\n                    return;\n                }\n                const filteredEmojis = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.filterEmojis)(emojiData.current.emojis, search.current);\n                return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.generateEmojiPickerData)(filteredEmojis, emojiData.current.categories, columns);\n            });\n            resetSelection();\n        });\n    }, [\n        columns,\n        resetSelection\n    ]);\n    const handleSearch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>{\n        search.current = value;\n        updateEmojis();\n    }, [\n        updateEmojis\n    ]);\n    const initializeEmojiData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (locale2)=>{\n        try {\n            emojiData.current = await (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.getEmojiData)(locale2);\n            updateEmojis();\n        } catch (error2) {\n            setError(error2);\n        }\n    }, [\n        updateEmojis\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let idleCallbackId;\n        const timeoutId = setTimeout(()=>{\n            idleCallbackId = (0,_utils_request_idle_callback_mjs__WEBPACK_IMPORTED_MODULE_3__.requestIdleCallback)(()=>{\n                initializeEmojiData(locale);\n            });\n        }, LOADING_MINIMUM_TIMEOUT);\n        return ()=>{\n            clearTimeout(timeoutId);\n            (0,_utils_request_idle_callback_mjs__WEBPACK_IMPORTED_MODULE_3__.cancelIdleCallback)(idleCallbackId);\n        };\n    }, [\n        locale\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (interaction === \"none\") {\n            resetSelection();\n        }\n    }, [\n        interaction\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_mjs__WEBPACK_IMPORTED_MODULE_4__.EmojiPickerContext.Provider, {\n        value: {\n            data,\n            error,\n            isLoading: !data && !error,\n            columns,\n            onSearch: handleSearch,\n            onEmojiSelect,\n            selectCurrentEmoji,\n            selectedRowIndex,\n            selectedColumnIndex,\n            moveSelection,\n            setPointerSelection,\n            interaction,\n            setInteraction\n        }\n    }, children);\n}\nconst EmojiPickerSearch = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ asChild, value, defaultValue, onChange, ...props }, forwardedRef)=>{\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_5__.Slot : \"input\";\n    const { onSearch, selectCurrentEmoji, moveSelection, interaction, setInteraction } = (0,_contexts_mjs__WEBPACK_IMPORTED_MODULE_4__.useEmojiPicker)();\n    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        onChange?.(event);\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        const value2 = event.target.value;\n        setInteraction(value2 ? \"keyboard\" : \"none\");\n        onSearch(value2);\n    }, [\n        onChange,\n        onSearch,\n        setInteraction\n    ]);\n    const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_6__.isKey)(event, \"ArrowLeft\")) {\n            moveSelection(\"left\", event);\n        } else if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_6__.isKey)(event, \"ArrowRight\")) {\n            moveSelection(\"right\", event);\n        } else if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_6__.isKey)(event, \"ArrowUp\")) {\n            moveSelection(\"up\", event);\n        } else if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_6__.isKey)(event, \"ArrowDown\")) {\n            moveSelection(\"down\", event);\n        } else if ((0,_utils_is_key_mjs__WEBPACK_IMPORTED_MODULE_6__.isKey)(event, \"Enter\")) {\n            if (interaction !== \"none\") {\n                event.preventDefault();\n                selectCurrentEmoji();\n            }\n        }\n    }, [\n        interaction,\n        moveSelection,\n        selectCurrentEmoji\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        onSearch(value ? String(value) : defaultValue ? String(defaultValue) : \"\");\n    }, []);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        type: \"search\",\n        value,\n        defaultValue,\n        onChange: handleChange,\n        onKeyDown: handleKeyDown,\n        ...props,\n        ref: forwardedRef\n    });\n});\nconst defaultContentComponents = {\n    CategoryHeader: ({ category, ...props })=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ...props\n        }, category),\n    Row: ({ children, attributes, ...props })=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ...props\n        }, children),\n    Emoji: ({ emoji, ...props })=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n            ...props\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_Emoji_mjs__WEBPACK_IMPORTED_MODULE_7__.Emoji, {\n            emoji\n        })),\n    Loading: (props)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ...props\n        }),\n    Empty: (props)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ...props\n        }),\n    Grid: (props)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ...props\n        }),\n    Error: ({ error, ...props })=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ...props\n        })\n};\nconst placeholderRowAttributes = {\n    rowIndex: -1,\n    categoryRowIndex: -1,\n    categoryRowsCount: 0\n};\nconst VirtuosoScroller = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...props,\n        tabIndex: -1,\n        \"data-testid\": void 0,\n        ref: forwardedRef\n    }, children);\n});\nconst VirtuosoTopList = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...props,\n        \"data-testid\": void 0,\n        ref: forwardedRef\n    }, children);\n});\nconst EmojiPickerContent = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ components, asChild, ...props }, forwardedRef)=>{\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_5__.Slot : \"div\";\n    const virtuosoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const placeholderContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const rowScrollMarginTopRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const rowScrollMarginBottomRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const categoryHeaderHeightRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const { data, error, isLoading, columns, onEmojiSelect, selectedColumnIndex, selectedRowIndex, setPointerSelection, interaction, setInteraction } = (0,_contexts_mjs__WEBPACK_IMPORTED_MODULE_4__.useEmojiPicker)();\n    const selectedEmoji = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>data?.rows[selectedRowIndex]?.[selectedColumnIndex], [\n        data?.rows,\n        selectedColumnIndex,\n        selectedRowIndex\n    ]);\n    const { Loading, Empty, Error, CategoryHeader, Grid, Row, Emoji } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...defaultContentComponents,\n            ...components\n        }), [\n        components\n    ]);\n    const VirtuosoList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, ...props2 }, forwardedRef2)=>{\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                role: \"grid\",\n                \"aria-colcount\": columns,\n                ...props2,\n                \"data-testid\": void 0,\n                ref: forwardedRef2\n            }, children);\n        }), [\n        columns\n    ]);\n    const placeholderColumns = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>Array(columns).fill(\"\\uD83C\\uDF2B\"), [\n        columns\n    ]);\n    const preventDefault = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.preventDefault();\n    }, []);\n    const handleEmojiPointerLeave = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (interaction === \"pointer\") {\n            setInteraction(\"none\");\n        }\n    }, [\n        interaction,\n        setInteraction\n    ]);\n    (0,_utils_use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_8__.useLayoutEffect)(()=>{\n        if (!placeholderContainerRef.current) {\n            return;\n        }\n        const row = placeholderContainerRef.current.childNodes[0];\n        const categoryHeader = placeholderContainerRef.current.childNodes[1];\n        if (row instanceof HTMLElement) {\n            const style = window.getComputedStyle(row);\n            rowScrollMarginTopRef.current = parseFloat(style.scrollMarginTop);\n            rowScrollMarginBottomRef.current = parseFloat(style.scrollMarginBottom);\n        }\n        if (categoryHeader instanceof HTMLElement) {\n            categoryHeaderHeightRef.current = categoryHeader.offsetHeight;\n        }\n    }, []);\n    const calculateViewLocation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ itemTop, itemBottom, viewportTop, viewportBottom, locationParams: { behavior, align, ...params } })=>{\n        if (itemTop - (categoryHeaderHeightRef.current + rowScrollMarginTopRef.current) < viewportTop) {\n            return {\n                ...params,\n                behavior,\n                align: align ?? \"start\"\n            };\n        }\n        if (itemBottom > viewportBottom) {\n            return {\n                ...params,\n                behavior,\n                align: align ?? \"end\",\n                offset: rowScrollMarginBottomRef.current\n            };\n        }\n        return null;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (interaction === \"keyboard\") {\n            virtuosoRef.current?.scrollIntoView({\n                index: selectedRowIndex,\n                behavior: \"auto\",\n                calculateViewLocation\n            });\n        }\n    }, [\n        interaction,\n        selectedRowIndex,\n        calculateViewLocation\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        ...props,\n        ref: forwardedRef\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: {\n            visibility: \"hidden\",\n            height: 0\n        },\n        ref: placeholderContainerRef\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Row, {\n        attributes: placeholderRowAttributes\n    }, placeholderColumns.map((placeholder, index)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Emoji, {\n            emoji: placeholder,\n            key: index\n        }))), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CategoryHeader, {\n        category: \"Category\"\n    })), isLoading ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Loading, null) : error ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Error, {\n        error\n    }) : data.count === 0 ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Empty, null) : /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Grid, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_virtuoso__WEBPACK_IMPORTED_MODULE_9__.GroupedVirtuoso, {\n        ref: virtuosoRef,\n        components: {\n            Scroller: VirtuosoScroller,\n            List: VirtuosoList,\n            TopItemList: VirtuosoTopList\n        },\n        groupCounts: data.categoriesRowCounts,\n        groupContent: (groupIndex)=>{\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CategoryHeader, {\n                category: data.categories[groupIndex]\n            });\n        },\n        itemContent: (rowIndex, groupIndex)=>{\n            const categoryRowIndex = data.categoriesRowIndices[groupIndex].indexOf(rowIndex);\n            const categoryRowsCount = data.categoriesRowCounts[groupIndex];\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Row, {\n                attributes: {\n                    rowIndex,\n                    categoryRowIndex,\n                    categoryRowsCount\n                }\n            }, data.rows[rowIndex].map((emoji, columnIndex)=>{\n                const isSelected = interaction !== \"none\" && selectedColumnIndex === columnIndex && selectedRowIndex === rowIndex;\n                return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Emoji, {\n                    key: emoji.emoji,\n                    role: \"gridcell\",\n                    \"aria-colindex\": columnIndex,\n                    \"aria-selected\": isSelected || void 0,\n                    \"data-selected\": isSelected || void 0,\n                    onMouseDown: preventDefault,\n                    tabIndex: -1,\n                    onPointerEnter: ()=>{\n                        setPointerSelection(columnIndex, rowIndex);\n                    },\n                    onPointerLeave: handleEmojiPointerLeave,\n                    onClick: (event)=>{\n                        onEmojiSelect?.(emoji.emoji);\n                        event.stopPropagation();\n                    },\n                    emoji: emoji.emoji\n                });\n            }));\n        }\n    })), selectedEmoji && interaction !== \"none\" && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        \"aria-live\": \"polite\",\n        style: _utils_visually_hidden_mjs__WEBPACK_IMPORTED_MODULE_10__.visuallyHidden\n    }, selectedEmoji.name));\n});\nif (true) {\n    EmojiPickerRoot.displayName = EMOJIPICKER_ROOT_NAME;\n    EmojiPickerContent.displayName = EMOJIPICKER_CONTENT_NAME;\n    EmojiPickerSearch.displayName = EMOJIPICKER_SEARCH_NAME;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0Vtb2ppUGlja2VyL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBLE1BQUFBLGtCQUFBO0FBQ0EsTUFBQUMsaUJBQUE7QUFDQSxNQUFBQywwQkFBQTtBQUVBLE1BQUFDLHdCQUFBO0FBQ0EsTUFBQUMsMkJBQUE7QUFDQSxNQUFBQywwQkFBQTtBQWtCQSxTQUFBQyxnQkFBQSxFQUF5QkMsVUFBQVAsZUFBQSxFQUNiUSxTQUFBUCxjQUFBLEVBQ0RRLGFBQUEsRUFDVEMsUUFBQSxFQUVGO0lBQ0UsTUFBQUMsWUFBQUMsNkNBQUFBO0lBQ0EsTUFBQUMsU0FBQUQsNkNBQUFBLENBQUE7SUFDQSxTQUFBRSxzQkFBQSxHQUFBQyx3RUFBQUE7SUFDQSxPQUFBQyxNQUFBQyxRQUFBLEdBQUFDLCtDQUFBQTtJQUNBLE9BQUFDLE9BQUFDLFNBQUEsR0FBQUYsK0NBQUFBO0lBQ0EsT0FBQUcscUJBQUFDLHVCQUFBLEdBQUFKLCtDQUFBQSxDQUFBO0lBQ0EsT0FBQUssa0JBQUFDLG9CQUFBLEdBQUFOLCtDQUFBQSxDQUFBO0lBQ0EsT0FBQU8sYUFBQUMsZUFBQSxHQUFBUiwrQ0FBQUEsQ0FBQTtJQUlBLE1BQUFTLHFCQUFBQyxrREFBQUEsQ0FBQTtRQUNFLElBQUFuQixlQUFBO1lBQ0UsTUFBQW9CLFFBQUFiLE1BQUFjLElBQUEsQ0FBQVAsaUJBQUEsR0FBQUYsb0JBQUE7WUFFQSxJQUFBUSxPQUFBO2dCQUNFcEIsY0FBQW9CLE1BQUFBLEtBQUE7WUFBeUI7UUFDM0I7SUFDRjtRQUFBYixNQUFBYztRQUFBckI7UUFBQVk7UUFBQUU7S0FBQTtJQUdGLE1BQUFRLGlCQUFBSCxrREFBQUEsQ0FBQTtRQUNFTix1QkFBQTtRQUNBRSxvQkFBQTtJQUFxQjtJQUd2QixNQUFBUSxzQkFBQUosa0RBQUFBLENBQTRCLENBQUFLLGFBQUFDO1FBRXhCUixlQUFBO1FBQ0FKLHVCQUFBVztRQUNBVCxvQkFBQVU7SUFBNEIsR0FDOUI7SUFJRixNQUFBQyxnQkFBQVAsa0RBQUFBLENBQXNCLENBQUFRLFdBQUFDO1FBS2xCLEtBQUFyQixNQUFBO1lBQ0U7UUFBQTtRQUdGcUIsTUFBQUMsY0FBQTtRQUVBLElBQUFiLGdCQUFBO1lBQ0VDLGVBQUE7WUFDQTtRQUFBO1FBR0ZBLGVBQUE7UUFFQSxPQUFBVTtZQUFtQjtnQkFBQTtvQkFJZixJQUFBZix3QkFBQTt3QkFDRSxNQUFBa0IsbUJBQUFoQixtQkFBQTt3QkFDQSxNQUFBaUIsY0FBQXhCLEtBQUFjLElBQUEsQ0FBQVMsaUJBQUE7d0JBRUEsSUFBQUMsYUFBQTs0QkFDRWhCLG9CQUFBZTs0QkFDQWpCLHVCQUFBa0IsWUFBQUMsTUFBQTt3QkFBNkM7b0JBQy9DO3dCQUVBbkIsdUJBQUFELHNCQUFBO29CQUE4QztvQkFHaEQ7Z0JBQUE7WUFDRjtnQkFBQTtvQkFLRSxNQUFBcUIsYUFBQTFCLEtBQUFjLElBQUEsQ0FBQVAsaUJBQUE7b0JBRUEsSUFBQUYsd0JBQUFxQixXQUFBRCxNQUFBO3dCQUNFLE1BQUFFLGVBQUFwQixtQkFBQTt3QkFDQSxNQUFBcUIsVUFBQTVCLEtBQUFjLElBQUEsQ0FBQWEsYUFBQTt3QkFFQSxJQUFBQyxTQUFBOzRCQUNFcEIsb0JBQUFtQjs0QkFDQXJCLHVCQUFBO3dCQUF3QjtvQkFDMUI7d0JBRUFBLHVCQUFBRCxzQkFBQTtvQkFBOEM7b0JBR2hEO2dCQUFBO1lBQ0Y7Z0JBQUE7b0JBS0UsTUFBQW1CLGNBQUF4QixLQUFBYyxJQUFBLENBQUFQLG1CQUFBO29CQUVBLElBQUFpQixhQUFBO3dCQUNFaEIsb0JBQUFELG1CQUFBO3dCQUVBLEtBQUFpQixXQUFBLENBQUFuQixvQkFBQTs0QkFDRUMsdUJBQUFrQixZQUFBQyxNQUFBO3dCQUE2QztvQkFDL0M7b0JBR0Y7Z0JBQUE7WUFDRjtnQkFBQTtvQkFLRSxNQUFBRyxVQUFBNUIsS0FBQWMsSUFBQSxDQUFBUCxtQkFBQTtvQkFFQSxJQUFBcUIsU0FBQTt3QkFDRXBCLG9CQUFBRCxtQkFBQTt3QkFFQSxLQUFBcUIsT0FBQSxDQUFBdkIsb0JBQUE7NEJBQ0VDLHVCQUFBc0IsUUFBQUgsTUFBQTt3QkFBeUM7b0JBQzNDO29CQUdGO2dCQUFBO1FBQ0Y7SUFDRixHQUNGO1FBQUF6QjtRQUFBUztRQUFBSjtRQUFBRTtLQUFBO0lBSUYsTUFBQXNCLGVBQUFqQixrREFBQUEsQ0FBQTtRQUNFLEtBQUFqQixVQUFBbUMsT0FBQTtZQUNFO1FBQUE7UUFHRmhDLHNCQUFBO1lBQ0VHLFFBQUE7Z0JBQ0UsS0FBQU4sVUFBQW1DLE9BQUE7b0JBQ0U7Z0JBQUE7Z0JBR0YsTUFBQUMsaUJBQUFDLHdEQUFBQSxDQUF1QnJDLFVBQUFtQyxPQUFBLENBQUFHLE1BQUEsRUFDSHBDLE9BQUFpQyxPQUFBO2dCQUlwQixPQUFBSSxtRUFBQUEsQ0FBT0gsZ0JBQ0xwQyxVQUFBbUMsT0FBQSxDQUFBSyxVQUFBLEVBQ2tCNUM7WUFFcEI7WUFFRndCO1FBQWU7SUFDaEI7UUFBQXhCO1FBQUF3QjtLQUFBO0lBR0gsTUFBQXFCLGVBQUF4QixrREFBQUEsQ0FBcUIsQ0FBQXlCO1FBRWpCeEMsT0FBQWlDLE9BQUEsR0FBQU87UUFDQVI7SUFBYSxHQUNmO1FBQUFBO0tBQUE7SUFJRixNQUFBUyxzQkFBQTFCLGtEQUFBQSxDQUE0QixPQUFBMkI7UUFFeEI7WUFDRTVDLFVBQUFtQyxPQUFBLFNBQUFVLHdEQUFBQSxDQUFBRDtZQUNBVjtRQUFhLFNBQUFZLFFBQUE7WUFFYnJDLFNBQUFxQztRQUF1QjtJQUN6QixHQUNGO1FBQUFaO0tBQUE7SUFJRmEsZ0RBQVNBLENBQVQ7UUFDRSxJQUFBQztRQUNBLE1BQUFDLFlBQUFDLFdBQUE7WUFDRUYsaUJBQUFHLHFGQUFBQSxDQUFBO2dCQUNFUixvQkFBQTlDO1lBQTBCO1FBQzNCLEdBQUFOO1FBR0g7WUFDRTZELGFBQUFIO1lBQ0FJLG9GQUFrQkEsQ0FBbEJMO1FBQWlDO0lBQ25DO1FBQUFuRDtLQUFBO0lBR0ZrRCxnREFBU0EsQ0FBVDtRQUNFLElBQUFqQyxnQkFBQTtZQUNFTTtRQUFlO0lBQ2pCO1FBQUFOO0tBQUE7SUFHRixxQ0FBQXdDLGdEQUFBLENBQUFFLDZEQUFBQSxDQUFBQyxRQUFBO1FBQ0dmLE9BQUE7WUFDUXJDO1lBQ0xHO1lBQ0FrRCxXQUFBLENBQUFyRCxRQUFBLENBQUFHO1lBQ3NCWjtZQUN0QitELFVBQUFsQjtZQUNVM0M7WUFDVmtCO1lBQ0FKO1lBQ0FGO1lBQ0FjO1lBQ0FIO1lBQ0FQO1lBQ0FDO1FBQ0E7SUFDRixHQUFBaEI7QUFLTjtBQWVBLE1BQUE2RCxrQ0FBQUMsaURBQUFBLENBQTBCLEdBQUFDLE9BQUEsRUFBQXBCLEtBQUEsRUFBQXFCLFlBQUEsRUFBQUMsUUFBQSxLQUFBQyxPQUFBLEVBQUFDO0lBRXRCLE1BQUFDLFlBQUFMLFVBQUFNLHNEQUFBQSxHQUFBO0lBQ0EsUUFBTVQsUUFBQSxFQUNKM0Msa0JBQUEsRUFDQVEsYUFBQSxFQUNBVixXQUFBLEVBQ0FDLGNBQUEsRUFDQSxHQUFBc0QsNkRBQUFBO0lBR0YsTUFBQUMsZUFBQXJELGtEQUFBQSxDQUFxQixDQUFBUztRQUVqQnNDLFdBQUF0QztRQUVBLElBQUFBLE1BQUE2QyxrQkFBQTtZQUNFO1FBQUE7UUFHRixNQUFBQyxTQUFBOUMsTUFBQStDLE1BQUEsQ0FBQS9CLEtBQUE7UUFDQTNCLGVBQUF5RCxTQUFBO1FBQ0FiLFNBQUFhO0lBQWMsR0FDaEI7UUFBQVI7UUFBQUw7UUFBQTVDO0tBQUE7SUFJRixNQUFBMkQsZ0JBQUF6RCxrREFBQUEsQ0FBc0IsQ0FBQVM7UUFFbEIsSUFBQUEsTUFBQTZDLGtCQUFBO1lBQ0U7UUFBQTtRQUdGLElBQUFJLHdEQUFBQSxDQUFBakQsT0FBQTtZQUNFRixjQUFBLFFBQUFFO1FBQTJCLFdBQUFpRCx3REFBQUEsQ0FBQWpELE9BQUE7WUFFM0JGLGNBQUEsU0FBQUU7UUFBNEIsV0FBQWlELHdEQUFBQSxDQUFBakQsT0FBQTtZQUU1QkYsY0FBQSxNQUFBRTtRQUF5QixXQUFBaUQsd0RBQUFBLENBQUFqRCxPQUFBO1lBRXpCRixjQUFBLFFBQUFFO1FBQTJCLFdBQUFpRCx3REFBQUEsQ0FBQWpELE9BQUE7WUFFM0IsSUFBQVosZ0JBQUE7Z0JBQ0VZLE1BQUFDLGNBQUE7Z0JBQ0FYO1lBQW1CO1FBQ3JCO0lBQ0YsR0FDRjtRQUFBRjtRQUFBVTtRQUFBUjtLQUFBO0lBSUYrQixnREFBU0EsQ0FBVDtRQUNFWSxTQUFBakIsUUFBQWtDLE9BQUFsQyxTQUFBcUIsZUFBQWEsT0FBQWIsZ0JBQUE7SUFFQTtJQUdGLHFDQUFBVCxnREFBQSxDQUFBYSxXQUFBO1FBQ0dVLE1BQUE7UUFDTW5DO1FBQ0xxQjtRQUNBQyxVQUFBTTtRQUNVUSxXQUFBSjtRQUNDLEdBQUFULEtBQUE7UUFDUGMsS0FBQWI7SUFDQztBQUNQO0FBS04sTUFBQWMsMkJBQUE7SUFBK0RDLGdCQUFBLEdBQUFDLFFBQUEsS0FBQWpCLE9BQUEsaUNBQUFYLGdEQUFBO1lBQ2hCLEdBQUFXLEtBQUE7UUFBUSxHQUFBaUI7SUFBaUJDLEtBQUEsR0FBQXBGLFFBQUEsRUFBQXFGLFVBQUEsS0FBQW5CLE9BQUEsaUNBQUFYLGdEQUFBO1lBRXhCLEdBQUFXLEtBQUE7UUFBUSxHQUFBbEU7SUFBaUJzRixPQUFBLEdBQUFuRSxLQUFBLEtBQUErQyxPQUFBLGlDQUFBWCxnREFBQTtZQUVwRSxHQUFBVyxLQUFBO1FBQVcsaUNBQUFYLGdEQUFBLENBQUErQixzREFBQUEsRUFBQTtZQUNUbkU7UUFBZTtJQUNsQm9FLFNBQUEsQ0FBQXJCLFFBQUEsOEJBQUFYLGdEQUFBO1lBRW1CLEdBQUFXLEtBQUE7UUFBUTtJQUFPc0IsT0FBQSxDQUFBdEIsUUFBQSw4QkFBQVgsZ0RBQUE7WUFDakIsR0FBQVcsS0FBQTtRQUFRO0lBQU91QixNQUFBLENBQUF2QixRQUFBLDhCQUFBWCxnREFBQTtZQUNoQixHQUFBVyxLQUFBO1FBQVE7SUFBT3dCLE9BQUEsR0FBQWpGLEtBQUEsS0FBQXlELE9BQUEsaUNBQUFYLGdEQUFBO1lBRUEsR0FBQVcsS0FBQTtRQUFRO0FBQzNDO0FBRUEsTUFBQXlCLDJCQUFBO0lBQXVFbkUsVUFBQTtJQUMzRG9FLGtCQUFBO0lBQ1FDLG1CQUFBO0FBRXBCO0FBS0EsTUFBQUMsaUNBQUFoQyxpREFBQUEsQ0FBeUIsR0FBQTlELFFBQUEsS0FBQWtFLE9BQUEsRUFBQUM7SUFFckIscUNBQUFaLGdEQUFBO1FBQ0csR0FBQVcsS0FBQTtRQUFRNkIsVUFBQTtRQUFpQjtRQUFpQmYsS0FBQWI7SUFBZ0IsR0FBQW5FO0FBRTNEO0FBS04sTUFBQWdHLGdDQUFBbEMsaURBQUFBLENBQXdCLEdBQUE5RCxRQUFBLEtBQUFrRSxPQUFBLEVBQUFDO0lBRXBCLHFDQUFBWixnREFBQTtRQUNHLEdBQUFXLEtBQUE7UUFBUTtRQUFvQmMsS0FBQWI7SUFBZ0IsR0FBQW5FO0FBRTdDO0FBNEJOLE1BQUFpRyxtQ0FBQW5DLGlEQUFBQSxDQUEyQixHQUFBb0MsVUFBQSxFQUFBbkMsT0FBQSxLQUFBRyxPQUFBLEVBQUFDO0lBRXZCLE1BQUFDLFlBQUFMLFVBQUFNLHNEQUFBQSxHQUFBO0lBQ0EsTUFBQThCLGNBQUFqRyw2Q0FBQUEsQ0FBQTtJQUNBLE1BQUFrRywwQkFBQWxHLDZDQUFBQSxDQUFBO0lBQ0EsTUFBQW1HLHdCQUFBbkcsNkNBQUFBLENBQUE7SUFDQSxNQUFBb0csMkJBQUFwRyw2Q0FBQUEsQ0FBQTtJQUNBLE1BQUFxRywwQkFBQXJHLDZDQUFBQSxDQUFBO0lBQ0EsUUFBTUksSUFBQSxFQUNKRyxLQUFBLEVBQ0FrRCxTQUFBLEVBQ0E5RCxPQUFBLEVBQ0FFLGFBQUEsRUFDQVksbUJBQUEsRUFDQUUsZ0JBQUEsRUFDQVMsbUJBQUEsRUFDQVAsV0FBQSxFQUNBQyxjQUFBLEVBQ0EsR0FBQXNELDZEQUFBQTtJQUVGLE1BQUFrQyxnQkFBQUMsOENBQUFBLENBQXNCLElBQUFuRyxNQUFBYyxJQUFBLENBQUFQLGlCQUFBLEdBQUFGLG9CQUFBLEVBQ2lCO1FBQUFMLE1BQUFjO1FBQUFUO1FBQUFFO0tBQUE7SUFHdkMsUUFBQTBFLE9BQUEsRUFBQUMsS0FBQSxFQUFBRSxLQUFBLEVBQUFSLGNBQUEsRUFBQU8sSUFBQSxFQUFBTCxHQUFBLEVBQUFFLEtBQUEsS0FBQW1CLDhDQUFBQSxDQUFvRTtZQUFBLEdBQUF4Qix3QkFBQTtZQUFBLEdBQUFpQixVQUFBO1FBQUEsSUFDZDtRQUFBQTtLQUFBO0lBR3RELE1BQUFRLGVBQUFELDhDQUFBQSxDQUFxQixrQkFBQTNDLGlEQUFBQSxDQUVqQixHQUFBOUQsUUFBQSxLQUFBMkcsUUFBQSxFQUFBQztZQUVJLHFDQUFBckQsZ0RBQUE7Z0JBQ0dzRCxNQUFBO2dCQUNNLGlCQUFBaEg7Z0JBQ1UsR0FBQThHLE1BQUE7Z0JBQ1g7Z0JBQ1MzQixLQUFBNEI7WUFDUixHQUFBNUc7UUFHUCxJQUdOO1FBQUFIO0tBQUE7SUFHSixNQUFBaUgscUJBQUFMLDhDQUFBQSxDQUEyQixJQUFBTSxNQUFBbEgsU0FBQW1ILElBQUEsbUJBQ2M7UUFBQW5IO0tBQUE7SUFJekMsTUFBQStCLGlCQUFBVixrREFBQUEsQ0FBQSxDQUFBUztRQUNFQSxNQUFBQyxjQUFBO0lBQXFCO0lBR3ZCLE1BQUFxRiwwQkFBQS9GLGtEQUFBQSxDQUFBO1FBQ0UsSUFBQUgsZ0JBQUE7WUFDRUMsZUFBQTtRQUFxQjtJQUN2QjtRQUFBRDtRQUFBQztLQUFBO0lBR0ZrRyw2RUFBZUEsQ0FBZjtRQUNFLEtBQUFkLHdCQUFBaEUsT0FBQTtZQUNFO1FBQUE7UUFHRixNQUFBK0UsTUFBQWYsd0JBQUFoRSxPQUFBLENBQUFnRixVQUFBO1FBQ0EsTUFBQUMsaUJBQUFqQix3QkFBQWhFLE9BQUEsQ0FBQWdGLFVBQUE7UUFFQSxJQUFBRCxlQUFBRyxhQUFBO1lBQ0UsTUFBQUMsUUFBQUMsT0FBQUMsZ0JBQUEsQ0FBQU47WUFFQWQsc0JBQUFqRSxPQUFBLEdBQUFzRixXQUFBSCxNQUFBSSxlQUFBO1lBQ0FyQix5QkFBQWxFLE9BQUEsR0FBQXNGLFdBQUFILE1BQUFLLGtCQUFBO1FBQXNFO1FBR3hFLElBQUFQLDBCQUFBQyxhQUFBO1lBQ0VmLHdCQUFBbkUsT0FBQSxHQUFBaUYsZUFBQVEsWUFBQTtRQUFpRDtJQUNuRDtJQUlGLE1BQUFDLHdCQUFBNUcsa0RBQUFBLENBQThCLEdBQzNCNkcsT0FBQSxFQUNDQyxVQUFBLEVBQ0FDLFdBQUEsRUFDQUMsY0FBQSxFQUNBQyxnQkFBQSxFQUFBQyxRQUFBLEVBQUFDLEtBQUEsS0FBQUMsUUFBQSxFQUM2QztRQUU3QyxJQUFBUCxVQUFBeEIsQ0FBQUEsd0JBQUFuRSxPQUFBLEdBQUFpRSxzQkFBQWpFLE9BQUEsSUFBQTZGLGFBQUE7WUFLRTtnQkFBTyxHQUFBSyxNQUFBO2dCQUNGRjtnQkFDSEMsT0FBQUEsU0FBQTtZQUNnQjtRQUNsQjtRQUdGLElBQUFMLGFBQUFFLGdCQUFBO1lBQ0U7Z0JBQU8sR0FBQUksTUFBQTtnQkFDRkY7Z0JBQ0hDLE9BQUFBLFNBQUE7Z0JBQ2dCRSxRQUFBakMseUJBQUFsRSxPQUFBO1lBQ2lCO1FBQ25DO1FBR0Y7SUFBTyxHQUNUO0lBSUZZLGdEQUFTQSxDQUFUO1FBQ0UsSUFBQWpDLGdCQUFBO1lBQ0VvRixZQUFBL0QsT0FBQSxFQUFBb0csZUFBQTtnQkFBb0NDLE9BQUE1SDtnQkFDM0J1SCxVQUFBO2dCQUNHTjtZQUNWO1FBQ0Q7SUFDSDtRQUFBL0c7UUFBQUY7UUFBQWlIO0tBQUE7SUFHRixxQ0FBQXZFLGdEQUFBLENBQUFhLFdBQUE7UUFDRyxHQUFBRixLQUFBO1FBQWNjLEtBQUFiO0lBQVksaUNBQUFaLGdEQUFBO1FBQ3hCZ0UsT0FBQTtZQUNRbUIsWUFBQTtZQUNPQyxRQUFBO1FBQ0o7UUFDVjNELEtBQUFvQjtJQUNLLGlDQUFBN0MsZ0RBQUEsQ0FBQTZCLEtBQUE7UUFLSkMsWUFBQU07SUFBZ0IsR0FBQW1CLG1CQUFBOEIsR0FBQSxFQUFBQyxhQUFBSixRQUFBLDhCQUFBbEYsZ0RBQUEsQ0FBQStCLE9BQUE7WUFFWm5FLE9BQUEwSDtZQUFhQyxLQUFBTDtRQUFrQixvQ0FBQWxGLGdEQUFBLENBQUEyQixnQkFBQTtRQUluQ0MsVUFBQTtJQUF3QixLQUFBeEIsWUFBQSw4QkFBQUosZ0RBQUEsQ0FBQWdDLFNBQUEsUUFBQTlFLFFBQUEsOEJBQUE4QyxnREFBQSxDQUFBbUMsT0FBQTtRQUt4QmpGO0lBQU0sS0FBQUgsS0FBQXlJLEtBQUEsdUNBQUF4RixnREFBQSxDQUFBaUMsT0FBQSxzQ0FBQWpDLGdEQUFBLENBQUFrQyxNQUFBLG9DQUFBbEMsZ0RBQUEsQ0FBQXlGLDJEQUFBQSxFQUFBO1FBS0poRSxLQUFBbUI7UUFDTUQsWUFBQTtZQUNPK0MsVUFBQW5EO1lBQ0FvRCxNQUFBeEM7WUFDSnlDLGFBQUFuRDtRQUNPO1FBQ2ZvRCxhQUFBOUksS0FBQStJLG1CQUFBO1FBQ2tCQyxjQUFBLENBQUFDO1lBRWhCLHFDQUFBaEcsZ0RBQUEsQ0FBQTJCLGdCQUFBO2dCQUNHQyxVQUFBN0UsS0FBQW1DLFVBQUEsQ0FBQThHLFdBQUE7WUFBeUM7UUFBYTtRQUUzREMsYUFBQSxDQUFBaEksVUFBQStIO1lBRUUsTUFBQTNELG1CQUFBdEYsS0FBQW1KLG9CQUFBLENBQUFGLFdBQUEsQ0FBQUcsT0FBQSxDQUFBbEk7WUFFQSxNQUFBcUUsb0JBQUF2RixLQUFBK0ksbUJBQUEsQ0FBQUUsV0FBQTtZQUVBLHFDQUFBaEcsZ0RBQUEsQ0FBQTZCLEtBQUE7Z0JBQ0dDLFlBQUE7b0JBQ2E3RDtvQkFDVm9FO29CQUNBQztnQkFDQTtZQUNGLEdBQUF2RixLQUFBYyxJQUFBLENBQUFJLFNBQUEsQ0FBQW9ILEdBQUEsRUFBQXpILE9BQUFJO2dCQUdFLE1BQUFvSSxhQUFBNUksZ0JBQUEsVUFBQUosd0JBQUFZLGVBQUFWLHFCQUFBVztnQkFLQSxxQ0FBQStCLGdEQUFBLENBQUErQixPQUFBO29CQUNHd0QsS0FBQTNILE1BQUFBLEtBQUE7b0JBQ1kwRixNQUFBO29CQUNOLGlCQUFBdEY7b0JBQ1UsaUJBQUFvSSxjQUFBO29CQUNjLGlCQUFBQSxjQUFBO29CQUNBQyxhQUFBaEk7b0JBQ2hCbUUsVUFBQTtvQkFDSDhELGdCQUFBO3dCQUVSdkksb0JBQUFDLGFBQUFDO29CQUF5QztvQkFDM0NzSSxnQkFBQTdDO29CQUNnQjhDLFNBQUEsQ0FBQXBJO3dCQUVkNUIsZ0JBQUFvQixNQUFBQSxLQUFBO3dCQUNBUSxNQUFBcUksZUFBQTtvQkFBc0I7b0JBQ3hCN0ksT0FBQUEsTUFBQUEsS0FBQTtnQkFDYTtZQUNmO1FBR047SUFFSixLQUFBcUYsaUJBQUF6RixnQkFBQSx3Q0FBQXdDLGdEQUFBO1FBS0g7UUFBY2dFLE9BQUEwQyx1RUFBQUE7SUFBZ0IsR0FBQXpELGNBQUEwRCxJQUFBO0FBSW5DO0FBS04sSUFBQUMsSUFBQTtJQUNFdkssZ0JBQUF3SyxXQUFBLEdBQUEzSztJQUNBd0csbUJBQUFtRSxXQUFBLEdBQUExSztJQUNBbUUsa0JBQUF1RyxXQUFBLEdBQUF6SztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4uLy4uLy4uL3NyYy9wcmltaXRpdmVzL0Vtb2ppUGlja2VyL2luZGV4LnRzeD80MTU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyBTbG90IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1zbG90XCI7XG5pbXBvcnQgdHlwZSB7IENoYW5nZUV2ZW50LCBLZXlib2FyZEV2ZW50LCBTeW50aGV0aWNFdmVudCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0LCB7XG4gIGZvcndhcmRSZWYsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHVzZVJlZixcbiAgdXNlU3RhdGUsXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBDYWxjdWxhdGVWaWV3TG9jYXRpb25QYXJhbXMsXG4gIEdyb3VwZWRWaXJ0dW9zb0hhbmRsZSxcbiAgTGlzdFByb3BzIGFzIFZpcnR1b3NvTGlzdFByb3BzLFxuICBTY3JvbGxlclByb3BzLFxuICBUb3BJdGVtTGlzdFByb3BzLFxufSBmcm9tIFwicmVhY3QtdmlydHVvc29cIjtcbmltcG9ydCB7IEdyb3VwZWRWaXJ0dW9zbyB9IGZyb20gXCJyZWFjdC12aXJ0dW9zb1wiO1xuXG5pbXBvcnQgeyBpc0tleSB9IGZyb20gXCIuLi8uLi91dGlscy9pcy1rZXlcIjtcbmltcG9ydCB7XG4gIGNhbmNlbElkbGVDYWxsYmFjayxcbiAgcmVxdWVzdElkbGVDYWxsYmFjayxcbn0gZnJvbSBcIi4uLy4uL3V0aWxzL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4uLy4uL3V0aWxzL3VzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3VzZS10cmFuc2l0aW9uXCI7XG5pbXBvcnQgeyB2aXN1YWxseUhpZGRlbiB9IGZyb20gXCIuLi8uLi91dGlscy92aXN1YWxseS1oaWRkZW5cIjtcbmltcG9ydCB7IEVtb2ppIGFzIEVtb2ppUHJpbWl0aXZlIH0gZnJvbSBcIi4uL2ludGVybmFsL0Vtb2ppXCI7XG5pbXBvcnQgeyBFbW9qaVBpY2tlckNvbnRleHQsIHVzZUVtb2ppUGlja2VyIH0gZnJvbSBcIi4vY29udGV4dHNcIjtcbmltcG9ydCB0eXBlIHtcbiAgRW1vamlEYXRhLFxuICBFbW9qaVBpY2tlckNvbnRlbnRDb21wb25lbnRzLFxuICBFbW9qaVBpY2tlckNvbnRlbnRFbW9qaVJvd0F0dHJpYnV0ZXMsXG4gIEVtb2ppUGlja2VyQ29udGVudFByb3BzLFxuICBFbW9qaVBpY2tlckRhdGEsXG4gIEVtb2ppUGlja2VyUm9vdFByb3BzLFxuICBFbW9qaVBpY2tlclNlYXJjaFByb3BzLFxuICBFbW9qaVBpY2tlclNlbGVjdGlvbkRpcmVjdGlvbixcbn0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGZpbHRlckVtb2ppcywgZ2VuZXJhdGVFbW9qaVBpY2tlckRhdGEsIGdldEVtb2ppRGF0YSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IERFRkFVTFRfQ09MVU1OUyA9IDEwO1xuY29uc3QgREVGQVVMVF9MT0NBTEUgPSBcImVuXCI7XG5jb25zdCBMT0FESU5HX01JTklNVU1fVElNRU9VVCA9IDEwMDtcblxuY29uc3QgRU1PSklQSUNLRVJfUk9PVF9OQU1FID0gXCJFbW9qaVBpY2tlclJvb3RcIjtcbmNvbnN0IEVNT0pJUElDS0VSX0NPTlRFTlRfTkFNRSA9IFwiRW1vamlQaWNrZXJDb250ZW50XCI7XG5jb25zdCBFTU9KSVBJQ0tFUl9TRUFSQ0hfTkFNRSA9IFwiRW1vamlQaWNrZXJTZWFyY2hcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVGhlIEVtb2ppUGlja2VyIHByaW1pdGl2ZSBpcyB1bmRvY3VtZW50ZWQgZm9yIG5vdyBhbmQgc3ViamVjdCB0byBjaGFuZ2UsXG4gKiB1c2UgYXQgeW91ciBvd24gcmlzay4gSWYgeW91IGhhdmUgYW55IGZlZWRiYWNrIG9uIGl0LCBwbGVhc2UgbGV0IHVzIGtub3chXG4gKiBTZWUgaG93IHdlIHVzZSBpdCBpbiB0aGUgZGVmYXVsdCBjb21wb25lbnRzIHRvIGxlYXJuIGhvdyB0byB1c2UgaXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL2Jsb2IvbWFpbi9wYWNrYWdlcy9saXZlYmxvY2tzLXJlYWN0LXVpL3NyYy9jb21wb25lbnRzL2ludGVybmFsL0Vtb2ppUGlja2VyLnRzeC5cbiAqXG4gKiBTdXJyb3VuZHMgdGhlIGVtb2ppIHBpY2tlciwgaXQgaGFuZGxlcyBlbW9qaSBkYXRhIGFuZCBjb29yZGluYXRlc1xuICogYEVtb2ppUGlja2VyLlNlYXJjaGAgYW5kIGBFbW9qaVBpY2tlci5Db250ZW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogPEVtb2ppUGlja2VyLlJvb3Q+XG4gKiAgIDxFbW9qaVBpY2tlci5TZWFyY2ggLz5cbiAqICAgPEVtb2ppUGlja2VyLkNvbnRlbnQgLz5cbiAqIDwvRW1vamlQaWNrZXIuUm9vdD5cbiAqL1xuZnVuY3Rpb24gRW1vamlQaWNrZXJSb290KHtcbiAgY29sdW1ucyA9IERFRkFVTFRfQ09MVU1OUyxcbiAgbG9jYWxlID0gREVGQVVMVF9MT0NBTEUsXG4gIG9uRW1vamlTZWxlY3QsXG4gIGNoaWxkcmVuLFxufTogRW1vamlQaWNrZXJSb290UHJvcHMpIHtcbiAgY29uc3QgZW1vamlEYXRhID0gdXNlUmVmPEVtb2ppRGF0YT4oKTtcbiAgY29uc3Qgc2VhcmNoID0gdXNlUmVmKFwiXCIpO1xuICBjb25zdCBbLCBzdGFydEVtb2ppc1RyYW5zaXRpb25dID0gdXNlVHJhbnNpdGlvbigpO1xuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSB1c2VTdGF0ZTxFbW9qaVBpY2tlckRhdGE+KCk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8RXJyb3I+KCk7XG4gIGNvbnN0IFtzZWxlY3RlZENvbHVtbkluZGV4LCBzZXRTZWxlY3RlZENvbHVtbkluZGV4XSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbc2VsZWN0ZWRSb3dJbmRleCwgc2V0U2VsZWN0ZWRSb3dJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2ludGVyYWN0aW9uLCBzZXRJbnRlcmFjdGlvbl0gPSB1c2VTdGF0ZTxcbiAgICBcImtleWJvYXJkXCIgfCBcInBvaW50ZXJcIiB8IFwibm9uZVwiXG4gID4oXCJub25lXCIpO1xuXG4gIGNvbnN0IHNlbGVjdEN1cnJlbnRFbW9qaSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAob25FbW9qaVNlbGVjdCkge1xuICAgICAgY29uc3QgZW1vamkgPSBkYXRhPy5yb3dzW3NlbGVjdGVkUm93SW5kZXhdPy5bc2VsZWN0ZWRDb2x1bW5JbmRleF07XG5cbiAgICAgIGlmIChlbW9qaSkge1xuICAgICAgICBvbkVtb2ppU2VsZWN0KGVtb2ppLmVtb2ppKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtkYXRhPy5yb3dzLCBvbkVtb2ppU2VsZWN0LCBzZWxlY3RlZENvbHVtbkluZGV4LCBzZWxlY3RlZFJvd0luZGV4XSk7XG5cbiAgY29uc3QgcmVzZXRTZWxlY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U2VsZWN0ZWRDb2x1bW5JbmRleCgwKTtcbiAgICBzZXRTZWxlY3RlZFJvd0luZGV4KDApO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2V0UG9pbnRlclNlbGVjdGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIChjb2x1bW5JbmRleDogbnVtYmVyLCByb3dJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBzZXRJbnRlcmFjdGlvbihcInBvaW50ZXJcIik7XG4gICAgICBzZXRTZWxlY3RlZENvbHVtbkluZGV4KGNvbHVtbkluZGV4KTtcbiAgICAgIHNldFNlbGVjdGVkUm93SW5kZXgocm93SW5kZXgpO1xuICAgIH0sXG4gICAgW11cbiAgKTtcblxuICBjb25zdCBtb3ZlU2VsZWN0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgKFxuICAgICAgZGlyZWN0aW9uOiBFbW9qaVBpY2tlclNlbGVjdGlvbkRpcmVjdGlvbixcbiAgICAgIGV2ZW50OiBLZXlib2FyZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgKSA9PiB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoaW50ZXJhY3Rpb24gPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHNldEludGVyYWN0aW9uKFwia2V5Ym9hcmRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0SW50ZXJhY3Rpb24oXCJrZXlib2FyZFwiKTtcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgLy8gSWYgZmlyc3QgY29sdW1uLCBtb3ZlIHRvIGxhc3QgY29sdW1uIG9mIHByZXZpb3VzIHJvdyAoaWYgYXZhaWxhYmxlKVxuICAgICAgICAvLyBPdGhlcndpc2UsIG1vdmUgdG8gcHJldmlvdXMgY29sdW1uXG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6IHtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRDb2x1bW5JbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNSb3dJbmRleCA9IHNlbGVjdGVkUm93SW5kZXggLSAxO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNSb3cgPSBkYXRhLnJvd3NbcHJldmlvdXNSb3dJbmRleF07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1Jvdykge1xuICAgICAgICAgICAgICBzZXRTZWxlY3RlZFJvd0luZGV4KHByZXZpb3VzUm93SW5kZXgpO1xuICAgICAgICAgICAgICBzZXRTZWxlY3RlZENvbHVtbkluZGV4KHByZXZpb3VzUm93Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZENvbHVtbkluZGV4KHNlbGVjdGVkQ29sdW1uSW5kZXggLSAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGxhc3QgY29sdW1uLCBtb3ZlIHRvIGZpcnN0IGNvbHVtbiBvZiBuZXh0IHJvdyAoaWYgYXZhaWxhYmxlKVxuICAgICAgICAvLyBPdGhlcndpc2UsIG1vdmUgdG8gbmV4dCBjb2x1bW5cbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Um93ID0gZGF0YS5yb3dzW3NlbGVjdGVkUm93SW5kZXhdO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGVkQ29sdW1uSW5kZXggPT09IGN1cnJlbnRSb3cubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFJvd0luZGV4ID0gc2VsZWN0ZWRSb3dJbmRleCArIDE7XG4gICAgICAgICAgICBjb25zdCBuZXh0Um93ID0gZGF0YS5yb3dzW25leHRSb3dJbmRleF07XG5cbiAgICAgICAgICAgIGlmIChuZXh0Um93KSB7XG4gICAgICAgICAgICAgIHNldFNlbGVjdGVkUm93SW5kZXgobmV4dFJvd0luZGV4KTtcbiAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5JbmRleCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5JbmRleChzZWxlY3RlZENvbHVtbkluZGV4ICsgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlIHRvIHNhbWUgY29sdW1uIG9mIHByZXZpb3VzIHJvd1xuICAgICAgICAvLyBJZiBzYW1lIGNvbHVtbiBpcyBub3QgYXZhaWxhYmxlLCBtb3ZlIHRvIGxhc3QgY29sdW1uIG9mIHByZXZpb3VzIHJvd1xuICAgICAgICBjYXNlIFwidXBcIjoge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzUm93ID0gZGF0YS5yb3dzW3NlbGVjdGVkUm93SW5kZXggLSAxXTtcblxuICAgICAgICAgIGlmIChwcmV2aW91c1Jvdykge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRSb3dJbmRleChzZWxlY3RlZFJvd0luZGV4IC0gMSk7XG5cbiAgICAgICAgICAgIGlmICghcHJldmlvdXNSb3dbc2VsZWN0ZWRDb2x1bW5JbmRleF0pIHtcbiAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5JbmRleChwcmV2aW91c1Jvdy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmUgdG8gc2FtZSBjb2x1bW4gb2YgbmV4dCByb3dcbiAgICAgICAgLy8gSWYgc2FtZSBjb2x1bW4gaXMgbm90IGF2YWlsYWJsZSwgbW92ZSB0byBsYXN0IGNvbHVtbiBvZiBuZXh0IHJvd1xuICAgICAgICBjYXNlIFwiZG93blwiOiB7XG4gICAgICAgICAgY29uc3QgbmV4dFJvdyA9IGRhdGEucm93c1tzZWxlY3RlZFJvd0luZGV4ICsgMV07XG5cbiAgICAgICAgICBpZiAobmV4dFJvdykge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRSb3dJbmRleChzZWxlY3RlZFJvd0luZGV4ICsgMSk7XG5cbiAgICAgICAgICAgIGlmICghbmV4dFJvd1tzZWxlY3RlZENvbHVtbkluZGV4XSkge1xuICAgICAgICAgICAgICBzZXRTZWxlY3RlZENvbHVtbkluZGV4KG5leHRSb3cubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtkYXRhLCBpbnRlcmFjdGlvbiwgc2VsZWN0ZWRDb2x1bW5JbmRleCwgc2VsZWN0ZWRSb3dJbmRleF1cbiAgKTtcblxuICBjb25zdCB1cGRhdGVFbW9qaXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFlbW9qaURhdGEuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXJ0RW1vamlzVHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBzZXREYXRhKCgpID0+IHtcbiAgICAgICAgaWYgKCFlbW9qaURhdGEuY3VycmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRW1vamlzID0gZmlsdGVyRW1vamlzKFxuICAgICAgICAgIGVtb2ppRGF0YS5jdXJyZW50LmVtb2ppcyxcbiAgICAgICAgICBzZWFyY2guY3VycmVudFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUVtb2ppUGlja2VyRGF0YShcbiAgICAgICAgICBmaWx0ZXJlZEVtb2ppcyxcbiAgICAgICAgICBlbW9qaURhdGEuY3VycmVudC5jYXRlZ29yaWVzLFxuICAgICAgICAgIGNvbHVtbnNcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmVzZXRTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfSwgW2NvbHVtbnMsIHJlc2V0U2VsZWN0aW9uXSk7XG5cbiAgY29uc3QgaGFuZGxlU2VhcmNoID0gdXNlQ2FsbGJhY2soXG4gICAgKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgIHNlYXJjaC5jdXJyZW50ID0gdmFsdWU7XG4gICAgICB1cGRhdGVFbW9qaXMoKTtcbiAgICB9LFxuICAgIFt1cGRhdGVFbW9qaXNdXG4gICk7XG5cbiAgY29uc3QgaW5pdGlhbGl6ZUVtb2ppRGF0YSA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChsb2NhbGU6IHN0cmluZykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZW1vamlEYXRhLmN1cnJlbnQgPSBhd2FpdCBnZXRFbW9qaURhdGEobG9jYWxlKTtcbiAgICAgICAgdXBkYXRlRW1vamlzKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZXRFcnJvcihlcnJvciBhcyBFcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBbdXBkYXRlRW1vamlzXVxuICApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlkbGVDYWxsYmFja0lkOiBudW1iZXI7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZGxlQ2FsbGJhY2tJZCA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpbml0aWFsaXplRW1vamlEYXRhKGxvY2FsZSk7XG4gICAgICB9KTtcbiAgICB9LCBMT0FESU5HX01JTklNVU1fVElNRU9VVCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBjYW5jZWxJZGxlQ2FsbGJhY2soaWRsZUNhbGxiYWNrSWQpO1xuICAgIH07XG4gIH0sIFtsb2NhbGVdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnRlcmFjdGlvbiA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LCBbaW50ZXJhY3Rpb25dKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblxuICByZXR1cm4gKFxuICAgIDxFbW9qaVBpY2tlckNvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIGRhdGE6IGRhdGEgYXMgRW1vamlQaWNrZXJEYXRhLFxuICAgICAgICBlcnJvcjogZXJyb3IgYXMgdW5kZWZpbmVkLFxuICAgICAgICBpc0xvYWRpbmc6ICghZGF0YSAmJiAhZXJyb3IpIGFzIGZhbHNlLFxuICAgICAgICBjb2x1bW5zLFxuICAgICAgICBvblNlYXJjaDogaGFuZGxlU2VhcmNoLFxuICAgICAgICBvbkVtb2ppU2VsZWN0LFxuICAgICAgICBzZWxlY3RDdXJyZW50RW1vamksXG4gICAgICAgIHNlbGVjdGVkUm93SW5kZXgsXG4gICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXgsXG4gICAgICAgIG1vdmVTZWxlY3Rpb24sXG4gICAgICAgIHNldFBvaW50ZXJTZWxlY3Rpb24sXG4gICAgICAgIGludGVyYWN0aW9uLFxuICAgICAgICBzZXRJbnRlcmFjdGlvbixcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvRW1vamlQaWNrZXJDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGUgRW1vamlQaWNrZXIgcHJpbWl0aXZlIGlzIHVuZG9jdW1lbnRlZCBmb3Igbm93IGFuZCBzdWJqZWN0IHRvIGNoYW5nZSxcbiAqIHVzZSBhdCB5b3VyIG93biByaXNrLiBJZiB5b3UgaGF2ZSBhbnkgZmVlZGJhY2sgb24gaXQsIHBsZWFzZSBsZXQgdXMga25vdyFcbiAqIFNlZSBob3cgd2UgdXNlIGl0IGluIHRoZSBkZWZhdWx0IGNvbXBvbmVudHMgdG8gbGVhcm4gaG93IHRvIHVzZSBpdDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZlYmxvY2tzL2xpdmVibG9ja3MvYmxvYi9tYWluL3BhY2thZ2VzL2xpdmVibG9ja3MtcmVhY3QtdWkvc3JjL2NvbXBvbmVudHMvaW50ZXJuYWwvRW1vamlQaWNrZXIudHN4LlxuICpcbiAqIFRoZSBzZWFyY2ggaW5wdXQgb2YgdGhlIGVtb2ppIHBpY2tlci4gSXQgYWxzbyBhZmZlY3RzIHRoZSBmb2N1cyBhbmQgc2VsZWN0aW9uXG4gKiB3aXRoaW4gYEVtb2ppUGlja2VyLkNvbnRlbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiA8RW1vamlQaWNrZXIuU2VhcmNoIC8+XG4gKi9cbmNvbnN0IEVtb2ppUGlja2VyU2VhcmNoID0gZm9yd2FyZFJlZjxIVE1MSW5wdXRFbGVtZW50LCBFbW9qaVBpY2tlclNlYXJjaFByb3BzPihcbiAgKHsgYXNDaGlsZCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSwgb25DaGFuZ2UsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJpbnB1dFwiO1xuICAgIGNvbnN0IHtcbiAgICAgIG9uU2VhcmNoLFxuICAgICAgc2VsZWN0Q3VycmVudEVtb2ppLFxuICAgICAgbW92ZVNlbGVjdGlvbixcbiAgICAgIGludGVyYWN0aW9uLFxuICAgICAgc2V0SW50ZXJhY3Rpb24sXG4gICAgfSA9IHVzZUVtb2ppUGlja2VyKCk7XG5cbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAgIChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICAgICAgb25DaGFuZ2U/LihldmVudCk7XG5cbiAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHNldEludGVyYWN0aW9uKHZhbHVlID8gXCJrZXlib2FyZFwiIDogXCJub25lXCIpO1xuICAgICAgICBvblNlYXJjaCh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgW29uQ2hhbmdlLCBvblNlYXJjaCwgc2V0SW50ZXJhY3Rpb25dXG4gICAgKTtcblxuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhcbiAgICAgIChldmVudDogS2V5Ym9hcmRFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNLZXkoZXZlbnQsIFwiQXJyb3dMZWZ0XCIpKSB7XG4gICAgICAgICAgbW92ZVNlbGVjdGlvbihcImxlZnRcIiwgZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzS2V5KGV2ZW50LCBcIkFycm93UmlnaHRcIikpIHtcbiAgICAgICAgICBtb3ZlU2VsZWN0aW9uKFwicmlnaHRcIiwgZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzS2V5KGV2ZW50LCBcIkFycm93VXBcIikpIHtcbiAgICAgICAgICBtb3ZlU2VsZWN0aW9uKFwidXBcIiwgZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzS2V5KGV2ZW50LCBcIkFycm93RG93blwiKSkge1xuICAgICAgICAgIG1vdmVTZWxlY3Rpb24oXCJkb3duXCIsIGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0tleShldmVudCwgXCJFbnRlclwiKSkge1xuICAgICAgICAgIGlmIChpbnRlcmFjdGlvbiAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZWxlY3RDdXJyZW50RW1vamkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbaW50ZXJhY3Rpb24sIG1vdmVTZWxlY3Rpb24sIHNlbGVjdEN1cnJlbnRFbW9qaV1cbiAgICApO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIG9uU2VhcmNoKFxuICAgICAgICB2YWx1ZSA/IFN0cmluZyh2YWx1ZSkgOiBkZWZhdWx0VmFsdWUgPyBTdHJpbmcoZGVmYXVsdFZhbHVlKSA6IFwiXCJcbiAgICAgICk7XG4gICAgfSwgW10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb21wb25lbnRcbiAgICAgICAgdHlwZT1cInNlYXJjaFwiXG4gICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgZGVmYXVsdFZhbHVlPXtkZWZhdWx0VmFsdWV9XG4gICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XG4gICAgICAgIG9uS2V5RG93bj17aGFuZGxlS2V5RG93bn1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuY29uc3QgZGVmYXVsdENvbnRlbnRDb21wb25lbnRzOiBFbW9qaVBpY2tlckNvbnRlbnRDb21wb25lbnRzID0ge1xuICBDYXRlZ29yeUhlYWRlcjogKHsgY2F0ZWdvcnksIC4uLnByb3BzIH0pID0+IDxkaXYgey4uLnByb3BzfT57Y2F0ZWdvcnl9PC9kaXY+LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIFJvdzogKHsgY2hpbGRyZW4sIGF0dHJpYnV0ZXMsIC4uLnByb3BzIH0pID0+IDxkaXYgey4uLnByb3BzfT57Y2hpbGRyZW59PC9kaXY+LFxuICBFbW9qaTogKHsgZW1vamksIC4uLnByb3BzIH0pID0+IChcbiAgICA8YnV0dG9uIHsuLi5wcm9wc30+XG4gICAgICA8RW1vamlQcmltaXRpdmUgZW1vamk9e2Vtb2ppfSAvPlxuICAgIDwvYnV0dG9uPlxuICApLFxuICBMb2FkaW5nOiAocHJvcHMpID0+IDxkaXYgey4uLnByb3BzfSAvPixcbiAgRW1wdHk6IChwcm9wcykgPT4gPGRpdiB7Li4ucHJvcHN9IC8+LFxuICBHcmlkOiAocHJvcHMpID0+IDxkaXYgey4uLnByb3BzfSAvPixcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBFcnJvcjogKHsgZXJyb3IsIC4uLnByb3BzIH0pID0+IDxkaXYgey4uLnByb3BzfSAvPixcbn07XG5cbmNvbnN0IHBsYWNlaG9sZGVyUm93QXR0cmlidXRlczogRW1vamlQaWNrZXJDb250ZW50RW1vamlSb3dBdHRyaWJ1dGVzID0ge1xuICByb3dJbmRleDogLTEsXG4gIGNhdGVnb3J5Um93SW5kZXg6IC0xLFxuICBjYXRlZ29yeVJvd3NDb3VudDogMCxcbn07XG5cbi8vIEFib3V0IGBkYXRhLXRlc3RpZD17dW5kZWZpbmVkfWA6IFZpcnR1b3NvIGJha2VzIHRlc3QgSURzIGludG8gdGhlIGNvbXBvbmVudHMgd2UgcGFzc1xuLy8gdG8gaXQsIHNvIHdlIG1hbnVhbGx5IHJlbW92ZSB0aGVtLlxuXG5jb25zdCBWaXJ0dW9zb1Njcm9sbGVyID0gZm9yd2FyZFJlZjxIVE1MRGl2RWxlbWVudCwgU2Nyb2xsZXJQcm9wcz4oXG4gICh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiB7Li4ucHJvcHN9IHRhYkluZGV4PXstMX0gZGF0YS10ZXN0aWQ9e3VuZGVmaW5lZH0gcmVmPXtmb3J3YXJkZWRSZWZ9PlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4pO1xuXG5jb25zdCBWaXJ0dW9zb1RvcExpc3QgPSBmb3J3YXJkUmVmPEhUTUxEaXZFbGVtZW50LCBUb3BJdGVtTGlzdFByb3BzPihcbiAgKHsgY2hpbGRyZW4sIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHsuLi5wcm9wc30gZGF0YS10ZXN0aWQ9e3VuZGVmaW5lZH0gcmVmPXtmb3J3YXJkZWRSZWZ9PlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4pO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGUgRW1vamlQaWNrZXIgcHJpbWl0aXZlIGlzIHVuZG9jdW1lbnRlZCBmb3Igbm93IGFuZCBzdWJqZWN0IHRvIGNoYW5nZSxcbiAqIHVzZSBhdCB5b3VyIG93biByaXNrLiBJZiB5b3UgaGF2ZSBhbnkgZmVlZGJhY2sgb24gaXQsIHBsZWFzZSBsZXQgdXMga25vdyFcbiAqIFNlZSBob3cgd2UgdXNlIGl0IGluIHRoZSBkZWZhdWx0IGNvbXBvbmVudHMgdG8gbGVhcm4gaG93IHRvIHVzZSBpdDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZlYmxvY2tzL2xpdmVibG9ja3MvYmxvYi9tYWluL3BhY2thZ2VzL2xpdmVibG9ja3MtcmVhY3QtdWkvc3JjL2NvbXBvbmVudHMvaW50ZXJuYWwvRW1vamlQaWNrZXIudHN4LlxuICpcbiAqIFRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIGVtb2ppIHBpY2tlciwgZWl0aGVyIGRpc3BsYXlpbmcgdGhlIGVtb2ppIGdyaWQgb3IgdmFyaW91c1xuICogYWx0ZXJuYXRpdmUgc3RhdGVzIChsb2FkaW5nLCBlbXB0eSwgYW5kIGVycm9yKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogPEVtb2ppUGlja2VyLkNvbnRlbnRcbiAqICBjb21wb25lbnRzPXt7XG4gKiAgICBMb2FkaW5nOiBFbW9qaVBpY2tlckxvYWRpbmcsXG4gKiAgICBFbXB0eTogRW1vamlQaWNrZXJFbXB0eSxcbiAqICAgIEVycm9yOiBFbW9qaVBpY2tlckVycm9yLFxuICogICAgQ2F0ZWdvcnlIZWFkZXI6IEVtb2ppUGlja2VyQ2F0ZWdvcnlIZWFkZXIsXG4gKiAgICBHcmlkOiBFbW9qaVBpY2tlckdyaWQsXG4gKiAgICBSb3c6IEVtb2ppUGlja2VyUm93LFxuICogICAgRW1vamk6IEVtb2ppUGlja2VyRW1vamksXG4gKiAgfX1cbiAqIC8+XG4gKi9cbmNvbnN0IEVtb2ppUGlja2VyQ29udGVudCA9IGZvcndhcmRSZWY8SFRNTERpdkVsZW1lbnQsIEVtb2ppUGlja2VyQ29udGVudFByb3BzPihcbiAgKHsgY29tcG9uZW50cywgYXNDaGlsZCwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gYXNDaGlsZCA/IFNsb3QgOiBcImRpdlwiO1xuICAgIGNvbnN0IHZpcnR1b3NvUmVmID0gdXNlUmVmPEdyb3VwZWRWaXJ0dW9zb0hhbmRsZT4obnVsbCk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICAgIGNvbnN0IHJvd1Njcm9sbE1hcmdpblRvcFJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xuICAgIGNvbnN0IHJvd1Njcm9sbE1hcmdpbkJvdHRvbVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xuICAgIGNvbnN0IGNhdGVnb3J5SGVhZGVySGVpZ2h0UmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGVycm9yLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgY29sdW1ucyxcbiAgICAgIG9uRW1vamlTZWxlY3QsXG4gICAgICBzZWxlY3RlZENvbHVtbkluZGV4LFxuICAgICAgc2VsZWN0ZWRSb3dJbmRleCxcbiAgICAgIHNldFBvaW50ZXJTZWxlY3Rpb24sXG4gICAgICBpbnRlcmFjdGlvbixcbiAgICAgIHNldEludGVyYWN0aW9uLFxuICAgIH0gPSB1c2VFbW9qaVBpY2tlcigpO1xuICAgIGNvbnN0IHNlbGVjdGVkRW1vamkgPSB1c2VNZW1vKFxuICAgICAgKCkgPT4gZGF0YT8ucm93c1tzZWxlY3RlZFJvd0luZGV4XT8uW3NlbGVjdGVkQ29sdW1uSW5kZXhdLFxuICAgICAgW2RhdGE/LnJvd3MsIHNlbGVjdGVkQ29sdW1uSW5kZXgsIHNlbGVjdGVkUm93SW5kZXhdXG4gICAgKTtcbiAgICBjb25zdCB7IExvYWRpbmcsIEVtcHR5LCBFcnJvciwgQ2F0ZWdvcnlIZWFkZXIsIEdyaWQsIFJvdywgRW1vamkgfSA9IHVzZU1lbW8oXG4gICAgICAoKSA9PiAoeyAuLi5kZWZhdWx0Q29udGVudENvbXBvbmVudHMsIC4uLmNvbXBvbmVudHMgfSksXG4gICAgICBbY29tcG9uZW50c11cbiAgICApO1xuICAgIGNvbnN0IFZpcnR1b3NvTGlzdCA9IHVzZU1lbW8oXG4gICAgICAoKSA9PlxuICAgICAgICBmb3J3YXJkUmVmPEhUTUxEaXZFbGVtZW50LCBWaXJ0dW9zb0xpc3RQcm9wcz4oXG4gICAgICAgICAgKHsgY2hpbGRyZW4sIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIHJvbGU9XCJncmlkXCJcbiAgICAgICAgICAgICAgICBhcmlhLWNvbGNvdW50PXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgW2NvbHVtbnNdXG4gICAgKTtcbiAgICBjb25zdCBwbGFjZWhvbGRlckNvbHVtbnMgPSB1c2VNZW1vKFxuICAgICAgKCkgPT4gQXJyYXk8c3RyaW5nPihjb2x1bW5zKS5maWxsKFwi8J+Mq++4j1wiKSxcbiAgICAgIFtjb2x1bW5zXVxuICAgICk7XG5cbiAgICBjb25zdCBwcmV2ZW50RGVmYXVsdCA9IHVzZUNhbGxiYWNrKChldmVudDogU3ludGhldGljRXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgaGFuZGxlRW1vamlQb2ludGVyTGVhdmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBpZiAoaW50ZXJhY3Rpb24gPT09IFwicG9pbnRlclwiKSB7XG4gICAgICAgIHNldEludGVyYWN0aW9uKFwibm9uZVwiKTtcbiAgICAgIH1cbiAgICB9LCBbaW50ZXJhY3Rpb24sIHNldEludGVyYWN0aW9uXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKCFwbGFjZWhvbGRlckNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm93ID0gcGxhY2Vob2xkZXJDb250YWluZXJSZWYuY3VycmVudC5jaGlsZE5vZGVzWzBdO1xuICAgICAgY29uc3QgY2F0ZWdvcnlIZWFkZXIgPSBwbGFjZWhvbGRlckNvbnRhaW5lclJlZi5jdXJyZW50LmNoaWxkTm9kZXNbMV07XG5cbiAgICAgIGlmIChyb3cgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJvdyk7XG5cbiAgICAgICAgcm93U2Nyb2xsTWFyZ2luVG9wUmVmLmN1cnJlbnQgPSBwYXJzZUZsb2F0KHN0eWxlLnNjcm9sbE1hcmdpblRvcCk7XG4gICAgICAgIHJvd1Njcm9sbE1hcmdpbkJvdHRvbVJlZi5jdXJyZW50ID0gcGFyc2VGbG9hdChzdHlsZS5zY3JvbGxNYXJnaW5Cb3R0b20pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2F0ZWdvcnlIZWFkZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICBjYXRlZ29yeUhlYWRlckhlaWdodFJlZi5jdXJyZW50ID0gY2F0ZWdvcnlIZWFkZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIEN1c3RvbWl6ZSBgc2Nyb2xsSW50b1ZpZXdgIGJlaGF2aW9yIHRvIHRha2UgaW50byBhY2NvdW50IGNhdGVnb3J5IGhlYWRlcnMgYW5kIG1hcmdpbnNcbiAgICBjb25zdCBjYWxjdWxhdGVWaWV3TG9jYXRpb24gPSB1c2VDYWxsYmFjayhcbiAgICAgICh7XG4gICAgICAgIGl0ZW1Ub3AsXG4gICAgICAgIGl0ZW1Cb3R0b20sXG4gICAgICAgIHZpZXdwb3J0VG9wLFxuICAgICAgICB2aWV3cG9ydEJvdHRvbSxcbiAgICAgICAgbG9jYXRpb25QYXJhbXM6IHsgYmVoYXZpb3IsIGFsaWduLCAuLi5wYXJhbXMgfSxcbiAgICAgIH06IENhbGN1bGF0ZVZpZXdMb2NhdGlvblBhcmFtcykgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXRlbVRvcCAtXG4gICAgICAgICAgICAoY2F0ZWdvcnlIZWFkZXJIZWlnaHRSZWYuY3VycmVudCArIHJvd1Njcm9sbE1hcmdpblRvcFJlZi5jdXJyZW50KSA8XG4gICAgICAgICAgdmlld3BvcnRUb3BcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIGJlaGF2aW9yLFxuICAgICAgICAgICAgYWxpZ246IGFsaWduID8/IFwic3RhcnRcIixcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1Cb3R0b20gPiB2aWV3cG9ydEJvdHRvbSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBiZWhhdmlvcixcbiAgICAgICAgICAgIGFsaWduOiBhbGlnbiA/PyBcImVuZFwiLFxuICAgICAgICAgICAgb2Zmc2V0OiByb3dTY3JvbGxNYXJnaW5Cb3R0b21SZWYuY3VycmVudCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgW11cbiAgICApO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpbnRlcmFjdGlvbiA9PT0gXCJrZXlib2FyZFwiKSB7XG4gICAgICAgIHZpcnR1b3NvUmVmLmN1cnJlbnQ/LnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICBpbmRleDogc2VsZWN0ZWRSb3dJbmRleCxcbiAgICAgICAgICBiZWhhdmlvcjogXCJhdXRvXCIsXG4gICAgICAgICAgY2FsY3VsYXRlVmlld0xvY2F0aW9uLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbaW50ZXJhY3Rpb24sIHNlbGVjdGVkUm93SW5kZXgsIGNhbGN1bGF0ZVZpZXdMb2NhdGlvbl0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb21wb25lbnQgey4uLnByb3BzfSByZWY9e2ZvcndhcmRlZFJlZn0+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICB9fVxuICAgICAgICAgIHJlZj17cGxhY2Vob2xkZXJDb250YWluZXJSZWZ9XG4gICAgICAgID5cbiAgICAgICAgICB7LyogVmlydHVhbGl6ZWQgcm93cyBhcmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkIHNvIHRoZXkgd29uJ3QgbWFrZVxuICAgICAgICAgICAgdGhlIGNvbnRhaW5lciBhdXRvbWF0aWNhbGx5IHBpY2sgdXAgdGhlaXIgd2lkdGguIFRvIGFjaGlldmVcbiAgICAgICAgICAgIGFuIGF1dG9tYXRpYyB3aWR0aCwgd2UgYWRkIGEgcmVsYXRpdmUgKGJ1dCBoaWRkZW4pIGZ1bGwgcm93LiAqL31cbiAgICAgICAgICA8Um93IGF0dHJpYnV0ZXM9e3BsYWNlaG9sZGVyUm93QXR0cmlidXRlc30+XG4gICAgICAgICAgICB7cGxhY2Vob2xkZXJDb2x1bW5zLm1hcCgocGxhY2Vob2xkZXIsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgIDxFbW9qaSBlbW9qaT17cGxhY2Vob2xkZXJ9IGtleT17aW5kZXh9IC8+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L1Jvdz5cbiAgICAgICAgICB7LyogV2UgYWxzbyBhZGQgYSBoaWRkZW4gY2F0ZWdvcnkgaGVhZGVyIHRvIGdldCBpdHMgY29tcHV0ZWQgaGVpZ2h0LiAqL31cbiAgICAgICAgICA8Q2F0ZWdvcnlIZWFkZXIgY2F0ZWdvcnk9XCJDYXRlZ29yeVwiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7aXNMb2FkaW5nID8gKFxuICAgICAgICAgIDxMb2FkaW5nIC8+XG4gICAgICAgICkgOiBlcnJvciA/IChcbiAgICAgICAgICA8RXJyb3IgZXJyb3I9e2Vycm9yfSAvPlxuICAgICAgICApIDogZGF0YS5jb3VudCA9PT0gMCA/IChcbiAgICAgICAgICA8RW1wdHkgLz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8R3JpZD5cbiAgICAgICAgICAgIDxHcm91cGVkVmlydHVvc29cbiAgICAgICAgICAgICAgcmVmPXt2aXJ0dW9zb1JlZn1cbiAgICAgICAgICAgICAgY29tcG9uZW50cz17e1xuICAgICAgICAgICAgICAgIFNjcm9sbGVyOiBWaXJ0dW9zb1Njcm9sbGVyLFxuICAgICAgICAgICAgICAgIExpc3Q6IFZpcnR1b3NvTGlzdCxcbiAgICAgICAgICAgICAgICBUb3BJdGVtTGlzdDogVmlydHVvc29Ub3BMaXN0LFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBncm91cENvdW50cz17ZGF0YS5jYXRlZ29yaWVzUm93Q291bnRzfVxuICAgICAgICAgICAgICBncm91cENvbnRlbnQ9eyhncm91cEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIDxDYXRlZ29yeUhlYWRlciBjYXRlZ29yeT17ZGF0YS5jYXRlZ29yaWVzW2dyb3VwSW5kZXhdfSAvPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIGl0ZW1Db250ZW50PXsocm93SW5kZXgsIGdyb3VwSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeVJvd0luZGV4ID1cbiAgICAgICAgICAgICAgICAgIGRhdGEuY2F0ZWdvcmllc1Jvd0luZGljZXNbZ3JvdXBJbmRleF0uaW5kZXhPZihyb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnlSb3dzQ291bnQgPSBkYXRhLmNhdGVnb3JpZXNSb3dDb3VudHNbZ3JvdXBJbmRleF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgPFJvd1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzPXt7XG4gICAgICAgICAgICAgICAgICAgICAgcm93SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlSb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeVJvd3NDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge2RhdGEucm93c1tyb3dJbmRleF0ubWFwKChlbW9qaSwgY29sdW1uSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1NlbGVjdGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uICE9PSBcIm5vbmVcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRDb2x1bW5JbmRleCA9PT0gY29sdW1uSW5kZXggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXggPT09IHJvd0luZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxFbW9qaVxuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2Vtb2ppLmVtb2ppfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwiZ3JpZGNlbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWNvbGluZGV4PXtjb2x1bW5JbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD17aXNTZWxlY3RlZCB8fCB1bmRlZmluZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtc2VsZWN0ZWQ9e2lzU2VsZWN0ZWQgfHwgdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17cHJldmVudERlZmF1bHR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4PXstMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qb2ludGVyRW50ZXI9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQb2ludGVyU2VsZWN0aW9uKGNvbHVtbkluZGV4LCByb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uUG9pbnRlckxlYXZlPXtoYW5kbGVFbW9qaVBvaW50ZXJMZWF2ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbW9qaVNlbGVjdD8uKGVtb2ppLmVtb2ppKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW1vamk9e2Vtb2ppLmVtb2ppfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgIDwvUm93PlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvR3JpZD5cbiAgICAgICAgKX1cbiAgICAgICAge3NlbGVjdGVkRW1vamkgJiYgaW50ZXJhY3Rpb24gIT09IFwibm9uZVwiICYmIChcbiAgICAgICAgICA8ZGl2IGFyaWEtbGl2ZT1cInBvbGl0ZVwiIHN0eWxlPXt2aXN1YWxseUhpZGRlbn0+XG4gICAgICAgICAgICB7c2VsZWN0ZWRFbW9qaS5uYW1lfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9Db21wb25lbnQ+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBFbW9qaVBpY2tlclJvb3QuZGlzcGxheU5hbWUgPSBFTU9KSVBJQ0tFUl9ST09UX05BTUU7XG4gIEVtb2ppUGlja2VyQ29udGVudC5kaXNwbGF5TmFtZSA9IEVNT0pJUElDS0VSX0NPTlRFTlRfTkFNRTtcbiAgRW1vamlQaWNrZXJTZWFyY2guZGlzcGxheU5hbWUgPSBFTU9KSVBJQ0tFUl9TRUFSQ0hfTkFNRTtcbn1cblxuLy8gTk9URTogRXZlcnkgZXhwb3J0IGZyb20gdGhpcyBmaWxlIHdpbGwgYmUgYXZhaWxhYmxlIHB1YmxpY2x5IGFzIEVtb2ppUGlja2VyLipcbmV4cG9ydCB7XG4gIEVtb2ppUGlja2VyQ29udGVudCBhcyBDb250ZW50LFxuICBFbW9qaVBpY2tlclJvb3QgYXMgUm9vdCxcbiAgRW1vamlQaWNrZXJTZWFyY2ggYXMgU2VhcmNoLFxufTtcbiJdLCJuYW1lcyI6WyJERUZBVUxUX0NPTFVNTlMiLCJERUZBVUxUX0xPQ0FMRSIsIkxPQURJTkdfTUlOSU1VTV9USU1FT1VUIiwiRU1PSklQSUNLRVJfUk9PVF9OQU1FIiwiRU1PSklQSUNLRVJfQ09OVEVOVF9OQU1FIiwiRU1PSklQSUNLRVJfU0VBUkNIX05BTUUiLCJFbW9qaVBpY2tlclJvb3QiLCJjb2x1bW5zIiwibG9jYWxlIiwib25FbW9qaVNlbGVjdCIsImNoaWxkcmVuIiwiZW1vamlEYXRhIiwidXNlUmVmIiwic2VhcmNoIiwic3RhcnRFbW9qaXNUcmFuc2l0aW9uIiwidXNlVHJhbnNpdGlvbiIsImRhdGEiLCJzZXREYXRhIiwidXNlU3RhdGUiLCJlcnJvciIsInNldEVycm9yIiwic2VsZWN0ZWRDb2x1bW5JbmRleCIsInNldFNlbGVjdGVkQ29sdW1uSW5kZXgiLCJzZWxlY3RlZFJvd0luZGV4Iiwic2V0U2VsZWN0ZWRSb3dJbmRleCIsImludGVyYWN0aW9uIiwic2V0SW50ZXJhY3Rpb24iLCJzZWxlY3RDdXJyZW50RW1vamkiLCJ1c2VDYWxsYmFjayIsImVtb2ppIiwicm93cyIsInJlc2V0U2VsZWN0aW9uIiwic2V0UG9pbnRlclNlbGVjdGlvbiIsImNvbHVtbkluZGV4Iiwicm93SW5kZXgiLCJtb3ZlU2VsZWN0aW9uIiwiZGlyZWN0aW9uIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInByZXZpb3VzUm93SW5kZXgiLCJwcmV2aW91c1JvdyIsImxlbmd0aCIsImN1cnJlbnRSb3ciLCJuZXh0Um93SW5kZXgiLCJuZXh0Um93IiwidXBkYXRlRW1vamlzIiwiY3VycmVudCIsImZpbHRlcmVkRW1vamlzIiwiZmlsdGVyRW1vamlzIiwiZW1vamlzIiwiZ2VuZXJhdGVFbW9qaVBpY2tlckRhdGEiLCJjYXRlZ29yaWVzIiwiaGFuZGxlU2VhcmNoIiwidmFsdWUiLCJpbml0aWFsaXplRW1vamlEYXRhIiwibG9jYWxlMiIsImdldEVtb2ppRGF0YSIsImVycm9yMiIsInVzZUVmZmVjdCIsImlkbGVDYWxsYmFja0lkIiwidGltZW91dElkIiwic2V0VGltZW91dCIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjbGVhclRpbWVvdXQiLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJSZWFjdF9fZGVmYXVsdCIsImNyZWF0ZUVsZW1lbnQiLCJFbW9qaVBpY2tlckNvbnRleHQiLCJQcm92aWRlciIsImlzTG9hZGluZyIsIm9uU2VhcmNoIiwiRW1vamlQaWNrZXJTZWFyY2giLCJmb3J3YXJkUmVmIiwiYXNDaGlsZCIsImRlZmF1bHRWYWx1ZSIsIm9uQ2hhbmdlIiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJDb21wb25lbnQiLCJTbG90IiwidXNlRW1vamlQaWNrZXIiLCJoYW5kbGVDaGFuZ2UiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJ2YWx1ZTIiLCJ0YXJnZXQiLCJoYW5kbGVLZXlEb3duIiwiaXNLZXkiLCJTdHJpbmciLCJ0eXBlIiwib25LZXlEb3duIiwicmVmIiwiZGVmYXVsdENvbnRlbnRDb21wb25lbnRzIiwiQ2F0ZWdvcnlIZWFkZXIiLCJjYXRlZ29yeSIsIlJvdyIsImF0dHJpYnV0ZXMiLCJFbW9qaSIsIkxvYWRpbmciLCJFbXB0eSIsIkdyaWQiLCJFcnJvciIsInBsYWNlaG9sZGVyUm93QXR0cmlidXRlcyIsImNhdGVnb3J5Um93SW5kZXgiLCJjYXRlZ29yeVJvd3NDb3VudCIsIlZpcnR1b3NvU2Nyb2xsZXIiLCJ0YWJJbmRleCIsIlZpcnR1b3NvVG9wTGlzdCIsIkVtb2ppUGlja2VyQ29udGVudCIsImNvbXBvbmVudHMiLCJ2aXJ0dW9zb1JlZiIsInBsYWNlaG9sZGVyQ29udGFpbmVyUmVmIiwicm93U2Nyb2xsTWFyZ2luVG9wUmVmIiwicm93U2Nyb2xsTWFyZ2luQm90dG9tUmVmIiwiY2F0ZWdvcnlIZWFkZXJIZWlnaHRSZWYiLCJzZWxlY3RlZEVtb2ppIiwidXNlTWVtbyIsIlZpcnR1b3NvTGlzdCIsInByb3BzMiIsImZvcndhcmRlZFJlZjIiLCJyb2xlIiwicGxhY2Vob2xkZXJDb2x1bW5zIiwiQXJyYXkiLCJmaWxsIiwiaGFuZGxlRW1vamlQb2ludGVyTGVhdmUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJyb3ciLCJjaGlsZE5vZGVzIiwiY2F0ZWdvcnlIZWFkZXIiLCJIVE1MRWxlbWVudCIsInN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBhcnNlRmxvYXQiLCJzY3JvbGxNYXJnaW5Ub3AiLCJzY3JvbGxNYXJnaW5Cb3R0b20iLCJvZmZzZXRIZWlnaHQiLCJjYWxjdWxhdGVWaWV3TG9jYXRpb24iLCJpdGVtVG9wIiwiaXRlbUJvdHRvbSIsInZpZXdwb3J0VG9wIiwidmlld3BvcnRCb3R0b20iLCJsb2NhdGlvblBhcmFtcyIsImJlaGF2aW9yIiwiYWxpZ24iLCJwYXJhbXMiLCJvZmZzZXQiLCJzY3JvbGxJbnRvVmlldyIsImluZGV4IiwidmlzaWJpbGl0eSIsImhlaWdodCIsIm1hcCIsInBsYWNlaG9sZGVyIiwia2V5IiwiY291bnQiLCJHcm91cGVkVmlydHVvc28iLCJTY3JvbGxlciIsIkxpc3QiLCJUb3BJdGVtTGlzdCIsImdyb3VwQ291bnRzIiwiY2F0ZWdvcmllc1Jvd0NvdW50cyIsImdyb3VwQ29udGVudCIsImdyb3VwSW5kZXgiLCJpdGVtQ29udGVudCIsImNhdGVnb3JpZXNSb3dJbmRpY2VzIiwiaW5kZXhPZiIsImlzU2VsZWN0ZWQiLCJvbk1vdXNlRG93biIsIm9uUG9pbnRlckVudGVyIiwib25Qb2ludGVyTGVhdmUiLCJvbkNsaWNrIiwic3RvcFByb3BhZ2F0aW9uIiwidmlzdWFsbHlIaWRkZW4iLCJuYW1lIiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/utils.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/utils.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterEmojis: () => (/* binding */ filterEmojis),\n/* harmony export */   generateEmojiPickerData: () => (/* binding */ generateEmojiPickerData),\n/* harmony export */   getEmojiData: () => (/* binding */ getEmojiData)\n/* harmony export */ });\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.mjs\");\n/* harmony import */ var _utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/capitalize.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/capitalize.mjs\");\n/* harmony import */ var _utils_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/chunk.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/chunk.mjs\");\n\n\n\n\nconst EMOJIBASE_VERSION = \"15.3.0\";\nconst EMOJIBASE_CDN_URL = `https://cdn.jsdelivr.net/npm/emojibase-data@${EMOJIBASE_VERSION}`;\nconst EMOJIBASE_EMOJIS_URL = (locale) => `${EMOJIBASE_CDN_URL}/${locale}/data.json`;\nconst EMOJIBASE_MESSAGES_URL = (locale) => `${EMOJIBASE_CDN_URL}/${locale}/messages.json`;\nconst EMOJIBASE_LOCALES = [\n  \"bn\",\n  \"da\",\n  \"de\",\n  \"en\",\n  \"en-gb\",\n  \"es\",\n  \"es-mx\",\n  \"et\",\n  \"fi\",\n  \"fr\",\n  \"hi\",\n  \"hu\",\n  \"it\",\n  \"ja\",\n  \"ko\",\n  \"lt\",\n  \"ms\",\n  \"nb\",\n  \"nl\",\n  \"pl\",\n  \"pt\",\n  \"ru\",\n  \"sv\",\n  \"th\",\n  \"uk\",\n  \"zh\",\n  \"zh-hant\"\n];\nconst EMOJIBASE_DEFAULT_LOCALE = \"en\";\nconst CACHE_EMOJI_DATA_KEY = (locale) => `lb-emoji-data-${locale}`;\nconst CACHE_EMOJI_METADATA_KEY = (locale) => `lb-emoji-metadata-${locale}`;\nconst CACHE_EMOJI_SESSION_METADATA_KEY = \"lb-emoji-metadata\";\nconst EMOJI_DETECTION_CANVAS_WIDTH = 20;\nconst EMOJI_DETECTION_CANVAS_HEIGHT = 25;\nconst EMOJI_DETECTION_COUNTRY_FLAG = \"\\u{1F1EB}\\u{1F1F7}\";\nfunction generateRangeIndices(start, end) {\n  const range = [];\n  for (let i = start; i <= end; i++) {\n    range.push(i);\n  }\n  return range;\n}\nfunction getStorageItem(storage, key) {\n  const item = storage.getItem(key);\n  return item ? JSON.parse(item) : null;\n}\nfunction setStorageItem(storage, key, value) {\n  storage.setItem(key, JSON.stringify(value));\n}\nasync function fetchEtag(url) {\n  try {\n    const response = await fetch(url, { method: \"HEAD\" });\n    return response.headers.get(\"etag\");\n  } catch (error) {\n    return null;\n  }\n}\nfunction getEmojibaseSupportedLocale(locale) {\n  return EMOJIBASE_LOCALES.includes(locale) ? locale : EMOJIBASE_DEFAULT_LOCALE;\n}\nasync function fetchEmojibaseData(locale) {\n  const [{ emojis, emojisEtag }, { messages, messagesEtag }] = await Promise.all([\n    fetch(EMOJIBASE_EMOJIS_URL(locale)).then(async (response) => {\n      return {\n        emojis: await response.json(),\n        emojisEtag: response.headers.get(\"etag\")\n      };\n    }),\n    fetch(EMOJIBASE_MESSAGES_URL(locale)).then(async (response) => {\n      return {\n        messages: await response.json(),\n        messagesEtag: response.headers.get(\"etag\")\n      };\n    })\n  ]);\n  return {\n    emojis,\n    messages,\n    emojisEtag,\n    messagesEtag\n  };\n}\nasync function fetchEmojibaseEtags(locale) {\n  const [emojisEtag, messagesEtag] = await Promise.all([\n    fetchEtag(EMOJIBASE_EMOJIS_URL(locale)),\n    fetchEtag(EMOJIBASE_MESSAGES_URL(locale))\n  ]);\n  return {\n    emojisEtag,\n    messagesEtag\n  };\n}\nasync function fetchEmojiData(locale) {\n  const { emojis, emojisEtag, messages, messagesEtag } = await fetchEmojibaseData(locale);\n  const countryFlagsSubgroup = messages.subgroups.find(\n    (subgroup) => subgroup.key === \"subdivision-flag\"\n  );\n  const filteredGroups = messages.groups.filter(\n    (group) => group.key !== \"component\"\n  );\n  const filteredEmojis = emojis.filter((emoji) => {\n    return \"group\" in emoji;\n  });\n  const categories = filteredGroups.map((group) => ({\n    key: group.order,\n    name: (0,_utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_0__.capitalize)(group.message)\n  }));\n  const skinTones = messages.skinTones.map((skinTone) => ({\n    key: skinTone.key,\n    name: (0,_utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_0__.capitalize)(skinTone.message)\n  }));\n  const compactEmojis = filteredEmojis.map((emoji) => {\n    const compactEmoji = {\n      emoji: emoji.emoji,\n      category: emoji.group,\n      version: emoji.version,\n      name: (0,_utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_0__.capitalize)(emoji.label),\n      tags: emoji.tags\n    };\n    if (countryFlagsSubgroup && emoji.subgroup === countryFlagsSubgroup.order) {\n      compactEmoji.countryFlag = true;\n    }\n    return compactEmoji;\n  });\n  const emojiData = {\n    emojis: compactEmojis,\n    categories,\n    skinTones\n  };\n  setStorageItem(\n    localStorage,\n    CACHE_EMOJI_DATA_KEY(locale),\n    emojiData\n  );\n  setStorageItem(\n    localStorage,\n    CACHE_EMOJI_METADATA_KEY(locale),\n    {\n      emojisEtag,\n      messagesEtag\n    }\n  );\n  return emojiData;\n}\nfunction detectEmojiSupport(canvasContext, emoji) {\n  canvasContext.clearRect(\n    0,\n    0,\n    EMOJI_DETECTION_CANVAS_WIDTH * 2,\n    EMOJI_DETECTION_CANVAS_HEIGHT\n  );\n  canvasContext.fillStyle = \"#f00\";\n  canvasContext.fillText(emoji, 0, 22);\n  canvasContext.fillStyle = \"#00f\";\n  canvasContext.fillText(emoji, EMOJI_DETECTION_CANVAS_WIDTH, 22);\n  const pixels = canvasContext.getImageData(\n    0,\n    0,\n    EMOJI_DETECTION_CANVAS_WIDTH,\n    EMOJI_DETECTION_CANVAS_HEIGHT\n  ).data;\n  const pixelCount = pixels.length;\n  let i = 0;\n  for (; i < pixelCount && !pixels[i + 3]; i += 4)\n    ;\n  if (i >= pixelCount) {\n    return false;\n  }\n  const x = EMOJI_DETECTION_CANVAS_WIDTH + i / 4 % EMOJI_DETECTION_CANVAS_WIDTH;\n  const y = Math.floor(i / 4 / EMOJI_DETECTION_CANVAS_WIDTH);\n  const pixel = canvasContext.getImageData(x, y, 1, 1).data;\n  if (pixels[i] !== pixel[0] || pixels[i + 2] !== pixel[2]) {\n    return false;\n  }\n  if (canvasContext.measureText(emoji).width >= EMOJI_DETECTION_CANVAS_WIDTH) {\n    return false;\n  }\n  return true;\n}\nfunction getEmojiFontFamily() {\n  try {\n    const element = document.createElement(\"span\");\n    element.style.display = \"none\";\n    element.dataset.emoji = \"\";\n    document.body.appendChild(element);\n    const computedFontFamily = window.getComputedStyle(element).fontFamily;\n    document.body.removeChild(element);\n    return computedFontFamily;\n  } catch {\n    return _constants_mjs__WEBPACK_IMPORTED_MODULE_1__.EMOJI_FONT_FAMILY;\n  }\n}\nfunction getEmojiSessionMetadata(emojis) {\n  const versions = /* @__PURE__ */ new Map();\n  for (const emoji of emojis) {\n    if (!versions.has(emoji.version)) {\n      versions.set(emoji.version, emoji.emoji);\n    }\n  }\n  const descendingVersions = [...versions.keys()].sort((a, b) => b - a);\n  const canvasContext = document.createElement(\"canvas\").getContext(\"2d\", { willReadFrequently: true });\n  if (!canvasContext) {\n    return { emojiVersion: descendingVersions[0], countryFlags: true };\n  }\n  canvasContext.font = `${Math.floor(\n    EMOJI_DETECTION_CANVAS_HEIGHT / 2\n  )}px ${getEmojiFontFamily()}`;\n  canvasContext.textBaseline = \"top\";\n  canvasContext.canvas.width = EMOJI_DETECTION_CANVAS_WIDTH * 2;\n  canvasContext.canvas.height = EMOJI_DETECTION_CANVAS_HEIGHT;\n  const supportsCountryFlags = detectEmojiSupport(\n    canvasContext,\n    EMOJI_DETECTION_COUNTRY_FLAG\n  );\n  for (const version of descendingVersions) {\n    const emoji = versions.get(version);\n    const isSupported = detectEmojiSupport(canvasContext, emoji);\n    if (isSupported) {\n      return {\n        emojiVersion: version,\n        countryFlags: supportsCountryFlags\n      };\n    }\n  }\n  return {\n    emojiVersion: descendingVersions[0],\n    countryFlags: supportsCountryFlags\n  };\n}\nasync function getEmojiData(locale) {\n  const emojibaseLocale = getEmojibaseSupportedLocale(locale);\n  const sessionMetadata = getStorageItem(\n    sessionStorage,\n    CACHE_EMOJI_SESSION_METADATA_KEY\n  );\n  const cachedData = getStorageItem(\n    localStorage,\n    CACHE_EMOJI_DATA_KEY(emojibaseLocale)\n  );\n  let data;\n  if (cachedData) {\n    if (sessionMetadata) {\n      data = cachedData;\n    } else {\n      const { emojisEtag, messagesEtag } = await fetchEmojibaseEtags(emojibaseLocale);\n      const cachedMetadata = getStorageItem(\n        localStorage,\n        CACHE_EMOJI_METADATA_KEY(emojibaseLocale)\n      );\n      if (cachedMetadata && emojisEtag === cachedMetadata.emojisEtag && messagesEtag === cachedMetadata.messagesEtag) {\n        data = cachedData;\n      } else {\n        data = await fetchEmojiData(emojibaseLocale);\n      }\n    }\n  } else {\n    data = await fetchEmojiData(emojibaseLocale);\n  }\n  const newSessionMetadata = sessionMetadata ?? getEmojiSessionMetadata(data.emojis);\n  setStorageItem(\n    sessionStorage,\n    CACHE_EMOJI_SESSION_METADATA_KEY,\n    newSessionMetadata\n  );\n  const filteredEmojis = data.emojis.filter((emoji) => {\n    const isSupportedVersion = emoji.version <= newSessionMetadata.emojiVersion;\n    return emoji.countryFlag ? isSupportedVersion && newSessionMetadata.countryFlags : isSupportedVersion;\n  });\n  return {\n    emojis: filteredEmojis,\n    categories: data.categories,\n    skinTones: data.skinTones\n  };\n}\nfunction filterEmojis(emojis, search) {\n  if (!search) {\n    return emojis;\n  }\n  const searchText = search.toLowerCase().trim();\n  return emojis.filter(\n    (emoji) => emoji.name.toLowerCase().includes(searchText) || emoji.tags?.some((tag) => tag.toLowerCase().includes(searchText))\n  );\n}\nfunction generateEmojiPickerData(emojis, categories, columns) {\n  let currentIndex = 0;\n  const rows = [];\n  const indexedEmojis = emojis.map((emoji, index) => ({ ...emoji, index }));\n  const categoriesRowCounts = [];\n  const categoriesRowIndices = [];\n  const categoriesNames = [];\n  const categorizedEmojis = categories.map((category) => ({\n    ...category,\n    emojis: indexedEmojis.filter((emoji) => emoji.category === category.key)\n  })).filter((category) => category.emojis.length > 0);\n  for (const category of categorizedEmojis) {\n    const categoryRows = (0,_utils_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.chunk)(category.emojis, columns);\n    const nextIndex = currentIndex + categoryRows.length;\n    rows.push(...categoryRows);\n    categoriesNames.push(category.name);\n    categoriesRowCounts.push(categoryRows.length);\n    categoriesRowIndices.push(\n      generateRangeIndices(currentIndex, nextIndex - 1)\n    );\n    currentIndex = nextIndex;\n  }\n  return {\n    count: emojis.length,\n    rows,\n    categories: categoriesNames,\n    categoriesRowCounts,\n    categoriesRowIndices\n  };\n}\n\n\n//# sourceMappingURL=utils.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0Vtb2ppUGlja2VyL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0Q7QUFDQTtBQUNWOztBQUU5QztBQUNBLHlFQUF5RSxrQkFBa0I7QUFDM0YsNENBQTRDLGtCQUFrQixHQUFHLE9BQU87QUFDeEUsOENBQThDLGtCQUFrQixHQUFHLE9BQU87QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakUsa0VBQWtFLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU0sR0FBRyxNQUFNO0FBQ3hEO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQixJQUFJLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLGlFQUFVO0FBQ3BCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxpRUFBVTtBQUNwQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0NBQWtDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixXQUFXLDZEQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwwQkFBMEI7QUFDdEc7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxJQUFJLEtBQUsscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5QkFBeUIsdURBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0Q7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL0Vtb2ppUGlja2VyL3V0aWxzLm1qcz8wYzlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVNT0pJX0ZPTlRfRkFNSUxZIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyBjYXBpdGFsaXplIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2FwaXRhbGl6ZS5tanMnO1xuaW1wb3J0IHsgY2h1bmsgfSBmcm9tICcuLi8uLi91dGlscy9jaHVuay5tanMnO1xuXG5jb25zdCBFTU9KSUJBU0VfVkVSU0lPTiA9IFwiMTUuMy4wXCI7XG5jb25zdCBFTU9KSUJBU0VfQ0ROX1VSTCA9IGBodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2Vtb2ppYmFzZS1kYXRhQCR7RU1PSklCQVNFX1ZFUlNJT059YDtcbmNvbnN0IEVNT0pJQkFTRV9FTU9KSVNfVVJMID0gKGxvY2FsZSkgPT4gYCR7RU1PSklCQVNFX0NETl9VUkx9LyR7bG9jYWxlfS9kYXRhLmpzb25gO1xuY29uc3QgRU1PSklCQVNFX01FU1NBR0VTX1VSTCA9IChsb2NhbGUpID0+IGAke0VNT0pJQkFTRV9DRE5fVVJMfS8ke2xvY2FsZX0vbWVzc2FnZXMuanNvbmA7XG5jb25zdCBFTU9KSUJBU0VfTE9DQUxFUyA9IFtcbiAgXCJiblwiLFxuICBcImRhXCIsXG4gIFwiZGVcIixcbiAgXCJlblwiLFxuICBcImVuLWdiXCIsXG4gIFwiZXNcIixcbiAgXCJlcy1teFwiLFxuICBcImV0XCIsXG4gIFwiZmlcIixcbiAgXCJmclwiLFxuICBcImhpXCIsXG4gIFwiaHVcIixcbiAgXCJpdFwiLFxuICBcImphXCIsXG4gIFwia29cIixcbiAgXCJsdFwiLFxuICBcIm1zXCIsXG4gIFwibmJcIixcbiAgXCJubFwiLFxuICBcInBsXCIsXG4gIFwicHRcIixcbiAgXCJydVwiLFxuICBcInN2XCIsXG4gIFwidGhcIixcbiAgXCJ1a1wiLFxuICBcInpoXCIsXG4gIFwiemgtaGFudFwiXG5dO1xuY29uc3QgRU1PSklCQVNFX0RFRkFVTFRfTE9DQUxFID0gXCJlblwiO1xuY29uc3QgQ0FDSEVfRU1PSklfREFUQV9LRVkgPSAobG9jYWxlKSA9PiBgbGItZW1vamktZGF0YS0ke2xvY2FsZX1gO1xuY29uc3QgQ0FDSEVfRU1PSklfTUVUQURBVEFfS0VZID0gKGxvY2FsZSkgPT4gYGxiLWVtb2ppLW1ldGFkYXRhLSR7bG9jYWxlfWA7XG5jb25zdCBDQUNIRV9FTU9KSV9TRVNTSU9OX01FVEFEQVRBX0tFWSA9IFwibGItZW1vamktbWV0YWRhdGFcIjtcbmNvbnN0IEVNT0pJX0RFVEVDVElPTl9DQU5WQVNfV0lEVEggPSAyMDtcbmNvbnN0IEVNT0pJX0RFVEVDVElPTl9DQU5WQVNfSEVJR0hUID0gMjU7XG5jb25zdCBFTU9KSV9ERVRFQ1RJT05fQ09VTlRSWV9GTEFHID0gXCJcXHV7MUYxRUJ9XFx1ezFGMUY3fVwiO1xuZnVuY3Rpb24gZ2VuZXJhdGVSYW5nZUluZGljZXMoc3RhcnQsIGVuZCkge1xuICBjb25zdCByYW5nZSA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICByYW5nZS5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByYW5nZTtcbn1cbmZ1bmN0aW9uIGdldFN0b3JhZ2VJdGVtKHN0b3JhZ2UsIGtleSkge1xuICBjb25zdCBpdGVtID0gc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gIHJldHVybiBpdGVtID8gSlNPTi5wYXJzZShpdGVtKSA6IG51bGw7XG59XG5mdW5jdGlvbiBzZXRTdG9yYWdlSXRlbShzdG9yYWdlLCBrZXksIHZhbHVlKSB7XG4gIHN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEV0YWcodXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHsgbWV0aG9kOiBcIkhFQURcIiB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJldGFnXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRFbW9qaWJhc2VTdXBwb3J0ZWRMb2NhbGUobG9jYWxlKSB7XG4gIHJldHVybiBFTU9KSUJBU0VfTE9DQUxFUy5pbmNsdWRlcyhsb2NhbGUpID8gbG9jYWxlIDogRU1PSklCQVNFX0RFRkFVTFRfTE9DQUxFO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hFbW9qaWJhc2VEYXRhKGxvY2FsZSkge1xuICBjb25zdCBbeyBlbW9qaXMsIGVtb2ppc0V0YWcgfSwgeyBtZXNzYWdlcywgbWVzc2FnZXNFdGFnIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgIGZldGNoKEVNT0pJQkFTRV9FTU9KSVNfVVJMKGxvY2FsZSkpLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbW9qaXM6IGF3YWl0IHJlc3BvbnNlLmpzb24oKSxcbiAgICAgICAgZW1vamlzRXRhZzogcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJldGFnXCIpXG4gICAgICB9O1xuICAgIH0pLFxuICAgIGZldGNoKEVNT0pJQkFTRV9NRVNTQUdFU19VUkwobG9jYWxlKSkudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2VzOiBhd2FpdCByZXNwb25zZS5qc29uKCksXG4gICAgICAgIG1lc3NhZ2VzRXRhZzogcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJldGFnXCIpXG4gICAgICB9O1xuICAgIH0pXG4gIF0pO1xuICByZXR1cm4ge1xuICAgIGVtb2ppcyxcbiAgICBtZXNzYWdlcyxcbiAgICBlbW9qaXNFdGFnLFxuICAgIG1lc3NhZ2VzRXRhZ1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hFbW9qaWJhc2VFdGFncyhsb2NhbGUpIHtcbiAgY29uc3QgW2Vtb2ppc0V0YWcsIG1lc3NhZ2VzRXRhZ10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgZmV0Y2hFdGFnKEVNT0pJQkFTRV9FTU9KSVNfVVJMKGxvY2FsZSkpLFxuICAgIGZldGNoRXRhZyhFTU9KSUJBU0VfTUVTU0FHRVNfVVJMKGxvY2FsZSkpXG4gIF0pO1xuICByZXR1cm4ge1xuICAgIGVtb2ppc0V0YWcsXG4gICAgbWVzc2FnZXNFdGFnXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEVtb2ppRGF0YShsb2NhbGUpIHtcbiAgY29uc3QgeyBlbW9qaXMsIGVtb2ppc0V0YWcsIG1lc3NhZ2VzLCBtZXNzYWdlc0V0YWcgfSA9IGF3YWl0IGZldGNoRW1vamliYXNlRGF0YShsb2NhbGUpO1xuICBjb25zdCBjb3VudHJ5RmxhZ3NTdWJncm91cCA9IG1lc3NhZ2VzLnN1Ymdyb3Vwcy5maW5kKFxuICAgIChzdWJncm91cCkgPT4gc3ViZ3JvdXAua2V5ID09PSBcInN1YmRpdmlzaW9uLWZsYWdcIlxuICApO1xuICBjb25zdCBmaWx0ZXJlZEdyb3VwcyA9IG1lc3NhZ2VzLmdyb3Vwcy5maWx0ZXIoXG4gICAgKGdyb3VwKSA9PiBncm91cC5rZXkgIT09IFwiY29tcG9uZW50XCJcbiAgKTtcbiAgY29uc3QgZmlsdGVyZWRFbW9qaXMgPSBlbW9qaXMuZmlsdGVyKChlbW9qaSkgPT4ge1xuICAgIHJldHVybiBcImdyb3VwXCIgaW4gZW1vamk7XG4gIH0pO1xuICBjb25zdCBjYXRlZ29yaWVzID0gZmlsdGVyZWRHcm91cHMubWFwKChncm91cCkgPT4gKHtcbiAgICBrZXk6IGdyb3VwLm9yZGVyLFxuICAgIG5hbWU6IGNhcGl0YWxpemUoZ3JvdXAubWVzc2FnZSlcbiAgfSkpO1xuICBjb25zdCBza2luVG9uZXMgPSBtZXNzYWdlcy5za2luVG9uZXMubWFwKChza2luVG9uZSkgPT4gKHtcbiAgICBrZXk6IHNraW5Ub25lLmtleSxcbiAgICBuYW1lOiBjYXBpdGFsaXplKHNraW5Ub25lLm1lc3NhZ2UpXG4gIH0pKTtcbiAgY29uc3QgY29tcGFjdEVtb2ppcyA9IGZpbHRlcmVkRW1vamlzLm1hcCgoZW1vamkpID0+IHtcbiAgICBjb25zdCBjb21wYWN0RW1vamkgPSB7XG4gICAgICBlbW9qaTogZW1vamkuZW1vamksXG4gICAgICBjYXRlZ29yeTogZW1vamkuZ3JvdXAsXG4gICAgICB2ZXJzaW9uOiBlbW9qaS52ZXJzaW9uLFxuICAgICAgbmFtZTogY2FwaXRhbGl6ZShlbW9qaS5sYWJlbCksXG4gICAgICB0YWdzOiBlbW9qaS50YWdzXG4gICAgfTtcbiAgICBpZiAoY291bnRyeUZsYWdzU3ViZ3JvdXAgJiYgZW1vamkuc3ViZ3JvdXAgPT09IGNvdW50cnlGbGFnc1N1Ymdyb3VwLm9yZGVyKSB7XG4gICAgICBjb21wYWN0RW1vamkuY291bnRyeUZsYWcgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGFjdEVtb2ppO1xuICB9KTtcbiAgY29uc3QgZW1vamlEYXRhID0ge1xuICAgIGVtb2ppczogY29tcGFjdEVtb2ppcyxcbiAgICBjYXRlZ29yaWVzLFxuICAgIHNraW5Ub25lc1xuICB9O1xuICBzZXRTdG9yYWdlSXRlbShcbiAgICBsb2NhbFN0b3JhZ2UsXG4gICAgQ0FDSEVfRU1PSklfREFUQV9LRVkobG9jYWxlKSxcbiAgICBlbW9qaURhdGFcbiAgKTtcbiAgc2V0U3RvcmFnZUl0ZW0oXG4gICAgbG9jYWxTdG9yYWdlLFxuICAgIENBQ0hFX0VNT0pJX01FVEFEQVRBX0tFWShsb2NhbGUpLFxuICAgIHtcbiAgICAgIGVtb2ppc0V0YWcsXG4gICAgICBtZXNzYWdlc0V0YWdcbiAgICB9XG4gICk7XG4gIHJldHVybiBlbW9qaURhdGE7XG59XG5mdW5jdGlvbiBkZXRlY3RFbW9qaVN1cHBvcnQoY2FudmFzQ29udGV4dCwgZW1vamkpIHtcbiAgY2FudmFzQ29udGV4dC5jbGVhclJlY3QoXG4gICAgMCxcbiAgICAwLFxuICAgIEVNT0pJX0RFVEVDVElPTl9DQU5WQVNfV0lEVEggKiAyLFxuICAgIEVNT0pJX0RFVEVDVElPTl9DQU5WQVNfSEVJR0hUXG4gICk7XG4gIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gXCIjZjAwXCI7XG4gIGNhbnZhc0NvbnRleHQuZmlsbFRleHQoZW1vamksIDAsIDIyKTtcbiAgY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSBcIiMwMGZcIjtcbiAgY2FudmFzQ29udGV4dC5maWxsVGV4dChlbW9qaSwgRU1PSklfREVURUNUSU9OX0NBTlZBU19XSURUSCwgMjIpO1xuICBjb25zdCBwaXhlbHMgPSBjYW52YXNDb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAwLFxuICAgIDAsXG4gICAgRU1PSklfREVURUNUSU9OX0NBTlZBU19XSURUSCxcbiAgICBFTU9KSV9ERVRFQ1RJT05fQ0FOVkFTX0hFSUdIVFxuICApLmRhdGE7XG4gIGNvbnN0IHBpeGVsQ291bnQgPSBwaXhlbHMubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgcGl4ZWxDb3VudCAmJiAhcGl4ZWxzW2kgKyAzXTsgaSArPSA0KVxuICAgIDtcbiAgaWYgKGkgPj0gcGl4ZWxDb3VudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gRU1PSklfREVURUNUSU9OX0NBTlZBU19XSURUSCArIGkgLyA0ICUgRU1PSklfREVURUNUSU9OX0NBTlZBU19XSURUSDtcbiAgY29uc3QgeSA9IE1hdGguZmxvb3IoaSAvIDQgLyBFTU9KSV9ERVRFQ1RJT05fQ0FOVkFTX1dJRFRIKTtcbiAgY29uc3QgcGl4ZWwgPSBjYW52YXNDb250ZXh0LmdldEltYWdlRGF0YSh4LCB5LCAxLCAxKS5kYXRhO1xuICBpZiAocGl4ZWxzW2ldICE9PSBwaXhlbFswXSB8fCBwaXhlbHNbaSArIDJdICE9PSBwaXhlbFsyXSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY2FudmFzQ29udGV4dC5tZWFzdXJlVGV4dChlbW9qaSkud2lkdGggPj0gRU1PSklfREVURUNUSU9OX0NBTlZBU19XSURUSCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEVtb2ppRm9udEZhbWlseSgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZWxlbWVudC5kYXRhc2V0LmVtb2ppID0gXCJcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIGNvbnN0IGNvbXB1dGVkRm9udEZhbWlseSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmZvbnRGYW1pbHk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICByZXR1cm4gY29tcHV0ZWRGb250RmFtaWx5O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gRU1PSklfRk9OVF9GQU1JTFk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVtb2ppU2Vzc2lvbk1ldGFkYXRhKGVtb2ppcykge1xuICBjb25zdCB2ZXJzaW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgZW1vamkgb2YgZW1vamlzKSB7XG4gICAgaWYgKCF2ZXJzaW9ucy5oYXMoZW1vamkudmVyc2lvbikpIHtcbiAgICAgIHZlcnNpb25zLnNldChlbW9qaS52ZXJzaW9uLCBlbW9qaS5lbW9qaSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlc2NlbmRpbmdWZXJzaW9ucyA9IFsuLi52ZXJzaW9ucy5rZXlzKCldLnNvcnQoKGEsIGIpID0+IGIgLSBhKTtcbiAgY29uc3QgY2FudmFzQ29udGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIsIHsgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlIH0pO1xuICBpZiAoIWNhbnZhc0NvbnRleHQpIHtcbiAgICByZXR1cm4geyBlbW9qaVZlcnNpb246IGRlc2NlbmRpbmdWZXJzaW9uc1swXSwgY291bnRyeUZsYWdzOiB0cnVlIH07XG4gIH1cbiAgY2FudmFzQ29udGV4dC5mb250ID0gYCR7TWF0aC5mbG9vcihcbiAgICBFTU9KSV9ERVRFQ1RJT05fQ0FOVkFTX0hFSUdIVCAvIDJcbiAgKX1weCAke2dldEVtb2ppRm9udEZhbWlseSgpfWA7XG4gIGNhbnZhc0NvbnRleHQudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGggPSBFTU9KSV9ERVRFQ1RJT05fQ0FOVkFTX1dJRFRIICogMjtcbiAgY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gRU1PSklfREVURUNUSU9OX0NBTlZBU19IRUlHSFQ7XG4gIGNvbnN0IHN1cHBvcnRzQ291bnRyeUZsYWdzID0gZGV0ZWN0RW1vamlTdXBwb3J0KFxuICAgIGNhbnZhc0NvbnRleHQsXG4gICAgRU1PSklfREVURUNUSU9OX0NPVU5UUllfRkxBR1xuICApO1xuICBmb3IgKGNvbnN0IHZlcnNpb24gb2YgZGVzY2VuZGluZ1ZlcnNpb25zKSB7XG4gICAgY29uc3QgZW1vamkgPSB2ZXJzaW9ucy5nZXQodmVyc2lvbik7XG4gICAgY29uc3QgaXNTdXBwb3J0ZWQgPSBkZXRlY3RFbW9qaVN1cHBvcnQoY2FudmFzQ29udGV4dCwgZW1vamkpO1xuICAgIGlmIChpc1N1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW1vamlWZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICBjb3VudHJ5RmxhZ3M6IHN1cHBvcnRzQ291bnRyeUZsYWdzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGVtb2ppVmVyc2lvbjogZGVzY2VuZGluZ1ZlcnNpb25zWzBdLFxuICAgIGNvdW50cnlGbGFnczogc3VwcG9ydHNDb3VudHJ5RmxhZ3NcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEVtb2ppRGF0YShsb2NhbGUpIHtcbiAgY29uc3QgZW1vamliYXNlTG9jYWxlID0gZ2V0RW1vamliYXNlU3VwcG9ydGVkTG9jYWxlKGxvY2FsZSk7XG4gIGNvbnN0IHNlc3Npb25NZXRhZGF0YSA9IGdldFN0b3JhZ2VJdGVtKFxuICAgIHNlc3Npb25TdG9yYWdlLFxuICAgIENBQ0hFX0VNT0pJX1NFU1NJT05fTUVUQURBVEFfS0VZXG4gICk7XG4gIGNvbnN0IGNhY2hlZERhdGEgPSBnZXRTdG9yYWdlSXRlbShcbiAgICBsb2NhbFN0b3JhZ2UsXG4gICAgQ0FDSEVfRU1PSklfREFUQV9LRVkoZW1vamliYXNlTG9jYWxlKVxuICApO1xuICBsZXQgZGF0YTtcbiAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICBpZiAoc2Vzc2lvbk1ldGFkYXRhKSB7XG4gICAgICBkYXRhID0gY2FjaGVkRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBlbW9qaXNFdGFnLCBtZXNzYWdlc0V0YWcgfSA9IGF3YWl0IGZldGNoRW1vamliYXNlRXRhZ3MoZW1vamliYXNlTG9jYWxlKTtcbiAgICAgIGNvbnN0IGNhY2hlZE1ldGFkYXRhID0gZ2V0U3RvcmFnZUl0ZW0oXG4gICAgICAgIGxvY2FsU3RvcmFnZSxcbiAgICAgICAgQ0FDSEVfRU1PSklfTUVUQURBVEFfS0VZKGVtb2ppYmFzZUxvY2FsZSlcbiAgICAgICk7XG4gICAgICBpZiAoY2FjaGVkTWV0YWRhdGEgJiYgZW1vamlzRXRhZyA9PT0gY2FjaGVkTWV0YWRhdGEuZW1vamlzRXRhZyAmJiBtZXNzYWdlc0V0YWcgPT09IGNhY2hlZE1ldGFkYXRhLm1lc3NhZ2VzRXRhZykge1xuICAgICAgICBkYXRhID0gY2FjaGVkRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBmZXRjaEVtb2ppRGF0YShlbW9qaWJhc2VMb2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gYXdhaXQgZmV0Y2hFbW9qaURhdGEoZW1vamliYXNlTG9jYWxlKTtcbiAgfVxuICBjb25zdCBuZXdTZXNzaW9uTWV0YWRhdGEgPSBzZXNzaW9uTWV0YWRhdGEgPz8gZ2V0RW1vamlTZXNzaW9uTWV0YWRhdGEoZGF0YS5lbW9qaXMpO1xuICBzZXRTdG9yYWdlSXRlbShcbiAgICBzZXNzaW9uU3RvcmFnZSxcbiAgICBDQUNIRV9FTU9KSV9TRVNTSU9OX01FVEFEQVRBX0tFWSxcbiAgICBuZXdTZXNzaW9uTWV0YWRhdGFcbiAgKTtcbiAgY29uc3QgZmlsdGVyZWRFbW9qaXMgPSBkYXRhLmVtb2ppcy5maWx0ZXIoKGVtb2ppKSA9PiB7XG4gICAgY29uc3QgaXNTdXBwb3J0ZWRWZXJzaW9uID0gZW1vamkudmVyc2lvbiA8PSBuZXdTZXNzaW9uTWV0YWRhdGEuZW1vamlWZXJzaW9uO1xuICAgIHJldHVybiBlbW9qaS5jb3VudHJ5RmxhZyA/IGlzU3VwcG9ydGVkVmVyc2lvbiAmJiBuZXdTZXNzaW9uTWV0YWRhdGEuY291bnRyeUZsYWdzIDogaXNTdXBwb3J0ZWRWZXJzaW9uO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBlbW9qaXM6IGZpbHRlcmVkRW1vamlzLFxuICAgIGNhdGVnb3JpZXM6IGRhdGEuY2F0ZWdvcmllcyxcbiAgICBza2luVG9uZXM6IGRhdGEuc2tpblRvbmVzXG4gIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJFbW9qaXMoZW1vamlzLCBzZWFyY2gpIHtcbiAgaWYgKCFzZWFyY2gpIHtcbiAgICByZXR1cm4gZW1vamlzO1xuICB9XG4gIGNvbnN0IHNlYXJjaFRleHQgPSBzZWFyY2gudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIHJldHVybiBlbW9qaXMuZmlsdGVyKFxuICAgIChlbW9qaSkgPT4gZW1vamkubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRleHQpIHx8IGVtb2ppLnRhZ3M/LnNvbWUoKHRhZykgPT4gdGFnLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGV4dCkpXG4gICk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUVtb2ppUGlja2VyRGF0YShlbW9qaXMsIGNhdGVnb3JpZXMsIGNvbHVtbnMpIHtcbiAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gIGNvbnN0IHJvd3MgPSBbXTtcbiAgY29uc3QgaW5kZXhlZEVtb2ppcyA9IGVtb2ppcy5tYXAoKGVtb2ppLCBpbmRleCkgPT4gKHsgLi4uZW1vamksIGluZGV4IH0pKTtcbiAgY29uc3QgY2F0ZWdvcmllc1Jvd0NvdW50cyA9IFtdO1xuICBjb25zdCBjYXRlZ29yaWVzUm93SW5kaWNlcyA9IFtdO1xuICBjb25zdCBjYXRlZ29yaWVzTmFtZXMgPSBbXTtcbiAgY29uc3QgY2F0ZWdvcml6ZWRFbW9qaXMgPSBjYXRlZ29yaWVzLm1hcCgoY2F0ZWdvcnkpID0+ICh7XG4gICAgLi4uY2F0ZWdvcnksXG4gICAgZW1vamlzOiBpbmRleGVkRW1vamlzLmZpbHRlcigoZW1vamkpID0+IGVtb2ppLmNhdGVnb3J5ID09PSBjYXRlZ29yeS5rZXkpXG4gIH0pKS5maWx0ZXIoKGNhdGVnb3J5KSA9PiBjYXRlZ29yeS5lbW9qaXMubGVuZ3RoID4gMCk7XG4gIGZvciAoY29uc3QgY2F0ZWdvcnkgb2YgY2F0ZWdvcml6ZWRFbW9qaXMpIHtcbiAgICBjb25zdCBjYXRlZ29yeVJvd3MgPSBjaHVuayhjYXRlZ29yeS5lbW9qaXMsIGNvbHVtbnMpO1xuICAgIGNvbnN0IG5leHRJbmRleCA9IGN1cnJlbnRJbmRleCArIGNhdGVnb3J5Um93cy5sZW5ndGg7XG4gICAgcm93cy5wdXNoKC4uLmNhdGVnb3J5Um93cyk7XG4gICAgY2F0ZWdvcmllc05hbWVzLnB1c2goY2F0ZWdvcnkubmFtZSk7XG4gICAgY2F0ZWdvcmllc1Jvd0NvdW50cy5wdXNoKGNhdGVnb3J5Um93cy5sZW5ndGgpO1xuICAgIGNhdGVnb3JpZXNSb3dJbmRpY2VzLnB1c2goXG4gICAgICBnZW5lcmF0ZVJhbmdlSW5kaWNlcyhjdXJyZW50SW5kZXgsIG5leHRJbmRleCAtIDEpXG4gICAgKTtcbiAgICBjdXJyZW50SW5kZXggPSBuZXh0SW5kZXg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb3VudDogZW1vamlzLmxlbmd0aCxcbiAgICByb3dzLFxuICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXNOYW1lcyxcbiAgICBjYXRlZ29yaWVzUm93Q291bnRzLFxuICAgIGNhdGVnb3JpZXNSb3dJbmRpY2VzXG4gIH07XG59XG5cbmV4cG9ydCB7IGZpbHRlckVtb2ppcywgZ2VuZXJhdGVFbW9qaVBpY2tlckRhdGEsIGdldEVtb2ppRGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/EmojiPicker/utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Timestamp.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/Timestamp.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Timestamp: () => (/* binding */ Timestamp)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/capitalize.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/capitalize.mjs\");\n/* harmony import */ var _utils_intl_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/intl.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/intl.mjs\");\n/* harmony import */ var _utils_use_interval_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/use-interval.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-interval.mjs\");\n/* harmony import */ var _utils_use_rerender_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/use-rerender.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-rerender.mjs\");\n/* __next_internal_client_entry_do_not_use__ Timestamp auto */ \n\n\n\n\n\nconst DYNAMIC_DATE_THRESHOLD = 3 * 24 * 60 * 60 * 1e3;\nconst RENDER_INTERVAL = 30 * 1e3;\nconst TIMESTAMP_NAME = \"Timestamp\";\nconst relativeUnits = {\n    seconds: 60,\n    minutes: 60,\n    hours: 24,\n    days: 7,\n    weeks: 4.34524,\n    months: 12\n};\nfunction formatVerboseDate(date, locale) {\n    const formatter = (0,_utils_intl_mjs__WEBPACK_IMPORTED_MODULE_1__.dateTimeFormat)(locale, {\n        year: \"numeric\",\n        month: \"numeric\",\n        day: \"numeric\",\n        hour: \"numeric\",\n        minute: \"numeric\"\n    });\n    return (0,_utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_2__.capitalize)(formatter.format(date));\n}\nfunction formatShortDate(date, locale) {\n    const formatter = (0,_utils_intl_mjs__WEBPACK_IMPORTED_MODULE_1__.dateTimeFormat)(locale, {\n        month: \"short\",\n        day: \"numeric\"\n    });\n    return (0,_utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_2__.capitalize)(formatter.format(date));\n}\nconst localesWithBrokenNarrowRelativeFormatting = [\n    \"br\",\n    \"fr\",\n    \"nb\",\n    \"nn\",\n    \"no\",\n    \"ro\",\n    \"sv\"\n];\nfunction formatRelativeDate(date, locale) {\n    let resolvedLocale;\n    if (locale) {\n        resolvedLocale = locale;\n    } else {\n        const formatter2 = (0,_utils_intl_mjs__WEBPACK_IMPORTED_MODULE_1__.relativeTimeFormat)();\n        resolvedLocale = formatter2.resolvedOptions().locale;\n    }\n    const isBrokenWhenNarrow = localesWithBrokenNarrowRelativeFormatting.some((locale2)=>resolvedLocale === locale2 || resolvedLocale.startsWith(`${locale2}-`));\n    const formatter = (0,_utils_intl_mjs__WEBPACK_IMPORTED_MODULE_1__.relativeTimeFormat)(resolvedLocale, {\n        style: isBrokenWhenNarrow ? \"short\" : \"narrow\",\n        numeric: \"auto\"\n    });\n    let difference = (date.getTime() - Date.now()) / 1e3;\n    if (difference > -relativeUnits.seconds && difference < relativeUnits.seconds) {\n        return formatter.format(0, \"seconds\");\n    }\n    for (const [unit, length] of Object.entries(relativeUnits)){\n        if (Math.abs(difference) < length) {\n            return formatter.format(Math.round(difference), unit);\n        }\n        difference /= length;\n    }\n    return (0,_utils_capitalize_mjs__WEBPACK_IMPORTED_MODULE_2__.capitalize)(formatter.format(Math.round(difference), \"years\"));\n}\nfunction formatDynamicDate(date, locale) {\n    return date.getTime() > Date.now() - DYNAMIC_DATE_THRESHOLD ? formatRelativeDate(date, locale) : formatShortDate(date, locale);\n}\nconst Timestamp = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ date, locale, children: renderChildren = formatDynamicDate, title: renderTitle = formatVerboseDate, dateTime, interval = RENDER_INTERVAL, asChild, ...props }, forwardedRef)=>{\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_3__.Slot : \"time\";\n    const [rerender, key] = (0,_utils_use_rerender_mjs__WEBPACK_IMPORTED_MODULE_4__.useRerender)();\n    const parsedDate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new Date(date), [\n        date\n    ]);\n    const normalizedDate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>parsedDate.toISOString(), [\n        parsedDate\n    ]);\n    const title = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>typeof renderTitle === \"function\" ? renderTitle(parsedDate, locale) : renderTitle, [\n        renderTitle,\n        parsedDate,\n        key\n    ]);\n    const children = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>typeof renderChildren === \"function\" ? renderChildren(parsedDate, locale) : renderChildren, [\n        renderChildren,\n        parsedDate,\n        key\n    ]);\n    (0,_utils_use_interval_mjs__WEBPACK_IMPORTED_MODULE_5__.useInterval)(rerender, interval);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        ...props,\n        ref: forwardedRef,\n        dateTime: dateTime ?? normalizedDate,\n        title\n    }, children);\n});\nif (true) {\n    Timestamp.displayName = TIMESTAMP_NAME;\n}\n //# sourceMappingURL=Timestamp.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL1RpbWVzdGFtcC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQVlBLE1BQUFBLHlCQUFBO0FBQ0EsTUFBQUMsa0JBQUE7QUFFQSxNQUFBQyxpQkFBQTtBQStCQSxNQUFBQyxnQkFBQTtJQUFzQkMsU0FBQTtJQUNYQyxTQUFBO0lBQ0FDLE9BQUE7SUFDRkMsTUFBQTtJQUNEQyxPQUFBO0lBQ0NDLFFBQUE7QUFFVDtBQUtBLFNBQUFDLGtCQUFBQyxJQUFBLEVBQUFDLE1BQUE7SUFDRSxNQUFBQyxZQUFBQywrREFBQUEsQ0FBQUYsUUFBQTtRQUF5Q0csTUFBQTtRQUNqQ0MsT0FBQTtRQUNDQyxLQUFBO1FBQ0ZDLE1BQUE7UUFDQ0MsUUFBQTtJQUNFO0lBR1YsT0FBQUMsaUVBQUFBLENBQUFQLFVBQUFRLE1BQUEsQ0FBQVY7QUFDRjtBQUtBLFNBQUFXLGdCQUFBWCxJQUFBLEVBQUFDLE1BQUE7SUFDRSxNQUFBQyxZQUFBQywrREFBQUEsQ0FBQUYsUUFBQTtRQUF5Q0ksT0FBQTtRQUNoQ0MsS0FBQTtJQUNGO0lBR1AsT0FBQUcsaUVBQUFBLENBQUFQLFVBQUFRLE1BQUEsQ0FBQVY7QUFDRjtBQUdBLE1BQUFZLDRDQUFBO0lBQWtEO0lBQ2hEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUVGO0FBS0EsU0FBQUMsbUJBQUFiLElBQUEsRUFBQUMsTUFBQTtJQUNFLElBQUFhO0lBRUEsSUFBQWIsUUFBQTtRQUNFYSxpQkFBQWI7SUFBaUI7UUFFakIsTUFBQWMsYUFBQUMsbUVBQUFBO1FBRUFGLGlCQUFBQyxXQUFBRSxlQUFBLEdBQUFoQixNQUFBO0lBQTZDO0lBRy9DLE1BQUFpQixxQkFBQU4sMENBQUFPLElBQUEsQ0FBcUUsQ0FBQUMsVUFBQU4sbUJBQUFNLFdBQUFOLGVBQUFPLFVBQUEsSUFBQUQsUUFBQTtJQUtyRSxNQUFBbEIsWUFBQWMsbUVBQUFBLENBQUFGLGdCQUFBO1FBQXFEUSxPQUFBSixxQkFBQTtRQUNiSyxTQUFBO0lBQzdCO0lBR1gsSUFBQUMsYUFBQSxDQUFBeEIsS0FBQXlCLE9BQUEsS0FBQUMsS0FBQUMsR0FBQTtJQUVBLElBQUFILGFBQUEsQ0FBQWhDLGNBQUFDLE9BQUEsSUFBQStCLGFBQUFoQyxjQUFBQyxPQUFBO1FBSUUsT0FBQVMsVUFBQVEsTUFBQTtJQUFvQztJQUd0QyxZQUFBa0IsTUFBQUMsT0FBQSxJQUFBQyxPQUFBQyxPQUFBLENBQUF2QyxlQUFBO1FBQ0UsSUFBQXdDLEtBQUFDLEdBQUEsQ0FBQVQsY0FBQUssUUFBQTtZQUNFLE9BQUEzQixVQUFBUSxNQUFBLENBQWlCc0IsS0FBQUUsS0FBQSxDQUFBVixhQUNNSTtRQUV2QjtRQUdGSixjQUFBSztJQUFjO0lBR2hCLE9BQUFwQixpRUFBQUEsQ0FBQVAsVUFBQVEsTUFBQSxDQUFBc0IsS0FBQUUsS0FBQSxDQUFBVixhQUFBO0FBQ0Y7QUFNQSxTQUFBVyxrQkFBQW5DLElBQUEsRUFBQUMsTUFBQTtJQUNFLE9BQUFELEtBQUF5QixPQUFBLEtBQUFDLEtBQUFDLEdBQUEsS0FBQXRDLHlCQUFBd0IsbUJBQUFiLE1BQUFDLFVBQUFVLGdCQUFBWCxNQUFBQztBQUdGO0FBZU8sTUFBQW1DLDBCQUFBQyxpREFBQUEsQ0FBa0IsR0FFckJyQyxJQUFBLEVBQ0VDLE1BQUEsRUFDQXFDLFVBQUFDLGlCQUFBSixpQkFBQSxFQUMyQkssT0FBQUMsY0FBQTFDLGlCQUFBLEVBQ04yQyxRQUFBLEVBQ3JCQyxXQUFBckQsZUFBQSxFQUNXc0QsT0FBQSxFQUNYLEdBQUFDLE9BQ0csRUFBQUM7SUFJTCxNQUFBQyxZQUFBSCxVQUFBSSxzREFBQUEsR0FBQTtJQUNBLE9BQUFDLFVBQUFDLElBQUEsR0FBQUMsb0VBQUFBO0lBQ0EsTUFBQUMsYUFBQUMsOENBQUFBLENBQUEsUUFBQTNCLEtBQUExQixPQUFBO1FBQUFBO0tBQUE7SUFDQSxNQUFBc0QsaUJBQUFELDhDQUFBQSxDQUF1QixJQUFBRCxXQUFBRyxXQUFBLElBQ1E7UUFBQUg7S0FBQTtJQUcvQixNQUFBWixRQUFBYSw4Q0FBQUEsQ0FBYyxXQUFBWixnQkFBQSxhQUFBQSxZQUFBVyxZQUFBbkQsVUFBQXdDLGFBSU47UUFBQUE7UUFBQVc7UUFBQUY7S0FBQTtJQUlSLE1BQUFaLFdBQUFlLDhDQUFBQSxDQUFpQixXQUFBZCxtQkFBQSxhQUFBQSxlQUFBYSxZQUFBbkQsVUFBQXNDLGdCQUlUO1FBQUFBO1FBQUFhO1FBQUFGO0tBQUE7SUFLUk0sb0VBQVdBLENBQVhQLFVBQUFOO0lBRUEscUNBQUFjLGdEQUFBLENBQUFWLFdBQUE7UUFDRyxHQUFBRixLQUFBO1FBQ0tjLEtBQUFiO1FBQ0NKLFVBQUFBLFlBQUFZO1FBQ2lCZDtJQUN0QixHQUFBRjtBQUdGO0FBS04sSUFBQXNCLElBQUE7SUFDRXhCLFVBQUF5QixXQUFBLEdBQUF0RTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4uLy4uL3NyYy9wcmltaXRpdmVzL1RpbWVzdGFtcC50c3g/ZDgyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgU2xvdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3Qtc2xvdFwiO1xuaW1wb3J0IHR5cGUgeyBSZWFjdE5vZGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50UHJvcHNXaXRoU2xvdCB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gXCIuLi91dGlscy9jYXBpdGFsaXplXCI7XG5pbXBvcnQgeyBkYXRlVGltZUZvcm1hdCwgcmVsYXRpdmVUaW1lRm9ybWF0IH0gZnJvbSBcIi4uL3V0aWxzL2ludGxcIjtcbmltcG9ydCB7IHVzZUludGVydmFsIH0gZnJvbSBcIi4uL3V0aWxzL3VzZS1pbnRlcnZhbFwiO1xuaW1wb3J0IHsgdXNlUmVyZW5kZXIgfSBmcm9tIFwiLi4vdXRpbHMvdXNlLXJlcmVuZGVyXCI7XG5cbmNvbnN0IERZTkFNSUNfREFURV9USFJFU0hPTEQgPSAzICogMjQgKiA2MCAqIDYwICogMTAwMDsgLy8gMyBkYXlzXG5jb25zdCBSRU5ERVJfSU5URVJWQUwgPSAzMCAqIDEwMDA7IC8vIDMwIHNlY29uZHNcblxuY29uc3QgVElNRVNUQU1QX05BTUUgPSBcIlRpbWVzdGFtcFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVzdGFtcFByb3BzXG4gIGV4dGVuZHMgT21pdDxDb21wb25lbnRQcm9wc1dpdGhTbG90PFwidGltZVwiPiwgXCJjaGlsZHJlblwiIHwgXCJ0aXRsZVwiPiB7XG4gIC8qKlxuICAgKiBUaGUgZGF0ZSB0byBkaXNwbGF5LlxuICAgKi9cbiAgZGF0ZTogRGF0ZSB8IHN0cmluZyB8IG51bWJlcjtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0byBmb3JtYXQgdGhlIGRpc3BsYXllZCBkYXRlLlxuICAgKi9cbiAgY2hpbGRyZW4/OiAoZGF0ZTogRGF0ZSwgbG9jYWxlPzogc3RyaW5nKSA9PiBSZWFjdE5vZGU7XG5cbiAgLyoqXG4gICAqIFRoZSBgdGl0bGVgIGF0dHJpYnV0ZSdzIHZhbHVlIG9yIGEgZnVuY3Rpb24gdG8gZm9ybWF0IGl0LlxuICAgKi9cbiAgdGl0bGU/OiBzdHJpbmcgfCAoKGRhdGU6IERhdGUsIGxvY2FsZT86IHN0cmluZykgPT4gc3RyaW5nKTtcblxuICAvKipcbiAgICogVGhlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyBhdCB3aGljaCB0aGUgY29tcG9uZW50IHdpbGwgcmUtcmVuZGVyLlxuICAgKiBDYW4gYmUgc2V0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSByZS1yZW5kZXJpbmcuXG4gICAqL1xuICBpbnRlcnZhbD86IG51bWJlciB8IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgbG9jYWxlIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBkYXRlLlxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nO1xufVxuXG5jb25zdCByZWxhdGl2ZVVuaXRzID0ge1xuICBzZWNvbmRzOiA2MCxcbiAgbWludXRlczogNjAsXG4gIGhvdXJzOiAyNCxcbiAgZGF5czogNyxcbiAgd2Vla3M6IDQuMzQ1MjQsXG4gIG1vbnRoczogMTIsXG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBkYXRlIGFic29sdXRlbHkuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFZlcmJvc2VEYXRlKGRhdGU6IERhdGUsIGxvY2FsZT86IHN0cmluZykge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBkYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCJudW1lcmljXCIsXG4gICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICBtaW51dGU6IFwibnVtZXJpY1wiLFxuICB9KTtcblxuICByZXR1cm4gY2FwaXRhbGl6ZShmb3JtYXR0ZXIuZm9ybWF0KGRhdGUpKTtcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSBhYnNvbHV0ZWx5IHdpdGggb25seSB0aGUgZGF5IGFuZCBtb250aC5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0U2hvcnREYXRlKGRhdGU6IERhdGUsIGxvY2FsZT86IHN0cmluZykge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBkYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICBtb250aDogXCJzaG9ydFwiLFxuICAgIGRheTogXCJudW1lcmljXCIsXG4gIH0pO1xuXG4gIHJldHVybiBjYXBpdGFsaXplKGZvcm1hdHRlci5mb3JtYXQoZGF0ZSkpO1xufVxuXG4vLyBTb21lIGxvY2FsZXMnIHJlbGF0aXZlIGZvcm1hdHRpbmcgY2FuIGJlIGJyb2tlbiAoZS5nLiBcIi0xaFwiKSB3aGVuIHVzaW5nIHRoZSBuYXJyb3cgc3R5bGUuXG5jb25zdCBsb2NhbGVzV2l0aEJyb2tlbk5hcnJvd1JlbGF0aXZlRm9ybWF0dGluZyA9IFtcbiAgXCJiclwiLFxuICBcImZyXCIsXG4gIFwibmJcIixcbiAgXCJublwiLFxuICBcIm5vXCIsXG4gIFwicm9cIixcbiAgXCJzdlwiLFxuXTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSByZWxhdGl2ZWx5LlxuICovXG5mdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZURhdGUoZGF0ZTogRGF0ZSwgbG9jYWxlPzogc3RyaW5nKSB7XG4gIGxldCByZXNvbHZlZExvY2FsZTogc3RyaW5nO1xuXG4gIGlmIChsb2NhbGUpIHtcbiAgICByZXNvbHZlZExvY2FsZSA9IGxvY2FsZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSByZWxhdGl2ZVRpbWVGb3JtYXQoKTtcblxuICAgIHJlc29sdmVkTG9jYWxlID0gZm9ybWF0dGVyLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgfVxuXG4gIGNvbnN0IGlzQnJva2VuV2hlbk5hcnJvdyA9IGxvY2FsZXNXaXRoQnJva2VuTmFycm93UmVsYXRpdmVGb3JtYXR0aW5nLnNvbWUoXG4gICAgKGxvY2FsZSkgPT5cbiAgICAgIHJlc29sdmVkTG9jYWxlID09PSBsb2NhbGUgfHwgcmVzb2x2ZWRMb2NhbGUuc3RhcnRzV2l0aChgJHtsb2NhbGV9LWApXG4gICk7XG5cbiAgY29uc3QgZm9ybWF0dGVyID0gcmVsYXRpdmVUaW1lRm9ybWF0KHJlc29sdmVkTG9jYWxlLCB7XG4gICAgc3R5bGU6IGlzQnJva2VuV2hlbk5hcnJvdyA/IFwic2hvcnRcIiA6IFwibmFycm93XCIsXG4gICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gIH0pO1xuXG4gIGxldCBkaWZmZXJlbmNlID0gKGRhdGUuZ2V0VGltZSgpIC0gRGF0ZS5ub3coKSkgLyAxMDAwO1xuXG4gIGlmIChcbiAgICBkaWZmZXJlbmNlID4gLXJlbGF0aXZlVW5pdHMuc2Vjb25kcyAmJlxuICAgIGRpZmZlcmVuY2UgPCByZWxhdGl2ZVVuaXRzLnNlY29uZHNcbiAgKSB7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoMCwgXCJzZWNvbmRzXCIpO1xuICB9XG5cbiAgZm9yIChjb25zdCBbdW5pdCwgbGVuZ3RoXSBvZiBPYmplY3QuZW50cmllcyhyZWxhdGl2ZVVuaXRzKSkge1xuICAgIGlmIChNYXRoLmFicyhkaWZmZXJlbmNlKSA8IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoXG4gICAgICAgIE1hdGgucm91bmQoZGlmZmVyZW5jZSksXG4gICAgICAgIHVuaXQgYXMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXRVbml0XG4gICAgICApO1xuICAgIH1cblxuICAgIGRpZmZlcmVuY2UgLz0gbGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGNhcGl0YWxpemUoZm9ybWF0dGVyLmZvcm1hdChNYXRoLnJvdW5kKGRpZmZlcmVuY2UpLCBcInllYXJzXCIpKTtcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSByZWxhdGl2ZWx5IGlmIGl0J3MgcmVjZW50LFxuICogb3RoZXJ3aXNlIGFic29sdXRlbHkgd2l0aCBvbmx5IHRoZSBkYXkgYW5kIG1vbnRoLlxuICovXG5mdW5jdGlvbiBmb3JtYXREeW5hbWljRGF0ZShkYXRlOiBEYXRlLCBsb2NhbGU/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpID4gRGF0ZS5ub3coKSAtIERZTkFNSUNfREFURV9USFJFU0hPTERcbiAgICA/IGZvcm1hdFJlbGF0aXZlRGF0ZShkYXRlLCBsb2NhbGUpXG4gICAgOiBmb3JtYXRTaG9ydERhdGUoZGF0ZSwgbG9jYWxlKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5cyBhIGZvcm1hdHRlZCBkYXRlLCBhbmQgYXV0b21hdGljYWxseSByZS1yZW5kZXJzIHRvIHN1cHBvcnQgcmVsYXRpdmVcbiAqIGZvcm1hdHRpbmcuIERlZmF1bHRzIHRvIHJlbGF0aXZlIGZvcm1hdHRpbmcgZm9yIHJlY2VudCBkYXRlcyBhbmQgYSBzaG9ydFxuICogYWJzb2x1dGUgZm9ybWF0dGluZyBmb3Igb2xkZXIgb25lcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogPFRpbWVzdGFtcCBkYXRlPXtuZXcgRGF0ZSgpfSAvPlxuICpcbiAqIEBleGFtcGxlXG4gKiA8VGltZXN0YW1wIGRhdGU9e25ldyBEYXRlKCl9IHRpdGxlPXsoZGF0ZSkgPT4gZGF0ZS50b0lTT1N0cmluZygpfSBpbnRlcnZhbD17ZmFsc2V9PlxuICogICB7KGRhdGUpID0+IGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG4gKiA8L1RpbWVzdGFtcD5cbiAqL1xuZXhwb3J0IGNvbnN0IFRpbWVzdGFtcCA9IGZvcndhcmRSZWY8SFRNTFRpbWVFbGVtZW50LCBUaW1lc3RhbXBQcm9wcz4oXG4gIChcbiAgICB7XG4gICAgICBkYXRlLFxuICAgICAgbG9jYWxlLFxuICAgICAgY2hpbGRyZW46IHJlbmRlckNoaWxkcmVuID0gZm9ybWF0RHluYW1pY0RhdGUsXG4gICAgICB0aXRsZTogcmVuZGVyVGl0bGUgPSBmb3JtYXRWZXJib3NlRGF0ZSxcbiAgICAgIGRhdGVUaW1lLFxuICAgICAgaW50ZXJ2YWwgPSBSRU5ERVJfSU5URVJWQUwsXG4gICAgICBhc0NoaWxkLFxuICAgICAgLi4ucHJvcHNcbiAgICB9LFxuICAgIGZvcndhcmRlZFJlZlxuICApID0+IHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBhc0NoaWxkID8gU2xvdCA6IFwidGltZVwiO1xuICAgIGNvbnN0IFtyZXJlbmRlciwga2V5XSA9IHVzZVJlcmVuZGVyKCk7XG4gICAgY29uc3QgcGFyc2VkRGF0ZSA9IHVzZU1lbW8oKCkgPT4gbmV3IERhdGUoZGF0ZSksIFtkYXRlXSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZERhdGUgPSB1c2VNZW1vKFxuICAgICAgKCkgPT4gcGFyc2VkRGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgW3BhcnNlZERhdGVdXG4gICAgKTtcbiAgICBjb25zdCB0aXRsZSA9IHVzZU1lbW8oXG4gICAgICAoKSA9PlxuICAgICAgICB0eXBlb2YgcmVuZGVyVGl0bGUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcmVuZGVyVGl0bGUocGFyc2VkRGF0ZSwgbG9jYWxlKVxuICAgICAgICAgIDogcmVuZGVyVGl0bGUsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICBbcmVuZGVyVGl0bGUsIHBhcnNlZERhdGUsIGtleV1cbiAgICApO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdXNlTWVtbyhcbiAgICAgICgpID0+XG4gICAgICAgIHR5cGVvZiByZW5kZXJDaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyByZW5kZXJDaGlsZHJlbihwYXJzZWREYXRlLCBsb2NhbGUpXG4gICAgICAgICAgOiByZW5kZXJDaGlsZHJlbixcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgIFtyZW5kZXJDaGlsZHJlbiwgcGFyc2VkRGF0ZSwga2V5XVxuICAgICk7XG5cbiAgICB1c2VJbnRlcnZhbChyZXJlbmRlciwgaW50ZXJ2YWwpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb21wb25lbnRcbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgICAgZGF0ZVRpbWU9e2RhdGVUaW1lID8/IG5vcm1hbGl6ZWREYXRlfVxuICAgICAgICB0aXRsZT17dGl0bGV9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvQ29tcG9uZW50PlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgVGltZXN0YW1wLmRpc3BsYXlOYW1lID0gVElNRVNUQU1QX05BTUU7XG59XG4iXSwibmFtZXMiOlsiRFlOQU1JQ19EQVRFX1RIUkVTSE9MRCIsIlJFTkRFUl9JTlRFUlZBTCIsIlRJTUVTVEFNUF9OQU1FIiwicmVsYXRpdmVVbml0cyIsInNlY29uZHMiLCJtaW51dGVzIiwiaG91cnMiLCJkYXlzIiwid2Vla3MiLCJtb250aHMiLCJmb3JtYXRWZXJib3NlRGF0ZSIsImRhdGUiLCJsb2NhbGUiLCJmb3JtYXR0ZXIiLCJkYXRlVGltZUZvcm1hdCIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJjYXBpdGFsaXplIiwiZm9ybWF0IiwiZm9ybWF0U2hvcnREYXRlIiwibG9jYWxlc1dpdGhCcm9rZW5OYXJyb3dSZWxhdGl2ZUZvcm1hdHRpbmciLCJmb3JtYXRSZWxhdGl2ZURhdGUiLCJyZXNvbHZlZExvY2FsZSIsImZvcm1hdHRlcjIiLCJyZWxhdGl2ZVRpbWVGb3JtYXQiLCJyZXNvbHZlZE9wdGlvbnMiLCJpc0Jyb2tlbldoZW5OYXJyb3ciLCJzb21lIiwibG9jYWxlMiIsInN0YXJ0c1dpdGgiLCJzdHlsZSIsIm51bWVyaWMiLCJkaWZmZXJlbmNlIiwiZ2V0VGltZSIsIkRhdGUiLCJub3ciLCJ1bml0IiwibGVuZ3RoIiwiT2JqZWN0IiwiZW50cmllcyIsIk1hdGgiLCJhYnMiLCJyb3VuZCIsImZvcm1hdER5bmFtaWNEYXRlIiwiVGltZXN0YW1wIiwiZm9yd2FyZFJlZiIsImNoaWxkcmVuIiwicmVuZGVyQ2hpbGRyZW4iLCJ0aXRsZSIsInJlbmRlclRpdGxlIiwiZGF0ZVRpbWUiLCJpbnRlcnZhbCIsImFzQ2hpbGQiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsIkNvbXBvbmVudCIsIlNsb3QiLCJyZXJlbmRlciIsImtleSIsInVzZVJlcmVuZGVyIiwicGFyc2VkRGF0ZSIsInVzZU1lbW8iLCJub3JtYWxpemVkRGF0ZSIsInRvSVNPU3RyaW5nIiwidXNlSW50ZXJ2YWwiLCJSZWFjdF9fZGVmYXVsdCIsImNyZWF0ZUVsZW1lbnQiLCJyZWYiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/Timestamp.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/internal/Emoji.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/internal/Emoji.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Emoji: () => (/* binding */ Emoji)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../constants.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.mjs\");\n\n\n\n\nconst Emoji = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({ emoji, style, asChild, ...props }, forwardedRef) => {\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_1__.Slot : \"span\";\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n      role: \"img\",\n      \"aria-label\": emoji,\n      \"data-emoji\": emoji,\n      style: {\n        ...style,\n        fontFamily: _constants_mjs__WEBPACK_IMPORTED_MODULE_2__.EMOJI_FONT_FAMILY,\n        display: \"inline-flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        width: \"1em\",\n        whiteSpace: \"nowrap\"\n      },\n      ...props,\n      ref: forwardedRef\n    }, emoji);\n  }\n);\n\n\n//# sourceMappingURL=Emoji.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL2ludGVybmFsL0Vtb2ppLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ087QUFDSzs7QUFFeEQsY0FBYyxpREFBVTtBQUN4QixLQUFLLGlDQUFpQztBQUN0QyxnQ0FBZ0Msc0RBQUk7QUFDcEMsMkJBQTJCLGdEQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL2ludGVybmFsL0Vtb2ppLm1qcz9lZmIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsb3QgfSBmcm9tICdAcmFkaXgtdWkvcmVhY3Qtc2xvdCc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVNT0pJX0ZPTlRfRkFNSUxZIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLm1qcyc7XG5cbmNvbnN0IEVtb2ppID0gZm9yd2FyZFJlZihcbiAgKHsgZW1vamksIHN0eWxlLCBhc0NoaWxkLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBhc0NoaWxkID8gU2xvdCA6IFwic3BhblwiO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgIHJvbGU6IFwiaW1nXCIsXG4gICAgICBcImFyaWEtbGFiZWxcIjogZW1vamksXG4gICAgICBcImRhdGEtZW1vamlcIjogZW1vamksXG4gICAgICBzdHlsZToge1xuICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgZm9udEZhbWlseTogRU1PSklfRk9OVF9GQU1JTFksXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWZsZXhcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgIHdpZHRoOiBcIjFlbVwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgICB9LFxuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgIH0sIGVtb2ppKTtcbiAgfVxuKTtcblxuZXhwb3J0IHsgRW1vamkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtb2ppLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/internal/Emoji.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/shared.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/shared.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCurrentUserId: () => (/* binding */ useCurrentUserId),\n/* harmony export */   useMentionSuggestions: () => (/* binding */ useMentionSuggestions)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n\n\n\n\n\nconst MENTION_SUGGESTIONS_DEBOUNCE = 500;\nconst _cachesByClient = /* @__PURE__ */ new WeakMap();\nfunction getMentionSuggestionsCacheForClient(client) {\n  let cache = _cachesByClient.get(client);\n  if (!cache) {\n    cache = /* @__PURE__ */ new Map();\n    _cachesByClient.set(client, cache);\n  }\n  return cache;\n}\nfunction useMentionSuggestions(search) {\n  const client = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__.useClient)();\n  const room = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__._useRoom)();\n  const [mentionSuggestions, setMentionSuggestions] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const lastInvokedAt = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const resolveMentionSuggestions = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].resolveMentionSuggestions;\n    if (search === void 0 || !resolveMentionSuggestions) {\n      return;\n    }\n    const resolveMentionSuggestionsArgs = { text: search, roomId: room.id };\n    const mentionSuggestionsCacheKey = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(resolveMentionSuggestionsArgs);\n    let debounceTimeout;\n    let isCanceled = false;\n    const mentionSuggestionsCache = getMentionSuggestionsCacheForClient(client);\n    const getMentionSuggestions = async () => {\n      try {\n        lastInvokedAt.current = performance.now();\n        const mentionSuggestions2 = await resolveMentionSuggestions(\n          resolveMentionSuggestionsArgs\n        );\n        if (!isCanceled) {\n          setMentionSuggestions(mentionSuggestions2);\n          mentionSuggestionsCache.set(\n            mentionSuggestionsCacheKey,\n            mentionSuggestions2\n          );\n        }\n      } catch (error) {\n        console.error(error?.message);\n      }\n    };\n    if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {\n      setMentionSuggestions(\n        mentionSuggestionsCache.get(mentionSuggestionsCacheKey)\n      );\n    } else if (!lastInvokedAt.current || Math.abs(performance.now() - lastInvokedAt.current) > MENTION_SUGGESTIONS_DEBOUNCE) {\n      void getMentionSuggestions();\n    } else {\n      debounceTimeout = window.setTimeout(() => {\n        void getMentionSuggestions();\n      }, MENTION_SUGGESTIONS_DEBOUNCE);\n    }\n    return () => {\n      isCanceled = true;\n      window.clearTimeout(debounceTimeout);\n    };\n  }, [client, room.id, search]);\n  return mentionSuggestions;\n}\nfunction useCurrentUserIdFromRoom() {\n  return (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__._useSelf)((user) => typeof user.id === \"string\" ? user.id : null);\n}\nfunction useCurrentUserIdFromClient_withClient(client) {\n  const currentUserIdStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].currentUserIdStore;\n  return (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(\n    currentUserIdStore.subscribe,\n    currentUserIdStore.get,\n    currentUserIdStore.get\n  );\n}\nfunction useCurrentUserId() {\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__.ClientContext);\n  const room = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__.RoomContext);\n  if (room !== null) {\n    return useCurrentUserIdFromRoom();\n  } else if (client !== null) {\n    return useCurrentUserIdFromClient_withClient(client);\n  } else {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\n      \"LiveblocksProvider or RoomProvider are missing from the React tree.\"\n    );\n  }\n}\n\n\n//# sourceMappingURL=shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zaGFyZWQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErRDtBQUM2QjtBQUN6QztBQUMwQjs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0REFBUztBQUMxQixlQUFlLDJEQUFPO0FBQ3RCLHNEQUFzRCwyQ0FBdUI7QUFDN0Usd0JBQXdCLHlDQUFxQjtBQUM3QyxFQUFFLDRDQUF3QjtBQUMxQiw2Q0FBNkMsdURBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHVDQUF1QywyREFBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsU0FBUywyREFBTztBQUNoQjtBQUNBO0FBQ0Esb0NBQW9DLHVEQUFTO0FBQzdDLFNBQVMsMkZBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpREFBVSxDQUFDLDREQUFhO0FBQ3pDLGVBQWUsaURBQVUsQ0FBQywwREFBVztBQUNyQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLElBQUksdURBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFbUQ7QUFDbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zaGFyZWQubWpzP2VjMTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga0ludGVybmFsLCBzdHJpbmdpZnksIHJhaXNlIH0gZnJvbSAnQGxpdmVibG9ja3MvY29yZSc7XG5pbXBvcnQgeyB1c2VDbGllbnQsIHVzZVJvb20sIENsaWVudENvbnRleHQsIFJvb21Db250ZXh0LCB1c2VTZWxmIH0gZnJvbSAnQGxpdmVibG9ja3MvcmVhY3QnO1xuaW1wb3J0IFJlYWN0X19kZWZhdWx0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanMnO1xuXG5jb25zdCBNRU5USU9OX1NVR0dFU1RJT05TX0RFQk9VTkNFID0gNTAwO1xuY29uc3QgX2NhY2hlc0J5Q2xpZW50ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXRNZW50aW9uU3VnZ2VzdGlvbnNDYWNoZUZvckNsaWVudChjbGllbnQpIHtcbiAgbGV0IGNhY2hlID0gX2NhY2hlc0J5Q2xpZW50LmdldChjbGllbnQpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIF9jYWNoZXNCeUNsaWVudC5zZXQoY2xpZW50LCBjYWNoZSk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlO1xufVxuZnVuY3Rpb24gdXNlTWVudGlvblN1Z2dlc3Rpb25zKHNlYXJjaCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgW21lbnRpb25TdWdnZXN0aW9ucywgc2V0TWVudGlvblN1Z2dlc3Rpb25zXSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKCk7XG4gIGNvbnN0IGxhc3RJbnZva2VkQXQgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoKTtcbiAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zID0gY2xpZW50W2tJbnRlcm5hbF0ucmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucztcbiAgICBpZiAoc2VhcmNoID09PSB2b2lkIDAgfHwgIXJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uc0FyZ3MgPSB7IHRleHQ6IHNlYXJjaCwgcm9vbUlkOiByb29tLmlkIH07XG4gICAgY29uc3QgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVLZXkgPSBzdHJpbmdpZnkocmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uc0FyZ3MpO1xuICAgIGxldCBkZWJvdW5jZVRpbWVvdXQ7XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSA9IGdldE1lbnRpb25TdWdnZXN0aW9uc0NhY2hlRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgY29uc3QgZ2V0TWVudGlvblN1Z2dlc3Rpb25zID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGFzdEludm9rZWRBdC5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNvbnN0IG1lbnRpb25TdWdnZXN0aW9uczIgPSBhd2FpdCByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zKFxuICAgICAgICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnNBcmdzXG4gICAgICAgICk7XG4gICAgICAgIGlmICghaXNDYW5jZWxlZCkge1xuICAgICAgICAgIHNldE1lbnRpb25TdWdnZXN0aW9ucyhtZW50aW9uU3VnZ2VzdGlvbnMyKTtcbiAgICAgICAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZS5zZXQoXG4gICAgICAgICAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZUtleSxcbiAgICAgICAgICAgIG1lbnRpb25TdWdnZXN0aW9uczJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yPy5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZS5oYXMobWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVLZXkpKSB7XG4gICAgICBzZXRNZW50aW9uU3VnZ2VzdGlvbnMoXG4gICAgICAgIG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLmdldChtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZUtleSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghbGFzdEludm9rZWRBdC5jdXJyZW50IHx8IE1hdGguYWJzKHBlcmZvcm1hbmNlLm5vdygpIC0gbGFzdEludm9rZWRBdC5jdXJyZW50KSA+IE1FTlRJT05fU1VHR0VTVElPTlNfREVCT1VOQ0UpIHtcbiAgICAgIHZvaWQgZ2V0TWVudGlvblN1Z2dlc3Rpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYm91bmNlVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdm9pZCBnZXRNZW50aW9uU3VnZ2VzdGlvbnMoKTtcbiAgICAgIH0sIE1FTlRJT05fU1VHR0VTVElPTlNfREVCT1VOQ0UpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNDYW5jZWxlZCA9IHRydWU7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZW91dCk7XG4gICAgfTtcbiAgfSwgW2NsaWVudCwgcm9vbS5pZCwgc2VhcmNoXSk7XG4gIHJldHVybiBtZW50aW9uU3VnZ2VzdGlvbnM7XG59XG5mdW5jdGlvbiB1c2VDdXJyZW50VXNlcklkRnJvbVJvb20oKSB7XG4gIHJldHVybiB1c2VTZWxmKCh1c2VyKSA9PiB0eXBlb2YgdXNlci5pZCA9PT0gXCJzdHJpbmdcIiA/IHVzZXIuaWQgOiBudWxsKTtcbn1cbmZ1bmN0aW9uIHVzZUN1cnJlbnRVc2VySWRGcm9tQ2xpZW50X3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGNvbnN0IGN1cnJlbnRVc2VySWRTdG9yZSA9IGNsaWVudFtrSW50ZXJuYWxdLmN1cnJlbnRVc2VySWRTdG9yZTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIGN1cnJlbnRVc2VySWRTdG9yZS5zdWJzY3JpYmUsXG4gICAgY3VycmVudFVzZXJJZFN0b3JlLmdldCxcbiAgICBjdXJyZW50VXNlcklkU3RvcmUuZ2V0XG4gICk7XG59XG5mdW5jdGlvbiB1c2VDdXJyZW50VXNlcklkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDb250ZXh0KENsaWVudENvbnRleHQpO1xuICBjb25zdCByb29tID0gdXNlQ29udGV4dChSb29tQ29udGV4dCk7XG4gIGlmIChyb29tICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHVzZUN1cnJlbnRVc2VySWRGcm9tUm9vbSgpO1xuICB9IGVsc2UgaWYgKGNsaWVudCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB1c2VDdXJyZW50VXNlcklkRnJvbUNsaWVudF93aXRoQ2xpZW50KGNsaWVudCk7XG4gIH0gZWxzZSB7XG4gICAgcmFpc2UoXG4gICAgICBcIkxpdmVibG9ja3NQcm92aWRlciBvciBSb29tUHJvdmlkZXIgYXJlIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHsgdXNlQ3VycmVudFVzZXJJZCwgdXNlTWVudGlvblN1Z2dlc3Rpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZWQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/shared.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/auto-formatting.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/plugins/auto-formatting.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   withAutoFormatting: () => (/* binding */ withAutoFormatting)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _utils_get_character_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/get-character.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-character.mjs\");\n/* harmony import */ var _utils_get_match_range_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/get-match-range.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-match-range.mjs\");\n/* harmony import */ var _utils_is_empty_string_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/is-empty-string.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty-string.mjs\");\n/* harmony import */ var _utils_is_selection_collapsed_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/is-selection-collapsed.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-selection-collapsed.mjs\");\n\n\n\n\n\n\nconst formatters = [\n  {\n    type: \"mark\",\n    mark: \"bold\",\n    character: \"*\"\n  },\n  {\n    type: \"mark\",\n    mark: \"italic\",\n    character: \"_\"\n  },\n  {\n    type: \"mark\",\n    mark: \"strikethrough\",\n    character: \"~\"\n  },\n  {\n    type: \"mark\",\n    mark: \"code\",\n    character: \"`\"\n  }\n];\nconst markFormattingCharacters = formatters.filter((formatter) => formatter.type === \"mark\").map((formatter) => formatter.character);\nfunction formatMark(editor, text, formatter) {\n  if (text !== formatter.character) {\n    return false;\n  }\n  const match = (0,_utils_get_match_range_mjs__WEBPACK_IMPORTED_MODULE_0__.getMatchRange)(editor, editor.selection, [formatter.character]);\n  if (!match || slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(match)) {\n    return false;\n  }\n  const formattingCharacter = (0,_utils_get_character_mjs__WEBPACK_IMPORTED_MODULE_2__.getCharacterBefore)(editor, match);\n  if (!formattingCharacter || formattingCharacter.text !== formatter.character) {\n    return false;\n  }\n  const beforeCharacter = (0,_utils_get_character_mjs__WEBPACK_IMPORTED_MODULE_2__.getCharacterBefore)(editor, formattingCharacter.range);\n  if (beforeCharacter && !markFormattingCharacters.includes(beforeCharacter.text) && !(0,_utils_is_empty_string_mjs__WEBPACK_IMPORTED_MODULE_3__.isEmptyString)(beforeCharacter.text)) {\n    return false;\n  }\n  const matchText = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.string(editor, match);\n  if (matchText.trim() !== matchText) {\n    return false;\n  }\n  slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.select(editor, match);\n  editor.addMark(formatter.mark, true);\n  slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.collapse(editor, { edge: \"end\" });\n  editor.removeMark(formatter.mark);\n  slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.delete(editor, {\n    at: formattingCharacter.range\n  });\n  return true;\n}\nfunction withAutoFormatting(editor) {\n  const { insertText } = editor;\n  editor.insertText = (text, options) => {\n    if (!(0,_utils_is_selection_collapsed_mjs__WEBPACK_IMPORTED_MODULE_4__.isSelectionCollapsed)(editor.selection)) {\n      return insertText(text, options);\n    }\n    let shouldInsertText = true;\n    for (const formatter of formatters) {\n      if (formatter.type === \"mark\") {\n        if (formatMark(editor, text, formatter)) {\n          shouldInsertText = false;\n        }\n      }\n    }\n    if (shouldInsertText) {\n      insertText(text, options);\n    }\n  };\n  return editor;\n}\n\n\n//# sourceMappingURL=auto-formatting.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS9wbHVnaW5zL2F1dG8tZm9ybWF0dGluZy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtEO0FBQ2M7QUFDSDtBQUNBO0FBQ2M7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5RUFBYTtBQUM3QixnQkFBZ0Isd0NBQUs7QUFDckI7QUFDQTtBQUNBLDhCQUE4Qiw0RUFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRFQUFrQjtBQUM1QyxzRkFBc0YseUVBQWE7QUFDbkc7QUFDQTtBQUNBLG9CQUFvQix5Q0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLDZDQUFVO0FBQ1o7QUFDQSxFQUFFLDZDQUFVLG9CQUFvQixhQUFhO0FBQzdDO0FBQ0EsRUFBRSw2Q0FBVTtBQUNaO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBLFNBQVMsdUZBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3NsYXRlL3BsdWdpbnMvYXV0by1mb3JtYXR0aW5nLm1qcz9jMzZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJhbmdlLCBFZGl0b3IsIFRyYW5zZm9ybXMgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBnZXRDaGFyYWN0ZXJCZWZvcmUgfSBmcm9tICcuLi91dGlscy9nZXQtY2hhcmFjdGVyLm1qcyc7XG5pbXBvcnQgeyBnZXRNYXRjaFJhbmdlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0LW1hdGNoLXJhbmdlLm1qcyc7XG5pbXBvcnQgeyBpc0VtcHR5U3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMvaXMtZW1wdHktc3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBpc1NlbGVjdGlvbkNvbGxhcHNlZCB9IGZyb20gJy4uL3V0aWxzL2lzLXNlbGVjdGlvbi1jb2xsYXBzZWQubWpzJztcblxuY29uc3QgZm9ybWF0dGVycyA9IFtcbiAge1xuICAgIHR5cGU6IFwibWFya1wiLFxuICAgIG1hcms6IFwiYm9sZFwiLFxuICAgIGNoYXJhY3RlcjogXCIqXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwibWFya1wiLFxuICAgIG1hcms6IFwiaXRhbGljXCIsXG4gICAgY2hhcmFjdGVyOiBcIl9cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJtYXJrXCIsXG4gICAgbWFyazogXCJzdHJpa2V0aHJvdWdoXCIsXG4gICAgY2hhcmFjdGVyOiBcIn5cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJtYXJrXCIsXG4gICAgbWFyazogXCJjb2RlXCIsXG4gICAgY2hhcmFjdGVyOiBcImBcIlxuICB9XG5dO1xuY29uc3QgbWFya0Zvcm1hdHRpbmdDaGFyYWN0ZXJzID0gZm9ybWF0dGVycy5maWx0ZXIoKGZvcm1hdHRlcikgPT4gZm9ybWF0dGVyLnR5cGUgPT09IFwibWFya1wiKS5tYXAoKGZvcm1hdHRlcikgPT4gZm9ybWF0dGVyLmNoYXJhY3Rlcik7XG5mdW5jdGlvbiBmb3JtYXRNYXJrKGVkaXRvciwgdGV4dCwgZm9ybWF0dGVyKSB7XG4gIGlmICh0ZXh0ICE9PSBmb3JtYXR0ZXIuY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gZ2V0TWF0Y2hSYW5nZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIFtmb3JtYXR0ZXIuY2hhcmFjdGVyXSk7XG4gIGlmICghbWF0Y2ggfHwgUmFuZ2UuaXNDb2xsYXBzZWQobWF0Y2gpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGZvcm1hdHRpbmdDaGFyYWN0ZXIgPSBnZXRDaGFyYWN0ZXJCZWZvcmUoZWRpdG9yLCBtYXRjaCk7XG4gIGlmICghZm9ybWF0dGluZ0NoYXJhY3RlciB8fCBmb3JtYXR0aW5nQ2hhcmFjdGVyLnRleHQgIT09IGZvcm1hdHRlci5jaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYmVmb3JlQ2hhcmFjdGVyID0gZ2V0Q2hhcmFjdGVyQmVmb3JlKGVkaXRvciwgZm9ybWF0dGluZ0NoYXJhY3Rlci5yYW5nZSk7XG4gIGlmIChiZWZvcmVDaGFyYWN0ZXIgJiYgIW1hcmtGb3JtYXR0aW5nQ2hhcmFjdGVycy5pbmNsdWRlcyhiZWZvcmVDaGFyYWN0ZXIudGV4dCkgJiYgIWlzRW1wdHlTdHJpbmcoYmVmb3JlQ2hhcmFjdGVyLnRleHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBtYXRjaCk7XG4gIGlmIChtYXRjaFRleHQudHJpbSgpICE9PSBtYXRjaFRleHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBtYXRjaCk7XG4gIGVkaXRvci5hZGRNYXJrKGZvcm1hdHRlci5tYXJrLCB0cnVlKTtcbiAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHsgZWRnZTogXCJlbmRcIiB9KTtcbiAgZWRpdG9yLnJlbW92ZU1hcmsoZm9ybWF0dGVyLm1hcmspO1xuICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICBhdDogZm9ybWF0dGluZ0NoYXJhY3Rlci5yYW5nZVxuICB9KTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB3aXRoQXV0b0Zvcm1hdHRpbmcoZWRpdG9yKSB7XG4gIGNvbnN0IHsgaW5zZXJ0VGV4dCB9ID0gZWRpdG9yO1xuICBlZGl0b3IuaW5zZXJ0VGV4dCA9ICh0ZXh0LCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFpc1NlbGVjdGlvbkNvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGluc2VydFRleHQodGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBzaG91bGRJbnNlcnRUZXh0ID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGZvcm1hdHRlciBvZiBmb3JtYXR0ZXJzKSB7XG4gICAgICBpZiAoZm9ybWF0dGVyLnR5cGUgPT09IFwibWFya1wiKSB7XG4gICAgICAgIGlmIChmb3JtYXRNYXJrKGVkaXRvciwgdGV4dCwgZm9ybWF0dGVyKSkge1xuICAgICAgICAgIHNob3VsZEluc2VydFRleHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkSW5zZXJ0VGV4dCkge1xuICAgICAgaW5zZXJ0VGV4dCh0ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmV4cG9ydCB7IHdpdGhBdXRvRm9ybWF0dGluZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0by1mb3JtYXR0aW5nLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/auto-formatting.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/auto-links.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/plugins/auto-links.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isComposerBodyAutoLink: () => (/* binding */ isComposerBodyAutoLink),\n/* harmony export */   withAutoLinks: () => (/* binding */ withAutoLinks)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/is-text.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-text.mjs\");\n/* harmony import */ var _custom_links_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./custom-links.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/custom-links.mjs\");\n\n\n\n\nfunction withAutoLinks(editor) {\n  const { isInline, normalizeNode, deleteBackward } = editor;\n  editor.isInline = (element) => {\n    return element.type === \"auto-link\" ? true : isInline(element);\n  };\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n    if ((0,_custom_links_mjs__WEBPACK_IMPORTED_MODULE_0__.isComposerBodyCustomLink)(node)) {\n      return;\n    }\n    if ((0,_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_1__.isText)(node)) {\n      const parentNode = slate__WEBPACK_IMPORTED_MODULE_2__.Node.parent(editor, path);\n      if ((0,_custom_links_mjs__WEBPACK_IMPORTED_MODULE_0__.isComposerBodyCustomLink)(parentNode)) {\n        return;\n      } else if (isComposerBodyAutoLink(parentNode)) {\n        const parentPath = slate__WEBPACK_IMPORTED_MODULE_2__.Path.parent(path);\n        handleLinkEdit(editor, [parentNode, parentPath]);\n        if (!(0,_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainText)(node)) {\n          const marks = Object.keys(node).filter((key) => key !== \"text\");\n          slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unsetNodes(editor, marks, { at: path });\n        }\n      } else {\n        handleLinkCreate(editor, [node, path]);\n        handleNeighbours(editor, [node, path]);\n      }\n    }\n    normalizeNode(entry);\n  };\n  editor.deleteBackward = (unit) => {\n    deleteBackward(unit);\n    const { selection } = editor;\n    if (!selection)\n      return;\n    if (!slate__WEBPACK_IMPORTED_MODULE_2__.Range.isCollapsed(selection))\n      return;\n    const [match] = slate__WEBPACK_IMPORTED_MODULE_2__.Editor.nodes(editor, {\n      at: selection,\n      match: isComposerBodyAutoLink,\n      mode: \"lowest\"\n    });\n    if (!match)\n      return;\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unwrapNodes(editor, {\n      match: isComposerBodyAutoLink\n    });\n  };\n  return editor;\n}\nfunction isComposerBodyAutoLink(node) {\n  return slate__WEBPACK_IMPORTED_MODULE_2__.Element.isElement(node) && node.type === \"auto-link\";\n}\nconst URL_REGEX = /((https?:\\/\\/(www\\.)?)|(www\\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9().@:%_+~#?&//=]*)/;\nconst PUNCTUATION_OR_SPACE = /[.,;!?\\s()]/;\nconst PERIOD_OR_QUESTION_MARK_FOLLOWED_BY_ALPHANUMERIC = /^[.?][a-zA-Z0-9]+/;\nconst PARENTHESES = /[()]/;\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\nfunction endsWithPeriodOrQuestionMark(textContent) {\n  return textContent[textContent.length - 1] === \".\" || textContent[textContent.length - 1] === \"?\";\n}\nfunction getUrlLogicalLength(url) {\n  if (!PARENTHESES.test(url)) {\n    return url.length;\n  }\n  let logicalLength = 0;\n  let parenthesesCount = 0;\n  for (const character of url) {\n    if (character === \"(\") {\n      parenthesesCount++;\n    }\n    if (character === \")\") {\n      parenthesesCount--;\n      if (parenthesesCount < 0) {\n        break;\n      }\n    }\n    logicalLength++;\n  }\n  return logicalLength;\n}\nfunction isPreviousNodeValid(editor, path) {\n  const entry = slate__WEBPACK_IMPORTED_MODULE_2__.Editor.previous(editor, { at: path });\n  if (!entry)\n    return true;\n  return (0,_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_1__.isText)(entry[0]) && (endsWithSeparator(entry[0].text) || entry[0].text === \"\");\n}\nfunction isNextNodeValid(editor, path) {\n  const entry = slate__WEBPACK_IMPORTED_MODULE_2__.Editor.next(editor, { at: path });\n  if (!entry)\n    return true;\n  return (0,_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_1__.isText)(entry[0]) && (startsWithSeparator(entry[0].text) || entry[0].text === \"\");\n}\nfunction isContentAroundValid(editor, entry, start, end) {\n  const [node, path] = entry;\n  const text = node.text;\n  const contentBeforeIsValid = start > 0 ? isSeparator(text[start - 1]) : isPreviousNodeValid(editor, path);\n  const contentAfterIsValid = end < text.length ? isSeparator(text[end]) : isNextNodeValid(editor, path);\n  return contentBeforeIsValid && contentAfterIsValid;\n}\nconst handleLinkEdit = (editor, entry) => {\n  const [node, path] = entry;\n  const children = slate__WEBPACK_IMPORTED_MODULE_2__.Node.children(editor, path);\n  for (const [child] of children) {\n    if ((0,_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_1__.isText)(child))\n      continue;\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unwrapNodes(editor, { at: path });\n    return;\n  }\n  const text = slate__WEBPACK_IMPORTED_MODULE_2__.Node.string(node);\n  const match = URL_REGEX.exec(text);\n  if (!match || match[0] !== text) {\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unwrapNodes(editor, { at: path });\n    return;\n  }\n  if (endsWithPeriodOrQuestionMark(text)) {\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unwrapNodes(editor, { at: path });\n    const textBeforePeriod = text.slice(0, text.length - 1);\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.wrapNodes(\n      editor,\n      {\n        type: \"auto-link\",\n        url: textBeforePeriod,\n        children: []\n      },\n      {\n        at: {\n          anchor: { path, offset: 0 },\n          focus: { path, offset: textBeforePeriod.length }\n        },\n        split: true\n      }\n    );\n    return;\n  }\n  const logicalLength = getUrlLogicalLength(text);\n  if (logicalLength < text.length) {\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unwrapNodes(editor, { at: path });\n    const logicalText = text.slice(0, logicalLength);\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.wrapNodes(\n      editor,\n      {\n        type: \"auto-link\",\n        url: logicalText,\n        children: []\n      },\n      {\n        at: {\n          anchor: { path, offset: 0 },\n          focus: { path, offset: logicalText.length }\n        },\n        split: true\n      }\n    );\n    return;\n  }\n  if (!isPreviousNodeValid(editor, path) || !isNextNodeValid(editor, path)) {\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unwrapNodes(editor, { at: path });\n    return;\n  }\n  if (node.url !== text) {\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.setNodes(editor, { url: match[0] }, { at: path });\n    return;\n  }\n};\nconst handleLinkCreate = (editor, entry) => {\n  const [node, path] = entry;\n  const match = URL_REGEX.exec(node.text);\n  if (!match)\n    return;\n  const start = match.index;\n  const end = start + match[0].length;\n  if (!isContentAroundValid(editor, entry, start, end))\n    return;\n  slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.wrapNodes(\n    editor,\n    {\n      type: \"auto-link\",\n      url: match[0],\n      children: []\n    },\n    {\n      at: {\n        anchor: { path, offset: start },\n        focus: { path, offset: end }\n      },\n      split: true\n    }\n  );\n  return;\n};\nconst handleNeighbours = (editor, entry) => {\n  const [node, path] = entry;\n  const text = node.text;\n  const previousSibling = slate__WEBPACK_IMPORTED_MODULE_2__.Editor.previous(editor, { at: path });\n  if (previousSibling && isComposerBodyAutoLink(previousSibling[0])) {\n    if (PERIOD_OR_QUESTION_MARK_FOLLOWED_BY_ALPHANUMERIC.test(text)) {\n      slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unwrapNodes(editor, { at: previousSibling[1] });\n      slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.mergeNodes(editor, { at: path });\n      return;\n    }\n    if (!startsWithSeparator(text)) {\n      slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unwrapNodes(editor, { at: previousSibling[1] });\n      return;\n    }\n  }\n  const nextSibling = slate__WEBPACK_IMPORTED_MODULE_2__.Editor.next(editor, { at: path });\n  if (nextSibling && isComposerBodyAutoLink(nextSibling[0]) && !endsWithSeparator(text)) {\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.unwrapNodes(editor, { at: nextSibling[1] });\n    return;\n  }\n};\n\n\n//# sourceMappingURL=auto-links.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS9wbHVnaW5zL2F1dG8tbGlua3MubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVFO0FBQ1o7QUFDRzs7QUFFOUQ7QUFDQSxVQUFVLDBDQUEwQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyRUFBd0I7QUFDaEM7QUFDQTtBQUNBLFFBQVEsMERBQU07QUFDZCx5QkFBeUIsdUNBQUk7QUFDN0IsVUFBVSwyRUFBd0I7QUFDbEM7QUFDQSxRQUFRO0FBQ1IsMkJBQTJCLHVDQUFJO0FBQy9CO0FBQ0EsYUFBYSwrREFBVztBQUN4QjtBQUNBLFVBQVUsNkNBQVUsNkJBQTZCLFVBQVU7QUFDM0Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsU0FBUyx3Q0FBSztBQUNkO0FBQ0Esb0JBQW9CLHlDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSw2Q0FBVTtBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBTztBQUNoQjtBQUNBLHdFQUF3RSxNQUFNLGdCQUFnQixJQUFJO0FBQ2xHLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUFNLG9CQUFvQixVQUFVO0FBQ3BEO0FBQ0E7QUFDQSxTQUFTLDBEQUFNO0FBQ2Y7QUFDQTtBQUNBLGdCQUFnQix5Q0FBTSxnQkFBZ0IsVUFBVTtBQUNoRDtBQUNBO0FBQ0EsU0FBUywwREFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVDQUFJO0FBQ3ZCO0FBQ0EsUUFBUSwwREFBTTtBQUNkO0FBQ0EsSUFBSSw2Q0FBVSx1QkFBdUIsVUFBVTtBQUMvQztBQUNBO0FBQ0EsZUFBZSx1Q0FBSTtBQUNuQjtBQUNBO0FBQ0EsSUFBSSw2Q0FBVSx1QkFBdUIsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFVLHVCQUF1QixVQUFVO0FBQy9DO0FBQ0EsSUFBSSw2Q0FBVTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQVUsdUJBQXVCLFVBQVU7QUFDL0M7QUFDQSxJQUFJLDZDQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQVUsdUJBQXVCLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2Q0FBVSxvQkFBb0IsZUFBZSxJQUFJLFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw2Q0FBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkMsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlDQUFNLG9CQUFvQixVQUFVO0FBQzlEO0FBQ0E7QUFDQSxNQUFNLDZDQUFVLHVCQUF1Qix3QkFBd0I7QUFDL0QsTUFBTSw2Q0FBVSxzQkFBc0IsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZDQUFVLHVCQUF1Qix3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlDQUFNLGdCQUFnQixVQUFVO0FBQ3REO0FBQ0EsSUFBSSw2Q0FBVSx1QkFBdUIsb0JBQW9CO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFaUQ7QUFDakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS9wbHVnaW5zL2F1dG8tbGlua3MubWpzP2JkNWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudCwgTm9kZSwgUGF0aCwgVHJhbnNmb3JtcywgUmFuZ2UsIEVkaXRvciB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IGlzVGV4dCwgaXNQbGFpblRleHQgfSBmcm9tICcuLi91dGlscy9pcy10ZXh0Lm1qcyc7XG5pbXBvcnQgeyBpc0NvbXBvc2VyQm9keUN1c3RvbUxpbmsgfSBmcm9tICcuL2N1c3RvbS1saW5rcy5tanMnO1xuXG5mdW5jdGlvbiB3aXRoQXV0b0xpbmtzKGVkaXRvcikge1xuICBjb25zdCB7IGlzSW5saW5lLCBub3JtYWxpemVOb2RlLCBkZWxldGVCYWNrd2FyZCB9ID0gZWRpdG9yO1xuICBlZGl0b3IuaXNJbmxpbmUgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUgPT09IFwiYXV0by1saW5rXCIgPyB0cnVlIDogaXNJbmxpbmUoZWxlbWVudCk7XG4gIH07XG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKGVudHJ5KSA9PiB7XG4gICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gICAgaWYgKGlzQ29tcG9zZXJCb2R5Q3VzdG9tTGluayhub2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNUZXh0KG5vZGUpKSB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIGlmIChpc0NvbXBvc2VyQm9keUN1c3RvbUxpbmsocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChpc0NvbXBvc2VyQm9keUF1dG9MaW5rKHBhcmVudE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICAgICAgaGFuZGxlTGlua0VkaXQoZWRpdG9yLCBbcGFyZW50Tm9kZSwgcGFyZW50UGF0aF0pO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0KG5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbWFya3MgPSBPYmplY3Qua2V5cyhub2RlKS5maWx0ZXIoKGtleSkgPT4ga2V5ICE9PSBcInRleHRcIik7XG4gICAgICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwgbWFya3MsIHsgYXQ6IHBhdGggfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUxpbmtDcmVhdGUoZWRpdG9yLCBbbm9kZSwgcGF0aF0pO1xuICAgICAgICBoYW5kbGVOZWlnaGJvdXJzKGVkaXRvciwgW25vZGUsIHBhdGhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG4gIGVkaXRvci5kZWxldGVCYWNrd2FyZCA9ICh1bml0KSA9PiB7XG4gICAgZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IGVkaXRvcjtcbiAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIVJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBzZWxlY3Rpb24sXG4gICAgICBtYXRjaDogaXNDb21wb3NlckJvZHlBdXRvTGluayxcbiAgICAgIG1vZGU6IFwibG93ZXN0XCJcbiAgICB9KTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgcmV0dXJuO1xuICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogaXNDb21wb3NlckJvZHlBdXRvTGlua1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuZnVuY3Rpb24gaXNDb21wb3NlckJvZHlBdXRvTGluayhub2RlKSB7XG4gIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09IFwiYXV0by1saW5rXCI7XG59XG5jb25zdCBVUkxfUkVHRVggPSAvKChodHRwcz86XFwvXFwvKHd3d1xcLik/KXwod3d3XFwuKSlbLWEtekEtWjAtOUA6JS5fK34jPV17MSwyNTZ9XFwuW2EtekEtWjAtOSgpXXsxLDZ9XFxiKFstYS16QS1aMC05KCkuQDolXyt+Iz8mLy89XSopLztcbmNvbnN0IFBVTkNUVUFUSU9OX09SX1NQQUNFID0gL1suLDshP1xccygpXS87XG5jb25zdCBQRVJJT0RfT1JfUVVFU1RJT05fTUFSS19GT0xMT1dFRF9CWV9BTFBIQU5VTUVSSUMgPSAvXlsuP11bYS16QS1aMC05XSsvO1xuY29uc3QgUEFSRU5USEVTRVMgPSAvWygpXS87XG5mdW5jdGlvbiBpc1NlcGFyYXRvcihjaGFyKSB7XG4gIHJldHVybiBQVU5DVFVBVElPTl9PUl9TUEFDRS50ZXN0KGNoYXIpO1xufVxuZnVuY3Rpb24gZW5kc1dpdGhTZXBhcmF0b3IodGV4dENvbnRlbnQpIHtcbiAgcmV0dXJuIGlzU2VwYXJhdG9yKHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0c1dpdGhTZXBhcmF0b3IodGV4dENvbnRlbnQpIHtcbiAgcmV0dXJuIGlzU2VwYXJhdG9yKHRleHRDb250ZW50WzBdKTtcbn1cbmZ1bmN0aW9uIGVuZHNXaXRoUGVyaW9kT3JRdWVzdGlvbk1hcmsodGV4dENvbnRlbnQpIHtcbiAgcmV0dXJuIHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdID09PSBcIi5cIiB8fCB0ZXh0Q29udGVudFt0ZXh0Q29udGVudC5sZW5ndGggLSAxXSA9PT0gXCI/XCI7XG59XG5mdW5jdGlvbiBnZXRVcmxMb2dpY2FsTGVuZ3RoKHVybCkge1xuICBpZiAoIVBBUkVOVEhFU0VTLnRlc3QodXJsKSkge1xuICAgIHJldHVybiB1cmwubGVuZ3RoO1xuICB9XG4gIGxldCBsb2dpY2FsTGVuZ3RoID0gMDtcbiAgbGV0IHBhcmVudGhlc2VzQ291bnQgPSAwO1xuICBmb3IgKGNvbnN0IGNoYXJhY3RlciBvZiB1cmwpIHtcbiAgICBpZiAoY2hhcmFjdGVyID09PSBcIihcIikge1xuICAgICAgcGFyZW50aGVzZXNDb3VudCsrO1xuICAgIH1cbiAgICBpZiAoY2hhcmFjdGVyID09PSBcIilcIikge1xuICAgICAgcGFyZW50aGVzZXNDb3VudC0tO1xuICAgICAgaWYgKHBhcmVudGhlc2VzQ291bnQgPCAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2dpY2FsTGVuZ3RoKys7XG4gIH1cbiAgcmV0dXJuIGxvZ2ljYWxMZW5ndGg7XG59XG5mdW5jdGlvbiBpc1ByZXZpb3VzTm9kZVZhbGlkKGVkaXRvciwgcGF0aCkge1xuICBjb25zdCBlbnRyeSA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHsgYXQ6IHBhdGggfSk7XG4gIGlmICghZW50cnkpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBpc1RleHQoZW50cnlbMF0pICYmIChlbmRzV2l0aFNlcGFyYXRvcihlbnRyeVswXS50ZXh0KSB8fCBlbnRyeVswXS50ZXh0ID09PSBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzTmV4dE5vZGVWYWxpZChlZGl0b3IsIHBhdGgpIHtcbiAgY29uc3QgZW50cnkgPSBFZGl0b3IubmV4dChlZGl0b3IsIHsgYXQ6IHBhdGggfSk7XG4gIGlmICghZW50cnkpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBpc1RleHQoZW50cnlbMF0pICYmIChzdGFydHNXaXRoU2VwYXJhdG9yKGVudHJ5WzBdLnRleHQpIHx8IGVudHJ5WzBdLnRleHQgPT09IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNDb250ZW50QXJvdW5kVmFsaWQoZWRpdG9yLCBlbnRyeSwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgY29uc3QgdGV4dCA9IG5vZGUudGV4dDtcbiAgY29uc3QgY29udGVudEJlZm9yZUlzVmFsaWQgPSBzdGFydCA+IDAgPyBpc1NlcGFyYXRvcih0ZXh0W3N0YXJ0IC0gMV0pIDogaXNQcmV2aW91c05vZGVWYWxpZChlZGl0b3IsIHBhdGgpO1xuICBjb25zdCBjb250ZW50QWZ0ZXJJc1ZhbGlkID0gZW5kIDwgdGV4dC5sZW5ndGggPyBpc1NlcGFyYXRvcih0ZXh0W2VuZF0pIDogaXNOZXh0Tm9kZVZhbGlkKGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBjb250ZW50QmVmb3JlSXNWYWxpZCAmJiBjb250ZW50QWZ0ZXJJc1ZhbGlkO1xufVxuY29uc3QgaGFuZGxlTGlua0VkaXQgPSAoZWRpdG9yLCBlbnRyeSkgPT4ge1xuICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgY29uc3QgY2hpbGRyZW4gPSBOb2RlLmNoaWxkcmVuKGVkaXRvciwgcGF0aCk7XG4gIGZvciAoY29uc3QgW2NoaWxkXSBvZiBjaGlsZHJlbikge1xuICAgIGlmIChpc1RleHQoY2hpbGQpKVxuICAgICAgY29udGludWU7XG4gICAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHsgYXQ6IHBhdGggfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRleHQgPSBOb2RlLnN0cmluZyhub2RlKTtcbiAgY29uc3QgbWF0Y2ggPSBVUkxfUkVHRVguZXhlYyh0ZXh0KTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFswXSAhPT0gdGV4dCkge1xuICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7IGF0OiBwYXRoIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZW5kc1dpdGhQZXJpb2RPclF1ZXN0aW9uTWFyayh0ZXh0KSkge1xuICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7IGF0OiBwYXRoIH0pO1xuICAgIGNvbnN0IHRleHRCZWZvcmVQZXJpb2QgPSB0ZXh0LnNsaWNlKDAsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoXG4gICAgICBlZGl0b3IsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiYXV0by1saW5rXCIsXG4gICAgICAgIHVybDogdGV4dEJlZm9yZVBlcmlvZCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBhdDoge1xuICAgICAgICAgIGFuY2hvcjogeyBwYXRoLCBvZmZzZXQ6IDAgfSxcbiAgICAgICAgICBmb2N1czogeyBwYXRoLCBvZmZzZXQ6IHRleHRCZWZvcmVQZXJpb2QubGVuZ3RoIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3BsaXQ6IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsb2dpY2FsTGVuZ3RoID0gZ2V0VXJsTG9naWNhbExlbmd0aCh0ZXh0KTtcbiAgaWYgKGxvZ2ljYWxMZW5ndGggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7IGF0OiBwYXRoIH0pO1xuICAgIGNvbnN0IGxvZ2ljYWxUZXh0ID0gdGV4dC5zbGljZSgwLCBsb2dpY2FsTGVuZ3RoKTtcbiAgICBUcmFuc2Zvcm1zLndyYXBOb2RlcyhcbiAgICAgIGVkaXRvcixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJhdXRvLWxpbmtcIixcbiAgICAgICAgdXJsOiBsb2dpY2FsVGV4dCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBhdDoge1xuICAgICAgICAgIGFuY2hvcjogeyBwYXRoLCBvZmZzZXQ6IDAgfSxcbiAgICAgICAgICBmb2N1czogeyBwYXRoLCBvZmZzZXQ6IGxvZ2ljYWxUZXh0Lmxlbmd0aCB9XG4gICAgICAgIH0sXG4gICAgICAgIHNwbGl0OiB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFpc1ByZXZpb3VzTm9kZVZhbGlkKGVkaXRvciwgcGF0aCkgfHwgIWlzTmV4dE5vZGVWYWxpZChlZGl0b3IsIHBhdGgpKSB7XG4gICAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHsgYXQ6IHBhdGggfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChub2RlLnVybCAhPT0gdGV4dCkge1xuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7IHVybDogbWF0Y2hbMF0gfSwgeyBhdDogcGF0aCB9KTtcbiAgICByZXR1cm47XG4gIH1cbn07XG5jb25zdCBoYW5kbGVMaW5rQ3JlYXRlID0gKGVkaXRvciwgZW50cnkpID0+IHtcbiAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gIGNvbnN0IG1hdGNoID0gVVJMX1JFR0VYLmV4ZWMobm9kZS50ZXh0KTtcbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm47XG4gIGNvbnN0IHN0YXJ0ID0gbWF0Y2guaW5kZXg7XG4gIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICBpZiAoIWlzQ29udGVudEFyb3VuZFZhbGlkKGVkaXRvciwgZW50cnksIHN0YXJ0LCBlbmQpKVxuICAgIHJldHVybjtcbiAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoXG4gICAgZWRpdG9yLFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYXV0by1saW5rXCIsXG4gICAgICB1cmw6IG1hdGNoWzBdLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSxcbiAgICB7XG4gICAgICBhdDoge1xuICAgICAgICBhbmNob3I6IHsgcGF0aCwgb2Zmc2V0OiBzdGFydCB9LFxuICAgICAgICBmb2N1czogeyBwYXRoLCBvZmZzZXQ6IGVuZCB9XG4gICAgICB9LFxuICAgICAgc3BsaXQ6IHRydWVcbiAgICB9XG4gICk7XG4gIHJldHVybjtcbn07XG5jb25zdCBoYW5kbGVOZWlnaGJvdXJzID0gKGVkaXRvciwgZW50cnkpID0+IHtcbiAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gIGNvbnN0IHRleHQgPSBub2RlLnRleHQ7XG4gIGNvbnN0IHByZXZpb3VzU2libGluZyA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHsgYXQ6IHBhdGggfSk7XG4gIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgaXNDb21wb3NlckJvZHlBdXRvTGluayhwcmV2aW91c1NpYmxpbmdbMF0pKSB7XG4gICAgaWYgKFBFUklPRF9PUl9RVUVTVElPTl9NQVJLX0ZPTExPV0VEX0JZX0FMUEhBTlVNRVJJQy50ZXN0KHRleHQpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwgeyBhdDogcHJldmlvdXNTaWJsaW5nWzFdIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwgeyBhdDogcGF0aCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzdGFydHNXaXRoU2VwYXJhdG9yKHRleHQpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwgeyBhdDogcHJldmlvdXNTaWJsaW5nWzFdIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCBuZXh0U2libGluZyA9IEVkaXRvci5uZXh0KGVkaXRvciwgeyBhdDogcGF0aCB9KTtcbiAgaWYgKG5leHRTaWJsaW5nICYmIGlzQ29tcG9zZXJCb2R5QXV0b0xpbmsobmV4dFNpYmxpbmdbMF0pICYmICFlbmRzV2l0aFNlcGFyYXRvcih0ZXh0KSkge1xuICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7IGF0OiBuZXh0U2libGluZ1sxXSB9KTtcbiAgICByZXR1cm47XG4gIH1cbn07XG5cbmV4cG9ydCB7IGlzQ29tcG9zZXJCb2R5QXV0b0xpbmssIHdpdGhBdXRvTGlua3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG8tbGlua3MubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/auto-links.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/custom-links.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/plugins/custom-links.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isComposerBodyCustomLink: () => (/* binding */ isComposerBodyCustomLink),\n/* harmony export */   withCustomLinks: () => (/* binding */ withCustomLinks)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is-text.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-text.mjs\");\n/* harmony import */ var _utils_selection_contains_inlines_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/selection-contains-inlines.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/selection-contains-inlines.mjs\");\n\n\n\n\nfunction isUrl(string) {\n  try {\n    new URL(string);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\nfunction withCustomLinks(editor) {\n  const { isInline, normalizeNode, insertData } = editor;\n  editor.isInline = (element) => {\n    return element.type === \"custom-link\" ? true : isInline(element);\n  };\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n    if ((0,_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_0__.isText)(node)) {\n      const parentNode = slate__WEBPACK_IMPORTED_MODULE_1__.Node.parent(editor, path);\n      if (isComposerBodyCustomLink(parentNode)) {\n        if (!(0,_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainText)(node)) {\n          const marks = Object.keys(node).filter((key) => key !== \"text\");\n          slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.unsetNodes(editor, marks, { at: path });\n        }\n      }\n    }\n    normalizeNode(entry);\n  };\n  editor.insertData = (data) => {\n    const { selection } = editor;\n    const pastedText = data.getData(\"text/plain\");\n    let shouldInvokeDefaultBehavior = true;\n    if (selection && !slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(selection)) {\n      if (selection.anchor.path[0] === selection.focus.path[0]) {\n        if (isUrl(pastedText)) {\n          if (!(0,_utils_selection_contains_inlines_mjs__WEBPACK_IMPORTED_MODULE_2__.selectionContainsInlines)(editor, (node) => !(0,_utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_0__.isText)(node))) {\n            slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.wrapNodes(\n              editor,\n              {\n                type: \"custom-link\",\n                url: pastedText,\n                children: []\n              },\n              {\n                at: selection,\n                split: true,\n                match: _utils_is_text_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainText\n              }\n            );\n            shouldInvokeDefaultBehavior = false;\n          }\n        }\n      }\n    }\n    if (shouldInvokeDefaultBehavior) {\n      insertData(data);\n    }\n  };\n  return editor;\n}\nfunction isComposerBodyCustomLink(node) {\n  return slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(node) && node.type === \"custom-link\";\n}\n\n\n//# sourceMappingURL=custom-links.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS9wbHVnaW5zL2N1c3RvbS1saW5rcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUQ7QUFDRTtBQUN3Qjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBTTtBQUNkLHlCQUF5Qix1Q0FBSTtBQUM3QjtBQUNBLGFBQWEsK0RBQVc7QUFDeEI7QUFDQSxVQUFVLDZDQUFVLDZCQUE2QixVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0Esc0JBQXNCLHdDQUFLO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLCtGQUF3QixvQkFBb0IsMERBQU07QUFDakUsWUFBWSw2Q0FBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBTztBQUNoQjs7QUFFcUQ7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS9wbHVnaW5zL2N1c3RvbS1saW5rcy5tanM/MDY3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50LCBOb2RlLCBUcmFuc2Zvcm1zLCBSYW5nZSB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IGlzVGV4dCwgaXNQbGFpblRleHQgfSBmcm9tICcuLi91dGlscy9pcy10ZXh0Lm1qcyc7XG5pbXBvcnQgeyBzZWxlY3Rpb25Db250YWluc0lubGluZXMgfSBmcm9tICcuLi91dGlscy9zZWxlY3Rpb24tY29udGFpbnMtaW5saW5lcy5tanMnO1xuXG5mdW5jdGlvbiBpc1VybChzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHN0cmluZyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhDdXN0b21MaW5rcyhlZGl0b3IpIHtcbiAgY29uc3QgeyBpc0lubGluZSwgbm9ybWFsaXplTm9kZSwgaW5zZXJ0RGF0YSB9ID0gZWRpdG9yO1xuICBlZGl0b3IuaXNJbmxpbmUgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUgPT09IFwiY3VzdG9tLWxpbmtcIiA/IHRydWUgOiBpc0lubGluZShlbGVtZW50KTtcbiAgfTtcbiAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoZW50cnkpID0+IHtcbiAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgICBpZiAoaXNUZXh0KG5vZGUpKSB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIGlmIChpc0NvbXBvc2VyQm9keUN1c3RvbUxpbmsocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dChub2RlKSkge1xuICAgICAgICAgIGNvbnN0IG1hcmtzID0gT2JqZWN0LmtleXMobm9kZSkuZmlsdGVyKChrZXkpID0+IGtleSAhPT0gXCJ0ZXh0XCIpO1xuICAgICAgICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsIG1hcmtzLCB7IGF0OiBwYXRoIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICB9O1xuICBlZGl0b3IuaW5zZXJ0RGF0YSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IGVkaXRvcjtcbiAgICBjb25zdCBwYXN0ZWRUZXh0ID0gZGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcbiAgICBsZXQgc2hvdWxkSW52b2tlRGVmYXVsdEJlaGF2aW9yID0gdHJ1ZTtcbiAgICBpZiAoc2VsZWN0aW9uICYmICFSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdID09PSBzZWxlY3Rpb24uZm9jdXMucGF0aFswXSkge1xuICAgICAgICBpZiAoaXNVcmwocGFzdGVkVGV4dCkpIHtcbiAgICAgICAgICBpZiAoIXNlbGVjdGlvbkNvbnRhaW5zSW5saW5lcyhlZGl0b3IsIChub2RlKSA9PiAhaXNUZXh0KG5vZGUpKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoXG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY3VzdG9tLWxpbmtcIixcbiAgICAgICAgICAgICAgICB1cmw6IHBhc3RlZFRleHQsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdDogc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBpc1BsYWluVGV4dFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2hvdWxkSW52b2tlRGVmYXVsdEJlaGF2aW9yID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRJbnZva2VEZWZhdWx0QmVoYXZpb3IpIHtcbiAgICAgIGluc2VydERhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuZnVuY3Rpb24gaXNDb21wb3NlckJvZHlDdXN0b21MaW5rKG5vZGUpIHtcbiAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gXCJjdXN0b20tbGlua1wiO1xufVxuXG5leHBvcnQgeyBpc0NvbXBvc2VyQm9keUN1c3RvbUxpbmssIHdpdGhDdXN0b21MaW5rcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VzdG9tLWxpbmtzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/custom-links.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/empty-clear-formatting.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/plugins/empty-clear-formatting.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   withEmptyClearFormatting: () => (/* binding */ withEmptyClearFormatting)\n/* harmony export */ });\n/* harmony import */ var _utils_is_empty_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is-empty.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty.mjs\");\n/* harmony import */ var _utils_marks_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/marks.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/marks.mjs\");\n\n\n\nfunction withEmptyClearFormatting(editor) {\n  const { onChange } = editor;\n  editor.onChange = (options) => {\n    if ((0,_utils_is_empty_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(editor, editor.children)) {\n      (0,_utils_marks_mjs__WEBPACK_IMPORTED_MODULE_1__.removeMarks)(editor);\n    }\n    onChange(options);\n  };\n  return editor;\n}\n\n\n//# sourceMappingURL=empty-clear-formatting.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS9wbHVnaW5zL2VtcHR5LWNsZWFyLWZvcm1hdHRpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnRDtBQUNDOztBQUVqRDtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBLFFBQVEsNERBQU87QUFDZixNQUFNLDZEQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3Qvc2xhdGUvcGx1Z2lucy9lbXB0eS1jbGVhci1mb3JtYXR0aW5nLm1qcz8xNzAzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRW1wdHkgfSBmcm9tICcuLi91dGlscy9pcy1lbXB0eS5tanMnO1xuaW1wb3J0IHsgcmVtb3ZlTWFya3MgfSBmcm9tICcuLi91dGlscy9tYXJrcy5tanMnO1xuXG5mdW5jdGlvbiB3aXRoRW1wdHlDbGVhckZvcm1hdHRpbmcoZWRpdG9yKSB7XG4gIGNvbnN0IHsgb25DaGFuZ2UgfSA9IGVkaXRvcjtcbiAgZWRpdG9yLm9uQ2hhbmdlID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoaXNFbXB0eShlZGl0b3IsIGVkaXRvci5jaGlsZHJlbikpIHtcbiAgICAgIHJlbW92ZU1hcmtzKGVkaXRvcik7XG4gICAgfVxuICAgIG9uQ2hhbmdlKG9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5leHBvcnQgeyB3aXRoRW1wdHlDbGVhckZvcm1hdHRpbmcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtcHR5LWNsZWFyLWZvcm1hdHRpbmcubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/empty-clear-formatting.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/mentions.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/plugins/mentions.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MENTION_CHARACTER: () => (/* binding */ MENTION_CHARACTER),\n/* harmony export */   getMentionDraftAtSelection: () => (/* binding */ getMentionDraftAtSelection),\n/* harmony export */   insertMention: () => (/* binding */ insertMention),\n/* harmony export */   insertMentionCharacter: () => (/* binding */ insertMentionCharacter),\n/* harmony export */   isComposerBodyMention: () => (/* binding */ isComposerBodyMention),\n/* harmony export */   withMentions: () => (/* binding */ withMentions)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _utils_get_character_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/get-character.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-character.mjs\");\n/* harmony import */ var _utils_get_match_range_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/get-match-range.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-match-range.mjs\");\n/* harmony import */ var _utils_is_empty_string_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/is-empty-string.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty-string.mjs\");\n/* harmony import */ var _utils_is_selection_collapsed_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is-selection-collapsed.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-selection-collapsed.mjs\");\n\n\n\n\n\n\nconst MENTION_CHARACTER = \"@\";\nfunction getMentionDraftAtSelection(editor) {\n  const { selection } = editor;\n  if (!(0,_utils_is_selection_collapsed_mjs__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(selection)) {\n    return;\n  }\n  const match = (0,_utils_get_match_range_mjs__WEBPACK_IMPORTED_MODULE_1__.getMatchRange)(editor, selection);\n  if (!match) {\n    return;\n  }\n  const matchText = slate__WEBPACK_IMPORTED_MODULE_2__.Editor.string(editor, match);\n  if (!matchText.startsWith(MENTION_CHARACTER)) {\n    return;\n  }\n  return {\n    range: match,\n    text: matchText.substring(1)\n  };\n}\nfunction isComposerBodyMention(node) {\n  return slate__WEBPACK_IMPORTED_MODULE_2__.Element.isElement(node) && node.type === \"mention\";\n}\nfunction insertMention(editor, userId) {\n  const mention = {\n    type: \"mention\",\n    id: userId,\n    children: [{ text: \"\" }]\n  };\n  slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.insertNodes(editor, mention);\n  slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.move(editor);\n  const afterCharacter = editor.selection ? (0,_utils_get_character_mjs__WEBPACK_IMPORTED_MODULE_3__.getCharacterAfter)(editor, editor.selection) : void 0;\n  if (!afterCharacter || afterCharacter.void) {\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.insertText(editor, \" \");\n  } else if ((0,_utils_is_empty_string_mjs__WEBPACK_IMPORTED_MODULE_4__.isEmptyString)(afterCharacter.text)) {\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.move(editor);\n  }\n}\nfunction insertMentionCharacter(editor) {\n  if (!editor.selection) {\n    return;\n  }\n  const beforeCharacter = (0,_utils_get_character_mjs__WEBPACK_IMPORTED_MODULE_3__.getCharacterBefore)(editor, editor.selection, {\n    filterVoids: true\n  });\n  const afterCharacter = (0,_utils_get_character_mjs__WEBPACK_IMPORTED_MODULE_3__.getCharacterAfter)(editor, editor.selection, {\n    filterVoids: true\n  });\n  const shouldInsertSpaceBefore = beforeCharacter && !(0,_utils_is_empty_string_mjs__WEBPACK_IMPORTED_MODULE_4__.isEmptyString)(beforeCharacter.text);\n  const shouldInsertSpaceAfter = afterCharacter && !(0,_utils_is_empty_string_mjs__WEBPACK_IMPORTED_MODULE_4__.isEmptyString)(afterCharacter.text);\n  if ((0,_utils_is_selection_collapsed_mjs__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(editor.selection)) {\n    const text = (shouldInsertSpaceBefore ? \" \" : \"\") + MENTION_CHARACTER + (shouldInsertSpaceAfter ? \" \" : \"\");\n    editor.insertText(text);\n    if (shouldInsertSpaceAfter) {\n      slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.move(editor, {\n        distance: 1,\n        unit: \"character\",\n        reverse: true\n      });\n    }\n  } else {\n    const beforeText = (shouldInsertSpaceBefore ? \" \" : \"\") + MENTION_CHARACTER;\n    editor.insertText(beforeText, { at: slate__WEBPACK_IMPORTED_MODULE_2__.Range.start(editor.selection) });\n    if (shouldInsertSpaceAfter) {\n      editor.insertText(\" \", { at: slate__WEBPACK_IMPORTED_MODULE_2__.Range.end(editor.selection) });\n    }\n    slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.collapse(editor, { edge: \"end\" });\n  }\n}\nfunction withMentions(editor) {\n  const { isInline, isVoid, markableVoid, deleteBackward } = editor;\n  editor.isInline = (element) => {\n    return isComposerBodyMention(element) || isInline(element);\n  };\n  editor.isVoid = (element) => {\n    return isComposerBodyMention(element) || isVoid(element);\n  };\n  editor.markableVoid = (element) => {\n    return isComposerBodyMention(element) || markableVoid(element);\n  };\n  editor.deleteBackward = (unit) => {\n    const { selection } = editor;\n    if ((0,_utils_is_selection_collapsed_mjs__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(selection)) {\n      const [mention] = slate__WEBPACK_IMPORTED_MODULE_2__.Editor.nodes(editor, {\n        at: unit === \"character\" ? slate__WEBPACK_IMPORTED_MODULE_2__.Editor.before(editor, selection, { unit: \"character\" }) : selection,\n        match: isComposerBodyMention\n      });\n      deleteBackward(unit);\n      if (mention) {\n        slate__WEBPACK_IMPORTED_MODULE_2__.Transforms.insertText(editor, MENTION_CHARACTER);\n      }\n    } else {\n      deleteBackward(unit);\n    }\n  };\n  return editor;\n}\n\n\n//# sourceMappingURL=mentions.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS9wbHVnaW5zL21lbnRpb25zLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEyRDtBQUN3QjtBQUN0QjtBQUNBO0FBQ2M7O0FBRTNFO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEIsT0FBTyx1RkFBb0I7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQix5RUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQSxFQUFFLDZDQUFVO0FBQ1osRUFBRSw2Q0FBVTtBQUNaLDRDQUE0QywyRUFBaUI7QUFDN0Q7QUFDQSxJQUFJLDZDQUFVO0FBQ2QsSUFBSSxTQUFTLHlFQUFhO0FBQzFCLElBQUksNkNBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEVBQWtCO0FBQzVDO0FBQ0EsR0FBRztBQUNILHlCQUF5QiwyRUFBaUI7QUFDMUM7QUFDQSxHQUFHO0FBQ0gsc0RBQXNELHlFQUFhO0FBQ25FLG9EQUFvRCx5RUFBYTtBQUNqRSxNQUFNLHVGQUFvQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZDQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBLG9DQUFvQyxJQUFJLHdDQUFLLDBCQUEwQjtBQUN2RTtBQUNBLCtCQUErQixJQUFJLHdDQUFLLHdCQUF3QjtBQUNoRTtBQUNBLElBQUksNkNBQVUsb0JBQW9CLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpREFBaUQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsUUFBUSx1RkFBb0I7QUFDNUIsd0JBQXdCLHlDQUFNO0FBQzlCLG1DQUFtQyx5Q0FBTSw2QkFBNkIsbUJBQW1CO0FBQ3pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRLDZDQUFVO0FBQ2xCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFJO0FBQ3JJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3Qvc2xhdGUvcGx1Z2lucy9tZW50aW9ucy5tanM/OWIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3IsIFRyYW5zZm9ybXMsIFJhbmdlLCBFbGVtZW50IH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgZ2V0Q2hhcmFjdGVyQWZ0ZXIsIGdldENoYXJhY3RlckJlZm9yZSB9IGZyb20gJy4uL3V0aWxzL2dldC1jaGFyYWN0ZXIubWpzJztcbmltcG9ydCB7IGdldE1hdGNoUmFuZ2UgfSBmcm9tICcuLi91dGlscy9nZXQtbWF0Y2gtcmFuZ2UubWpzJztcbmltcG9ydCB7IGlzRW1wdHlTdHJpbmcgfSBmcm9tICcuLi91dGlscy9pcy1lbXB0eS1zdHJpbmcubWpzJztcbmltcG9ydCB7IGlzU2VsZWN0aW9uQ29sbGFwc2VkIH0gZnJvbSAnLi4vdXRpbHMvaXMtc2VsZWN0aW9uLWNvbGxhcHNlZC5tanMnO1xuXG5jb25zdCBNRU5USU9OX0NIQVJBQ1RFUiA9IFwiQFwiO1xuZnVuY3Rpb24gZ2V0TWVudGlvbkRyYWZ0QXRTZWxlY3Rpb24oZWRpdG9yKSB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBlZGl0b3I7XG4gIGlmICghaXNTZWxlY3Rpb25Db2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtYXRjaCA9IGdldE1hdGNoUmFuZ2UoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1hdGNoVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBtYXRjaCk7XG4gIGlmICghbWF0Y2hUZXh0LnN0YXJ0c1dpdGgoTUVOVElPTl9DSEFSQUNURVIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmFuZ2U6IG1hdGNoLFxuICAgIHRleHQ6IG1hdGNoVGV4dC5zdWJzdHJpbmcoMSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9zZXJCb2R5TWVudGlvbihub2RlKSB7XG4gIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaW5zZXJ0TWVudGlvbihlZGl0b3IsIHVzZXJJZCkge1xuICBjb25zdCBtZW50aW9uID0ge1xuICAgIHR5cGU6IFwibWVudGlvblwiLFxuICAgIGlkOiB1c2VySWQsXG4gICAgY2hpbGRyZW46IFt7IHRleHQ6IFwiXCIgfV1cbiAgfTtcbiAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG1lbnRpb24pO1xuICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yKTtcbiAgY29uc3QgYWZ0ZXJDaGFyYWN0ZXIgPSBlZGl0b3Iuc2VsZWN0aW9uID8gZ2V0Q2hhcmFjdGVyQWZ0ZXIoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKSA6IHZvaWQgMDtcbiAgaWYgKCFhZnRlckNoYXJhY3RlciB8fCBhZnRlckNoYXJhY3Rlci52b2lkKSB7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgXCIgXCIpO1xuICB9IGVsc2UgaWYgKGlzRW1wdHlTdHJpbmcoYWZ0ZXJDaGFyYWN0ZXIudGV4dCkpIHtcbiAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0TWVudGlvbkNoYXJhY3RlcihlZGl0b3IpIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGJlZm9yZUNoYXJhY3RlciA9IGdldENoYXJhY3RlckJlZm9yZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICBmaWx0ZXJWb2lkczogdHJ1ZVxuICB9KTtcbiAgY29uc3QgYWZ0ZXJDaGFyYWN0ZXIgPSBnZXRDaGFyYWN0ZXJBZnRlcihlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICBmaWx0ZXJWb2lkczogdHJ1ZVxuICB9KTtcbiAgY29uc3Qgc2hvdWxkSW5zZXJ0U3BhY2VCZWZvcmUgPSBiZWZvcmVDaGFyYWN0ZXIgJiYgIWlzRW1wdHlTdHJpbmcoYmVmb3JlQ2hhcmFjdGVyLnRleHQpO1xuICBjb25zdCBzaG91bGRJbnNlcnRTcGFjZUFmdGVyID0gYWZ0ZXJDaGFyYWN0ZXIgJiYgIWlzRW1wdHlTdHJpbmcoYWZ0ZXJDaGFyYWN0ZXIudGV4dCk7XG4gIGlmIChpc1NlbGVjdGlvbkNvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IHRleHQgPSAoc2hvdWxkSW5zZXJ0U3BhY2VCZWZvcmUgPyBcIiBcIiA6IFwiXCIpICsgTUVOVElPTl9DSEFSQUNURVIgKyAoc2hvdWxkSW5zZXJ0U3BhY2VBZnRlciA/IFwiIFwiIDogXCJcIik7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gICAgaWYgKHNob3VsZEluc2VydFNwYWNlQWZ0ZXIpIHtcbiAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgZGlzdGFuY2U6IDEsXG4gICAgICAgIHVuaXQ6IFwiY2hhcmFjdGVyXCIsXG4gICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBiZWZvcmVUZXh0ID0gKHNob3VsZEluc2VydFNwYWNlQmVmb3JlID8gXCIgXCIgOiBcIlwiKSArIE1FTlRJT05fQ0hBUkFDVEVSO1xuICAgIGVkaXRvci5pbnNlcnRUZXh0KGJlZm9yZVRleHQsIHsgYXQ6IFJhbmdlLnN0YXJ0KGVkaXRvci5zZWxlY3Rpb24pIH0pO1xuICAgIGlmIChzaG91bGRJbnNlcnRTcGFjZUFmdGVyKSB7XG4gICAgICBlZGl0b3IuaW5zZXJ0VGV4dChcIiBcIiwgeyBhdDogUmFuZ2UuZW5kKGVkaXRvci5zZWxlY3Rpb24pIH0pO1xuICAgIH1cbiAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwgeyBlZGdlOiBcImVuZFwiIH0pO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoTWVudGlvbnMoZWRpdG9yKSB7XG4gIGNvbnN0IHsgaXNJbmxpbmUsIGlzVm9pZCwgbWFya2FibGVWb2lkLCBkZWxldGVCYWNrd2FyZCB9ID0gZWRpdG9yO1xuICBlZGl0b3IuaXNJbmxpbmUgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBpc0NvbXBvc2VyQm9keU1lbnRpb24oZWxlbWVudCkgfHwgaXNJbmxpbmUoZWxlbWVudCk7XG4gIH07XG4gIGVkaXRvci5pc1ZvaWQgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBpc0NvbXBvc2VyQm9keU1lbnRpb24oZWxlbWVudCkgfHwgaXNWb2lkKGVsZW1lbnQpO1xuICB9O1xuICBlZGl0b3IubWFya2FibGVWb2lkID0gKGVsZW1lbnQpID0+IHtcbiAgICByZXR1cm4gaXNDb21wb3NlckJvZHlNZW50aW9uKGVsZW1lbnQpIHx8IG1hcmthYmxlVm9pZChlbGVtZW50KTtcbiAgfTtcbiAgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkID0gKHVuaXQpID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gZWRpdG9yO1xuICAgIGlmIChpc1NlbGVjdGlvbkNvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBbbWVudGlvbl0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiB1bml0ID09PSBcImNoYXJhY3RlclwiID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIHNlbGVjdGlvbiwgeyB1bml0OiBcImNoYXJhY3RlclwiIH0pIDogc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogaXNDb21wb3NlckJvZHlNZW50aW9uXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICAgICAgaWYgKG1lbnRpb24pIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgTUVOVElPTl9DSEFSQUNURVIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmV4cG9ydCB7IE1FTlRJT05fQ0hBUkFDVEVSLCBnZXRNZW50aW9uRHJhZnRBdFNlbGVjdGlvbiwgaW5zZXJ0TWVudGlvbiwgaW5zZXJ0TWVudGlvbkNoYXJhY3RlciwgaXNDb21wb3NlckJvZHlNZW50aW9uLCB3aXRoTWVudGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnRpb25zLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/mentions.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/paste-html.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/plugins/paste-html.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   withPasteHtml: () => (/* binding */ withPasteHtml)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_hyperscript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate-hyperscript */ \"(ssr)/./node_modules/slate-hyperscript/dist/index.es.js\");\n\n\n\nfunction areUrlsEqual(a, b) {\n  try {\n    const urlA = new URL(a);\n    const urlB = new URL(b);\n    return urlA.origin === urlB.origin && urlA.pathname === urlB.pathname;\n  } catch {\n    return false;\n  }\n}\nconst createParagraphElement = () => ({\n  type: \"paragraph\"\n});\nconst ELEMENT_TAGS = {\n  A: (element) => {\n    const href = element.getAttribute(\"href\");\n    const innerText = element.innerText;\n    return {\n      type: href && areUrlsEqual(href, innerText) ? \"auto-link\" : \"custom-link\",\n      url: href ?? \"\"\n    };\n  },\n  P: createParagraphElement,\n  BLOCKQUOTE: createParagraphElement,\n  H1: createParagraphElement,\n  H2: createParagraphElement,\n  H3: createParagraphElement,\n  H4: createParagraphElement,\n  H5: createParagraphElement,\n  H6: createParagraphElement,\n  LI: createParagraphElement\n};\nconst TEXT_TAGS = {\n  CODE: () => ({ code: true }),\n  DEL: () => ({ strikethrough: true }),\n  EM: () => ({ italic: true }),\n  I: () => ({ italic: true }),\n  S: () => ({ strikethrough: true }),\n  STRONG: () => ({ bold: true })\n};\nfunction flattenListItems(node) {\n  const listItems = [];\n  if (node.nodeName === \"LI\") {\n    listItems.push(node);\n  }\n  node.childNodes.forEach((child) => {\n    if (child.nodeType === 1) {\n      listItems.push(...flattenListItems(child));\n    }\n  });\n  return listItems;\n}\nfunction deserialize(node) {\n  if (node.nodeType === 3) {\n    return node.textContent;\n  } else if (node.nodeType !== 1) {\n    return null;\n  } else if (node.nodeName === \"BR\") {\n    return \"\\n\";\n  }\n  const childNodes = Array.from(node.childNodes);\n  let children = childNodes.map(deserialize).flat();\n  if (node.nodeName === \"UL\" || node.nodeName === \"OL\") {\n    const listItems = flattenListItems(node);\n    children = listItems.map((li) => deserialize(li)).flat();\n  }\n  if (children.length === 0) {\n    children = [{ text: \"\" }];\n  }\n  if (node.nodeName === \"BODY\") {\n    return (0,slate_hyperscript__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"fragment\", {}, children);\n  }\n  if (ELEMENT_TAGS[node.nodeName]) {\n    const attrs = ELEMENT_TAGS[node.nodeName](node);\n    return (0,slate_hyperscript__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"element\", attrs, children);\n  }\n  if (TEXT_TAGS[node.nodeName]) {\n    const attrs = TEXT_TAGS[node.nodeName](node);\n    return children.map((child) => (0,slate_hyperscript__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", attrs, child));\n  }\n  return children;\n}\nfunction withPasteHtml(editor) {\n  const { insertData } = editor;\n  editor.insertData = (data) => {\n    const html = data.getData(\"text/html\");\n    if (html) {\n      const parsed = new DOMParser().parseFromString(html, \"text/html\");\n      const fragment = deserialize(parsed.body);\n      if (fragment !== null && Array.isArray(fragment)) {\n        slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.insertFragment(editor, fragment);\n        return;\n      }\n    }\n    insertData(data);\n  };\n  return editor;\n}\n\n\n//# sourceMappingURL=paste-html.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS9wbHVnaW5zL3Bhc3RlLWh0bWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtQztBQUNLOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsZ0JBQWdCLHFCQUFxQjtBQUNyQyxlQUFlLGNBQWM7QUFDN0IsY0FBYyxjQUFjO0FBQzVCLGNBQWMscUJBQXFCO0FBQ25DLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBLFdBQVcsc0RBQUcsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNEQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3Qvc2xhdGUvcGx1Z2lucy9wYXN0ZS1odG1sLm1qcz9hYWZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zZm9ybXMgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdzbGF0ZS1oeXBlcnNjcmlwdCc7XG5cbmZ1bmN0aW9uIGFyZVVybHNFcXVhbChhLCBiKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsQSA9IG5ldyBVUkwoYSk7XG4gICAgY29uc3QgdXJsQiA9IG5ldyBVUkwoYik7XG4gICAgcmV0dXJuIHVybEEub3JpZ2luID09PSB1cmxCLm9yaWdpbiAmJiB1cmxBLnBhdGhuYW1lID09PSB1cmxCLnBhdGhuYW1lO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZVBhcmFncmFwaEVsZW1lbnQgPSAoKSA9PiAoe1xuICB0eXBlOiBcInBhcmFncmFwaFwiXG59KTtcbmNvbnN0IEVMRU1FTlRfVEFHUyA9IHtcbiAgQTogKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBocmVmID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgIGNvbnN0IGlubmVyVGV4dCA9IGVsZW1lbnQuaW5uZXJUZXh0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBocmVmICYmIGFyZVVybHNFcXVhbChocmVmLCBpbm5lclRleHQpID8gXCJhdXRvLWxpbmtcIiA6IFwiY3VzdG9tLWxpbmtcIixcbiAgICAgIHVybDogaHJlZiA/PyBcIlwiXG4gICAgfTtcbiAgfSxcbiAgUDogY3JlYXRlUGFyYWdyYXBoRWxlbWVudCxcbiAgQkxPQ0tRVU9URTogY3JlYXRlUGFyYWdyYXBoRWxlbWVudCxcbiAgSDE6IGNyZWF0ZVBhcmFncmFwaEVsZW1lbnQsXG4gIEgyOiBjcmVhdGVQYXJhZ3JhcGhFbGVtZW50LFxuICBIMzogY3JlYXRlUGFyYWdyYXBoRWxlbWVudCxcbiAgSDQ6IGNyZWF0ZVBhcmFncmFwaEVsZW1lbnQsXG4gIEg1OiBjcmVhdGVQYXJhZ3JhcGhFbGVtZW50LFxuICBINjogY3JlYXRlUGFyYWdyYXBoRWxlbWVudCxcbiAgTEk6IGNyZWF0ZVBhcmFncmFwaEVsZW1lbnRcbn07XG5jb25zdCBURVhUX1RBR1MgPSB7XG4gIENPREU6ICgpID0+ICh7IGNvZGU6IHRydWUgfSksXG4gIERFTDogKCkgPT4gKHsgc3RyaWtldGhyb3VnaDogdHJ1ZSB9KSxcbiAgRU06ICgpID0+ICh7IGl0YWxpYzogdHJ1ZSB9KSxcbiAgSTogKCkgPT4gKHsgaXRhbGljOiB0cnVlIH0pLFxuICBTOiAoKSA9PiAoeyBzdHJpa2V0aHJvdWdoOiB0cnVlIH0pLFxuICBTVFJPTkc6ICgpID0+ICh7IGJvbGQ6IHRydWUgfSlcbn07XG5mdW5jdGlvbiBmbGF0dGVuTGlzdEl0ZW1zKG5vZGUpIHtcbiAgY29uc3QgbGlzdEl0ZW1zID0gW107XG4gIGlmIChub2RlLm5vZGVOYW1lID09PSBcIkxJXCIpIHtcbiAgICBsaXN0SXRlbXMucHVzaChub2RlKTtcbiAgfVxuICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGxpc3RJdGVtcy5wdXNoKC4uLmZsYXR0ZW5MaXN0SXRlbXMoY2hpbGQpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGlzdEl0ZW1zO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUobm9kZSkge1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgIHJldHVybiBub2RlLnRleHRDb250ZW50O1xuICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09PSBcIkJSXCIpIHtcbiAgICByZXR1cm4gXCJcXG5cIjtcbiAgfVxuICBjb25zdCBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpO1xuICBsZXQgY2hpbGRyZW4gPSBjaGlsZE5vZGVzLm1hcChkZXNlcmlhbGl6ZSkuZmxhdCgpO1xuICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IG5vZGUubm9kZU5hbWUgPT09IFwiT0xcIikge1xuICAgIGNvbnN0IGxpc3RJdGVtcyA9IGZsYXR0ZW5MaXN0SXRlbXMobm9kZSk7XG4gICAgY2hpbGRyZW4gPSBsaXN0SXRlbXMubWFwKChsaSkgPT4gZGVzZXJpYWxpemUobGkpKS5mbGF0KCk7XG4gIH1cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgIGNoaWxkcmVuID0gW3sgdGV4dDogXCJcIiB9XTtcbiAgfVxuICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gXCJCT0RZXCIpIHtcbiAgICByZXR1cm4ganN4KFwiZnJhZ21lbnRcIiwge30sIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoRUxFTUVOVF9UQUdTW25vZGUubm9kZU5hbWVdKSB7XG4gICAgY29uc3QgYXR0cnMgPSBFTEVNRU5UX1RBR1Nbbm9kZS5ub2RlTmFtZV0obm9kZSk7XG4gICAgcmV0dXJuIGpzeChcImVsZW1lbnRcIiwgYXR0cnMsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoVEVYVF9UQUdTW25vZGUubm9kZU5hbWVdKSB7XG4gICAgY29uc3QgYXR0cnMgPSBURVhUX1RBR1Nbbm9kZS5ub2RlTmFtZV0obm9kZSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGpzeChcInRleHRcIiwgYXR0cnMsIGNoaWxkKSk7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gd2l0aFBhc3RlSHRtbChlZGl0b3IpIHtcbiAgY29uc3QgeyBpbnNlcnREYXRhIH0gPSBlZGl0b3I7XG4gIGVkaXRvci5pbnNlcnREYXRhID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCBodG1sID0gZGF0YS5nZXREYXRhKFwidGV4dC9odG1sXCIpO1xuICAgIGlmIChodG1sKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGh0bWwsIFwidGV4dC9odG1sXCIpO1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBkZXNlcmlhbGl6ZShwYXJzZWQuYm9keSk7XG4gICAgICBpZiAoZnJhZ21lbnQgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShmcmFnbWVudCkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnREYXRhKGRhdGEpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5leHBvcnQgeyB3aXRoUGFzdGVIdG1sIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXN0ZS1odG1sLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/plugins/paste-html.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-character.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/utils/get-character.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCharacterAfter: () => (/* binding */ getCharacterAfter),\n/* harmony export */   getCharacterBefore: () => (/* binding */ getCharacterBefore)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n\n\nfunction getCharacterBefore(editor, at, options = {}) {\n  const { filterVoids } = options;\n  const before = slate__WEBPACK_IMPORTED_MODULE_0__.Editor.before(editor, at, {\n    unit: \"character\",\n    voids: filterVoids\n  });\n  if (before) {\n    const range = slate__WEBPACK_IMPORTED_MODULE_0__.Editor.range(\n      editor,\n      before,\n      slate__WEBPACK_IMPORTED_MODULE_0__.Range.isRange(at) ? slate__WEBPACK_IMPORTED_MODULE_0__.Range.start(at) : at\n    );\n    const text = slate__WEBPACK_IMPORTED_MODULE_0__.Editor.string(editor, range);\n    return {\n      range,\n      text,\n      void: text.length === 0\n    };\n  }\n  return;\n}\nfunction getCharacterAfter(editor, at, options = {}) {\n  const { filterVoids } = options;\n  const after = slate__WEBPACK_IMPORTED_MODULE_0__.Editor.after(editor, at, {\n    unit: \"character\",\n    voids: filterVoids\n  });\n  if (after) {\n    const range = slate__WEBPACK_IMPORTED_MODULE_0__.Editor.range(\n      editor,\n      after,\n      slate__WEBPACK_IMPORTED_MODULE_0__.Range.isRange(at) ? slate__WEBPACK_IMPORTED_MODULE_0__.Range.end(at) : at\n    );\n    const text = slate__WEBPACK_IMPORTED_MODULE_0__.Editor.string(editor, range);\n    return {\n      range,\n      text,\n      void: text.length === 0\n    };\n  }\n  return;\n}\n\n\n//# sourceMappingURL=get-character.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9nZXQtY2hhcmFjdGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0M7O0FBRXRDLG9EQUFvRDtBQUNwRCxVQUFVLGNBQWM7QUFDeEIsaUJBQWlCLHlDQUFNO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0IseUNBQU07QUFDeEI7QUFDQTtBQUNBLE1BQU0sd0NBQUssZUFBZSx3Q0FBSztBQUMvQjtBQUNBLGlCQUFpQix5Q0FBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFVBQVUsY0FBYztBQUN4QixnQkFBZ0IseUNBQU07QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQix5Q0FBTTtBQUN4QjtBQUNBO0FBQ0EsTUFBTSx3Q0FBSyxlQUFlLHdDQUFLO0FBQy9CO0FBQ0EsaUJBQWlCLHlDQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlEO0FBQ2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3Qvc2xhdGUvdXRpbHMvZ2V0LWNoYXJhY3Rlci5tanM/ZWE1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3IsIFJhbmdlIH0gZnJvbSAnc2xhdGUnO1xuXG5mdW5jdGlvbiBnZXRDaGFyYWN0ZXJCZWZvcmUoZWRpdG9yLCBhdCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgZmlsdGVyVm9pZHMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhdCwge1xuICAgIHVuaXQ6IFwiY2hhcmFjdGVyXCIsXG4gICAgdm9pZHM6IGZpbHRlclZvaWRzXG4gIH0pO1xuICBpZiAoYmVmb3JlKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoXG4gICAgICBlZGl0b3IsXG4gICAgICBiZWZvcmUsXG4gICAgICBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLnN0YXJ0KGF0KSA6IGF0XG4gICAgKTtcbiAgICBjb25zdCB0ZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIHJhbmdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2UsXG4gICAgICB0ZXh0LFxuICAgICAgdm9pZDogdGV4dC5sZW5ndGggPT09IDBcbiAgICB9O1xuICB9XG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIGdldENoYXJhY3RlckFmdGVyKGVkaXRvciwgYXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGZpbHRlclZvaWRzIH0gPSBvcHRpb25zO1xuICBjb25zdCBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCB7XG4gICAgdW5pdDogXCJjaGFyYWN0ZXJcIixcbiAgICB2b2lkczogZmlsdGVyVm9pZHNcbiAgfSk7XG4gIGlmIChhZnRlcikge1xuICAgIGNvbnN0IHJhbmdlID0gRWRpdG9yLnJhbmdlKFxuICAgICAgZWRpdG9yLFxuICAgICAgYWZ0ZXIsXG4gICAgICBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmVuZChhdCkgOiBhdFxuICAgICk7XG4gICAgY29uc3QgdGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCByYW5nZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlLFxuICAgICAgdGV4dCxcbiAgICAgIHZvaWQ6IHRleHQubGVuZ3RoID09PSAwXG4gICAgfTtcbiAgfVxuICByZXR1cm47XG59XG5cbmV4cG9ydCB7IGdldENoYXJhY3RlckFmdGVyLCBnZXRDaGFyYWN0ZXJCZWZvcmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1jaGFyYWN0ZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-character.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-dom-range.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/utils/get-dom-range.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDOMRange: () => (/* binding */ getDOMRange)\n/* harmony export */ });\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/slate-react/dist/index.es.js\");\n\n\nfunction getDOMRange(editor, range) {\n  try {\n    return slate_react__WEBPACK_IMPORTED_MODULE_0__.ReactEditor.toDOMRange(editor, range);\n  } catch (error) {\n    return getDOMRange(editor, {\n      anchor: range.anchor,\n      focus: range.anchor\n    });\n  }\n}\n\n\n//# sourceMappingURL=get-dom-range.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9nZXQtZG9tLXJhbmdlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQzs7QUFFMUM7QUFDQTtBQUNBLFdBQVcsb0RBQVc7QUFDdEIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3NsYXRlL3V0aWxzL2dldC1kb20tcmFuZ2UubWpzPzdkZTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVhY3RFZGl0b3IgfSBmcm9tICdzbGF0ZS1yZWFjdCc7XG5cbmZ1bmN0aW9uIGdldERPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZ2V0RE9NUmFuZ2UoZWRpdG9yLCB7XG4gICAgICBhbmNob3I6IHJhbmdlLmFuY2hvcixcbiAgICAgIGZvY3VzOiByYW5nZS5hbmNob3JcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBnZXRET01SYW5nZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWRvbS1yYW5nZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-dom-range.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-match-range.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/utils/get-match-range.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMatchRange: () => (/* binding */ getMatchRange)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n\n\nconst defaultOptions = {\n  direction: \"before\"\n};\nfunction getMatchRange(editor, at, terminators = [\" \"], options = defaultOptions) {\n  const { include, direction } = { ...defaultOptions, ...options };\n  let [start, end] = slate__WEBPACK_IMPORTED_MODULE_0__.Range.edges(at);\n  let point = start;\n  function move(direction2) {\n    const next = direction2 === \"after\" ? slate__WEBPACK_IMPORTED_MODULE_0__.Editor.after(editor, point, {\n      unit: \"character\"\n    }) : slate__WEBPACK_IMPORTED_MODULE_0__.Editor.before(editor, point, { unit: \"character\" });\n    const nextWord = next && slate__WEBPACK_IMPORTED_MODULE_0__.Editor.string(\n      editor,\n      direction2 === \"after\" ? { anchor: point, focus: next } : { anchor: next, focus: point }\n    );\n    const lastWord = nextWord && nextWord[direction2 === \"after\" ? 0 : nextWord.length - 1];\n    if (next && lastWord && !terminators.includes(lastWord)) {\n      point = next;\n      if (point.offset === 0) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n    return true;\n  }\n  if (direction !== \"before\") {\n    point = end;\n    while (move(\"after\"))\n      ;\n    end = point;\n  }\n  if (direction !== \"after\") {\n    point = start;\n    while (move(\"before\"))\n      ;\n    start = point;\n  }\n  if (include) {\n    return {\n      anchor: slate__WEBPACK_IMPORTED_MODULE_0__.Editor.before(editor, start, { unit: \"offset\" }) ?? start,\n      focus: slate__WEBPACK_IMPORTED_MODULE_0__.Editor.after(editor, end, { unit: \"offset\" }) ?? end\n    };\n  }\n  return { anchor: start, focus: end };\n}\n\n\n//# sourceMappingURL=get-match-range.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9nZXQtbWF0Y2gtcmFuZ2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCLElBQUk7QUFDbkMscUJBQXFCLHdDQUFLO0FBQzFCO0FBQ0E7QUFDQSwwQ0FBMEMseUNBQU07QUFDaEQ7QUFDQSxLQUFLLElBQUkseUNBQU0seUJBQXlCLG1CQUFtQjtBQUMzRCw2QkFBNkIseUNBQU07QUFDbkM7QUFDQSxpQ0FBaUMsNkJBQTZCLElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5Q0FBTSx5QkFBeUIsZ0JBQWdCO0FBQzdELGFBQWEseUNBQU0sc0JBQXNCLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUV5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3NsYXRlL3V0aWxzL2dldC1tYXRjaC1yYW5nZS5tanM/NTZiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYW5nZSwgRWRpdG9yIH0gZnJvbSAnc2xhdGUnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZGlyZWN0aW9uOiBcImJlZm9yZVwiXG59O1xuZnVuY3Rpb24gZ2V0TWF0Y2hSYW5nZShlZGl0b3IsIGF0LCB0ZXJtaW5hdG9ycyA9IFtcIiBcIl0sIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICBjb25zdCB7IGluY2x1ZGUsIGRpcmVjdGlvbiB9ID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICBsZXQgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICBsZXQgcG9pbnQgPSBzdGFydDtcbiAgZnVuY3Rpb24gbW92ZShkaXJlY3Rpb24yKSB7XG4gICAgY29uc3QgbmV4dCA9IGRpcmVjdGlvbjIgPT09IFwiYWZ0ZXJcIiA/IEVkaXRvci5hZnRlcihlZGl0b3IsIHBvaW50LCB7XG4gICAgICB1bml0OiBcImNoYXJhY3RlclwiXG4gICAgfSkgOiBFZGl0b3IuYmVmb3JlKGVkaXRvciwgcG9pbnQsIHsgdW5pdDogXCJjaGFyYWN0ZXJcIiB9KTtcbiAgICBjb25zdCBuZXh0V29yZCA9IG5leHQgJiYgRWRpdG9yLnN0cmluZyhcbiAgICAgIGVkaXRvcixcbiAgICAgIGRpcmVjdGlvbjIgPT09IFwiYWZ0ZXJcIiA/IHsgYW5jaG9yOiBwb2ludCwgZm9jdXM6IG5leHQgfSA6IHsgYW5jaG9yOiBuZXh0LCBmb2N1czogcG9pbnQgfVxuICAgICk7XG4gICAgY29uc3QgbGFzdFdvcmQgPSBuZXh0V29yZCAmJiBuZXh0V29yZFtkaXJlY3Rpb24yID09PSBcImFmdGVyXCIgPyAwIDogbmV4dFdvcmQubGVuZ3RoIC0gMV07XG4gICAgaWYgKG5leHQgJiYgbGFzdFdvcmQgJiYgIXRlcm1pbmF0b3JzLmluY2x1ZGVzKGxhc3RXb3JkKSkge1xuICAgICAgcG9pbnQgPSBuZXh0O1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGRpcmVjdGlvbiAhPT0gXCJiZWZvcmVcIikge1xuICAgIHBvaW50ID0gZW5kO1xuICAgIHdoaWxlIChtb3ZlKFwiYWZ0ZXJcIikpXG4gICAgICA7XG4gICAgZW5kID0gcG9pbnQ7XG4gIH1cbiAgaWYgKGRpcmVjdGlvbiAhPT0gXCJhZnRlclwiKSB7XG4gICAgcG9pbnQgPSBzdGFydDtcbiAgICB3aGlsZSAobW92ZShcImJlZm9yZVwiKSlcbiAgICAgIDtcbiAgICBzdGFydCA9IHBvaW50O1xuICB9XG4gIGlmIChpbmNsdWRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogRWRpdG9yLmJlZm9yZShlZGl0b3IsIHN0YXJ0LCB7IHVuaXQ6IFwib2Zmc2V0XCIgfSkgPz8gc3RhcnQsXG4gICAgICBmb2N1czogRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kLCB7IHVuaXQ6IFwib2Zmc2V0XCIgfSkgPz8gZW5kXG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBhbmNob3I6IHN0YXJ0LCBmb2N1czogZW5kIH07XG59XG5cbmV4cG9ydCB7IGdldE1hdGNoUmFuZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1tYXRjaC1yYW5nZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-match-range.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty-string.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty-string.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isEmptyString: () => (/* binding */ isEmptyString)\n/* harmony export */ });\nfunction isEmptyString(string) {\n  return !string.trim();\n}\n\n\n//# sourceMappingURL=is-empty-string.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9pcy1lbXB0eS1zdHJpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3Qvc2xhdGUvdXRpbHMvaXMtZW1wdHktc3RyaW5nLm1qcz8yMWRhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzRW1wdHlTdHJpbmcoc3RyaW5nKSB7XG4gIHJldHVybiAhc3RyaW5nLnRyaW0oKTtcbn1cblxuZXhwb3J0IHsgaXNFbXB0eVN0cmluZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZW1wdHktc3RyaW5nLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty-string.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _is_empty_string_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-empty-string.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty-string.mjs\");\n/* harmony import */ var _is_text_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-text.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-text.mjs\");\n\n\n\n\nfunction isEmpty(editor, children) {\n  for (const child of children) {\n    if ((0,_is_text_mjs__WEBPACK_IMPORTED_MODULE_0__.isText)(child)) {\n      if (!(0,_is_empty_string_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmptyString)(child.text)) {\n        return false;\n      }\n    } else if (child.type === \"paragraph\") {\n      if (child.children.length > 1 || !((0,_is_text_mjs__WEBPACK_IMPORTED_MODULE_0__.isText)(child.children[0]) && (0,_is_empty_string_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmptyString)(child.children[0].text))) {\n        return false;\n      }\n    } else {\n      if (!slate__WEBPACK_IMPORTED_MODULE_2__.Editor.isEmpty(editor, child)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n//# sourceMappingURL=is-empty.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9pcy1lbXB0eS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUN1QjtBQUNmOztBQUV2QztBQUNBO0FBQ0EsUUFBUSxvREFBTTtBQUNkLFdBQVcsbUVBQWE7QUFDeEI7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsb0RBQU0sdUJBQXVCLG1FQUFhO0FBQ25GO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyx5Q0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3Qvc2xhdGUvdXRpbHMvaXMtZW1wdHkubWpzPzBkZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgaXNFbXB0eVN0cmluZyB9IGZyb20gJy4vaXMtZW1wdHktc3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBpc1RleHQgfSBmcm9tICcuL2lzLXRleHQubWpzJztcblxuZnVuY3Rpb24gaXNFbXB0eShlZGl0b3IsIGNoaWxkcmVuKSB7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICBpZiAoaXNUZXh0KGNoaWxkKSkge1xuICAgICAgaWYgKCFpc0VtcHR5U3RyaW5nKGNoaWxkLnRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IFwicGFyYWdyYXBoXCIpIHtcbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAxIHx8ICEoaXNUZXh0KGNoaWxkLmNoaWxkcmVuWzBdKSAmJiBpc0VtcHR5U3RyaW5nKGNoaWxkLmNoaWxkcmVuWzBdLnRleHQpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgaXNFbXB0eSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZW1wdHkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-empty.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-selection-collapsed.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/utils/is-selection-collapsed.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSelectionCollapsed: () => (/* binding */ isSelectionCollapsed)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n\n\nfunction isSelectionCollapsed(selection) {\n  return selection !== null && slate__WEBPACK_IMPORTED_MODULE_0__.Range.isCollapsed(selection);\n}\n\n\n//# sourceMappingURL=is-selection-collapsed.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9pcy1zZWxlY3Rpb24tY29sbGFwc2VkLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4Qjs7QUFFOUI7QUFDQSwrQkFBK0Isd0NBQUs7QUFDcEM7O0FBRWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3Qvc2xhdGUvdXRpbHMvaXMtc2VsZWN0aW9uLWNvbGxhcHNlZC5tanM/N2EyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYW5nZSB9IGZyb20gJ3NsYXRlJztcblxuZnVuY3Rpb24gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc2VsZWN0aW9uKSB7XG4gIHJldHVybiBzZWxlY3Rpb24gIT09IG51bGwgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKTtcbn1cblxuZXhwb3J0IHsgaXNTZWxlY3Rpb25Db2xsYXBzZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXNlbGVjdGlvbi1jb2xsYXBzZWQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-selection-collapsed.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-text.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/utils/is-text.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPlainText: () => (/* binding */ isPlainText),\n/* harmony export */   isText: () => (/* binding */ isText)\n/* harmony export */ });\nfunction isText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isPlainText(node) {\n  return isText(node) && Object.keys(node).length === 1;\n}\n\n\n//# sourceMappingURL=is-text.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9pcy10ZXh0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9pcy10ZXh0Lm1qcz8xZWE2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzVGV4dChlbGVtZW50KSB7XG4gIHJldHVybiAhKFwidHlwZVwiIGluIGVsZW1lbnQpICYmIFwidGV4dFwiIGluIGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQudGV4dCA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5UZXh0KG5vZGUpIHtcbiAgcmV0dXJuIGlzVGV4dChub2RlKSAmJiBPYmplY3Qua2V5cyhub2RlKS5sZW5ndGggPT09IDE7XG59XG5cbmV4cG9ydCB7IGlzUGxhaW5UZXh0LCBpc1RleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXRleHQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-text.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/marks.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/utils/marks.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   leaveMarkEdge: () => (/* binding */ leaveMarkEdge),\n/* harmony export */   removeMarks: () => (/* binding */ removeMarks),\n/* harmony export */   toggleMark: () => (/* binding */ toggleMark)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _get_character_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-character.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/get-character.mjs\");\n/* harmony import */ var _is_selection_collapsed_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-selection-collapsed.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/is-selection-collapsed.mjs\");\n\n\n\n\nfunction isMarkActive(editor, format) {\n  const marks = slate__WEBPACK_IMPORTED_MODULE_0__.Editor.marks(editor);\n  return marks ? marks[format] === true : false;\n}\nfunction toggleMark(editor, format) {\n  const isActive = isMarkActive(editor, format);\n  if (isActive) {\n    slate__WEBPACK_IMPORTED_MODULE_0__.Editor.removeMark(editor, format);\n  } else {\n    slate__WEBPACK_IMPORTED_MODULE_0__.Editor.addMark(editor, format, true);\n  }\n}\nfunction removeMarks(editor) {\n  const marks = slate__WEBPACK_IMPORTED_MODULE_0__.Editor.marks(editor);\n  if (marks) {\n    for (const mark in marks) {\n      slate__WEBPACK_IMPORTED_MODULE_0__.Editor.removeMark(editor, mark);\n    }\n  }\n}\nfunction leaveMarkEdge(editor, edge) {\n  if ((0,_is_selection_collapsed_mjs__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(editor.selection)) {\n    const marks = Object.keys(slate__WEBPACK_IMPORTED_MODULE_0__.Editor.marks(editor) ?? {});\n    if (marks.length > 0) {\n      const sibling = edge === \"start\" ? (0,_get_character_mjs__WEBPACK_IMPORTED_MODULE_2__.getCharacterBefore)(editor, editor.selection) : (0,_get_character_mjs__WEBPACK_IMPORTED_MODULE_2__.getCharacterAfter)(editor, editor.selection);\n      if (!sibling) {\n        removeMarks(editor);\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=marks.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9tYXJrcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUErQjtBQUM2QztBQUNSOztBQUVwRTtBQUNBLGdCQUFnQix5Q0FBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5Q0FBTTtBQUNWLElBQUk7QUFDSixJQUFJLHlDQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUFNO0FBQ3RCO0FBQ0E7QUFDQSxNQUFNLHlDQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlGQUFvQjtBQUMxQiw4QkFBOEIseUNBQU0sb0JBQW9CO0FBQ3hEO0FBQ0EseUNBQXlDLHNFQUFrQiw2QkFBNkIscUVBQWlCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0U7QUFDaEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9tYXJrcy5tanM/NTlkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3IgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBnZXRDaGFyYWN0ZXJCZWZvcmUsIGdldENoYXJhY3RlckFmdGVyIH0gZnJvbSAnLi9nZXQtY2hhcmFjdGVyLm1qcyc7XG5pbXBvcnQgeyBpc1NlbGVjdGlvbkNvbGxhcHNlZCB9IGZyb20gJy4vaXMtc2VsZWN0aW9uLWNvbGxhcHNlZC5tanMnO1xuXG5mdW5jdGlvbiBpc01hcmtBY3RpdmUoZWRpdG9yLCBmb3JtYXQpIHtcbiAgY29uc3QgbWFya3MgPSBFZGl0b3IubWFya3MoZWRpdG9yKTtcbiAgcmV0dXJuIG1hcmtzID8gbWFya3NbZm9ybWF0XSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gdG9nZ2xlTWFyayhlZGl0b3IsIGZvcm1hdCkge1xuICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShlZGl0b3IsIGZvcm1hdCk7XG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIEVkaXRvci5yZW1vdmVNYXJrKGVkaXRvciwgZm9ybWF0KTtcbiAgfSBlbHNlIHtcbiAgICBFZGl0b3IuYWRkTWFyayhlZGl0b3IsIGZvcm1hdCwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZU1hcmtzKGVkaXRvcikge1xuICBjb25zdCBtYXJrcyA9IEVkaXRvci5tYXJrcyhlZGl0b3IpO1xuICBpZiAobWFya3MpIHtcbiAgICBmb3IgKGNvbnN0IG1hcmsgaW4gbWFya3MpIHtcbiAgICAgIEVkaXRvci5yZW1vdmVNYXJrKGVkaXRvciwgbWFyayk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBsZWF2ZU1hcmtFZGdlKGVkaXRvciwgZWRnZSkge1xuICBpZiAoaXNTZWxlY3Rpb25Db2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBtYXJrcyA9IE9iamVjdC5rZXlzKEVkaXRvci5tYXJrcyhlZGl0b3IpID8/IHt9KTtcbiAgICBpZiAobWFya3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2libGluZyA9IGVkZ2UgPT09IFwic3RhcnRcIiA/IGdldENoYXJhY3RlckJlZm9yZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pIDogZ2V0Q2hhcmFjdGVyQWZ0ZXIoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgIGlmICghc2libGluZykge1xuICAgICAgICByZW1vdmVNYXJrcyhlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBpc01hcmtBY3RpdmUsIGxlYXZlTWFya0VkZ2UsIHJlbW92ZU1hcmtzLCB0b2dnbGVNYXJrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXJrcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/marks.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/selection-contains-inlines.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/slate/utils/selection-contains-inlines.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   selectionContainsInlines: () => (/* binding */ selectionContainsInlines)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n\n\nfunction selectionContainsInlines(editor, match) {\n  const { selection } = editor;\n  if (!selection) {\n    return false;\n  }\n  const roots = Array.from(\n    slate__WEBPACK_IMPORTED_MODULE_0__.Editor.nodes(editor, {\n      at: selection,\n      match: (node) => slate__WEBPACK_IMPORTED_MODULE_0__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_0__.Editor.isBlock(editor, node),\n      mode: \"lowest\"\n    })\n  );\n  for (const [, rootPath] of roots) {\n    const intersectingSelection = slate__WEBPACK_IMPORTED_MODULE_0__.Range.isRange(selection) ? slate__WEBPACK_IMPORTED_MODULE_0__.Range.intersection(selection, slate__WEBPACK_IMPORTED_MODULE_0__.Editor.range(editor, rootPath)) : selection;\n    if (!intersectingSelection) {\n      continue;\n    }\n    const matches = Array.from(\n      slate__WEBPACK_IMPORTED_MODULE_0__.Editor.nodes(editor, {\n        at: intersectingSelection,\n        match: (node) => slate__WEBPACK_IMPORTED_MODULE_0__.Editor.isInline(editor, node) && match(node)\n      })\n    );\n    if (matches.length > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n//# sourceMappingURL=selection-contains-inlines.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9zbGF0ZS91dGlscy9zZWxlY3Rpb24tY29udGFpbnMtaW5saW5lcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0M7O0FBRS9DO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5Q0FBTTtBQUNWO0FBQ0EsdUJBQXVCLDBDQUFPLG9CQUFvQix5Q0FBTTtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLHdDQUFLLHNCQUFzQix3Q0FBSyx5QkFBeUIseUNBQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlDQUFNO0FBQ1o7QUFDQSx5QkFBeUIseUNBQU07QUFDL0IsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQztBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3NsYXRlL3V0aWxzL3NlbGVjdGlvbi1jb250YWlucy1pbmxpbmVzLm1qcz8wMzJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVkaXRvciwgRWxlbWVudCwgUmFuZ2UgfSBmcm9tICdzbGF0ZSc7XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRhaW5zSW5saW5lcyhlZGl0b3IsIG1hdGNoKSB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBlZGl0b3I7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3RzID0gQXJyYXkuZnJvbShcbiAgICBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogc2VsZWN0aW9uLFxuICAgICAgbWF0Y2g6IChub2RlKSA9PiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG5vZGUpLFxuICAgICAgbW9kZTogXCJsb3dlc3RcIlxuICAgIH0pXG4gICk7XG4gIGZvciAoY29uc3QgWywgcm9vdFBhdGhdIG9mIHJvb3RzKSB7XG4gICAgY29uc3QgaW50ZXJzZWN0aW5nU2VsZWN0aW9uID0gUmFuZ2UuaXNSYW5nZShzZWxlY3Rpb24pID8gUmFuZ2UuaW50ZXJzZWN0aW9uKHNlbGVjdGlvbiwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IHNlbGVjdGlvbjtcbiAgICBpZiAoIWludGVyc2VjdGluZ1NlbGVjdGlvbikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZXMgPSBBcnJheS5mcm9tKFxuICAgICAgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogaW50ZXJzZWN0aW5nU2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogKG5vZGUpID0+IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG5vZGUpICYmIG1hdGNoKG5vZGUpXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IHsgc2VsZWN0aW9uQ29udGFpbnNJbmxpbmVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3Rpb24tY29udGFpbnMtaW5saW5lcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/slate/utils/selection-contains-inlines.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/Persist.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/Persist.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Persist: () => (/* binding */ Persist),\n/* harmony export */   useAnimationPersist: () => (/* binding */ useAnimationPersist),\n/* harmony export */   usePersist: () => (/* binding */ usePersist)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _flush_sync_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flush-sync.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/flush-sync.mjs\");\n/* harmony import */ var _use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-layout-effect.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-layout-effect.mjs\");\n/* __next_internal_client_entry_do_not_use__ Persist,useAnimationPersist,usePersist auto */ \n\n\n\nconst PERSIST_NAME = \"Persist\";\nconst PersistContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction usePersist() {\n    const persistContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PersistContext);\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(persistContext, \"Persist is missing from the React tree.\");\n}\nfunction getChild(children) {\n    const child = Array.isArray(children) ? react__WEBPACK_IMPORTED_MODULE_0__.Children.only(children) : children;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(child) ? child : void 0;\n}\nfunction useAnimationPersist(ref) {\n    const [isPresent, unmount] = usePersist();\n    const previousAnimationName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const unmountAnimationName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,_use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        const element = ref.current;\n        if (!element) {\n            return;\n        }\n        const handleAnimationEnd = (event)=>{\n            if (event.animationName === unmountAnimationName.current) {\n                unmount();\n            }\n            previousAnimationName.current = event.animationName;\n        };\n        element.addEventListener(\"animationcancel\", handleAnimationEnd);\n        element.addEventListener(\"animationend\", handleAnimationEnd);\n        return ()=>{\n            element.removeEventListener(\"animationcancel\", handleAnimationEnd);\n            element.removeEventListener(\"animationend\", handleAnimationEnd);\n        };\n    }, [\n        ref,\n        unmount\n    ]);\n    (0,_use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        const element = ref.current;\n        let animationFrameId;\n        if (!element) {\n            return;\n        }\n        if (!isPresent) {\n            animationFrameId = requestAnimationFrame(()=>{\n                const styles = getComputedStyle(element);\n                unmountAnimationName.current = styles.animationName;\n                if (styles.animationName === \"none\" || styles.animationName === previousAnimationName.current || styles.display === \"none\") {\n                    unmount();\n                }\n            });\n        }\n        return ()=>{\n            cancelAnimationFrame(animationFrameId);\n        };\n    }, [\n        isPresent,\n        ref,\n        unmount\n    ]);\n}\nfunction Persist({ children }) {\n    const [isPersisting, setPersisting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const lastPresentChild = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const child = getChild(children);\n    const unmount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        (0,_flush_sync_mjs__WEBPACK_IMPORTED_MODULE_3__.flushSync)(()=>setPersisting(false));\n    }, []);\n    (0,_use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        if (child) {\n            setPersisting(true);\n            lastPresentChild.current = child;\n        }\n    }, [\n        child\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PersistContext.Provider, {\n        value: [\n            Boolean(child),\n            unmount\n        ]\n    }, child ?? (isPersisting ? lastPresentChild.current : null));\n}\nif (true) {\n    Persist.displayName = PERSIST_NAME;\n}\n //# sourceMappingURL=Persist.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9QZXJzaXN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQW9CQSxNQUFBQSxlQUFBO0FBUUEsTUFBQUMsK0JBQUFDLG9EQUFBQSxDQUFBO0FBRU8sU0FBQUM7SUFDTCxNQUFBQyxpQkFBQUMsaURBQUFBLENBQUFKO0lBRUEsT0FBQUssb0RBQUFBLENBQUFGLGdCQUFBO0FBQ0Y7QUFFQSxTQUFBRyxTQUFBQyxRQUFBO0lBQ0UsTUFBQUMsUUFBQUMsTUFBQUMsT0FBQSxDQUFBSCxZQUFBSSwyQ0FBQUEsQ0FBQUMsSUFBQSxDQUFBTCxZQUFBQTtJQUlBLHFCQUFBTSxxREFBQUEsQ0FBQUwsU0FBQUEsUUFBQTtBQUNGO0FBRU8sU0FBQU0sb0JBQUFDLEdBQUE7SUFDTCxPQUFBQyxXQUFBQyxRQUFBLEdBQUFmO0lBQ0EsTUFBQWdCLHdCQUFBQyw2Q0FBQUEsQ0FBQTtJQUNBLE1BQUFDLHVCQUFBRCw2Q0FBQUEsQ0FBQTtJQUVBRSx1RUFBZUEsQ0FBZjtRQUNFLE1BQUFDLFVBQUFQLElBQUFRLE9BQUE7UUFFQSxLQUFBRCxTQUFBO1lBQ0U7UUFBQTtRQVdGLE1BQUFFLHFCQUFBLENBQUFDO1lBQ0UsSUFBQUEsTUFBQUMsYUFBQSxLQUFBTixxQkFBQUcsT0FBQTtnQkFDRU47WUFBUTtZQUdWQyxzQkFBQUssT0FBQSxHQUFBRSxNQUFBQyxhQUFBO1FBQXNDO1FBR3hDSixRQUFBSyxnQkFBQSxvQkFBQUg7UUFDQUYsUUFBQUssZ0JBQUEsaUJBQUFIO1FBRUE7WUFDRUYsUUFBQU0sbUJBQUEsb0JBQUFKO1lBQ0FGLFFBQUFNLG1CQUFBLGlCQUFBSjtRQUE4RDtJQUNoRTtRQUFBVDtRQUFBRTtLQUFBO0lBR0ZJLHVFQUFlQSxDQUFmO1FBQ0UsTUFBQUMsVUFBQVAsSUFBQVEsT0FBQTtRQUNBLElBQUFNO1FBRUEsS0FBQVAsU0FBQTtZQUNFO1FBQUE7UUFHRixLQUFBTixXQUFBO1lBR0VhLG1CQUFBQyxzQkFBQTtnQkFDRSxNQUFBQyxTQUFBQyxpQkFBQVY7Z0JBQ0FGLHFCQUFBRyxPQUFBLEdBQUFRLE9BQUFMLGFBQUE7Z0JBRUEsSUFBQUssT0FBQUwsYUFBQSxlQUFBSyxPQUFBTCxhQUFBLEtBQUFSLHNCQUFBSyxPQUFBLElBQUFRLE9BQUFFLE9BQUE7b0JBS0VoQjtnQkFBUTtZQUNWO1FBQ0Q7UUFHSDtZQUNFaUIscUJBQUFMO1FBQXFDO0lBQ3ZDO1FBQUFiO1FBQUFEO1FBQUFFO0tBQUE7QUFFSjtBQU1nQixTQUFBa0IsUUFBQSxFQUFBNUIsUUFBQTtJQUNkLE9BQUE2QixjQUFBQyxjQUFBLEdBQUFDLCtDQUFBQSxDQUFBO0lBQ0EsTUFBQUMsbUJBQUFwQiw2Q0FBQUEsQ0FBQTtJQUNBLE1BQUFYLFFBQUFGLFNBQUFDO0lBRUEsTUFBQVUsVUFBQXVCLGtEQUFBQSxDQUFBO1FBQ0VDLDBEQUFTQSxDQUFULElBQUFKLGNBQUE7SUFBb0M7SUFHdENoQix1RUFBZUEsQ0FBZjtRQUNFLElBQUFiLE9BQUE7WUFDRTZCLGNBQUE7WUFDQUUsaUJBQUFoQixPQUFBLEdBQUFmO1FBQTJCO0lBQzdCO1FBQUFBO0tBQUE7SUFHRixxQ0FBQWtDLGdEQUFBLENBQUExQyxlQUFBNEMsUUFBQTtRQUNHQyxPQUFBO1lBQUFDLFFBQUF0QztZQUFBUztTQUFBO0lBQXVELEdBQUFULFNBQUE0QixDQUFBQSxlQUFBRyxpQkFBQWhCLE9BQUE7QUFJNUQ7QUFFQSxJQUFBd0IsSUFBQTtJQUNFWixRQUFBYSxXQUFBLEdBQUFqRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4uLy4uL3NyYy91dGlscy9QZXJzaXN0LnRzeD9hYzcxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyBubiB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgdHlwZSB7IFJlYWN0Tm9kZSwgUmVmT2JqZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtcbiAgQ2hpbGRyZW4sXG4gIGNyZWF0ZUNvbnRleHQsXG4gIGlzVmFsaWRFbGVtZW50LFxuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlUmVmLFxuICB1c2VTdGF0ZSxcbn0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IGZsdXNoU3luYyB9IGZyb20gXCIuL2ZsdXNoLXN5bmNcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCI7XG5cbi8vIFBlcnNpc3QgaXMgYW4gb3Zlcmx5IHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBGcmFtZXIgTW90aW9uJ3MgQW5pbWF0ZVByZXNlbmNlLFxuLy8gbW9zdGx5IG1pbWlja2luZyBpdHMgdXNlUHJlc2VuY2UgQVBJOiBodHRwczovL2dpdGh1Yi5jb20vZnJhbWVyL21vdGlvbi9ibG9iL21haW4vcGFja2FnZXMvZnJhbWVyLW1vdGlvbi9zcmMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLnRzXG5cbmNvbnN0IFBFUlNJU1RfTkFNRSA9IFwiUGVyc2lzdFwiO1xuXG5pbnRlcmZhY2UgUGVyc2lzdFByb3BzIHtcbiAgY2hpbGRyZW46IEV4Y2x1ZGU8UmVhY3ROb2RlLCBJdGVyYWJsZTxSZWFjdE5vZGU+Pjtcbn1cblxudHlwZSBQZXJzaXN0Q29udGV4dCA9IFtib29sZWFuLCAoKSA9PiB2b2lkXTtcblxuY29uc3QgUGVyc2lzdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFBlcnNpc3RDb250ZXh0IHwgbnVsbD4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQZXJzaXN0KCkge1xuICBjb25zdCBwZXJzaXN0Q29udGV4dCA9IHVzZUNvbnRleHQoUGVyc2lzdENvbnRleHQpO1xuXG4gIHJldHVybiBubihwZXJzaXN0Q29udGV4dCwgXCJQZXJzaXN0IGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkKGNoaWxkcmVuOiBSZWFjdE5vZGUpIHtcbiAgY29uc3QgY2hpbGQ6IFJlYWN0Tm9kZSA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgPyBDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICAgIDogY2hpbGRyZW47XG5cbiAgcmV0dXJuIGlzVmFsaWRFbGVtZW50KGNoaWxkKSA/IGNoaWxkIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uUGVyc2lzdChyZWY6IFJlZk9iamVjdDxIVE1MRWxlbWVudD4pIHtcbiAgY29uc3QgW2lzUHJlc2VudCwgdW5tb3VudF0gPSB1c2VQZXJzaXN0KCk7XG4gIGNvbnN0IHByZXZpb3VzQW5pbWF0aW9uTmFtZSA9IHVzZVJlZjxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgdW5tb3VudEFuaW1hdGlvbk5hbWUgPSB1c2VSZWY8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHBlcnNpc3RpbmcgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBhbmltYXRpb24uXG4gICAgICpcbiAgICAgKiBXZSBrZWVwIHRyYWNrIG9mIGFsbCBlbmRpbmcgYW5pbWF0aW9ucyBiZWNhdXNlIGFuaW1hdGlvbnMgc3RheVxuICAgICAqIG9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuYW5pbWF0aW9uTmFtZSBldmVuIGlmIHRoZXkncmUgb3ZlcixcbiAgICAgKiBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgYW5pbWF0aW9ucyB0byB0cnVseSBrbm93IGlmXG4gICAgICogYW4gYW5pbWF0aW9uIHNob3VsZCBiZSB3YWl0ZWQgb24uXG4gICAgICovXG4gICAgY29uc3QgaGFuZGxlQW5pbWF0aW9uRW5kID0gKGV2ZW50OiBBbmltYXRpb25FdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmFuaW1hdGlvbk5hbWUgPT09IHVubW91bnRBbmltYXRpb25OYW1lLmN1cnJlbnQpIHtcbiAgICAgICAgdW5tb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c0FuaW1hdGlvbk5hbWUuY3VycmVudCA9IGV2ZW50LmFuaW1hdGlvbk5hbWU7XG4gICAgfTtcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmNhbmNlbFwiLCBoYW5kbGVBbmltYXRpb25FbmQpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBoYW5kbGVBbmltYXRpb25FbmQpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmNhbmNlbFwiLCBoYW5kbGVBbmltYXRpb25FbmQpO1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIGhhbmRsZUFuaW1hdGlvbkVuZCk7XG4gICAgfTtcbiAgfSwgW3JlZiwgdW5tb3VudF0pO1xuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xuICAgIGxldCBhbmltYXRpb25GcmFtZUlkOiBudW1iZXI7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUHJlc2VudCkge1xuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHVubW91bnRpbmcsIHdhaXQgZm9yIGEgcmVwYWludCBhbmQgY2hlY2tcbiAgICAgIC8vIGlmIGl0IGlzIHZpc2libGUgYW5kIGhhcyBhbiBhbmltYXRpb24uIElmIG5vdCwgdW5tb3VudCBpbW1lZGlhdGVseS5cbiAgICAgIGFuaW1hdGlvbkZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICB1bm1vdW50QW5pbWF0aW9uTmFtZS5jdXJyZW50ID0gc3R5bGVzLmFuaW1hdGlvbk5hbWU7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0eWxlcy5hbmltYXRpb25OYW1lID09PSBcIm5vbmVcIiB8fFxuICAgICAgICAgIHN0eWxlcy5hbmltYXRpb25OYW1lID09PSBwcmV2aW91c0FuaW1hdGlvbk5hbWUuY3VycmVudCB8fFxuICAgICAgICAgIHN0eWxlcy5kaXNwbGF5ID09PSBcIm5vbmVcIlxuICAgICAgICApIHtcbiAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkKTtcbiAgICB9O1xuICB9LCBbaXNQcmVzZW50LCByZWYsIHVubW91bnRdKTtcbn1cblxuLyoqXG4gKiBQZXJzaXN0IGEgY29tcG9uZW50IHVudGlsIGl0IGRlY2lkZXMgdG8gdW5tb3VudCBieVxuICogaXRzZWxmIChpbnN0ZWFkIG9mIG9yY2hlc3RyYXRpbmcgdGhlIHVubW91bnQgZnJvbSB0aGUgcGFyZW50KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBlcnNpc3QoeyBjaGlsZHJlbiB9OiBQZXJzaXN0UHJvcHMpIHtcbiAgY29uc3QgW2lzUGVyc2lzdGluZywgc2V0UGVyc2lzdGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgbGFzdFByZXNlbnRDaGlsZCA9IHVzZVJlZjxSZWFjdE5vZGU+KG51bGwpO1xuICBjb25zdCBjaGlsZCA9IGdldENoaWxkKGNoaWxkcmVuKTtcblxuICBjb25zdCB1bm1vdW50ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGZsdXNoU3luYygoKSA9PiBzZXRQZXJzaXN0aW5nKGZhbHNlKSk7XG4gIH0sIFtdKTtcblxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgc2V0UGVyc2lzdGluZyh0cnVlKTtcbiAgICAgIGxhc3RQcmVzZW50Q2hpbGQuY3VycmVudCA9IGNoaWxkO1xuICAgIH1cbiAgfSwgW2NoaWxkXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8UGVyc2lzdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e1tCb29sZWFuKGNoaWxkKSwgdW5tb3VudF19PlxuICAgICAge2NoaWxkID8/IChpc1BlcnNpc3RpbmcgPyBsYXN0UHJlc2VudENoaWxkLmN1cnJlbnQgOiBudWxsKX1cbiAgICA8L1BlcnNpc3RDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFBlcnNpc3QuZGlzcGxheU5hbWUgPSBQRVJTSVNUX05BTUU7XG59XG4iXSwibmFtZXMiOlsiUEVSU0lTVF9OQU1FIiwiUGVyc2lzdENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlUGVyc2lzdCIsInBlcnNpc3RDb250ZXh0IiwidXNlQ29udGV4dCIsIm5uIiwiZ2V0Q2hpbGQiLCJjaGlsZHJlbiIsImNoaWxkIiwiQXJyYXkiLCJpc0FycmF5IiwiQ2hpbGRyZW4iLCJvbmx5IiwiaXNWYWxpZEVsZW1lbnQiLCJ1c2VBbmltYXRpb25QZXJzaXN0IiwicmVmIiwiaXNQcmVzZW50IiwidW5tb3VudCIsInByZXZpb3VzQW5pbWF0aW9uTmFtZSIsInVzZVJlZiIsInVubW91bnRBbmltYXRpb25OYW1lIiwidXNlTGF5b3V0RWZmZWN0IiwiZWxlbWVudCIsImN1cnJlbnQiLCJoYW5kbGVBbmltYXRpb25FbmQiLCJldmVudCIsImFuaW1hdGlvbk5hbWUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFuaW1hdGlvbkZyYW1lSWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwiZGlzcGxheSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiUGVyc2lzdCIsImlzUGVyc2lzdGluZyIsInNldFBlcnNpc3RpbmciLCJ1c2VTdGF0ZSIsImxhc3RQcmVzZW50Q2hpbGQiLCJ1c2VDYWxsYmFjayIsImZsdXNoU3luYyIsIlJlYWN0X19kZWZhdWx0IiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiLCJCb29sZWFuIiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/Persist.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/Portal.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/Portal.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Portal: () => (/* binding */ Portal)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* __next_internal_client_entry_do_not_use__ Portal auto */ \n\n\nconst PORTAL_NAME = \"Portal\";\nconst Portal = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ container = document?.body, asChild, ...props }, forwardedRef)=>{\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_2__.Slot : \"div\";\n    return container ? /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n        \"data-liveblocks-portal\": \"\",\n        ...props,\n        ref: forwardedRef\n    }), container) : null;\n});\nif (true) {\n    Portal.displayName = PORTAL_NAME;\n}\n //# sourceMappingURL=Portal.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9Qb3J0YWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFRQSxNQUFBQSxjQUFBO0FBU0EsTUFBQUMsdUJBQUFDLGlEQUFBQSxDQUFlLEdBQUFDLFlBQUFDLFVBQUFDLElBQUEsRUFBQUMsT0FBQSxLQUFBQyxPQUFBLEVBQUFDO0lBRVgsTUFBQUMsWUFBQUgsVUFBQUksc0RBQUFBLEdBQUE7SUFFQSxPQUFBUCwwQkFBQVEsdURBQUFBLENBQ0ksOEJBQUFDLGdEQUFBLENBQUFILFdBQUE7UUFDRztRQUFpQyxHQUFBRixLQUFBO1FBQU9PLEtBQUFOO0lBQVksSUFBY0wsYUFDbkU7QUFFRjtBQUlSLElBQUFZLElBQUE7SUFDRWQsT0FBQWUsV0FBQSxHQUFBaEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uLi8uLi9zcmMvdXRpbHMvUG9ydGFsLnRzeD9iMDBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyBTbG90IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1zbG90XCI7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuXG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudFByb3BzV2l0aFNsb3QgfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuY29uc3QgUE9SVEFMX05BTUUgPSBcIlBvcnRhbFwiO1xuXG5pbnRlcmZhY2UgUG9ydGFsUHJvcHMgZXh0ZW5kcyBDb21wb25lbnRQcm9wc1dpdGhTbG90PFwiZGl2XCI+IHtcbiAgLyoqXG4gICAqIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHRoZSBwb3J0YWwgaW50by5cbiAgICovXG4gIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50IHwgbnVsbDtcbn1cblxuY29uc3QgUG9ydGFsID0gZm9yd2FyZFJlZjxIVE1MRGl2RWxlbWVudCwgUG9ydGFsUHJvcHM+KFxuICAoeyBjb250YWluZXIgPSBkb2N1bWVudD8uYm9keSwgYXNDaGlsZCwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gYXNDaGlsZCA/IFNsb3QgOiBcImRpdlwiO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lclxuICAgICAgPyBjcmVhdGVQb3J0YWwoXG4gICAgICAgICAgPENvbXBvbmVudCBkYXRhLWxpdmVibG9ja3MtcG9ydGFsPVwiXCIgey4uLnByb3BzfSByZWY9e2ZvcndhcmRlZFJlZn0gLz4sXG4gICAgICAgICAgY29udGFpbmVyXG4gICAgICAgIClcbiAgICAgIDogbnVsbDtcbiAgfVxuKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBQb3J0YWwuZGlzcGxheU5hbWUgPSBQT1JUQUxfTkFNRTtcbn1cblxuZXhwb3J0IHsgUG9ydGFsIH07XG4iXSwibmFtZXMiOlsiUE9SVEFMX05BTUUiLCJQb3J0YWwiLCJmb3J3YXJkUmVmIiwiY29udGFpbmVyIiwiZG9jdW1lbnQiLCJib2R5IiwiYXNDaGlsZCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiQ29tcG9uZW50IiwiU2xvdCIsImNyZWF0ZVBvcnRhbCIsIlJlYWN0X19kZWZhdWx0IiwiY3JlYXRlRWxlbWVudCIsInJlZiIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/Portal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/capitalize.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/capitalize.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   capitalize: () => (/* binding */ capitalize)\n/* harmony export */ });\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\n\n//# sourceMappingURL=capitalize.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9jYXBpdGFsaXplLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBOztBQUVzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL2NhcGl0YWxpemUubWpzPzM4ZTciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuZXhwb3J0IHsgY2FwaXRhbGl6ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FwaXRhbGl6ZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/capitalize.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/chunk.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/chunk.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chunk: () => (/* binding */ chunk)\n/* harmony export */ });\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n\n//# sourceMappingURL=chunk.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9jaHVuay5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9jaHVuay5tanM/ODk3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSkge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpICs9IHNpemUpIHtcbiAgICBjaHVua3MucHVzaChhcnJheS5zbGljZShpLCBpICsgc2l6ZSkpO1xuICB9XG4gIHJldHVybiBjaHVua3M7XG59XG5cbmV4cG9ydCB7IGNodW5rIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/chunk.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/clamp.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/clamp.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp)\n/* harmony export */ });\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\n\n//# sourceMappingURL=clamp.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9jbGFtcC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9jbGFtcC5tanM/ZjI0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG5leHBvcnQgeyBjbGFtcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xhbXAubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/clamp.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   classNames: () => (/* binding */ classNames)\n/* harmony export */ });\nfunction classNames(...args) {\n  return args.filter((arg) => typeof arg === \"string\" || typeof arg === \"number\").join(\" \");\n}\n\n\n//# sourceMappingURL=class-names.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9jbGFzcy1uYW1lcy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9jbGFzcy1uYW1lcy5tanM/ZGZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjbGFzc05hbWVzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MuZmlsdGVyKChhcmcpID0+IHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikuam9pbihcIiBcIik7XG59XG5cbmV4cG9ydCB7IGNsYXNzTmFtZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsYXNzLW5hbWVzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/exists.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/exists.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exists: () => (/* binding */ exists)\n/* harmony export */ });\nfunction exists(input) {\n  return input !== null && input !== void 0;\n}\n\n\n//# sourceMappingURL=exists.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9leGlzdHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvZXhpc3RzLm1qcz83MjEwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGV4aXN0cyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQgIT09IG51bGwgJiYgaW5wdXQgIT09IHZvaWQgMDtcbn1cblxuZXhwb3J0IHsgZXhpc3RzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGlzdHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/exists.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/flush-sync.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/flush-sync.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   flushSync: () => (/* binding */ flushSync)\n/* harmony export */ });\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\nconst useReactFlushSync = react_dom__WEBPACK_IMPORTED_MODULE_0__[\"flushSync\".toString()];\nfunction flushSyncFallback(fn) {\n  return fn();\n}\nconst flushSync = useReactFlushSync ?? flushSyncFallback;\n\n\n//# sourceMappingURL=flush-sync.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9mbHVzaC1zeW5jLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQzs7QUFFakMsMEJBQTBCLHNDQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL2ZsdXNoLXN5bmMubWpzPzZjYTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmNvbnN0IHVzZVJlYWN0Rmx1c2hTeW5jID0gUmVhY3RET01bXCJmbHVzaFN5bmNcIi50b1N0cmluZygpXTtcbmZ1bmN0aW9uIGZsdXNoU3luY0ZhbGxiYWNrKGZuKSB7XG4gIHJldHVybiBmbigpO1xufVxuY29uc3QgZmx1c2hTeW5jID0gdXNlUmVhY3RGbHVzaFN5bmMgPz8gZmx1c2hTeW5jRmFsbGJhY2s7XG5cbmV4cG9ydCB7IGZsdXNoU3luYyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmx1c2gtc3luYy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/flush-sync.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/get-initials.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/get-initials.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInitials: () => (/* binding */ getInitials)\n/* harmony export */ });\nfunction getInitials(name) {\n  return name.trim().split(\" \").reduce((initials, name2, index, array) => {\n    if (index === 0 || index === array.length - 1) {\n      initials += name2.charAt(0).toLocaleUpperCase();\n    }\n    return initials;\n  }, \"\");\n}\n\n\n//# sourceMappingURL=get-initials.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9nZXQtaW5pdGlhbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvZ2V0LWluaXRpYWxzLm1qcz8yMWY2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldEluaXRpYWxzKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUudHJpbSgpLnNwbGl0KFwiIFwiKS5yZWR1Y2UoKGluaXRpYWxzLCBuYW1lMiwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICBpbml0aWFscyArPSBuYW1lMi5jaGFyQXQoMCkudG9Mb2NhbGVVcHBlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxzO1xuICB9LCBcIlwiKTtcbn1cblxuZXhwb3J0IHsgZ2V0SW5pdGlhbHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1pbml0aWFscy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/get-initials.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/intl.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/intl.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dateTimeFormat: () => (/* binding */ dateTimeFormat),\n/* harmony export */   listFormat: () => (/* binding */ listFormat),\n/* harmony export */   relativeTimeFormat: () => (/* binding */ relativeTimeFormat)\n/* harmony export */ });\n/* harmony import */ var _memoize_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memoize.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/memoize.mjs\");\n\n\nconst dateTimeFormat = (0,_memoize_mjs__WEBPACK_IMPORTED_MODULE_0__.memoize)(\n  (...args) => {\n    return new Intl.DateTimeFormat(...args);\n  }\n);\nconst relativeTimeFormat = (0,_memoize_mjs__WEBPACK_IMPORTED_MODULE_0__.memoize)(\n  (...args) => {\n    return new Intl.RelativeTimeFormat(...args);\n  }\n);\nconst listFormat = (0,_memoize_mjs__WEBPACK_IMPORTED_MODULE_0__.memoize)(\n  (...args) => {\n    return new Intl.ListFormat(...args);\n  }\n);\n\n\n//# sourceMappingURL=intl.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9pbnRsLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDOztBQUV4Qyx1QkFBdUIscURBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRTBEO0FBQzFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvaW50bC5tanM/YTEyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi9tZW1vaXplLm1qcyc7XG5cbmNvbnN0IGRhdGVUaW1lRm9ybWF0ID0gbWVtb2l6ZShcbiAgKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoLi4uYXJncyk7XG4gIH1cbik7XG5jb25zdCByZWxhdGl2ZVRpbWVGb3JtYXQgPSBtZW1vaXplKFxuICAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQoLi4uYXJncyk7XG4gIH1cbik7XG5jb25zdCBsaXN0Rm9ybWF0ID0gbWVtb2l6ZShcbiAgKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gbmV3IEludGwuTGlzdEZvcm1hdCguLi5hcmdzKTtcbiAgfVxuKTtcblxuZXhwb3J0IHsgZGF0ZVRpbWVGb3JtYXQsIGxpc3RGb3JtYXQsIHJlbGF0aXZlVGltZUZvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50bC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/intl.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-apple.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/is-apple.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isApple: () => (/* binding */ isApple)\n/* harmony export */ });\nconst APPLE_REGEX = /Mac|iPod|iPhone|iPad/;\nfunction isApple() {\n  return typeof window !== \"undefined\" && APPLE_REGEX.test(window.navigator.platform);\n}\n\n\n//# sourceMappingURL=is-apple.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9pcy1hcHBsZS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL2lzLWFwcGxlLm1qcz9kNmY5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEFQUExFX1JFR0VYID0gL01hY3xpUG9kfGlQaG9uZXxpUGFkLztcbmZ1bmN0aW9uIGlzQXBwbGUoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIEFQUExFX1JFR0VYLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSk7XG59XG5cbmV4cG9ydCB7IGlzQXBwbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWFwcGxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-apple.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-key.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/is-key.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isKey: () => (/* binding */ isKey)\n/* harmony export */ });\n/* harmony import */ var _is_apple_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-apple.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-apple.mjs\");\n\n\nconst MODIFIERS = {\n  alt: () => \"altKey\",\n  ctrl: () => \"ctrlKey\",\n  meta: () => \"metaKey\",\n  mod: () => (0,_is_apple_mjs__WEBPACK_IMPORTED_MODULE_0__.isApple)() ? \"metaKey\" : \"ctrlKey\",\n  shift: () => \"shiftKey\"\n};\nfunction isKey(event, key, modifiers = {}) {\n  if (event.key !== key) {\n    return false;\n  }\n  const explicitModifiers = Object.entries(modifiers).filter(\n    ([, value]) => typeof value === \"boolean\"\n  );\n  return explicitModifiers.every(([modifier, value]) => {\n    const property = MODIFIERS[modifier]();\n    return event[property] === value;\n  });\n}\n\n\n//# sourceMappingURL=is-key.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9pcy1rZXkubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0RBQU87QUFDcEI7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvaXMta2V5Lm1qcz8xNDc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzQXBwbGUgfSBmcm9tICcuL2lzLWFwcGxlLm1qcyc7XG5cbmNvbnN0IE1PRElGSUVSUyA9IHtcbiAgYWx0OiAoKSA9PiBcImFsdEtleVwiLFxuICBjdHJsOiAoKSA9PiBcImN0cmxLZXlcIixcbiAgbWV0YTogKCkgPT4gXCJtZXRhS2V5XCIsXG4gIG1vZDogKCkgPT4gaXNBcHBsZSgpID8gXCJtZXRhS2V5XCIgOiBcImN0cmxLZXlcIixcbiAgc2hpZnQ6ICgpID0+IFwic2hpZnRLZXlcIlxufTtcbmZ1bmN0aW9uIGlzS2V5KGV2ZW50LCBrZXksIG1vZGlmaWVycyA9IHt9KSB7XG4gIGlmIChldmVudC5rZXkgIT09IGtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBleHBsaWNpdE1vZGlmaWVycyA9IE9iamVjdC5lbnRyaWVzKG1vZGlmaWVycykuZmlsdGVyKFxuICAgIChbLCB2YWx1ZV0pID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCJcbiAgKTtcbiAgcmV0dXJuIGV4cGxpY2l0TW9kaWZpZXJzLmV2ZXJ5KChbbW9kaWZpZXIsIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gTU9ESUZJRVJTW21vZGlmaWVyXSgpO1xuICAgIHJldHVybiBldmVudFtwcm9wZXJ0eV0gPT09IHZhbHVlO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgaXNLZXkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWtleS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-key.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/memoize.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/memoize.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   memoize: () => (/* binding */ memoize)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n\n\nfunction memoize(fn) {\n  const cache = /* @__PURE__ */ new Map();\n  return (...args) => {\n    const key = JSON.stringify(args.map((arg) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.stringify)(arg)));\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n\n//# sourceMappingURL=memoize.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9tZW1vaXplLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJEQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvbWVtb2l6ZS5tanM/M2JmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICdAbGl2ZWJsb2Nrcy9jb3JlJztcblxuZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MubWFwKChhcmcpID0+IHN0cmluZ2lmeShhcmcpKSk7XG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgIGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZXhwb3J0IHsgbWVtb2l6ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVtb2l6ZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/memoize.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/pluralize.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/pluralize.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pluralize: () => (/* binding */ pluralize)\n/* harmony export */ });\nfunction pluralize(count, singular, plural) {\n  return count === 1 ? singular : plural ?? `${singular}s`;\n}\n\n\n//# sourceMappingURL=pluralize.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9wbHVyYWxpemUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEOztBQUVxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3BsdXJhbGl6ZS5tanM/ZTU2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBwbHVyYWxpemUoY291bnQsIHNpbmd1bGFyLCBwbHVyYWwpIHtcbiAgcmV0dXJuIGNvdW50ID09PSAxID8gc2luZ3VsYXIgOiBwbHVyYWwgPz8gYCR7c2luZ3VsYXJ9c2A7XG59XG5cbmV4cG9ydCB7IHBsdXJhbGl6ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1cmFsaXplLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/pluralize.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/request-idle-callback.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/request-idle-callback.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancelIdleCallback: () => (/* binding */ cancelIdleCallback),\n/* harmony export */   requestIdleCallback: () => (/* binding */ requestIdleCallback)\n/* harmony export */ });\nconst IDLE_CALLBACK_FALLBACK_TIMEOUT = 100;\nfunction requestIdleCallbackFallback(callback, options) {\n  return setTimeout(\n    callback,\n    Math.min(options?.timeout ?? Infinity, IDLE_CALLBACK_FALLBACK_TIMEOUT)\n  );\n}\nconst requestIdleCallback = (typeof window !== \"undefined\" ? window.requestIdleCallback : null) ?? requestIdleCallbackFallback;\nconst cancelIdleCallback = (typeof window !== \"undefined\" ? window.cancelIdleCallback : null) ?? clearTimeout;\n\n\n//# sourceMappingURL=request-idle-callback.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9yZXF1ZXN0LWlkbGUtY2FsbGJhY2subWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRDtBQUNuRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3JlcXVlc3QtaWRsZS1jYWxsYmFjay5tanM/MTY3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJRExFX0NBTExCQUNLX0ZBTExCQUNLX1RJTUVPVVQgPSAxMDA7XG5mdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrRmFsbGJhY2soY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoXG4gICAgY2FsbGJhY2ssXG4gICAgTWF0aC5taW4ob3B0aW9ucz8udGltZW91dCA/PyBJbmZpbml0eSwgSURMRV9DQUxMQkFDS19GQUxMQkFDS19USU1FT1VUKVxuICApO1xufVxuY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgOiBudWxsKSA/PyByZXF1ZXN0SWRsZUNhbGxiYWNrRmFsbGJhY2s7XG5jb25zdCBjYW5jZWxJZGxlQ2FsbGJhY2sgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgOiBudWxsKSA/PyBjbGVhclRpbWVvdXQ7XG5cbmV4cG9ydCB7IGNhbmNlbElkbGVDYWxsYmFjaywgcmVxdWVzdElkbGVDYWxsYmFjayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1pZGxlLWNhbGxiYWNrLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/request-idle-callback.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/request-submit.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/request-submit.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requestSubmit: () => (/* binding */ requestSubmit)\n/* harmony export */ });\nfunction requestSubmit(form, submitter) {\n  if (typeof form.requestSubmit === \"function\") {\n    return form.requestSubmit(submitter);\n  }\n  if (submitter) {\n    submitter.click();\n  } else {\n    submitter = document.createElement(\"input\");\n    submitter.type = \"submit\";\n    submitter.hidden = true;\n    form.appendChild(submitter);\n    submitter.click();\n    form.removeChild(submitter);\n  }\n}\n\n\n//# sourceMappingURL=request-submit.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9yZXF1ZXN0LXN1Ym1pdC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3JlcXVlc3Qtc3VibWl0Lm1qcz9iNjdjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHJlcXVlc3RTdWJtaXQoZm9ybSwgc3VibWl0dGVyKSB7XG4gIGlmICh0eXBlb2YgZm9ybS5yZXF1ZXN0U3VibWl0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZm9ybS5yZXF1ZXN0U3VibWl0KHN1Ym1pdHRlcik7XG4gIH1cbiAgaWYgKHN1Ym1pdHRlcikge1xuICAgIHN1Ym1pdHRlci5jbGljaygpO1xuICB9IGVsc2Uge1xuICAgIHN1Ym1pdHRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBzdWJtaXR0ZXIudHlwZSA9IFwic3VibWl0XCI7XG4gICAgc3VibWl0dGVyLmhpZGRlbiA9IHRydWU7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChzdWJtaXR0ZXIpO1xuICAgIHN1Ym1pdHRlci5jbGljaygpO1xuICAgIGZvcm0ucmVtb3ZlQ2hpbGQoc3VibWl0dGVyKTtcbiAgfVxufVxuXG5leHBvcnQgeyByZXF1ZXN0U3VibWl0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LXN1Ym1pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/request-submit.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/url.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/url.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateURL: () => (/* binding */ generateURL)\n/* harmony export */ });\nconst PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nfunction generateURL(url, params, hash) {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(url);\n  const urlObject = new URL(url, isAbsolute ? void 0 : PLACEHOLDER_BASE_URL);\n  if (params !== void 0) {\n    for (const [param, value] of Object.entries(params)) {\n      if (value) {\n        urlObject.searchParams.set(param, String(value));\n      }\n    }\n  }\n  if (!urlObject.hash && hash !== void 0) {\n    urlObject.hash = `#${hash}`;\n  }\n  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\n\n\n//# sourceMappingURL=url.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91cmwubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91cmwubWpzP2M1ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUExBQ0VIT0xERVJfQkFTRV9VUkwgPSBcImh0dHBzOi8vbG9jYWxob3N0Ojk5OTlcIjtcbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKj86LztcbmZ1bmN0aW9uIGdlbmVyYXRlVVJMKHVybCwgcGFyYW1zLCBoYXNoKSB7XG4gIGNvbnN0IGlzQWJzb2x1dGUgPSBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh1cmwpO1xuICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCwgaXNBYnNvbHV0ZSA/IHZvaWQgMCA6IFBMQUNFSE9MREVSX0JBU0VfVVJMKTtcbiAgaWYgKHBhcmFtcyAhPT0gdm9pZCAwKSB7XG4gICAgZm9yIChjb25zdCBbcGFyYW0sIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5zZXQocGFyYW0sIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIXVybE9iamVjdC5oYXNoICYmIGhhc2ggIT09IHZvaWQgMCkge1xuICAgIHVybE9iamVjdC5oYXNoID0gYCMke2hhc2h9YDtcbiAgfVxuICByZXR1cm4gaXNBYnNvbHV0ZSA/IHVybE9iamVjdC5ocmVmIDogdXJsT2JqZWN0LmhyZWYucmVwbGFjZShQTEFDRUhPTERFUl9CQVNFX1VSTCwgXCJcIik7XG59XG5cbmV4cG9ydCB7IGdlbmVyYXRlVVJMIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/url.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-controllable-state.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-controllable-state.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useControllableState: () => (/* binding */ useControllableState)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\nfunction useControllableState(value, onChange, defaultValue) {\n  const [uncontrolledValue, setUncontrolledValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue);\n  const isControlled = value !== void 0;\n  const wasControlled = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isControlled);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if ( true && wasControlled.current !== isControlled) {\n      _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n        `A component is changing from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`\n      );\n    }\n    wasControlled.current = isControlled;\n  }, [isControlled]);\n  const currentValue = isControlled ? value : uncontrolledValue;\n  const setValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (value2) => {\n      if (isControlled) {\n        return onChange?.(value2);\n      } else {\n        setUncontrolledValue(value2);\n        return onChange?.(value2);\n      }\n    },\n    [isControlled, onChange]\n  );\n  return [currentValue, setValue];\n}\n\n\n//# sourceMappingURL=use-controllable-state.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtY29udHJvbGxhYmxlLXN0YXRlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkM7QUFDc0I7O0FBRWpFO0FBQ0Esb0RBQW9ELCtDQUFRO0FBQzVEO0FBQ0Esd0JBQXdCLDZDQUFNO0FBQzlCLEVBQUUsZ0RBQVM7QUFDWCxRQUFRLEtBQXFDO0FBQzdDLE1BQU0scURBQU87QUFDYix3Q0FBd0MsK0NBQStDLEtBQUssNkNBQTZDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3VzZS1jb250cm9sbGFibGUtc3RhdGUubWpzPzJkMjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uc29sZSB9IGZyb20gJ0BsaXZlYmxvY2tzL2NvcmUnO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gdXNlQ29udHJvbGxhYmxlU3RhdGUodmFsdWUsIG9uQ2hhbmdlLCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3QgW3VuY29udHJvbGxlZFZhbHVlLCBzZXRVbmNvbnRyb2xsZWRWYWx1ZV0gPSB1c2VTdGF0ZShkZWZhdWx0VmFsdWUpO1xuICBjb25zdCBpc0NvbnRyb2xsZWQgPSB2YWx1ZSAhPT0gdm9pZCAwO1xuICBjb25zdCB3YXNDb250cm9sbGVkID0gdXNlUmVmKGlzQ29udHJvbGxlZCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB3YXNDb250cm9sbGVkLmN1cnJlbnQgIT09IGlzQ29udHJvbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgZnJvbSAke3dhc0NvbnRyb2xsZWQgPyBcImNvbnRyb2xsZWRcIiA6IFwidW5jb250cm9sbGVkXCJ9IHRvICR7aXNDb250cm9sbGVkID8gXCJjb250cm9sbGVkXCIgOiBcInVuY29udHJvbGxlZFwifS5gXG4gICAgICApO1xuICAgIH1cbiAgICB3YXNDb250cm9sbGVkLmN1cnJlbnQgPSBpc0NvbnRyb2xsZWQ7XG4gIH0sIFtpc0NvbnRyb2xsZWRdKTtcbiAgY29uc3QgY3VycmVudFZhbHVlID0gaXNDb250cm9sbGVkID8gdmFsdWUgOiB1bmNvbnRyb2xsZWRWYWx1ZTtcbiAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjayhcbiAgICAodmFsdWUyKSA9PiB7XG4gICAgICBpZiAoaXNDb250cm9sbGVkKSB7XG4gICAgICAgIHJldHVybiBvbkNoYW5nZT8uKHZhbHVlMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRVbmNvbnRyb2xsZWRWYWx1ZSh2YWx1ZTIpO1xuICAgICAgICByZXR1cm4gb25DaGFuZ2U/Lih2YWx1ZTIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2lzQ29udHJvbGxlZCwgb25DaGFuZ2VdXG4gICk7XG4gIHJldHVybiBbY3VycmVudFZhbHVlLCBzZXRWYWx1ZV07XG59XG5cbmV4cG9ydCB7IHVzZUNvbnRyb2xsYWJsZVN0YXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtY29udHJvbGxhYmxlLXN0YXRlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-controllable-state.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-id.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-id.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useId: () => (/* binding */ useId)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-layout-effect.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-layout-effect.mjs\");\n\n\n\nlet isHydrated = false;\nlet id = 0;\nfunction getId() {\n  return ++id;\n}\nconst useReactId = react__WEBPACK_IMPORTED_MODULE_0__[\"useId\".toString()];\nfunction useIncrementalId() {\n  const [id2, setId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isHydrated ? getId : null);\n  (0,_use_layout_effect_mjs__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(() => {\n    if (id2 === null) {\n      setId(getId());\n    }\n  }, [id2]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!isHydrated) {\n      isHydrated = true;\n    }\n  }, []);\n  return String(id2) ?? void 0;\n}\nconst useId = useReactId ?? useIncrementalId;\n\n\n//# sourceMappingURL=use-id.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtaWQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0RDtBQUNGOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFjO0FBQ2pDO0FBQ0EsdUJBQXVCLCtDQUFRO0FBQy9CLEVBQUUsdUVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3VzZS1pZC5tanM/NGVjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gJy4vdXNlLWxheW91dC1lZmZlY3QubWpzJztcblxubGV0IGlzSHlkcmF0ZWQgPSBmYWxzZTtcbmxldCBpZCA9IDA7XG5mdW5jdGlvbiBnZXRJZCgpIHtcbiAgcmV0dXJuICsraWQ7XG59XG5jb25zdCB1c2VSZWFjdElkID0gUmVhY3RfX2RlZmF1bHRbXCJ1c2VJZFwiLnRvU3RyaW5nKCldO1xuZnVuY3Rpb24gdXNlSW5jcmVtZW50YWxJZCgpIHtcbiAgY29uc3QgW2lkMiwgc2V0SWRdID0gdXNlU3RhdGUoaXNIeWRyYXRlZCA/IGdldElkIDogbnVsbCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlkMiA9PT0gbnVsbCkge1xuICAgICAgc2V0SWQoZ2V0SWQoKSk7XG4gICAgfVxuICB9LCBbaWQyXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0h5ZHJhdGVkKSB7XG4gICAgICBpc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFN0cmluZyhpZDIpID8/IHZvaWQgMDtcbn1cbmNvbnN0IHVzZUlkID0gdXNlUmVhY3RJZCA/PyB1c2VJbmNyZW1lbnRhbElkO1xuXG5leHBvcnQgeyB1c2VJZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWlkLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-id.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-index.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-index.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useIndex: () => (/* binding */ useIndex)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _clamp_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clamp.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/clamp.mjs\");\n/* harmony import */ var _wrap_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrap.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/wrap.mjs\");\n\n\n\n\nconst defaultOptions = {\n  wrap: true\n};\nfunction useIndex(initial, length, options) {\n  const { wrap: shouldWrap } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...defaultOptions,\n      ...options\n    };\n  }, [options]);\n  const transform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => shouldWrap ? _wrap_mjs__WEBPACK_IMPORTED_MODULE_1__.wrap : _clamp_mjs__WEBPACK_IMPORTED_MODULE_2__.clamp, [shouldWrap]);\n  const [index, setIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initial);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setIndex((index2) => (0,_clamp_mjs__WEBPACK_IMPORTED_MODULE_2__.clamp)(index2, 0, Math.max(length - 1, 0)));\n  }, [length]);\n  const previousIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    setIndex((index2) => transform(index2 - 1, 0, Math.max(length, 0)));\n  }, [length, transform]);\n  const nextIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    setIndex((index2) => transform(index2 + 1, 0, Math.max(length, 0)));\n  }, [length, transform]);\n  return [index, previousIndex, nextIndex, setIndex];\n}\n\n\n//# sourceMappingURL=use-index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0U7QUFDOUI7QUFDRjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQixFQUFFLDhDQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9CQUFvQiw4Q0FBTyxvQkFBb0IsMkNBQUksR0FBRyw2Q0FBSztBQUMzRCw0QkFBNEIsK0NBQVE7QUFDcEMsRUFBRSxnREFBUztBQUNYLHlCQUF5QixpREFBSztBQUM5QixHQUFHO0FBQ0gsd0JBQXdCLGtEQUFXO0FBQ25DO0FBQ0EsR0FBRztBQUNILG9CQUFvQixrREFBVztBQUMvQjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3VzZS1pbmRleC5tanM/MThiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9jbGFtcC5tanMnO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gJy4vd3JhcC5tanMnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgd3JhcDogdHJ1ZVxufTtcbmZ1bmN0aW9uIHVzZUluZGV4KGluaXRpYWwsIGxlbmd0aCwgb3B0aW9ucykge1xuICBjb25zdCB7IHdyYXA6IHNob3VsZFdyYXAgfSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICB9LCBbb3B0aW9uc10pO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB1c2VNZW1vKCgpID0+IHNob3VsZFdyYXAgPyB3cmFwIDogY2xhbXAsIFtzaG91bGRXcmFwXSk7XG4gIGNvbnN0IFtpbmRleCwgc2V0SW5kZXhdID0gdXNlU3RhdGUoaW5pdGlhbCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SW5kZXgoKGluZGV4MikgPT4gY2xhbXAoaW5kZXgyLCAwLCBNYXRoLm1heChsZW5ndGggLSAxLCAwKSkpO1xuICB9LCBbbGVuZ3RoXSk7XG4gIGNvbnN0IHByZXZpb3VzSW5kZXggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0SW5kZXgoKGluZGV4MikgPT4gdHJhbnNmb3JtKGluZGV4MiAtIDEsIDAsIE1hdGgubWF4KGxlbmd0aCwgMCkpKTtcbiAgfSwgW2xlbmd0aCwgdHJhbnNmb3JtXSk7XG4gIGNvbnN0IG5leHRJbmRleCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRJbmRleCgoaW5kZXgyKSA9PiB0cmFuc2Zvcm0oaW5kZXgyICsgMSwgMCwgTWF0aC5tYXgobGVuZ3RoLCAwKSkpO1xuICB9LCBbbGVuZ3RoLCB0cmFuc2Zvcm1dKTtcbiAgcmV0dXJuIFtpbmRleCwgcHJldmlvdXNJbmRleCwgbmV4dEluZGV4LCBzZXRJbmRleF07XG59XG5cbmV4cG9ydCB7IHVzZUluZGV4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtaW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-initial.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-initial.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useInitial: () => (/* binding */ useInitial)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction useInitial(value) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value instanceof Function ? value() : value).current;\n}\n\n\n//# sourceMappingURL=use-initial.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtaW5pdGlhbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0EsU0FBUyw2Q0FBTTtBQUNmOztBQUVzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3VzZS1pbml0aWFsLm1qcz81YWM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gdXNlSW5pdGlhbCh2YWx1ZSkge1xuICByZXR1cm4gdXNlUmVmKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24gPyB2YWx1ZSgpIDogdmFsdWUpLmN1cnJlbnQ7XG59XG5cbmV4cG9ydCB7IHVzZUluaXRpYWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbml0aWFsLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-initial.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-interval.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-interval.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useInterval: () => (/* binding */ useInterval)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction useInterval(callback, delay) {\n  const latestCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    latestCallback.current = callback;\n  }, [callback]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!delay && delay !== 0) {\n      return;\n    }\n    const id = setInterval(() => {\n      if (latestCallback.current() === false) {\n        clearInterval(id);\n      }\n    }, delay);\n    return () => clearInterval(id);\n  }, [delay]);\n}\n\n\n//# sourceMappingURL=use-interval.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtaW50ZXJ2YWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDOztBQUUxQztBQUNBLHlCQUF5Qiw2Q0FBTTtBQUMvQixFQUFFLGdEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3VzZS1pbnRlcnZhbC5tanM/MzY2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gdXNlSW50ZXJ2YWwoY2FsbGJhY2ssIGRlbGF5KSB7XG4gIGNvbnN0IGxhdGVzdENhbGxiYWNrID0gdXNlUmVmKGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsYXRlc3RDYWxsYmFjay5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0sIFtjYWxsYmFja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZGVsYXkgJiYgZGVsYXkgIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAobGF0ZXN0Q2FsbGJhY2suY3VycmVudCgpID09PSBmYWxzZSkge1xuICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgIH1cbiAgICB9LCBkZWxheSk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaWQpO1xuICB9LCBbZGVsYXldKTtcbn1cblxuZXhwb3J0IHsgdXNlSW50ZXJ2YWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbnRlcnZhbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-interval.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-latest.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-latest.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLatest: () => (/* binding */ useLatest)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction useLatest(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\n\n//# sourceMappingURL=use-latest.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtbGF0ZXN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQzs7QUFFMUM7QUFDQSxjQUFjLDZDQUFNO0FBQ3BCLEVBQUUsZ0RBQVM7QUFDWDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3VzZS1sYXRlc3QubWpzPzEzNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIHVzZUxhdGVzdCh2YWx1ZSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYodmFsdWUpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5leHBvcnQgeyB1c2VMYXRlc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1sYXRlc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-latest.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-layout-effect.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-layout-effect.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLayoutEffect: () => (/* binding */ useLayoutEffect)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nconst useLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n\n//# sourceMappingURL=use-layout-effect.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtbGF5b3V0LWVmZmVjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0U7O0FBRXhFLHdEQUF3RCxrREFBaUIsR0FBRyw0Q0FBUzs7QUFFMUQ7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtbGF5b3V0LWVmZmVjdC5tanM/MjZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0JDEsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgdXNlTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHVzZUxheW91dEVmZmVjdCQxIDogdXNlRWZmZWN0O1xuXG5leHBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1sYXlvdXQtZWZmZWN0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-layout-effect.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-refs.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-refs.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRefs: () => (/* binding */ useRefs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction applyRef(ref, value) {\n  if (value) {\n    if (typeof ref === \"function\") {\n      ref(value);\n    } else if (ref && \"current\" in ref) {\n      ref.current = value;\n    }\n  }\n}\nfunction mergeRefs(value, ...refs) {\n  for (const ref of refs) {\n    applyRef(ref, value);\n  }\n}\nfunction useRefs(...refs) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value) => mergeRefs(value, ...refs), [refs]);\n}\n\n\n//# sourceMappingURL=use-refs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtcmVmcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBVztBQUNwQjs7QUFFbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtcmVmcy5tanM/YjI5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gYXBwbHlSZWYocmVmLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZWYodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocmVmICYmIFwiY3VycmVudFwiIGluIHJlZikge1xuICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlUmVmcyh2YWx1ZSwgLi4ucmVmcykge1xuICBmb3IgKGNvbnN0IHJlZiBvZiByZWZzKSB7XG4gICAgYXBwbHlSZWYocmVmLCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZVJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiBtZXJnZVJlZnModmFsdWUsIC4uLnJlZnMpLCBbcmVmc10pO1xufVxuXG5leHBvcnQgeyB1c2VSZWZzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtcmVmcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-refs.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-rerender.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-rerender.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRerender: () => (/* binding */ useRerender)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction useRerender() {\n  const [key, update] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(\n    (key2) => key2 + 1,\n    0\n  );\n  return [update, key];\n}\n\n\n//# sourceMappingURL=use-rerender.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtcmVyZW5kZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1DOztBQUVuQztBQUNBLHdCQUF3QixpREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3VzZS1yZXJlbmRlci5tanM/OTVjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiB1c2VSZXJlbmRlcigpIHtcbiAgY29uc3QgW2tleSwgdXBkYXRlXSA9IHVzZVJlZHVjZXIoXG4gICAgKGtleTIpID0+IGtleTIgKyAxLFxuICAgIDBcbiAgKTtcbiAgcmV0dXJuIFt1cGRhdGUsIGtleV07XG59XG5cbmV4cG9ydCB7IHVzZVJlcmVuZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtcmVyZW5kZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-rerender.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-transition.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-transition.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTransition: () => (/* binding */ useTransition)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nconst useReactTransition = react__WEBPACK_IMPORTED_MODULE_0__[\"useTransition\".toString()];\nfunction useTransitionFallback() {\n  const startTransition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (callback) => callback(),\n    []\n  );\n  return [false, startTransition];\n}\nconst useTransition = useReactTransition ?? useTransitionFallback;\n\n\n//# sourceMappingURL=use-transition.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtdHJhbnNpdGlvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0Q7O0FBRXBELDJCQUEyQixrQ0FBYztBQUN6QztBQUNBLDBCQUEwQixrREFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvdXNlLXRyYW5zaXRpb24ubWpzPzJjMGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0X19kZWZhdWx0LCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCB1c2VSZWFjdFRyYW5zaXRpb24gPSBSZWFjdF9fZGVmYXVsdFtcInVzZVRyYW5zaXRpb25cIi50b1N0cmluZygpXTtcbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25GYWxsYmFjaygpIHtcbiAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpLFxuICAgIFtdXG4gICk7XG4gIHJldHVybiBbZmFsc2UsIHN0YXJ0VHJhbnNpdGlvbl07XG59XG5jb25zdCB1c2VUcmFuc2l0aW9uID0gdXNlUmVhY3RUcmFuc2l0aW9uID8/IHVzZVRyYW5zaXRpb25GYWxsYmFjaztcblxuZXhwb3J0IHsgdXNlVHJhbnNpdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXRyYW5zaXRpb24ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-transition.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-visible.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-visible.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useVisibleCallback: () => (/* binding */ useVisibleCallback)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _use_latest_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-latest.mjs */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-latest.mjs\");\n\n\n\nlet intersectionObserver;\nconst intersectionCallbacks = /* @__PURE__ */ new WeakMap();\nfunction observe(element, callback) {\n  if (!intersectionObserver) {\n    intersectionObserver = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        const callback2 = intersectionCallbacks.get(entry.target);\n        callback2?.(entry);\n      }\n    });\n  }\n  intersectionCallbacks.set(element, callback);\n  intersectionObserver.observe(element);\n}\nfunction unobserve(element) {\n  intersectionCallbacks.delete(element);\n  intersectionObserver?.unobserve(element);\n}\nfunction useVisibleCallback(ref, callback, options) {\n  const enabled = options?.enabled ?? true;\n  const latestCallback = (0,_use_latest_mjs__WEBPACK_IMPORTED_MODULE_1__.useLatest)(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const element = ref.current;\n    if (!element) {\n      return;\n    }\n    if (enabled) {\n      observe(element, (entry) => {\n        if (entry.isIntersecting) {\n          latestCallback.current();\n        }\n      });\n    } else {\n      unobserve(element);\n    }\n    return () => {\n      unobserve(element);\n    };\n  }, [enabled]);\n}\n\n\n//# sourceMappingURL=use-visible.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtdmlzaWJsZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtDO0FBQ1c7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwREFBUztBQUNsQyxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3VzZS12aXNpYmxlLm1qcz85ODdiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxhdGVzdCB9IGZyb20gJy4vdXNlLWxhdGVzdC5tanMnO1xuXG5sZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG5jb25zdCBpbnRlcnNlY3Rpb25DYWxsYmFja3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgaWYgKCFpbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgIGludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2syID0gaW50ZXJzZWN0aW9uQ2FsbGJhY2tzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICBjYWxsYmFjazI/LihlbnRyeSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW50ZXJzZWN0aW9uQ2FsbGJhY2tzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gIGludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiB1bm9ic2VydmUoZWxlbWVudCkge1xuICBpbnRlcnNlY3Rpb25DYWxsYmFja3MuZGVsZXRlKGVsZW1lbnQpO1xuICBpbnRlcnNlY3Rpb25PYnNlcnZlcj8udW5vYnNlcnZlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gdXNlVmlzaWJsZUNhbGxiYWNrKHJlZiwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgY29uc3QgZW5hYmxlZCA9IG9wdGlvbnM/LmVuYWJsZWQgPz8gdHJ1ZTtcbiAgY29uc3QgbGF0ZXN0Q2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgIG9ic2VydmUoZWxlbWVudCwgKGVudHJ5KSA9PiB7XG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgIGxhdGVzdENhbGxiYWNrLmN1cnJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZF0pO1xufVxuXG5leHBvcnQgeyB1c2VWaXNpYmxlQ2FsbGJhY2sgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS12aXNpYmxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-visible.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-window-focus.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-window-focus.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWindowFocus: () => (/* binding */ useWindowFocus)\n/* harmony export */ });\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n\n\nfunction subscribe(callback) {\n  window.addEventListener(\"blur\", callback);\n  window.addEventListener(\"focus\", callback);\n  return () => {\n    window.removeEventListener(\"blur\", callback);\n    window.removeEventListener(\"focus\", callback);\n  };\n}\nfunction getSnapshot() {\n  return document.hasFocus();\n}\nfunction getServerSnapshot() {\n  return true;\n}\nfunction useWindowFocus() {\n  return (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);\n}\n\n\n//# sourceMappingURL=use-window-focus.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2Utd2luZG93LWZvY3VzLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyRkFBb0I7QUFDN0I7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvdXNlLXdpbmRvdy1mb2N1cy5tanM/MDMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanMnO1xuXG5mdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGNhbGxiYWNrKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBjYWxsYmFjayk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGNhbGxiYWNrKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGNhbGxiYWNrKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNuYXBzaG90KCkge1xuICByZXR1cm4gZG9jdW1lbnQuaGFzRm9jdXMoKTtcbn1cbmZ1bmN0aW9uIGdldFNlcnZlclNuYXBzaG90KCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVzZVdpbmRvd0ZvY3VzKCkge1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xufVxuXG5leHBvcnQgeyB1c2VXaW5kb3dGb2N1cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXdpbmRvdy1mb2N1cy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-window-focus.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/visually-hidden.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/visually-hidden.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   visuallyHidden: () => (/* binding */ visuallyHidden)\n/* harmony export */ });\nconst visuallyHidden = {\n  position: \"absolute\",\n  border: 0,\n  width: 1,\n  height: 1,\n  padding: 0,\n  margin: -1,\n  overflow: \"hidden\",\n  clip: \"rect(0, 0, 0, 0)\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n};\n\n\n//# sourceMappingURL=visually-hidden.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy92aXN1YWxseS1oaWRkZW4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvdmlzdWFsbHktaGlkZGVuLm1qcz9iYTI1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHZpc3VhbGx5SGlkZGVuID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICBib3JkZXI6IDAsXG4gIHdpZHRoOiAxLFxuICBoZWlnaHQ6IDEsXG4gIHBhZGRpbmc6IDAsXG4gIG1hcmdpbjogLTEsXG4gIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICBjbGlwOiBcInJlY3QoMCwgMCwgMCwgMClcIixcbiAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgd29yZFdyYXA6IFwibm9ybWFsXCJcbn07XG5cbmV4cG9ydCB7IHZpc3VhbGx5SGlkZGVuIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXN1YWxseS1oaWRkZW4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/visually-hidden.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/wrap.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/wrap.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\nfunction wrap(value, min, max) {\n  const range = max - min;\n  return range > 0 ? ((value - min) % range + range) % range + min : 0;\n}\n\n\n//# sourceMappingURL=wrap.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy93cmFwLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvd3JhcC5tanM/MzJhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3cmFwKHZhbHVlLCBtaW4sIG1heCkge1xuICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcbiAgcmV0dXJuIHJhbmdlID4gMCA/ICgodmFsdWUgLSBtaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIG1pbiA6IDA7XG59XG5cbmV4cG9ydCB7IHdyYXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXAubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/wrap.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientContext: () => (/* binding */ ClientContext),\n/* harmony export */   ClientSideSuspense: () => (/* binding */ ClientSideSuspense),\n/* harmony export */   CreateThreadError: () => (/* binding */ CreateThreadError),\n/* harmony export */   LiveblocksProvider: () => (/* binding */ LiveblocksProvider),\n/* harmony export */   PKG_FORMAT: () => (/* binding */ PKG_FORMAT),\n/* harmony export */   PKG_NAME: () => (/* binding */ PKG_NAME),\n/* harmony export */   PKG_VERSION: () => (/* binding */ PKG_VERSION),\n/* harmony export */   RoomContext: () => (/* binding */ RoomContext),\n/* harmony export */   _RoomProvider: () => (/* binding */ _RoomProvider),\n/* harmony export */   _useAddReaction: () => (/* binding */ _useAddReaction),\n/* harmony export */   _useBroadcastEvent: () => (/* binding */ _useBroadcastEvent),\n/* harmony export */   _useCreateThread: () => (/* binding */ _useCreateThread),\n/* harmony export */   _useDeleteThread: () => (/* binding */ _useDeleteThread),\n/* harmony export */   _useEditThreadMetadata: () => (/* binding */ _useEditThreadMetadata),\n/* harmony export */   _useEventListener: () => (/* binding */ _useEventListener),\n/* harmony export */   _useInboxNotificationThread: () => (/* binding */ _useInboxNotificationThread),\n/* harmony export */   _useMutation: () => (/* binding */ _useMutation),\n/* harmony export */   _useMyPresence: () => (/* binding */ _useMyPresence),\n/* harmony export */   _useOther: () => (/* binding */ _useOther),\n/* harmony export */   _useOtherSuspense: () => (/* binding */ _useOtherSuspense),\n/* harmony export */   _useOthers: () => (/* binding */ _useOthers),\n/* harmony export */   _useOthersListener: () => (/* binding */ _useOthersListener),\n/* harmony export */   _useOthersMapped: () => (/* binding */ _useOthersMapped),\n/* harmony export */   _useOthersMappedSuspense: () => (/* binding */ _useOthersMappedSuspense),\n/* harmony export */   _useOthersSuspense: () => (/* binding */ _useOthersSuspense),\n/* harmony export */   _useRoom: () => (/* binding */ _useRoom),\n/* harmony export */   _useSelf: () => (/* binding */ _useSelf),\n/* harmony export */   _useSelfSuspense: () => (/* binding */ _useSelfSuspense),\n/* harmony export */   _useStorage: () => (/* binding */ _useStorage),\n/* harmony export */   _useStorageRoot: () => (/* binding */ _useStorageRoot),\n/* harmony export */   _useStorageSuspense: () => (/* binding */ _useStorageSuspense),\n/* harmony export */   _useThreads: () => (/* binding */ _useThreads),\n/* harmony export */   _useThreadsSuspense: () => (/* binding */ _useThreadsSuspense),\n/* harmony export */   _useUpdateMyPresence: () => (/* binding */ _useUpdateMyPresence),\n/* harmony export */   _useUser: () => (/* binding */ _useUser),\n/* harmony export */   _useUserSuspense: () => (/* binding */ _useUserSuspense),\n/* harmony export */   createLiveblocksContext: () => (/* binding */ createLiveblocksContext),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   selectedThreads: () => (/* binding */ selectedThreads),\n/* harmony export */   useBatch: () => (/* binding */ useBatch),\n/* harmony export */   useCanRedo: () => (/* binding */ useCanRedo),\n/* harmony export */   useCanUndo: () => (/* binding */ useCanUndo),\n/* harmony export */   useClient: () => (/* binding */ useClient),\n/* harmony export */   useCommentsErrorListener: () => (/* binding */ useCommentsErrorListener),\n/* harmony export */   useCreateComment: () => (/* binding */ useCreateComment),\n/* harmony export */   useDeleteAllInboxNotifications: () => (/* binding */ useDeleteAllInboxNotifications),\n/* harmony export */   useDeleteComment: () => (/* binding */ useDeleteComment),\n/* harmony export */   useDeleteInboxNotification: () => (/* binding */ useDeleteInboxNotification),\n/* harmony export */   useEditComment: () => (/* binding */ useEditComment),\n/* harmony export */   useErrorListener: () => (/* binding */ useErrorListener),\n/* harmony export */   useHistory: () => (/* binding */ useHistory),\n/* harmony export */   useInboxNotifications: () => (/* binding */ useInboxNotifications),\n/* harmony export */   useInboxNotificationsSuspense: () => (/* binding */ useInboxNotificationsSuspense),\n/* harmony export */   useLostConnectionListener: () => (/* binding */ useLostConnectionListener),\n/* harmony export */   useMarkAllInboxNotificationsAsRead: () => (/* binding */ useMarkAllInboxNotificationsAsRead),\n/* harmony export */   useMarkInboxNotificationAsRead: () => (/* binding */ useMarkInboxNotificationAsRead),\n/* harmony export */   useMarkThreadAsRead: () => (/* binding */ useMarkThreadAsRead),\n/* harmony export */   useMarkThreadAsResolved: () => (/* binding */ useMarkThreadAsResolved),\n/* harmony export */   useMarkThreadAsUnresolved: () => (/* binding */ useMarkThreadAsUnresolved),\n/* harmony export */   useOthersConnectionIds: () => (/* binding */ useOthersConnectionIds),\n/* harmony export */   useOthersConnectionIdsSuspense: () => (/* binding */ useOthersConnectionIdsSuspense),\n/* harmony export */   useRedo: () => (/* binding */ useRedo),\n/* harmony export */   useRemoveReaction: () => (/* binding */ useRemoveReaction),\n/* harmony export */   useRoomInfo: () => (/* binding */ useRoomInfo),\n/* harmony export */   useRoomInfoSuspense: () => (/* binding */ useRoomInfoSuspense),\n/* harmony export */   useRoomNotificationSettings: () => (/* binding */ useRoomNotificationSettings),\n/* harmony export */   useStatus: () => (/* binding */ useStatus),\n/* harmony export */   useStorageStatus: () => (/* binding */ useStorageStatus),\n/* harmony export */   useStorageStatusSuspense: () => (/* binding */ useStorageStatusSuspense),\n/* harmony export */   useThreadSubscription: () => (/* binding */ useThreadSubscription),\n/* harmony export */   useUndo: () => (/* binding */ useUndo),\n/* harmony export */   useUnreadInboxNotificationsCount: () => (/* binding */ useUnreadInboxNotificationsCount),\n/* harmony export */   useUnreadInboxNotificationsCountSuspense: () => (/* binding */ useUnreadInboxNotificationsCountSuspense),\n/* harmony export */   useUpdateRoomNotificationSettings: () => (/* binding */ useUpdateRoomNotificationSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid */ \"(ssr)/./node_modules/@liveblocks/react/node_modules/nanoid/index.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"2.3.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/ClientSideSuspense.tsx\n\nfunction ClientSideSuspense(props) {\n  const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    setMounted(true);\n  }, []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: props.fallback }, mounted ? typeof props.children === \"function\" ? props.children() : props.children : props.fallback);\n}\n\n// src/liveblocks.tsx\n\n\n\n\n\n\n// src/comments/lib/selected-inbox-notifications.ts\n\nfunction selectedInboxNotifications(state) {\n  const result = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n  return Object.values(result.inboxNotifications).sort(\n    // Sort so that the most recent notifications are first\n    (a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime()\n  );\n}\n\n// src/lib/retry-error.ts\n\nvar MAX_ERROR_RETRY_COUNT = 5;\nvar ERROR_RETRY_INTERVAL = 5e3;\nfunction retryError(action, retryCount) {\n  if (retryCount >= MAX_ERROR_RETRY_COUNT) return;\n  const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;\n  setTimeout(() => {\n    void action();\n  }, timeout);\n}\nasync function autoRetry(promiseFn, maxTries, backoff) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    const promise = promiseFn();\n    try {\n      return await promise;\n    } catch (err) {\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    await (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.wait)(delay);\n  }\n}\n\n// src/lib/use-initial.ts\n\n\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\n// src/lib/use-initial.ts\nvar noop = (state) => state;\nfunction useInitial(value) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(noop, value)[0];\n}\nfunction useInitialUnlessFunction(latestValue) {\n  const frozenValue = useInitial(latestValue);\n  if (typeof frozenValue === \"function\") {\n    const ref = useLatest(latestValue);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args) => ref.current(...args), [\n      ref\n    ]);\n  } else {\n    return frozenValue;\n  }\n}\n\n// src/lib/use-polyfill.ts\nvar use = (\n  // React.use ||\n  (promise) => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  }\n);\n\n// src/liveblocks.tsx\nvar ClientContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction missingUserError(userId) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\nfunction missingRoomInfoError(roomId) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\nvar _extras = /* @__PURE__ */ new WeakMap();\nvar _bundles = /* @__PURE__ */ new WeakMap();\nvar POLLING_INTERVAL = 60 * 1e3;\nvar INBOX_NOTIFICATIONS_QUERY = \"INBOX_NOTIFICATIONS\";\nfunction selectorFor_useInboxNotifications(state) {\n  const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n  if (query === void 0 || query.isLoading) {\n    return {\n      isLoading: true\n    };\n  }\n  if (query.error !== void 0) {\n    return {\n      error: query.error,\n      isLoading: false\n    };\n  }\n  return {\n    inboxNotifications: selectedInboxNotifications(state),\n    isLoading: false\n  };\n}\nfunction selectUnreadInboxNotificationsCount(state) {\n  let count = 0;\n  for (const notification of selectedInboxNotifications(state)) {\n    if (notification.readAt === null || notification.readAt < notification.notifiedAt) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction selectorFor_useUnreadInboxNotificationsCount(state) {\n  const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n  if (query === void 0 || query.isLoading) {\n    return {\n      isLoading: true\n    };\n  }\n  if (query.error !== void 0) {\n    return {\n      error: query.error,\n      isLoading: false\n    };\n  }\n  return {\n    isLoading: false,\n    count: selectUnreadInboxNotificationsCount(state)\n  };\n}\nfunction selectorFor_useUser(state, userId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId)\n    };\n  }\n  return {\n    isLoading: false,\n    user: state.data\n  };\n}\nfunction selectorFor_useRoomInfo(state, roomId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId)\n    };\n  }\n  return {\n    isLoading: false,\n    info: state.data\n  };\n}\nfunction getOrCreateContextBundle(client) {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getExtrasForClient(client) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n  return extras;\n}\nfunction makeExtrasForClient(client) {\n  const internals = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal];\n  const store = internals.cacheStore;\n  const notifications = internals.notifications;\n  let lastRequestedAt;\n  async function fetchInboxNotifications() {\n    const since = lastRequestedAt !== void 0 ? { since: lastRequestedAt } : void 0;\n    const result = await notifications.getInboxNotifications(since);\n    store.updateThreadsAndNotifications(\n      result.threads,\n      result.inboxNotifications,\n      result.deletedThreads,\n      result.deletedInboxNotifications,\n      INBOX_NOTIFICATIONS_QUERY\n    );\n    if (lastRequestedAt === void 0 || lastRequestedAt < result.meta.requestedAt) {\n      lastRequestedAt = result.meta.requestedAt;\n    }\n  }\n  let pollerSubscribers = 0;\n  const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(async () => {\n    try {\n      await waitUntilInboxNotificationsLoaded();\n      await fetchInboxNotifications();\n    } catch (err) {\n      console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n    }\n  });\n  const waitUntilInboxNotificationsLoaded = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.memoizeOnSuccess)(async () => {\n    store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n      isLoading: true\n    });\n    try {\n      await autoRetry(\n        () => fetchInboxNotifications(),\n        5,\n        [5e3, 5e3, 1e4, 15e3]\n      );\n    } catch (err) {\n      store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n        isLoading: false,\n        error: err\n      });\n      throw err;\n    }\n  });\n  function loadInboxNotifications() {\n    void waitUntilInboxNotificationsLoaded().catch(() => {\n    });\n  }\n  function useEnableInboxNotificationsPolling() {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      pollerSubscribers++;\n      poller.start(POLLING_INTERVAL);\n      return () => {\n        if (pollerSubscribers <= 0) {\n          console.warn(\n            `Internal unexpected behavior. Cannot decrease subscriber count for query \"${INBOX_NOTIFICATIONS_QUERY}\"`\n          );\n          return;\n        }\n        pollerSubscribers--;\n        if (pollerSubscribers <= 0) {\n          poller.stop();\n        }\n      };\n    }, []);\n  }\n  return {\n    store,\n    notifications,\n    useEnableInboxNotificationsPolling,\n    waitUntilInboxNotificationsLoaded,\n    loadInboxNotifications\n  };\n}\nfunction makeLiveblocksContextBundle(client) {\n  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);\n  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);\n  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);\n  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);\n  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);\n  function LiveblocksProvider2(props) {\n    useEnsureNoLiveblocksProvider();\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClientContext.Provider, { value: client }, props.children);\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    LiveblocksProvider: LiveblocksProvider2,\n    useInboxNotifications: () => useInboxNotifications_withClient(client),\n    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),\n    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n    useDeleteInboxNotification: useDeleteInboxNotification2,\n    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n    useInboxNotificationThread: useInboxNotificationThread2,\n    ...shared.classic,\n    suspense: {\n      LiveblocksProvider: LiveblocksProvider2,\n      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),\n      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),\n      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n      useDeleteInboxNotification: useDeleteInboxNotification2,\n      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n      useInboxNotificationThread: useInboxNotificationThread2,\n      ...shared.suspense\n    }\n  };\n  return bundle;\n}\nfunction useInboxNotifications_withClient(client) {\n  const { loadInboxNotifications, store, useEnableInboxNotificationsPolling } = getExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    loadInboxNotifications();\n  }, [loadInboxNotifications]);\n  useEnableInboxNotificationsPolling();\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.get,\n    store.get,\n    selectorFor_useInboxNotifications,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n}\nfunction useInboxNotificationsSuspense_withClient(client) {\n  const { waitUntilInboxNotificationsLoaded } = getExtrasForClient(client);\n  use(waitUntilInboxNotificationsLoaded());\n  const result = useInboxNotifications_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUnreadInboxNotificationsCount_withClient(client) {\n  const { store, loadInboxNotifications, useEnableInboxNotificationsPolling } = getExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    loadInboxNotifications();\n  }, [loadInboxNotifications]);\n  useEnableInboxNotificationsPolling();\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.get,\n    store.get,\n    selectorFor_useUnreadInboxNotificationsCount,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n}\nfunction useUnreadInboxNotificationsCountSuspense_withClient(client) {\n  const { waitUntilInboxNotificationsLoaded } = getExtrasForClient(client);\n  use(waitUntilInboxNotificationsLoaded());\n  const result = useUnreadInboxNotificationsCount_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  return result;\n}\nfunction useMarkInboxNotificationAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store, notifications } = getExtrasForClient(client);\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const readAt = /* @__PURE__ */ new Date();\n      store.pushOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        id: optimisticUpdateId,\n        inboxNotificationId,\n        readAt\n      });\n      notifications.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          store.set((state) => {\n            const existingNotification = state.inboxNotifications[inboxNotificationId];\n            if (existingNotification === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                )\n              };\n            }\n            return {\n              ...state,\n              inboxNotifications: {\n                ...state.inboxNotifications,\n                [inboxNotificationId]: {\n                  ...existingNotification,\n                  readAt\n                }\n              },\n              optimisticUpdates: state.optimisticUpdates.filter(\n                (update) => update.id !== optimisticUpdateId\n              )\n            };\n          });\n        },\n        () => {\n          store.set((state) => ({\n            ...state,\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            )\n          }));\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store, notifications } = getExtrasForClient(client);\n    const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n    const readAt = /* @__PURE__ */ new Date();\n    store.pushOptimisticUpdate({\n      type: \"mark-all-inbox-notifications-as-read\",\n      id: optimisticUpdateId,\n      readAt\n    });\n    notifications.markAllInboxNotificationsAsRead().then(\n      () => {\n        store.set((state) => ({\n          ...state,\n          inboxNotifications: Object.fromEntries(\n            Array.from(Object.entries(state.inboxNotifications)).map(\n              ([id, inboxNotification]) => [\n                id,\n                { ...inboxNotification, readAt }\n              ]\n            )\n          ),\n          optimisticUpdates: state.optimisticUpdates.filter(\n            (update) => update.id !== optimisticUpdateId\n          )\n        }));\n      },\n      () => {\n        store.set((state) => ({\n          ...state,\n          optimisticUpdates: state.optimisticUpdates.filter(\n            (update) => update.id !== optimisticUpdateId\n          )\n        }));\n      }\n    );\n  }, [client]);\n}\nfunction useDeleteInboxNotification_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store, notifications } = getExtrasForClient(client);\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const deletedAt = /* @__PURE__ */ new Date();\n      store.pushOptimisticUpdate({\n        type: \"delete-inbox-notification\",\n        id: optimisticUpdateId,\n        inboxNotificationId,\n        deletedAt\n      });\n      notifications.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          store.set((state) => {\n            const existingNotification = state.inboxNotifications[inboxNotificationId];\n            if (existingNotification === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                )\n              };\n            }\n            const { [inboxNotificationId]: _, ...inboxNotifications } = state.inboxNotifications;\n            return {\n              ...state,\n              inboxNotifications,\n              optimisticUpdates: state.optimisticUpdates.filter(\n                (update) => update.id !== optimisticUpdateId\n              )\n            };\n          });\n        },\n        () => {\n          store.set((state) => ({\n            ...state,\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            )\n          }));\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useDeleteAllInboxNotifications_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store, notifications } = getExtrasForClient(client);\n    const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n    const deletedAt = /* @__PURE__ */ new Date();\n    store.pushOptimisticUpdate({\n      type: \"delete-all-inbox-notifications\",\n      id: optimisticUpdateId,\n      deletedAt\n    });\n    notifications.deleteAllInboxNotifications().then(\n      () => {\n        store.set((state) => ({\n          ...state,\n          inboxNotifications: {},\n          optimisticUpdates: state.optimisticUpdates.filter(\n            (update) => update.id !== optimisticUpdateId\n          )\n        }));\n      },\n      () => {\n        store.set((state) => ({\n          ...state,\n          optimisticUpdates: state.optimisticUpdates.filter(\n            (update) => update.id !== optimisticUpdateId\n          )\n        }));\n      }\n    );\n  }, [client]);\n}\nfunction useInboxNotificationThread_withClient(client, inboxNotificationId) {\n  const { store } = getExtrasForClient(client);\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => {\n      const inboxNotification = state.inboxNotifications[inboxNotificationId] ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(`Inbox notification with ID \"${inboxNotificationId}\" not found`);\n      if (inboxNotification.kind !== \"thread\") {\n        (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\n          `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n        );\n      }\n      const thread = state.threads[inboxNotification.threadId] ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\n        `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n      );\n      return thread;\n    },\n    [inboxNotificationId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n}\nfunction useUser_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void usersStore.get(userId);\n  }, [usersStore, userId]);\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useUser(state, userId),\n    [userId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n}\nfunction useUserSuspense_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n  if (!userState || userState.isLoading) {\n    throw usersStore.get(userId);\n  }\n  if (userState.error) {\n    throw userState.error;\n  }\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n  const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: void 0\n  };\n}\nfunction useRoomInfo_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void roomsInfoStore.get(roomId);\n  }, [roomsInfoStore, roomId]);\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n}\nfunction useRoomInfoSuspense_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.get(roomId);\n  }\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n  const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.error, \"Unexpected error state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state.data !== void 0, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: void 0\n  };\n}\nfunction createSharedContext(client) {\n  const useClient2 = () => client;\n  return {\n    classic: {\n      useClient: useClient2,\n      useUser: (userId) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId)\n    },\n    suspense: {\n      useClient: useClient2,\n      useUser: (userId) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId)\n    }\n  };\n}\nfunction useEnsureNoLiveblocksProvider(options) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\nfunction useClientOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ClientContext);\n}\nfunction useClient() {\n  return useClientOrNull() ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\"LiveblocksProvider is missing from the React tree.\");\n}\nfunction LiveblocksProviderWithClient(props) {\n  useEnsureNoLiveblocksProvider(props);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClientContext.Provider, { value: props.client }, props.children);\n}\nfunction LiveblocksProvider(props) {\n  const { children, ...o } = props;\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging\n    )\n  };\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createClient)(options), []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiveblocksProviderWithClient, { client }, children);\n}\nfunction createLiveblocksContext(client) {\n  return getOrCreateContextBundle(client);\n}\nfunction useInboxNotifications() {\n  return useInboxNotifications_withClient(useClient());\n}\nfunction useInboxNotificationsSuspense() {\n  return useInboxNotificationsSuspense_withClient(useClient());\n}\nfunction useInboxNotificationThread(inboxNotificationId) {\n  return useInboxNotificationThread_withClient(\n    useClient(),\n    inboxNotificationId\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCount() {\n  return useUnreadInboxNotificationsCount_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCountSuspense() {\n  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());\n}\nfunction useUser(userId) {\n  const client = useClient();\n  return useUser_withClient(client, userId);\n}\nfunction useUserSuspense(userId) {\n  const client = useClient();\n  return useUserSuspense_withClient(client, userId);\n}\nfunction useRoomInfo(roomId) {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\nfunction useRoomInfoSuspense(roomId) {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\nvar _useInboxNotificationThread = useInboxNotificationThread;\nvar _useUser = useUser;\nvar _useUserSuspense = useUserSuspense;\n\n// src/comments/errors.ts\nvar CreateThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateThreadError\";\n  }\n};\nvar DeleteThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteThreadError\";\n  }\n};\nvar EditThreadMetadataError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit thread metadata failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditThreadMetadataError\";\n  }\n};\nvar MarkThreadAsResolvedError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark thread as resolved failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkThreadAsResolvedError\";\n  }\n};\nvar MarkThreadAsUnresolvedError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark thread as unresolved failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkThreadAsUnresolvedError\";\n  }\n};\nvar CreateCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateCommentError\";\n  }\n};\nvar EditCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditCommentError\";\n  }\n};\nvar DeleteCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteCommentError\";\n  }\n};\nvar AddReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Add reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"AddReactionError\";\n  }\n};\nvar RemoveReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Remove reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"RemoveReactionError\";\n  }\n};\nvar MarkInboxNotificationAsReadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark inbox notification as read failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkInboxNotificationAsReadError\";\n  }\n};\nvar UpdateNotificationSettingsError = class extends Error {\n  constructor(cause, context) {\n    super(\"Update notification settings failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"UpdateNotificationSettingsError\";\n  }\n};\n\n// src/comments/lib/selected-threads.ts\n\nfunction selectedThreads(roomId, state, options) {\n  const result = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n  const threads = Object.values(result.threads).filter(\n    (thread) => {\n      if (thread.roomId !== roomId) return false;\n      if (thread.deletedAt !== void 0) {\n        return false;\n      }\n      const query = options.query;\n      if (!query) return true;\n      if (query.resolved !== void 0 && thread.resolved !== query.resolved) {\n        return false;\n      }\n      for (const key in query.metadata) {\n        const metadataValue = thread.metadata[key];\n        const filterValue = query.metadata[key];\n        if (assertFilterIsStartsWithOperator(filterValue) && assertMetadataValueIsString(metadataValue)) {\n          if (metadataValue.startsWith(filterValue.startsWith)) {\n            return true;\n          }\n        }\n        if (metadataValue !== filterValue) {\n          return false;\n        }\n      }\n      return true;\n    }\n  );\n  return threads.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n}\nvar assertFilterIsStartsWithOperator = (filter) => {\n  if (typeof filter === \"object\" && typeof filter.startsWith === \"string\") {\n    return true;\n  } else {\n    return false;\n  }\n};\nvar assertMetadataValueIsString = (value) => {\n  return typeof value === \"string\";\n};\n\n// src/room.tsx\n\n\n\n\n\n\n// src/comments/lib/createIds.ts\n\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${(0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\n\n// src/comments/lib/select-notification-settings.ts\n\nfunction selectNotificationSettings(roomId, state) {\n  const { notificationSettings } = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(notificationSettings[roomId]);\n}\n\n// src/use-scroll-to-comment-on-load-effect.ts\n\nfunction handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {\n  if (shouldScrollOnLoad === false) return;\n  if (state.isLoading) return;\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n  if (!commentId.startsWith(\"cm_\")) return;\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment2) => comment2.id === commentId\n  );\n  if (!isCommentInThreads) return;\n  comment.scrollIntoView();\n}\nfunction useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n\n// src/room.tsx\nvar SMOOTH_DELAY = 1e3;\nvar noop2 = () => {\n};\nvar identity = (x) => x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\\u2019re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(\n  roomId\n)} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\nvar superfluous_unstable_batchedUpdates = \"You don\\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\\u2019re on React 18+ already.\";\nfunction useSyncExternalStore2(s, gs, gss) {\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(s, gs, gss, identity);\n}\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nvar POLLING_INTERVAL2 = 5 * 60 * 1e3;\nfunction makeNotificationSettingsQueryKey(roomId) {\n  return `${roomId}:NOTIFICATION_SETTINGS`;\n}\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n  return null;\n}\nfunction selectorFor_useOthersConnectionIds(others) {\n  return others.map((user) => user.connectionId);\n}\nfunction makeMutationContext(room) {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n    setMyPresence: room.updatePresence\n  };\n}\nfunction getCurrentUserId(room) {\n  const self = room.getSelf();\n  if (self === null || self.id === void 0) {\n    return \"anonymous\";\n  } else {\n    return self.id;\n  }\n}\nfunction handleApiError(err) {\n  const message = `Request failed with status ${err.status}: ${err.message}`;\n  if (err.details?.error === \"FORBIDDEN\") {\n    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join(\"\\n\");\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.error(detailedMessage);\n  }\n  return new Error(message);\n}\nvar _extras2 = /* @__PURE__ */ new WeakMap();\nvar _bundles2 = /* @__PURE__ */ new WeakMap();\nfunction getOrCreateRoomContextBundle(client) {\n  let bundle = _bundles2.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles2.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getExtrasForClient2(client) {\n  let extras = _extras2.get(client);\n  if (!extras) {\n    extras = makeExtrasForClient2(client);\n    _extras2.set(client, extras);\n  }\n  return extras;\n}\nfunction makeExtrasForClient2(client) {\n  const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].cacheStore;\n  const DEFAULT_DEDUPING_INTERVAL = 2e3;\n  const lastRequestedAtByRoom = /* @__PURE__ */ new Map();\n  const requestsByQuery = /* @__PURE__ */ new Map();\n  const requestStatusByRoom = /* @__PURE__ */ new Map();\n  const subscribersByQuery = /* @__PURE__ */ new Map();\n  const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(refreshThreadsAndNotifications);\n  async function refreshThreadsAndNotifications() {\n    const requests = [];\n    client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getRoomIds().map((roomId) => {\n      const room = client.getRoom(roomId);\n      if (room === null) return;\n      requests.push(getThreadsUpdates(room.id));\n    });\n    await Promise.allSettled(requests);\n  }\n  function incrementQuerySubscribers(queryKey) {\n    const subscribers = subscribersByQuery.get(queryKey) ?? 0;\n    subscribersByQuery.set(queryKey, subscribers + 1);\n    poller.start(POLLING_INTERVAL2);\n    return () => {\n      const subscribers2 = subscribersByQuery.get(queryKey);\n      if (subscribers2 === void 0 || subscribers2 <= 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(\n          `Internal unexpected behavior. Cannot decrease subscriber count for query \"${queryKey}\"`\n        );\n        return;\n      }\n      subscribersByQuery.set(queryKey, subscribers2 - 1);\n      let totalSubscribers = 0;\n      for (const subscribers3 of subscribersByQuery.values()) {\n        totalSubscribers += subscribers3;\n      }\n      if (totalSubscribers <= 0) {\n        poller.stop();\n      }\n    };\n  }\n  async function getThreadsUpdates(roomId) {\n    const room = client.getRoom(roomId);\n    if (room === null) return;\n    const since = lastRequestedAtByRoom.get(room.id);\n    if (since === void 0) return;\n    const isFetchingThreadsUpdates = requestStatusByRoom.get(room.id) ?? false;\n    if (isFetchingThreadsUpdates === true) return;\n    try {\n      requestStatusByRoom.set(room.id, true);\n      const commentsAPI = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments;\n      const updates = await commentsAPI.getThreads({ since });\n      setTimeout(() => {\n        requestStatusByRoom.set(room.id, false);\n      }, DEFAULT_DEDUPING_INTERVAL);\n      store.updateThreadsAndNotifications(\n        updates.threads,\n        updates.inboxNotifications,\n        updates.deletedThreads,\n        updates.deletedInboxNotifications\n      );\n      lastRequestedAtByRoom.set(room.id, updates.meta.requestedAt);\n    } catch (err) {\n      requestStatusByRoom.set(room.id, false);\n      return;\n    }\n  }\n  async function getThreadsAndInboxNotifications(room, queryKey, options, { retryCount } = { retryCount: 0 }) {\n    const existingRequest = requestsByQuery.get(queryKey);\n    if (existingRequest !== void 0) return existingRequest;\n    const commentsAPI = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments;\n    const request = commentsAPI.getThreads(options);\n    requestsByQuery.set(queryKey, request);\n    store.setQueryState(queryKey, {\n      isLoading: true\n    });\n    try {\n      const result = await request;\n      store.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications,\n        result.deletedThreads,\n        result.deletedInboxNotifications,\n        queryKey\n      );\n      const lastRequestedAt = lastRequestedAtByRoom.get(room.id);\n      if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {\n        lastRequestedAtByRoom.set(room.id, result.meta.requestedAt);\n      }\n      poller.start(POLLING_INTERVAL2);\n    } catch (err) {\n      requestsByQuery.delete(queryKey);\n      retryError(() => {\n        void getThreadsAndInboxNotifications(room, queryKey, options, {\n          retryCount: retryCount + 1\n        });\n      }, retryCount);\n      store.setQueryState(queryKey, {\n        isLoading: false,\n        error: err\n      });\n    }\n    return;\n  }\n  async function getInboxNotificationSettings(room, queryKey, { retryCount } = { retryCount: 0 }) {\n    const existingRequest = requestsByQuery.get(queryKey);\n    if (existingRequest !== void 0) return existingRequest;\n    try {\n      const request = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.getRoomNotificationSettings();\n      requestsByQuery.set(queryKey, request);\n      store.setQueryState(queryKey, {\n        isLoading: true\n      });\n      const settings = await request;\n      store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);\n    } catch (err) {\n      requestsByQuery.delete(queryKey);\n      retryError(() => {\n        void getInboxNotificationSettings(room, queryKey, {\n          retryCount: retryCount + 1\n        });\n      }, retryCount);\n      store.setQueryState(queryKey, {\n        isLoading: false,\n        error: err\n      });\n    }\n    return;\n  }\n  const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n  function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {\n    store.set((state) => ({\n      ...state,\n      optimisticUpdates: state.optimisticUpdates.filter(\n        (update) => update.id !== optimisticUpdateId\n      )\n    }));\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError) {\n      const error = handleApiError(innerError);\n      commentsErrorEventSource.notify(createPublicError(error));\n      return;\n    }\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.NotificationsApiError) {\n      handleApiError(innerError);\n      return;\n    }\n    throw innerError;\n  }\n  return {\n    store,\n    incrementQuerySubscribers,\n    commentsErrorEventSource,\n    getThreadsUpdates,\n    getThreadsAndInboxNotifications,\n    getInboxNotificationSettings,\n    onMutationFailure\n  };\n}\nvar RoomContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction makeRoomContextBundle(client) {\n  function RoomProvider_withImplicitLiveblocksProvider(props) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiveblocksProviderWithClient, { client, allowNesting: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProvider, { ...props }));\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    RoomContext,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n    useRoom,\n    useStatus,\n    useStorageStatus,\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useErrorListener,\n    useEventListener,\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n    useStorageRoot,\n    useStorage,\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n    useMutation,\n    useThreads,\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useRoomNotificationSettings,\n    useUpdateRoomNotificationSettings,\n    ...shared.classic,\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n      useRoom,\n      useStatus,\n      useStorageStatus: useStorageStatusSuspense,\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useErrorListener,\n      useEventListener,\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n      useMutation,\n      useThreads: useThreadsSuspense,\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n      useUpdateRoomNotificationSettings,\n      ...shared.suspense\n    },\n    useCommentsErrorListener\n  };\n  return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal, {\n    enumerable: false\n  });\n}\nfunction RoomProvider(props) {\n  const client = useClient();\n  const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => /* @__PURE__ */ new Map()\n  );\n  const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (roomId, options) => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n      const rv = client.enterRoom(roomId, options);\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    RoomProviderInner,\n    {\n      ...props,\n      stableEnterRoom\n    }\n  );\n}\nfunction RoomProviderInner(props) {\n  const client = useClient();\n  const { id: roomId, stableEnterRoom } = props;\n  if (true) {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n    if (typeof roomId !== \"string\") {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n    const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n    const oldReactVersion = majorReactVersion < 18;\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.errorIf)(\n      oldReactVersion && props.unstable_batchedUpdates === void 0,\n      missing_unstable_batchedUpdates(majorReactVersion, roomId)\n    );\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deprecateIf)(\n      !oldReactVersion && props.unstable_batchedUpdates !== void 0,\n      superfluous_unstable_batchedUpdates\n    );\n  }\n  const frozenProps = useInitial({\n    initialPresence: props.initialPresence,\n    initialStorage: props.initialStorage,\n    unstable_batchedUpdates: props.unstable_batchedUpdates,\n    autoConnect: props.autoConnect ?? typeof window !== \"undefined\"\n  });\n  const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false\n      // Deliberately using false here on the first render, see below\n    })\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const { store } = getExtrasForClient2(client);\n    async function handleCommentEvent(message) {\n      if (message.type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId);\n        return;\n      }\n      const info = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThread({\n        threadId: message.threadId\n      });\n      if (!info) {\n        store.deleteThread(message.threadId);\n        return;\n      }\n      const { thread, inboxNotification } = info;\n      const existingThread = store.get().threads[message.threadId];\n      switch (message.type) {\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_EDITED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_METADATA_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_ADDED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_DELETED:\n          if (!existingThread) break;\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        default:\n          break;\n      }\n    }\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const { getThreadsUpdates } = getExtrasForClient2(client);\n    void getThreadsUpdates(room.id);\n  }, [client, room.id]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    function handleIsOnline() {\n      const { getThreadsUpdates } = getExtrasForClient2(client);\n      void getThreadsUpdates(room.id);\n    }\n    window.addEventListener(\"online\", handleIsOnline);\n    return () => {\n      window.removeEventListener(\"online\", handleIsOnline);\n    };\n  }, [client, room.id]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n    setRoomLeavePair(pair);\n    const { room: room2, leave } = pair;\n    if (frozenProps.autoConnect) {\n      room2.connect();\n    }\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, { value: room }, props.children);\n}\nfunction useRoom() {\n  const room = useRoomOrNull();\n  if (room === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\nfunction useStatus() {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatus(options) {\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useStorageStatusSmooth();\n  } else {\n    return useStorageStatusImmediate();\n  }\n}\nfunction useStorageStatusImmediate() {\n  const room = useRoom();\n  const subscribe = room.events.storageStatus.subscribe;\n  const getSnapshot = room.getStorageStatus;\n  const getServerSnapshot = room.getStorageStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatusSmooth() {\n  const room = useRoom();\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(room.getStorageStatus);\n  const oldStatus = useLatest(room.getStorageStatus());\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let timeoutId;\n    const unsub = room.events.storageStatus.subscribe((newStatus) => {\n      if (oldStatus.current === \"synchronizing\" && newStatus === \"synchronized\") {\n        timeoutId = setTimeout(() => setStatus(newStatus), SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [room, oldStatus]);\n  return status;\n}\nfunction useBatch() {\n  return useRoom().batch;\n}\nfunction useBroadcastEvent() {\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (event, options = { shouldQueueEventIfNotReady: false }) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\nfunction useOthersListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\nfunction useLostConnectionListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.lostConnection.subscribe(\n      (event) => savedCallback.current(event)\n    ),\n    [room, savedCallback]\n  );\n}\nfunction useErrorListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.error.subscribe((e) => savedCallback.current(e)),\n    [room, savedCallback]\n  );\n}\nfunction useEventListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const listener = (eventData) => {\n      savedCallback.current(eventData);\n    };\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\nfunction useHistory() {\n  return useRoom().history;\n}\nfunction useUndo() {\n  return useHistory().undo;\n}\nfunction useRedo() {\n  return useHistory().redo;\n}\nfunction useCanUndo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return useSyncExternalStore2(subscribe, canUndo, canUndo);\n}\nfunction useCanRedo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return useSyncExternalStore2(subscribe, canRedo, canRedo);\n}\nfunction useSelf(maybeSelector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot = room.getSelf;\n  const selector = maybeSelector ?? identity;\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (me) => me !== null ? selector(me) : null,\n    [selector]\n  );\n  const getServerSnapshot = alwaysNull;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMyPresence() {\n  const room = useRoom();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = useSyncExternalStore2(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\nfunction useUpdateMyPresence() {\n  return useRoom().updatePresence;\n}\nfunction useOthers(selector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? identity,\n    isEqual\n  );\n}\nfunction useOthersMapped(itemSelector, itemIsEqual) {\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),\n    [itemSelector]\n  );\n  const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (a, b) => {\n      const eq = itemIsEqual ?? Object.is;\n      return a.length === b.length && a.every((atuple, index) => {\n        const btuple = b[index];\n        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n      });\n    },\n    [itemIsEqual]\n  );\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\nfunction useOthersConnectionIds() {\n  return useOthers(selectorFor_useOthersConnectionIds, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n}\nvar NOT_FOUND = Symbol();\nfunction useOther(connectionId, selector, isEqual) {\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (others) => {\n      const other2 = others.find((other3) => other3.connectionId === connectionId);\n      return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n  const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (prev, curr) => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n  return other;\n}\nfunction useMutableStorageRoot() {\n  const room = useRoom();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageRoot() {\n  return [useMutableStorageRoot()];\n}\nfunction useStorage(selector, isEqual) {\n  const room = useRoom();\n  const rootOrNull = useMutableStorageRoot();\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,\n    [selector]\n  );\n  const subscribe = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop2,\n    [room, rootOrNull]\n  );\n  const getSnapshot = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n  const getServerSnapshot = alwaysNull;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMutation(callback, deps) {\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => {\n      return (...args) => (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(\n          () => (\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              ...args\n            )\n          )\n        )\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\nfunction useThreads(options = {\n  query: { metadata: {} }\n}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const queryKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => generateQueryKey(room.id, options.query),\n    [room, options]\n  );\n  const { store, getThreadsAndInboxNotifications, incrementQuerySubscribers } = getExtrasForClient2(client);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    void getThreadsAndInboxNotifications(room, queryKey, options);\n    return incrementQuerySubscribers(queryKey);\n  }, [room, queryKey]);\n  const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (state2) => {\n      const query = state2.queries[queryKey];\n      if (query === void 0 || query.isLoading) {\n        return {\n          isLoading: true\n        };\n      }\n      return {\n        threads: selectedThreads(room.id, state2, options),\n        isLoading: false,\n        error: query.error\n      };\n    },\n    [room, queryKey]\n    // eslint-disable-line react-hooks/exhaustive-deps\n  );\n  const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, state);\n  return state;\n}\nfunction useCommentsErrorListener(callback) {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  const { commentsErrorEventSource } = getExtrasForClient2(client);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return commentsErrorEventSource.subscribe(savedCallback.current);\n  }, [savedCallback, commentsErrorEventSource]);\n}\nfunction useCreateThread() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (options) => {\n      const body = options.body;\n      const metadata = options.metadata ?? {};\n      const threadId = createThreadId();\n      const commentId = createCommentId();\n      const createdAt = /* @__PURE__ */ new Date();\n      const newComment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(room),\n        body,\n        reactions: []\n      };\n      const newThread = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId: room.id,\n        metadata,\n        comments: [newComment],\n        resolved: false\n      };\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"create-thread\",\n        thread: newThread,\n        id: optimisticUpdateId,\n        roomId: room.id\n      });\n      const commentsAPI = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments;\n      commentsAPI.createThread({ threadId, commentId, body, metadata }).then(\n        (thread) => {\n          store.set((state) => ({\n            ...state,\n            threads: {\n              ...state.threads,\n              [threadId]: thread\n            },\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            )\n          }));\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateThreadError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body,\n            metadata\n          })\n        )\n      );\n      return newThread;\n    },\n    [client, room]\n  );\n}\nfunction useDeleteThread() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      const thread = store.get().threads[threadId];\n      const userId = getCurrentUserId(room);\n      if (thread?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n      store.pushOptimisticUpdate({\n        type: \"delete-thread\",\n        id: optimisticUpdateId,\n        roomId: room.id,\n        threadId,\n        deletedAt: /* @__PURE__ */ new Date()\n      });\n      const commentsAPI = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments;\n      commentsAPI.deleteThread({ threadId }).then(\n        () => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            if (existingThread === void 0) {\n              return state;\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: {\n                  ...existingThread,\n                  updatedAt: /* @__PURE__ */ new Date(),\n                  deletedAt: /* @__PURE__ */ new Date()\n                }\n              },\n              optimisticUpdates: state.optimisticUpdates.filter(\n                (update) => update.id !== optimisticUpdateId\n              )\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new DeleteThreadError(err2, { roomId: room.id, threadId })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useEditThreadMetadata() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (options) => {\n      if (!options.metadata) {\n        return;\n      }\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"edit-thread-metadata\",\n        metadata,\n        id: optimisticUpdateId,\n        threadId,\n        updatedAt\n      });\n      const commentsAPI = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments;\n      commentsAPI.editThreadMetadata({ metadata, threadId }).then(\n        (metadata2) => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            if (existingThread.deletedAt !== void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: {\n                  ...existingThread,\n                  metadata: metadata2\n                }\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditThreadMetadataError(error, {\n            roomId: room.id,\n            threadId,\n            metadata\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useCreateComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, body }) => {\n      const commentId = createCommentId();\n      const createdAt = /* @__PURE__ */ new Date();\n      const comment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(room),\n        body,\n        reactions: []\n      };\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"create-comment\",\n        comment,\n        id: optimisticUpdateId\n      });\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.createComment({ threadId, commentId, body }).then(\n        (newComment) => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            const inboxNotification = Object.values(\n              state.inboxNotifications\n            ).find(\n              (notification) => notification.kind === \"thread\" && notification.threadId === threadId\n            );\n            const updatedInboxNotifications = inboxNotification !== void 0 ? {\n              ...state.inboxNotifications,\n              [inboxNotification.id]: {\n                ...inboxNotification,\n                notifiedAt: newComment.createdAt,\n                readAt: newComment.createdAt\n              }\n            } : state.inboxNotifications;\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.upsertComment)(existingThread, newComment)\n                // Upsert the new comment into the thread comments list (if applicable)\n              },\n              inboxNotifications: updatedInboxNotifications,\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateCommentError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n      return comment;\n    },\n    [client, room]\n  );\n}\nfunction useEditComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, body }) => {\n      const editedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      const thread = store.get().threads[threadId];\n      if (thread === void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n      const comment = thread.comments.find(\n        (comment2) => comment2.id === commentId\n      );\n      if (comment === void 0 || comment.deletedAt !== void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n      store.pushOptimisticUpdate({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body\n        },\n        id: optimisticUpdateId\n      });\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.editComment({ threadId, commentId, body }).then(\n        (editedComment) => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.upsertComment)(existingThread, editedComment)\n                // Upsert the edited comment into the thread comments list (if applicable)\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useDeleteComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId }) => {\n      const deletedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        id: optimisticUpdateId,\n        roomId: room.id\n      });\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.deleteComment({ threadId, commentId }).then(\n        () => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deleteComment)(existingThread, commentId, deletedAt)\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new DeleteCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useAddReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const createdAt = /* @__PURE__ */ new Date();\n      const userId = getCurrentUserId(room);\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt\n        },\n        id: optimisticUpdateId\n      });\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.addReaction({ threadId, commentId, emoji }).then(\n        (addedReaction) => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.addReaction)(\n                  existingThread,\n                  commentId,\n                  addedReaction\n                )\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new AddReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useRemoveReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const userId = getCurrentUserId(room);\n      const removedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt,\n        id: optimisticUpdateId\n      });\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.removeReaction({ threadId, commentId, emoji }).then(\n        () => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.removeReaction)(\n                  existingThread,\n                  commentId,\n                  emoji,\n                  userId,\n                  removedAt\n                )\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new RemoveReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsRead() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      const inboxNotification = Object.values(\n        store.get().inboxNotifications\n      ).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      if (!inboxNotification) return;\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const now = /* @__PURE__ */ new Date();\n      store.pushOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        id: optimisticUpdateId,\n        inboxNotificationId: inboxNotification.id,\n        readAt: now\n      });\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.markInboxNotificationAsRead(inboxNotification.id).then(\n        () => {\n          store.set((state) => ({\n            ...state,\n            inboxNotifications: {\n              ...state.inboxNotifications,\n              [inboxNotification.id]: {\n                ...inboxNotification,\n                readAt: now\n              }\n            },\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            )\n          }));\n        },\n        (err) => {\n          onMutationFailure(\n            err,\n            optimisticUpdateId,\n            (error) => new MarkInboxNotificationAsReadError(error, {\n              inboxNotificationId: inboxNotification.id\n            })\n          );\n          return;\n        }\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsResolved() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"mark-thread-as-resolved\",\n        id: optimisticUpdateId,\n        threadId,\n        updatedAt\n      });\n      const commentsAPI = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments;\n      commentsAPI.markThreadAsResolved({ threadId }).then(\n        () => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            if (existingThread.deletedAt !== void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: {\n                  ...existingThread,\n                  resolved: true\n                }\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new MarkThreadAsResolvedError(error, {\n            roomId: room.id,\n            threadId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsUnresolved() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"mark-thread-as-unresolved\",\n        id: optimisticUpdateId,\n        threadId,\n        updatedAt\n      });\n      const commentsAPI = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments;\n      commentsAPI.markThreadAsUnresolved({ threadId }).then(\n        () => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            if (existingThread.deletedAt !== void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: {\n                  ...existingThread,\n                  resolved: false\n                }\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new MarkThreadAsUnresolvedError(error, {\n            roomId: room.id,\n            threadId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useThreadSubscription(threadId) {\n  const client = useClient();\n  const { store } = getExtrasForClient2(client);\n  const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (state) => {\n      const inboxNotification = selectedInboxNotifications(state).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      const thread = state.threads[threadId];\n      if (inboxNotification === void 0 || thread === void 0) {\n        return {\n          status: \"not-subscribed\"\n        };\n      }\n      return {\n        status: \"subscribed\",\n        unreadSince: inboxNotification.readAt\n      };\n    },\n    [threadId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n}\nfunction useRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getExtrasForClient2(client);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const { getInboxNotificationSettings } = getExtrasForClient2(client);\n    const queryKey = makeNotificationSettingsQueryKey(room.id);\n    void getInboxNotificationSettings(room, queryKey);\n  }, [client, room]);\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (state) => {\n      const query = state.queries[makeNotificationSettingsQueryKey(room.id)];\n      if (query === void 0 || query.isLoading) {\n        return { isLoading: true };\n      }\n      if (query.error !== void 0) {\n        return { isLoading: false, error: query.error };\n      }\n      return {\n        isLoading: false,\n        settings: selectNotificationSettings(room.id, state)\n      };\n    },\n    [room]\n  );\n  const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useUpdateRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (settings) => {\n      const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        id: optimisticUpdateId,\n        type: \"update-notification-settings\",\n        roomId: room.id,\n        settings\n      });\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.updateRoomNotificationSettings(settings).then(\n        (settings2) => {\n          store.set((state) => ({\n            ...state,\n            notificationSettings: {\n              [room.id]: settings2\n            },\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            )\n          }));\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new UpdateNotificationSettingsError(error, {\n            roomId: room.id\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction ensureNotServerSide() {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\"\n    );\n  }\n}\nfunction useSuspendUntilPresenceReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\nfunction useSelfSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersConnectionIdsSuspense() {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\nfunction useOthersMappedSuspense(itemSelector, itemIsEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\nfunction useOtherSuspense(connectionId, selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\nfunction useSuspendUntilStorageReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\nfunction useStorageSuspense(selector, isEqual) {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual\n  );\n}\nfunction useStorageStatusSuspense(options) {\n  useSuspendUntilStorageReady();\n  return useStorageStatus(options);\n}\nfunction useThreadsSuspense(options = {\n  query: { metadata: {} }\n}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const queryKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => generateQueryKey(room.id, options.query),\n    [room, options]\n  );\n  const { store, getThreadsAndInboxNotifications } = getExtrasForClient2(client);\n  const query = store.get().queries[queryKey];\n  if (query === void 0 || query.isLoading) {\n    throw getThreadsAndInboxNotifications(room, queryKey, options);\n  }\n  if (query.error) {\n    throw query.error;\n  }\n  const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (state2) => {\n      return {\n        threads: selectedThreads(room.id, state2, options),\n        isLoading: false\n      };\n    },\n    [room, queryKey]\n    // eslint-disable-line react-hooks/exhaustive-deps\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const { incrementQuerySubscribers } = getExtrasForClient2(client);\n    return incrementQuerySubscribers(queryKey);\n  }, [client, queryKey]);\n  const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, state);\n  return state;\n}\nfunction useRoomNotificationSettingsSuspense() {\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const client = useClient();\n  const room = useRoom();\n  const queryKey = makeNotificationSettingsQueryKey(room.id);\n  const { store, getInboxNotificationSettings } = getExtrasForClient2(client);\n  const query = store.get().queries[queryKey];\n  if (query === void 0 || query.isLoading) {\n    throw getInboxNotificationSettings(room, queryKey);\n  }\n  if (query.error) {\n    throw query.error;\n  }\n  const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (state) => {\n      return {\n        isLoading: false,\n        settings: selectNotificationSettings(room.id, state)\n      };\n    },\n    [room]\n  );\n  const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useRoomOrNull() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n}\nfunction createRoomContext(client) {\n  return getOrCreateRoomContextBundle(client);\n}\nfunction generateQueryKey(roomId, options) {\n  return `${roomId}-${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options ?? {})}`;\n}\nvar _RoomProvider = RoomProvider;\nvar _useBroadcastEvent = useBroadcastEvent;\nvar _useOthersListener = useOthersListener;\nvar _useRoom = useRoom;\nvar _useAddReaction = useAddReaction;\nvar _useMutation = useMutation;\nvar _useCreateThread = useCreateThread;\nvar _useDeleteThread = useDeleteThread;\nvar _useEditThreadMetadata = useEditThreadMetadata;\nvar _useEventListener = useEventListener;\nvar _useMyPresence = useMyPresence;\nvar _useOthersMapped = useOthersMapped;\nvar _useOthersMappedSuspense = useOthersMappedSuspense;\nvar _useThreads = useThreads;\nvar _useThreadsSuspense = useThreadsSuspense;\nvar _useOther = useOther;\nfunction _useOthers(...args) {\n  return useOthers(...args);\n}\nvar _useOtherSuspense = useOtherSuspense;\nfunction _useOthersSuspense(...args) {\n  return useOthersSuspense(...args);\n}\nvar _useStorage = useStorage;\nvar _useStorageSuspense = useStorageSuspense;\nfunction _useSelf(...args) {\n  return useSelf(...args);\n}\nfunction _useSelfSuspense(...args) {\n  return useSelfSuspense(...args);\n}\nvar _useStorageRoot = useStorageRoot;\nvar _useUpdateMyPresence = useUpdateMyPresence;\n\n\n//# sourceMappingURL=chunk-N2EE2UOX.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1OMkVFMlVPWC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQytCO0FBQy9CO0FBQ0EsZ0NBQWdDLDJDQUFjO0FBQzlDLEVBQUUsNENBQWU7QUFDakI7QUFDQSxHQUFHO0FBQ0gseUJBQXlCLGdEQUFtQixDQUFDLDJDQUFjLElBQUksMEJBQTBCO0FBQ3pGOztBQUVBO0FBUzBCO0FBQ007QUFPakI7QUFDOEQ7QUFDb0I7O0FBRWpHO0FBQzBEO0FBQzFEO0FBQ0EsaUJBQWlCLHdFQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3dDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHdDQUF3QyxVQUFVLFlBQVksWUFBWTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNEQUFJO0FBQ2Q7QUFDQTs7QUFFQTtBQUNnRDs7QUFFaEQ7QUFDd0Q7QUFDeEQ7QUFDQSxjQUFjLDZDQUFNO0FBQ3BCLEVBQUUsZ0RBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaURBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQVc7QUFDdEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUcwQjtBQUMxQjtBQUNBLGlCQUFpQix3RUFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTtBQUNBLFVBQVUseUNBQXlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0EsR0FBRztBQUNILGdCQUFnQiwrR0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLCtHQUFpQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBYztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyw2Q0FBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxHQUFHLDJEQUFTLGNBQWMsRUFBRTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE2RUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC9kaXN0L2NodW5rLU4yRUUyVU9YLm1qcz85YTkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL3JlYWN0XCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjIuMy4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9DbGllbnRTaWRlU3VzcGVuc2UudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIENsaWVudFNpZGVTdXNwZW5zZShwcm9wcykge1xuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuU3VzcGVuc2UsIHsgZmFsbGJhY2s6IHByb3BzLmZhbGxiYWNrIH0sIG1vdW50ZWQgPyB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IHByb3BzLmNoaWxkcmVuKCkgOiBwcm9wcy5jaGlsZHJlbiA6IHByb3BzLmZhbGxiYWNrKTtcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG5pbXBvcnQge1xuICBhc3NlcnQsXG4gIGNyZWF0ZUNsaWVudCxcbiAga0ludGVybmFsLFxuICBtYWtlUG9sbGVyLFxuICBtZW1vaXplT25TdWNjZXNzLFxuICByYWlzZSxcbiAgc2hhbGxvd1xufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0IFJlYWN0Miwge1xuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLFxuICB1c2VNZW1vXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy9jb21tZW50cy9saWIvc2VsZWN0ZWQtaW5ib3gtbm90aWZpY2F0aW9ucy50c1xuaW1wb3J0IHsgYXBwbHlPcHRpbWlzdGljVXBkYXRlcyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyhzdGF0ZSkge1xuICBjb25zdCByZXN1bHQgPSBhcHBseU9wdGltaXN0aWNVcGRhdGVzKHN0YXRlKTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucykuc29ydChcbiAgICAvLyBTb3J0IHNvIHRoYXQgdGhlIG1vc3QgcmVjZW50IG5vdGlmaWNhdGlvbnMgYXJlIGZpcnN0XG4gICAgKGEsIGIpID0+IGIubm90aWZpZWRBdC5nZXRUaW1lKCkgLSBhLm5vdGlmaWVkQXQuZ2V0VGltZSgpXG4gICk7XG59XG5cbi8vIHNyYy9saWIvcmV0cnktZXJyb3IudHNcbmltcG9ydCB7IHdhaXQgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xudmFyIE1BWF9FUlJPUl9SRVRSWV9DT1VOVCA9IDU7XG52YXIgRVJST1JfUkVUUllfSU5URVJWQUwgPSA1ZTM7XG5mdW5jdGlvbiByZXRyeUVycm9yKGFjdGlvbiwgcmV0cnlDb3VudCkge1xuICBpZiAocmV0cnlDb3VudCA+PSBNQVhfRVJST1JfUkVUUllfQ09VTlQpIHJldHVybjtcbiAgY29uc3QgdGltZW91dCA9IE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogRVJST1JfUkVUUllfSU5URVJWQUw7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHZvaWQgYWN0aW9uKCk7XG4gIH0sIHRpbWVvdXQpO1xufVxuYXN5bmMgZnVuY3Rpb24gYXV0b1JldHJ5KHByb21pc2VGbiwgbWF4VHJpZXMsIGJhY2tvZmYpIHtcbiAgY29uc3QgZmFsbGJhY2tCYWNrb2ZmID0gYmFja29mZi5sZW5ndGggPiAwID8gYmFja29mZltiYWNrb2ZmLmxlbmd0aCAtIDFdIDogMDtcbiAgbGV0IGF0dGVtcHQgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGF0dGVtcHQrKztcbiAgICBjb25zdCBwcm9taXNlID0gcHJvbWlzZUZuKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGF0dGVtcHQgPj0gbWF4VHJpZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgYWZ0ZXIgJHttYXhUcmllc30gYXR0ZW1wdHM6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gYmFja29mZlthdHRlbXB0IC0gMV0gPz8gZmFsbGJhY2tCYWNrb2ZmO1xuICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICB9XG59XG5cbi8vIHNyYy9saWIvdXNlLWluaXRpYWwudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWR1Y2VyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9saWIvdXNlLWxhdGVzdC50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlTGF0ZXN0KHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG4vLyBzcmMvbGliL3VzZS1pbml0aWFsLnRzXG52YXIgbm9vcCA9IChzdGF0ZSkgPT4gc3RhdGU7XG5mdW5jdGlvbiB1c2VJbml0aWFsKHZhbHVlKSB7XG4gIHJldHVybiB1c2VSZWR1Y2VyKG5vb3AsIHZhbHVlKVswXTtcbn1cbmZ1bmN0aW9uIHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihsYXRlc3RWYWx1ZSkge1xuICBjb25zdCBmcm96ZW5WYWx1ZSA9IHVzZUluaXRpYWwobGF0ZXN0VmFsdWUpO1xuICBpZiAodHlwZW9mIGZyb3plblZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCByZWYgPSB1c2VMYXRlc3QobGF0ZXN0VmFsdWUpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoLi4uYXJncykgPT4gcmVmLmN1cnJlbnQoLi4uYXJncyksIFtcbiAgICAgIHJlZlxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm96ZW5WYWx1ZTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3VzZS1wb2x5ZmlsbC50c1xudmFyIHVzZSA9IChcbiAgLy8gUmVhY3QudXNlIHx8XG4gIChwcm9taXNlKSA9PiB7XG4gICAgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgIHRocm93IHByb21pc2UucmVhc29uO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICAodikgPT4ge1xuICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICBwcm9taXNlLnJlYXNvbiA9IGU7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aHJvdyBwcm9taXNlO1xuICAgIH1cbiAgfVxuKTtcblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG52YXIgQ2xpZW50Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiBtaXNzaW5nVXNlckVycm9yKHVzZXJJZCkge1xuICByZXR1cm4gbmV3IEVycm9yKGByZXNvbHZlVXNlcnMgZGlkbid0IHJldHVybiBhbnl0aGluZyBmb3IgdXNlciAnJHt1c2VySWR9J2ApO1xufVxuZnVuY3Rpb24gbWlzc2luZ1Jvb21JbmZvRXJyb3Iocm9vbUlkKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYHJlc29sdmVSb29tc0luZm8gZGlkbid0IHJldHVybiBhbnl0aGluZyBmb3Igcm9vbSAnJHtyb29tSWR9J2BcbiAgKTtcbn1cbnZhciBfZXh0cmFzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgX2J1bmRsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBQT0xMSU5HX0lOVEVSVkFMID0gNjAgKiAxZTM7XG52YXIgSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWSA9IFwiSU5CT1hfTk9USUZJQ0FUSU9OU1wiO1xuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlSW5ib3hOb3RpZmljYXRpb25zKHN0YXRlKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gc3RhdGUucXVlcmllc1tJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZXTtcbiAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYgKHF1ZXJ5LmVycm9yICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHF1ZXJ5LmVycm9yLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHNlbGVjdGVkSW5ib3hOb3RpZmljYXRpb25zKHN0YXRlKSxcbiAgICBpc0xvYWRpbmc6IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBzZWxlY3RVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChzdGF0ZSkge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGNvbnN0IG5vdGlmaWNhdGlvbiBvZiBzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyhzdGF0ZSkpIHtcbiAgICBpZiAobm90aWZpY2F0aW9uLnJlYWRBdCA9PT0gbnVsbCB8fCBub3RpZmljYXRpb24ucmVhZEF0IDwgbm90aWZpY2F0aW9uLm5vdGlmaWVkQXQpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KHN0YXRlKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gc3RhdGUucXVlcmllc1tJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZXTtcbiAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYgKHF1ZXJ5LmVycm9yICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHF1ZXJ5LmVycm9yLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIGNvdW50OiBzZWxlY3RVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChzdGF0ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZVVzZXIoc3RhdGUsIHVzZXJJZCkge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCB8fCBzdGF0ZT8uaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlID8/IHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbiAgaWYgKHN0YXRlLmVycm9yKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmICghc3RhdGUuZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG1pc3NpbmdVc2VyRXJyb3IodXNlcklkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIHVzZXI6IHN0YXRlLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZVJvb21JbmZvKHN0YXRlLCByb29tSWQpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDAgfHwgc3RhdGU/LmlzTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZSA/PyB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGlmIChzdGF0ZS5lcnJvcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAoIXN0YXRlLmRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGVycm9yOiBtaXNzaW5nUm9vbUluZm9FcnJvcihyb29tSWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgaW5mbzogc3RhdGUuZGF0YVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVDb250ZXh0QnVuZGxlKGNsaWVudCkge1xuICBsZXQgYnVuZGxlID0gX2J1bmRsZXMuZ2V0KGNsaWVudCk7XG4gIGlmICghYnVuZGxlKSB7XG4gICAgYnVuZGxlID0gbWFrZUxpdmVibG9ja3NDb250ZXh0QnVuZGxlKGNsaWVudCk7XG4gICAgX2J1bmRsZXMuc2V0KGNsaWVudCwgYnVuZGxlKTtcbiAgfVxuICByZXR1cm4gYnVuZGxlO1xufVxuZnVuY3Rpb24gZ2V0RXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBsZXQgZXh0cmFzID0gX2V4dHJhcy5nZXQoY2xpZW50KTtcbiAgaWYgKCFleHRyYXMpIHtcbiAgICBleHRyYXMgPSBtYWtlRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgX2V4dHJhcy5zZXQoY2xpZW50LCBleHRyYXMpO1xuICB9XG4gIHJldHVybiBleHRyYXM7XG59XG5mdW5jdGlvbiBtYWtlRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBpbnRlcm5hbHMgPSBjbGllbnRba0ludGVybmFsXTtcbiAgY29uc3Qgc3RvcmUgPSBpbnRlcm5hbHMuY2FjaGVTdG9yZTtcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGludGVybmFscy5ub3RpZmljYXRpb25zO1xuICBsZXQgbGFzdFJlcXVlc3RlZEF0O1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaEluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgICBjb25zdCBzaW5jZSA9IGxhc3RSZXF1ZXN0ZWRBdCAhPT0gdm9pZCAwID8geyBzaW5jZTogbGFzdFJlcXVlc3RlZEF0IH0gOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbm90aWZpY2F0aW9ucy5nZXRJbmJveE5vdGlmaWNhdGlvbnMoc2luY2UpO1xuICAgIHN0b3JlLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgcmVzdWx0LnRocmVhZHMsXG4gICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgcmVzdWx0LmRlbGV0ZWRUaHJlYWRzLFxuICAgICAgcmVzdWx0LmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICBJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZXG4gICAgKTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDAgfHwgbGFzdFJlcXVlc3RlZEF0IDwgcmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpIHtcbiAgICAgIGxhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0O1xuICAgIH1cbiAgfVxuICBsZXQgcG9sbGVyU3Vic2NyaWJlcnMgPSAwO1xuICBjb25zdCBwb2xsZXIgPSBtYWtlUG9sbGVyKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgd2FpdFVudGlsSW5ib3hOb3RpZmljYXRpb25zTG9hZGVkKCk7XG4gICAgICBhd2FpdCBmZXRjaEluYm94Tm90aWZpY2F0aW9ucygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBQb2xsaW5nIG5ldyBpbmJveCBub3RpZmljYXRpb25zIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCB3YWl0VW50aWxJbmJveE5vdGlmaWNhdGlvbnNMb2FkZWQgPSBtZW1vaXplT25TdWNjZXNzKGFzeW5jICgpID0+IHtcbiAgICBzdG9yZS5zZXRRdWVyeVN0YXRlKElOQk9YX05PVElGSUNBVElPTlNfUVVFUlksIHtcbiAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhdXRvUmV0cnkoXG4gICAgICAgICgpID0+IGZldGNoSW5ib3hOb3RpZmljYXRpb25zKCksXG4gICAgICAgIDUsXG4gICAgICAgIFs1ZTMsIDVlMywgMWU0LCAxNWUzXVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN0b3JlLnNldFF1ZXJ5U3RhdGUoSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBsb2FkSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICAgIHZvaWQgd2FpdFVudGlsSW5ib3hOb3RpZmljYXRpb25zTG9hZGVkKCkuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUVuYWJsZUluYm94Tm90aWZpY2F0aW9uc1BvbGxpbmcoKSB7XG4gICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICBwb2xsZXJTdWJzY3JpYmVycysrO1xuICAgICAgcG9sbGVyLnN0YXJ0KFBPTExJTkdfSU5URVJWQUwpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKHBvbGxlclN1YnNjcmliZXJzIDw9IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgSW50ZXJuYWwgdW5leHBlY3RlZCBiZWhhdmlvci4gQ2Fubm90IGRlY3JlYXNlIHN1YnNjcmliZXIgY291bnQgZm9yIHF1ZXJ5IFwiJHtJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBvbGxlclN1YnNjcmliZXJzLS07XG4gICAgICAgIGlmIChwb2xsZXJTdWJzY3JpYmVycyA8PSAwKSB7XG4gICAgICAgICAgcG9sbGVyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdG9yZSxcbiAgICBub3RpZmljYXRpb25zLFxuICAgIHVzZUVuYWJsZUluYm94Tm90aWZpY2F0aW9uc1BvbGxpbmcsXG4gICAgd2FpdFVudGlsSW5ib3hOb3RpZmljYXRpb25zTG9hZGVkLFxuICAgIGxvYWRJbmJveE5vdGlmaWNhdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VMaXZlYmxvY2tzQ29udGV4dEJ1bmRsZShjbGllbnQpIHtcbiAgY29uc3QgdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQyID0gKGluYm94Tm90aWZpY2F0aW9uSWQpID0+IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkX3dpdGhDbGllbnQoY2xpZW50LCBpbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgY29uc3QgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkMiA9ICgpID0+IHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZF93aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyID0gKCkgPT4gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZF93aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uMiA9ICgpID0+IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uX3dpdGhDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zMiA9ICgpID0+IHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCk7XG4gIGZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcjIocHJvcHMpIHtcbiAgICB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcigpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoQ2xpZW50Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY2xpZW50IH0sIHByb3BzLmNoaWxkcmVuKTtcbiAgfVxuICBjb25zdCBzaGFyZWQgPSBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCk7XG4gIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICBMaXZlYmxvY2tzUHJvdmlkZXI6IExpdmVibG9ja3NQcm92aWRlcjIsXG4gICAgdXNlSW5ib3hOb3RpZmljYXRpb25zOiAoKSA9PiB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQpLFxuICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiAoKSA9PiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KGNsaWVudCksXG4gICAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQyLFxuICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQ6IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyLFxuICAgIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uOiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjIsXG4gICAgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zOiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMyLFxuICAgIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkOiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDIsXG4gICAgLi4uc2hhcmVkLmNsYXNzaWMsXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIExpdmVibG9ja3NQcm92aWRlcjogTGl2ZWJsb2Nrc1Byb3ZpZGVyMixcbiAgICAgIHVzZUluYm94Tm90aWZpY2F0aW9uczogKCkgPT4gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQpLFxuICAgICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQ6ICgpID0+IHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQpLFxuICAgICAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQyLFxuICAgICAgdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDogdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDIsXG4gICAgICB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjogdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24yLFxuICAgICAgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zOiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMyLFxuICAgICAgdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQ6IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkMixcbiAgICAgIC4uLnNoYXJlZC5zdXNwZW5zZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCB7IGxvYWRJbmJveE5vdGlmaWNhdGlvbnMsIHN0b3JlLCB1c2VFbmFibGVJbmJveE5vdGlmaWNhdGlvbnNQb2xsaW5nIH0gPSBnZXRFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgbG9hZEluYm94Tm90aWZpY2F0aW9ucygpO1xuICB9LCBbbG9hZEluYm94Tm90aWZpY2F0aW9uc10pO1xuICB1c2VFbmFibGVJbmJveE5vdGlmaWNhdGlvbnNQb2xsaW5nKCk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgc3RvcmUuZ2V0LFxuICAgIHN0b3JlLmdldCxcbiAgICBzZWxlY3RvckZvcl91c2VJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgc2hhbGxvd1xuICApO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQpIHtcbiAgY29uc3QgeyB3YWl0VW50aWxJbmJveE5vdGlmaWNhdGlvbnNMb2FkZWQgfSA9IGdldEV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2Uod2FpdFVudGlsSW5ib3hOb3RpZmljYXRpb25zTG9hZGVkKCkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQpO1xuICBhc3NlcnQoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCB7IHN0b3JlLCBsb2FkSW5ib3hOb3RpZmljYXRpb25zLCB1c2VFbmFibGVJbmJveE5vdGlmaWNhdGlvbnNQb2xsaW5nIH0gPSBnZXRFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgbG9hZEluYm94Tm90aWZpY2F0aW9ucygpO1xuICB9LCBbbG9hZEluYm94Tm90aWZpY2F0aW9uc10pO1xuICB1c2VFbmFibGVJbmJveE5vdGlmaWNhdGlvbnNQb2xsaW5nKCk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgc3RvcmUuZ2V0LFxuICAgIHN0b3JlLmdldCxcbiAgICBzZWxlY3RvckZvcl91c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBzaGFsbG93XG4gICk7XG59XG5mdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGNvbnN0IHsgd2FpdFVudGlsSW5ib3hOb3RpZmljYXRpb25zTG9hZGVkIH0gPSBnZXRFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgdXNlKHdhaXRVbnRpbEluYm94Tm90aWZpY2F0aW9uc0xvYWRlZCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRfd2l0aENsaWVudChjbGllbnQpO1xuICBhc3NlcnQoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMihcbiAgICAoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSwgbm90aWZpY2F0aW9ucyB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQoKTtcbiAgICAgIGNvbnN0IHJlYWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9uLWFzLXJlYWRcIixcbiAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgcmVhZEF0XG4gICAgICB9KTtcbiAgICAgIG5vdGlmaWNhdGlvbnMubWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ05vdGlmaWNhdGlvbiA9IHN0YXRlLmluYm94Tm90aWZpY2F0aW9uc1tpbmJveE5vdGlmaWNhdGlvbklkXTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ05vdGlmaWNhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgICAgICBbaW5ib3hOb3RpZmljYXRpb25JZF06IHtcbiAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nTm90aWZpY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgcmVhZEF0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUsIG5vdGlmaWNhdGlvbnMgfSA9IGdldEV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZCgpO1xuICAgIGNvbnN0IHJlYWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgIHR5cGU6IFwibWFyay1hbGwtaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCIsXG4gICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgcmVhZEF0XG4gICAgfSk7XG4gICAgbm90aWZpY2F0aW9ucy5tYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkudGhlbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIEFycmF5LmZyb20oT2JqZWN0LmVudHJpZXMoc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zKSkubWFwKFxuICAgICAgICAgICAgICAoW2lkLCBpbmJveE5vdGlmaWNhdGlvbl0pID0+IFtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB7IC4uLmluYm94Tm90aWZpY2F0aW9uLCByZWFkQXQgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICApXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgKTtcbiAgfSwgW2NsaWVudF0pO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb25fd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMihcbiAgICAoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSwgbm90aWZpY2F0aW9ucyB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQoKTtcbiAgICAgIGNvbnN0IGRlbGV0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImRlbGV0ZS1pbmJveC1ub3RpZmljYXRpb25cIixcbiAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgZGVsZXRlZEF0XG4gICAgICB9KTtcbiAgICAgIG5vdGlmaWNhdGlvbnMuZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb25JZCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTm90aWZpY2F0aW9uID0gc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zW2luYm94Tm90aWZpY2F0aW9uSWRdO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nTm90aWZpY2F0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IFtpbmJveE5vdGlmaWNhdGlvbklkXTogXywgLi4uaW5ib3hOb3RpZmljYXRpb25zIH0gPSBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMigoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSwgbm90aWZpY2F0aW9ucyB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkKCk7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgdHlwZTogXCJkZWxldGUtYWxsLWluYm94LW5vdGlmaWNhdGlvbnNcIixcbiAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9KTtcbiAgICBub3RpZmljYXRpb25zLmRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucygpLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7fSxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICApXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgKTtcbiAgfSwgW2NsaWVudF0pO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWRfd2l0aENsaWVudChjbGllbnQsIGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHNlbGVjdG9yID0gdXNlQ2FsbGJhY2syKFxuICAgIChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnNbaW5ib3hOb3RpZmljYXRpb25JZF0gPz8gcmFpc2UoYEluYm94IG5vdGlmaWNhdGlvbiB3aXRoIElEIFwiJHtpbmJveE5vdGlmaWNhdGlvbklkfVwiIG5vdCBmb3VuZGApO1xuICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uLmtpbmQgIT09IFwidGhyZWFkXCIpIHtcbiAgICAgICAgcmFpc2UoXG4gICAgICAgICAgYEluYm94IG5vdGlmaWNhdGlvbiB3aXRoIElEIFwiJHtpbmJveE5vdGlmaWNhdGlvbklkfVwiIGlzIG5vdCBvZiBraW5kIFwidGhyZWFkXCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aHJlYWQgPSBzdGF0ZS50aHJlYWRzW2luYm94Tm90aWZpY2F0aW9uLnRocmVhZElkXSA/PyByYWlzZShcbiAgICAgICAgYFRocmVhZCB3aXRoIElEIFwiJHtpbmJveE5vdGlmaWNhdGlvbi50aHJlYWRJZH1cIiBub3QgZm91bmQsIHRoaXMgaW5ib3ggbm90aWZpY2F0aW9uIG1pZ2h0IG5vdCBiZSBvZiBraW5kIFwidGhyZWFkXCJgXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRocmVhZDtcbiAgICB9LFxuICAgIFtpbmJveE5vdGlmaWNhdGlvbklkXVxuICApO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgIHN0b3JlLmdldCxcbiAgICBzdG9yZS5nZXQsXG4gICAgc2VsZWN0b3JcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJfd2l0aENsaWVudChjbGllbnQsIHVzZXJJZCkge1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbF0udXNlcnNTdG9yZTtcbiAgY29uc3QgZ2V0VXNlclN0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHVzZXJzU3RvcmUuZ2V0U3RhdGUodXNlcklkKSxcbiAgICBbdXNlcnNTdG9yZSwgdXNlcklkXVxuICApO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICB2b2lkIHVzZXJzU3RvcmUuZ2V0KHVzZXJJZCk7XG4gIH0sIFt1c2Vyc1N0b3JlLCB1c2VySWRdKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazIoXG4gICAgKHN0YXRlKSA9PiBzZWxlY3RvckZvcl91c2VVc2VyKHN0YXRlLCB1c2VySWQpLFxuICAgIFt1c2VySWRdXG4gICk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICB1c2Vyc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRVc2VyU3RhdGUsXG4gICAgZ2V0VXNlclN0YXRlLFxuICAgIHNlbGVjdG9yLFxuICAgIHNoYWxsb3dcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSB7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjbGllbnRba0ludGVybmFsXS51c2Vyc1N0b3JlO1xuICBjb25zdCBnZXRVc2VyU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gdXNlcnNTdG9yZS5nZXRTdGF0ZSh1c2VySWQpLFxuICAgIFt1c2Vyc1N0b3JlLCB1c2VySWRdXG4gICk7XG4gIGNvbnN0IHVzZXJTdGF0ZSA9IGdldFVzZXJTdGF0ZSgpO1xuICBpZiAoIXVzZXJTdGF0ZSB8fCB1c2VyU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgdXNlcnNTdG9yZS5nZXQodXNlcklkKTtcbiAgfVxuICBpZiAodXNlclN0YXRlLmVycm9yKSB7XG4gICAgdGhyb3cgdXNlclN0YXRlLmVycm9yO1xuICB9XG4gIGlmICghdXNlclN0YXRlLmRhdGEpIHtcbiAgICB0aHJvdyBtaXNzaW5nVXNlckVycm9yKHVzZXJJZCk7XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICB1c2Vyc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRVc2VyU3RhdGUsXG4gICAgZ2V0VXNlclN0YXRlXG4gICk7XG4gIGFzc2VydChzdGF0ZSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5pc0xvYWRpbmcsIFwiVW5leHBlY3RlZCBsb2FkaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQoIXN0YXRlLmVycm9yLCBcIlVuZXhwZWN0ZWQgZXJyb3Igc3RhdGVcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1c2VyOiBzdGF0ZS5kYXRhLFxuICAgIGVycm9yOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpIHtcbiAgY29uc3Qgcm9vbXNJbmZvU3RvcmUgPSBjbGllbnRba0ludGVybmFsXS5yb29tc0luZm9TdG9yZTtcbiAgY29uc3QgZ2V0Um9vbUluZm9TdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoKSA9PiByb29tc0luZm9TdG9yZS5nZXRTdGF0ZShyb29tSWQpLFxuICAgIFtyb29tc0luZm9TdG9yZSwgcm9vbUlkXVxuICApO1xuICBjb25zdCBzZWxlY3RvciA9IHVzZUNhbGxiYWNrMihcbiAgICAoc3RhdGUpID0+IHNlbGVjdG9yRm9yX3VzZVJvb21JbmZvKHN0YXRlLCByb29tSWQpLFxuICAgIFtyb29tSWRdXG4gICk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIHZvaWQgcm9vbXNJbmZvU3RvcmUuZ2V0KHJvb21JZCk7XG4gIH0sIFtyb29tc0luZm9TdG9yZSwgcm9vbUlkXSk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICByb29tc0luZm9TdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZSxcbiAgICBnZXRSb29tSW5mb1N0YXRlLFxuICAgIHNlbGVjdG9yLFxuICAgIHNoYWxsb3dcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHJvb21JZCkge1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNsaWVudFtrSW50ZXJuYWxdLnJvb21zSW5mb1N0b3JlO1xuICBjb25zdCBnZXRSb29tSW5mb1N0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHJvb21zSW5mb1N0b3JlLmdldFN0YXRlKHJvb21JZCksXG4gICAgW3Jvb21zSW5mb1N0b3JlLCByb29tSWRdXG4gICk7XG4gIGNvbnN0IHJvb21JbmZvU3RhdGUgPSBnZXRSb29tSW5mb1N0YXRlKCk7XG4gIGlmICghcm9vbUluZm9TdGF0ZSB8fCByb29tSW5mb1N0YXRlLmlzTG9hZGluZykge1xuICAgIHRocm93IHJvb21zSW5mb1N0b3JlLmdldChyb29tSWQpO1xuICB9XG4gIGlmIChyb29tSW5mb1N0YXRlLmVycm9yKSB7XG4gICAgdGhyb3cgcm9vbUluZm9TdGF0ZS5lcnJvcjtcbiAgfVxuICBpZiAoIXJvb21JbmZvU3RhdGUuZGF0YSkge1xuICAgIHRocm93IG1pc3NpbmdSb29tSW5mb0Vycm9yKHJvb21JZCk7XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICByb29tc0luZm9TdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZSxcbiAgICBnZXRSb29tSW5mb1N0YXRlXG4gICk7XG4gIGFzc2VydChzdGF0ZSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5pc0xvYWRpbmcsIFwiVW5leHBlY3RlZCBsb2FkaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQoIXN0YXRlLmVycm9yLCBcIlVuZXhwZWN0ZWQgZXJyb3Igc3RhdGVcIik7XG4gIGFzc2VydChzdGF0ZS5kYXRhICE9PSB2b2lkIDAsIFwiVW5leHBlY3RlZCBtaXNzaW5nIHJvb20gaW5mbyBkYXRhXCIpO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgaW5mbzogc3RhdGUuZGF0YSxcbiAgICBlcnJvcjogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCkge1xuICBjb25zdCB1c2VDbGllbnQyID0gKCkgPT4gY2xpZW50O1xuICByZXR1cm4ge1xuICAgIGNsYXNzaWM6IHtcbiAgICAgIHVzZUNsaWVudDogdXNlQ2xpZW50MixcbiAgICAgIHVzZVVzZXI6ICh1c2VySWQpID0+IHVzZVVzZXJfd2l0aENsaWVudChjbGllbnQsIHVzZXJJZCksXG4gICAgICB1c2VSb29tSW5mbzogKHJvb21JZCkgPT4gdXNlUm9vbUluZm9fd2l0aENsaWVudChjbGllbnQsIHJvb21JZClcbiAgICB9LFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICB1c2VDbGllbnQ6IHVzZUNsaWVudDIsXG4gICAgICB1c2VVc2VyOiAodXNlcklkKSA9PiB1c2VVc2VyU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHVzZXJJZCksXG4gICAgICB1c2VSb29tSW5mbzogKHJvb21JZCkgPT4gdXNlUm9vbUluZm9TdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgcm9vbUlkKVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUVuc3VyZU5vTGl2ZWJsb2Nrc1Byb3ZpZGVyKG9wdGlvbnMpIHtcbiAgY29uc3QgZXhpc3RpbmcgPSB1c2VDbGllbnRPck51bGwoKTtcbiAgaWYgKCFvcHRpb25zPy5hbGxvd05lc3RpbmcgJiYgZXhpc3RpbmcgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3QgbmVzdCBtdWx0aXBsZSBMaXZlYmxvY2tzUHJvdmlkZXIgaW5zdGFuY2VzIGluIHRoZSBzYW1lIFJlYWN0IHRyZWUuXCJcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB1c2VDbGllbnRPck51bGwoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KENsaWVudENvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlQ2xpZW50KCkge1xuICByZXR1cm4gdXNlQ2xpZW50T3JOdWxsKCkgPz8gcmFpc2UoXCJMaXZlYmxvY2tzUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbn1cbmZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQocHJvcHMpIHtcbiAgdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KENsaWVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHByb3BzLmNsaWVudCB9LCBwcm9wcy5jaGlsZHJlbik7XG59XG5mdW5jdGlvbiBMaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4ubyB9ID0gcHJvcHM7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgcHVibGljQXBpS2V5OiB1c2VJbml0aWFsKG8ucHVibGljQXBpS2V5KSxcbiAgICB0aHJvdHRsZTogdXNlSW5pdGlhbChvLnRocm90dGxlKSxcbiAgICBsb3N0Q29ubmVjdGlvblRpbWVvdXQ6IHVzZUluaXRpYWwoby5sb3N0Q29ubmVjdGlvblRpbWVvdXQpLFxuICAgIGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0OiB1c2VJbml0aWFsKG8uYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQpLFxuICAgIHBvbHlmaWxsczogdXNlSW5pdGlhbChvLnBvbHlmaWxscyksXG4gICAgdW5zdGFibGVfZmFsbGJhY2tUb0hUVFA6IHVzZUluaXRpYWwoby51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCksXG4gICAgdW5zdGFibGVfc3RyZWFtRGF0YTogdXNlSW5pdGlhbChvLnVuc3RhYmxlX3N0cmVhbURhdGEpLFxuICAgIGF1dGhFbmRwb2ludDogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKG8uYXV0aEVuZHBvaW50KSxcbiAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oXG4gICAgICBvLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnNcbiAgICApLFxuICAgIHJlc29sdmVVc2VyczogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKG8ucmVzb2x2ZVVzZXJzKSxcbiAgICByZXNvbHZlUm9vbXNJbmZvOiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oby5yZXNvbHZlUm9vbXNJbmZvKSxcbiAgICBiYXNlVXJsOiB1c2VJbml0aWFsKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIEhpZGRlbiBjb25maWcgb3B0aW9uc1xuICAgICAgby5iYXNlVXJsXG4gICAgKSxcbiAgICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IHVzZUluaXRpYWwoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gSGlkZGVuIGNvbmZpZyBvcHRpb25zXG4gICAgICBvLmVuYWJsZURlYnVnTG9nZ2luZ1xuICAgIClcbiAgfTtcbiAgY29uc3QgY2xpZW50ID0gdXNlTWVtbygoKSA9PiBjcmVhdGVDbGllbnQob3B0aW9ucyksIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChMaXZlYmxvY2tzUHJvdmlkZXJXaXRoQ2xpZW50LCB7IGNsaWVudCB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBjcmVhdGVMaXZlYmxvY2tzQ29udGV4dChjbGllbnQpIHtcbiAgcmV0dXJuIGdldE9yQ3JlYXRlQ29udGV4dEJ1bmRsZShjbGllbnQpO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICByZXR1cm4gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZV93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkX3dpdGhDbGllbnQoXG4gICAgdXNlQ2xpZW50KCksXG4gICAgaW5ib3hOb3RpZmljYXRpb25JZFxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoKSB7XG4gIHJldHVybiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMoKSB7XG4gIHJldHVybiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbigpIHtcbiAgcmV0dXJuIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gIHJldHVybiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVXNlcih1c2VySWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpO1xufVxuZnVuY3Rpb24gdXNlVXNlclN1c3BlbnNlKHVzZXJJZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvKHJvb21JZCkge1xuICByZXR1cm4gdXNlUm9vbUluZm9fd2l0aENsaWVudCh1c2VDbGllbnQoKSwgcm9vbUlkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Uocm9vbUlkKSB7XG4gIHJldHVybiB1c2VSb29tSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCksIHJvb21JZCk7XG59XG52YXIgX3VzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkID0gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQ7XG52YXIgX3VzZVVzZXIgPSB1c2VVc2VyO1xudmFyIF91c2VVc2VyU3VzcGVuc2UgPSB1c2VVc2VyU3VzcGVuc2U7XG5cbi8vIHNyYy9jb21tZW50cy9lcnJvcnMudHNcbnZhciBDcmVhdGVUaHJlYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQ3JlYXRlIHRocmVhZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQ3JlYXRlVGhyZWFkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBEZWxldGVUaHJlYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRGVsZXRlIHRocmVhZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRGVsZXRlVGhyZWFkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBFZGl0VGhyZWFkTWV0YWRhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRWRpdCB0aHJlYWQgbWV0YWRhdGEgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkVkaXRUaHJlYWRNZXRhZGF0YUVycm9yXCI7XG4gIH1cbn07XG52YXIgTWFya1RocmVhZEFzUmVzb2x2ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiTWFyayB0aHJlYWQgYXMgcmVzb2x2ZWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIk1hcmtUaHJlYWRBc1Jlc29sdmVkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBNYXJrVGhyZWFkQXNVbnJlc29sdmVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIk1hcmsgdGhyZWFkIGFzIHVucmVzb2x2ZWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIk1hcmtUaHJlYWRBc1VucmVzb2x2ZWRFcnJvclwiO1xuICB9XG59O1xudmFyIENyZWF0ZUNvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQ3JlYXRlIGNvbW1lbnQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkNyZWF0ZUNvbW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIEVkaXRDb21tZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkVkaXQgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRWRpdENvbW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIERlbGV0ZUNvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRGVsZXRlIGNvbW1lbnQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkRlbGV0ZUNvbW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIEFkZFJlYWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkFkZCByZWFjdGlvbiBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQWRkUmVhY3Rpb25FcnJvclwiO1xuICB9XG59O1xudmFyIFJlbW92ZVJlYWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIlJlbW92ZSByZWFjdGlvbiBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiUmVtb3ZlUmVhY3Rpb25FcnJvclwiO1xuICB9XG59O1xudmFyIE1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJNYXJrIGluYm94IG5vdGlmaWNhdGlvbiBhcyByZWFkIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRFcnJvclwiO1xuICB9XG59O1xudmFyIFVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIlVwZGF0ZSBub3RpZmljYXRpb24gc2V0dGluZ3MgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIlVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1lbnRzL2xpYi9zZWxlY3RlZC10aHJlYWRzLnRzXG5pbXBvcnQge1xuICBhcHBseU9wdGltaXN0aWNVcGRhdGVzIGFzIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMyXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzZWxlY3RlZFRocmVhZHMocm9vbUlkLCBzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBhcHBseU9wdGltaXN0aWNVcGRhdGVzMihzdGF0ZSk7XG4gIGNvbnN0IHRocmVhZHMgPSBPYmplY3QudmFsdWVzKHJlc3VsdC50aHJlYWRzKS5maWx0ZXIoXG4gICAgKHRocmVhZCkgPT4ge1xuICAgICAgaWYgKHRocmVhZC5yb29tSWQgIT09IHJvb21JZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBxdWVyeSA9IG9wdGlvbnMucXVlcnk7XG4gICAgICBpZiAoIXF1ZXJ5KSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChxdWVyeS5yZXNvbHZlZCAhPT0gdm9pZCAwICYmIHRocmVhZC5yZXNvbHZlZCAhPT0gcXVlcnkucmVzb2x2ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkubWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFWYWx1ZSA9IHRocmVhZC5tZXRhZGF0YVtrZXldO1xuICAgICAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IHF1ZXJ5Lm1ldGFkYXRhW2tleV07XG4gICAgICAgIGlmIChhc3NlcnRGaWx0ZXJJc1N0YXJ0c1dpdGhPcGVyYXRvcihmaWx0ZXJWYWx1ZSkgJiYgYXNzZXJ0TWV0YWRhdGFWYWx1ZUlzU3RyaW5nKG1ldGFkYXRhVmFsdWUpKSB7XG4gICAgICAgICAgaWYgKG1ldGFkYXRhVmFsdWUuc3RhcnRzV2l0aChmaWx0ZXJWYWx1ZS5zdGFydHNXaXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YVZhbHVlICE9PSBmaWx0ZXJWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICApO1xuICByZXR1cm4gdGhyZWFkcy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRBdC5nZXRUaW1lKCkgLSBiLmNyZWF0ZWRBdC5nZXRUaW1lKCkpO1xufVxudmFyIGFzc2VydEZpbHRlcklzU3RhcnRzV2l0aE9wZXJhdG9yID0gKGZpbHRlcikgPT4ge1xuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZmlsdGVyLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgYXNzZXJ0TWV0YWRhdGFWYWx1ZUlzU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59O1xuXG4vLyBzcmMvcm9vbS50c3hcbmltcG9ydCB7IHNoYWxsb3cgYXMgc2hhbGxvdzIgfSBmcm9tIFwiQGxpdmVibG9ja3MvY2xpZW50XCI7XG5pbXBvcnQge1xuICBhZGRSZWFjdGlvbixcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgY29uc29sZSBhcyBjb25zb2xlMixcbiAgZGVsZXRlQ29tbWVudCxcbiAgZGVwcmVjYXRlSWYsXG4gIGVycm9ySWYsXG4gIGtJbnRlcm5hbCBhcyBrSW50ZXJuYWwyLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1ha2VQb2xsZXIgYXMgbWFrZVBvbGxlcjIsXG4gIE5vdGlmaWNhdGlvbnNBcGlFcnJvcixcbiAgcmVtb3ZlUmVhY3Rpb24sXG4gIFNlcnZlck1zZ0NvZGUsXG4gIHN0cmluZ2lmeSxcbiAgdXBzZXJ0Q29tbWVudFxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHsgbmFub2lkIGFzIG5hbm9pZDMgfSBmcm9tIFwibmFub2lkXCI7XG5pbXBvcnQgKiBhcyBSZWFjdDQgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy9jb21tZW50cy9saWIvY3JlYXRlSWRzLnRzXG5pbXBvcnQgeyBuYW5vaWQgYXMgbmFub2lkMiB9IGZyb20gXCJuYW5vaWRcIjtcbnZhciBUSFJFQURfSURfUFJFRklYID0gXCJ0aFwiO1xudmFyIENPTU1FTlRfSURfUFJFRklYID0gXCJjbVwiO1xuZnVuY3Rpb24gY3JlYXRlT3B0aW1pc3RpY0lkKHByZWZpeCkge1xuICByZXR1cm4gYCR7cHJlZml4fV8ke25hbm9pZDIoKX1gO1xufVxuZnVuY3Rpb24gY3JlYXRlVGhyZWFkSWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoVEhSRUFEX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50SWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoQ09NTUVOVF9JRF9QUkVGSVgpO1xufVxuXG4vLyBzcmMvY29tbWVudHMvbGliL3NlbGVjdC1ub3RpZmljYXRpb24tc2V0dGluZ3MudHNcbmltcG9ydCB7XG4gIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMgYXMgYXBwbHlPcHRpbWlzdGljVXBkYXRlczMsXG4gIG5uXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzZWxlY3ROb3RpZmljYXRpb25TZXR0aW5ncyhyb29tSWQsIHN0YXRlKSB7XG4gIGNvbnN0IHsgbm90aWZpY2F0aW9uU2V0dGluZ3MgfSA9IGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMzKHN0YXRlKTtcbiAgcmV0dXJuIG5uKG5vdGlmaWNhdGlvblNldHRpbmdzW3Jvb21JZF0pO1xufVxuXG4vLyBzcmMvdXNlLXNjcm9sbC10by1jb21tZW50LW9uLWxvYWQtZWZmZWN0LnRzXG5pbXBvcnQgKiBhcyBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQoc2hvdWxkU2Nyb2xsT25Mb2FkLCBzdGF0ZSkge1xuICBpZiAoc2hvdWxkU2Nyb2xsT25Mb2FkID09PSBmYWxzZSkgcmV0dXJuO1xuICBpZiAoc3RhdGUuaXNMb2FkaW5nKSByZXR1cm47XG4gIGNvbnN0IGlzV2luZG93RGVmaW5lZCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmICghaXNXaW5kb3dEZWZpbmVkKSByZXR1cm47XG4gIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgY29uc3QgY29tbWVudElkID0gaGFzaC5zbGljZSgxKTtcbiAgaWYgKCFjb21tZW50SWQuc3RhcnRzV2l0aChcImNtX1wiKSkgcmV0dXJuO1xuICBjb25zdCBjb21tZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29tbWVudElkKTtcbiAgaWYgKGNvbW1lbnQgPT09IG51bGwpIHJldHVybjtcbiAgY29uc3QgY29tbWVudHMgPSBzdGF0ZS50aHJlYWRzLmZsYXRNYXAoKHRocmVhZCkgPT4gdGhyZWFkLmNvbW1lbnRzKTtcbiAgY29uc3QgaXNDb21tZW50SW5UaHJlYWRzID0gY29tbWVudHMuc29tZShcbiAgICAoY29tbWVudDIpID0+IGNvbW1lbnQyLmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKCFpc0NvbW1lbnRJblRocmVhZHMpIHJldHVybjtcbiAgY29tbWVudC5zY3JvbGxJbnRvVmlldygpO1xufVxuZnVuY3Rpb24gdXNlU2Nyb2xsVG9Db21tZW50T25Mb2FkRWZmZWN0KHNob3VsZFNjcm9sbE9uTG9hZCwgc3RhdGUpIHtcbiAgUmVhY3QzLnVzZUVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICBoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQoc2hvdWxkU2Nyb2xsT25Mb2FkLCBzdGF0ZSk7XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tIFdlIG9ubHkgd2FudCB0byBydW4gdGhpcyBlZmZlY3Qgb25jZVxuICAgIFtzdGF0ZS5pc0xvYWRpbmddXG4gICk7XG59XG5cbi8vIHNyYy9yb29tLnRzeFxudmFyIFNNT09USF9ERUxBWSA9IDFlMztcbnZhciBub29wMiA9ICgpID0+IHtcbn07XG52YXIgaWRlbnRpdHkgPSAoeCkgPT4geDtcbnZhciBtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gKHJlYWN0VmVyc2lvbiwgcm9vbUlkKSA9PiBgV2Ugbm90aWNlZCB5b3VcXHUyMDE5cmUgdXNpbmcgUmVhY3QgJHtyZWFjdFZlcnNpb259LiBQbGVhc2UgcGFzcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhdCB0aGUgUm9vbVByb3ZpZGVyIGxldmVsIHVudGlsIHlvdVxcdTIwMTlyZSByZWFkeSB0byB1cGdyYWRlIHRvIFJlYWN0IDE4OlxuXG4gICAgaW1wb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tIFwicmVhY3QtZG9tXCI7ICAvLyBvciBcInJlYWN0LW5hdGl2ZVwiXG5cbiAgICA8Um9vbVByb3ZpZGVyIGlkPSR7SlNPTi5zdHJpbmdpZnkoXG4gIHJvb21JZFxuKX0gLi4uIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPXt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30+XG4gICAgICAuLi5cbiAgICA8L1Jvb21Qcm92aWRlcj5cblxuV2h5PyBQbGVhc2Ugc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3Ryb3VibGVzaG9vdGluZyNzdGFsZS1wcm9wcy16b21iaWUtY2hpbGQgZm9yIG1vcmUgaW5mb3JtYXRpb25gO1xudmFyIHN1cGVyZmx1b3VzX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gXCJZb3UgZG9uXFx1MjAxOXQgbmVlZCB0byBwYXNzIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIHRvIFJvb21Qcm92aWRlciBhbnltb3JlLCBzaW5jZSB5b3VcXHUyMDE5cmUgb24gUmVhY3QgMTgrIGFscmVhZHkuXCI7XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIocywgZ3MsIGdzcykge1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKHMsIGdzLCBnc3MsIGlkZW50aXR5KTtcbn1cbnZhciBTVEFCTEVfRU1QVFlfTElTVCA9IE9iamVjdC5mcmVlemUoW10pO1xudmFyIFBPTExJTkdfSU5URVJWQUwyID0gNSAqIDYwICogMWUzO1xuZnVuY3Rpb24gbWFrZU5vdGlmaWNhdGlvblNldHRpbmdzUXVlcnlLZXkocm9vbUlkKSB7XG4gIHJldHVybiBgJHtyb29tSWR9Ok5PVElGSUNBVElPTl9TRVRUSU5HU2A7XG59XG5mdW5jdGlvbiBhbHdheXNFbXB0eUxpc3QoKSB7XG4gIHJldHVybiBTVEFCTEVfRU1QVFlfTElTVDtcbn1cbmZ1bmN0aW9uIGFsd2F5c051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlT3RoZXJzQ29ubmVjdGlvbklkcyhvdGhlcnMpIHtcbiAgcmV0dXJuIG90aGVycy5tYXAoKHVzZXIpID0+IHVzZXIuY29ubmVjdGlvbklkKTtcbn1cbmZ1bmN0aW9uIG1ha2VNdXRhdGlvbkNvbnRleHQocm9vbSkge1xuICBjb25zdCBjYW5ub3RVc2VVbnRpbCA9IFwiVGhpcyBtdXRhdGlvbiBjYW5ub3QgYmUgdXNlZCB1bnRpbFwiO1xuICBjb25zdCBuZWVkc1ByZXNlbmNlID0gYCR7Y2Fubm90VXNlVW50aWx9IGNvbm5lY3RlZCB0byB0aGUgTGl2ZWJsb2NrcyByb29tYDtcbiAgY29uc3QgbmVlZHNTdG9yYWdlID0gYCR7Y2Fubm90VXNlVW50aWx9IHN0b3JhZ2UgaGFzIGJlZW4gbG9hZGVkYDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgIGNvbnN0IG11dGFibGVSb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgICAgIGlmIChtdXRhYmxlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNTdG9yYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtdXRhYmxlUm9vdDtcbiAgICB9LFxuICAgIGdldCBzZWxmKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHJvb20uZ2V0U2VsZigpO1xuICAgICAgaWYgKHNlbGYgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5lZWRzUHJlc2VuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcbiAgICBnZXQgb3RoZXJzKCkge1xuICAgICAgY29uc3Qgb3RoZXJzID0gcm9vbS5nZXRPdGhlcnMoKTtcbiAgICAgIGlmIChyb29tLmdldFNlbGYoKSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNQcmVzZW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXJzO1xuICAgIH0sXG4gICAgc2V0TXlQcmVzZW5jZTogcm9vbS51cGRhdGVQcmVzZW5jZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXJJZChyb29tKSB7XG4gIGNvbnN0IHNlbGYgPSByb29tLmdldFNlbGYoKTtcbiAgaWYgKHNlbGYgPT09IG51bGwgfHwgc2VsZi5pZCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlbGYuaWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUFwaUVycm9yKGVycikge1xuICBjb25zdCBtZXNzYWdlID0gYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7ZXJyLnN0YXR1c306ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgaWYgKGVyci5kZXRhaWxzPy5lcnJvciA9PT0gXCJGT1JCSURERU5cIikge1xuICAgIGNvbnN0IGRldGFpbGVkTWVzc2FnZSA9IFttZXNzYWdlLCBlcnIuZGV0YWlscy5zdWdnZXN0aW9uLCBlcnIuZGV0YWlscy5kb2NzXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICBjb25zb2xlMi5lcnJvcihkZXRhaWxlZE1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG52YXIgX2V4dHJhczIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfYnVuZGxlczIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldE9yQ3JlYXRlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGxldCBidW5kbGUgPSBfYnVuZGxlczIuZ2V0KGNsaWVudCk7XG4gIGlmICghYnVuZGxlKSB7XG4gICAgYnVuZGxlID0gbWFrZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCk7XG4gICAgX2J1bmRsZXMyLnNldChjbGllbnQsIGJ1bmRsZSk7XG4gIH1cbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIGdldEV4dHJhc0ZvckNsaWVudDIoY2xpZW50KSB7XG4gIGxldCBleHRyYXMgPSBfZXh0cmFzMi5nZXQoY2xpZW50KTtcbiAgaWYgKCFleHRyYXMpIHtcbiAgICBleHRyYXMgPSBtYWtlRXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICAgIF9leHRyYXMyLnNldChjbGllbnQsIGV4dHJhcyk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhcztcbn1cbmZ1bmN0aW9uIG1ha2VFeHRyYXNGb3JDbGllbnQyKGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS5jYWNoZVN0b3JlO1xuICBjb25zdCBERUZBVUxUX0RFRFVQSU5HX0lOVEVSVkFMID0gMmUzO1xuICBjb25zdCBsYXN0UmVxdWVzdGVkQXRCeVJvb20gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZXF1ZXN0c0J5UXVlcnkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZXF1ZXN0U3RhdHVzQnlSb29tID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3Qgc3Vic2NyaWJlcnNCeVF1ZXJ5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgcG9sbGVyID0gbWFrZVBvbGxlcjIocmVmcmVzaFRocmVhZHNBbmROb3RpZmljYXRpb25zKTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFRocmVhZHNBbmROb3RpZmljYXRpb25zKCkge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gW107XG4gICAgY2xpZW50W2tJbnRlcm5hbDJdLmdldFJvb21JZHMoKS5tYXAoKHJvb21JZCkgPT4ge1xuICAgICAgY29uc3Qgcm9vbSA9IGNsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICBpZiAocm9vbSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgcmVxdWVzdHMucHVzaChnZXRUaHJlYWRzVXBkYXRlcyhyb29tLmlkKSk7XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHJlcXVlc3RzKTtcbiAgfVxuICBmdW5jdGlvbiBpbmNyZW1lbnRRdWVyeVN1YnNjcmliZXJzKHF1ZXJ5S2V5KSB7XG4gICAgY29uc3Qgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVyc0J5UXVlcnkuZ2V0KHF1ZXJ5S2V5KSA/PyAwO1xuICAgIHN1YnNjcmliZXJzQnlRdWVyeS5zZXQocXVlcnlLZXksIHN1YnNjcmliZXJzICsgMSk7XG4gICAgcG9sbGVyLnN0YXJ0KFBPTExJTkdfSU5URVJWQUwyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3Qgc3Vic2NyaWJlcnMyID0gc3Vic2NyaWJlcnNCeVF1ZXJ5LmdldChxdWVyeUtleSk7XG4gICAgICBpZiAoc3Vic2NyaWJlcnMyID09PSB2b2lkIDAgfHwgc3Vic2NyaWJlcnMyIDw9IDApIHtcbiAgICAgICAgY29uc29sZTIud2FybihcbiAgICAgICAgICBgSW50ZXJuYWwgdW5leHBlY3RlZCBiZWhhdmlvci4gQ2Fubm90IGRlY3JlYXNlIHN1YnNjcmliZXIgY291bnQgZm9yIHF1ZXJ5IFwiJHtxdWVyeUtleX1cImBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlcnNCeVF1ZXJ5LnNldChxdWVyeUtleSwgc3Vic2NyaWJlcnMyIC0gMSk7XG4gICAgICBsZXQgdG90YWxTdWJzY3JpYmVycyA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHN1YnNjcmliZXJzMyBvZiBzdWJzY3JpYmVyc0J5UXVlcnkudmFsdWVzKCkpIHtcbiAgICAgICAgdG90YWxTdWJzY3JpYmVycyArPSBzdWJzY3JpYmVyczM7XG4gICAgICB9XG4gICAgICBpZiAodG90YWxTdWJzY3JpYmVycyA8PSAwKSB7XG4gICAgICAgIHBvbGxlci5zdG9wKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzVXBkYXRlcyhyb29tSWQpIHtcbiAgICBjb25zdCByb29tID0gY2xpZW50LmdldFJvb20ocm9vbUlkKTtcbiAgICBpZiAocm9vbSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHNpbmNlID0gbGFzdFJlcXVlc3RlZEF0QnlSb29tLmdldChyb29tLmlkKTtcbiAgICBpZiAoc2luY2UgPT09IHZvaWQgMCkgcmV0dXJuO1xuICAgIGNvbnN0IGlzRmV0Y2hpbmdUaHJlYWRzVXBkYXRlcyA9IHJlcXVlc3RTdGF0dXNCeVJvb20uZ2V0KHJvb20uaWQpID8/IGZhbHNlO1xuICAgIGlmIChpc0ZldGNoaW5nVGhyZWFkc1VwZGF0ZXMgPT09IHRydWUpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgcmVxdWVzdFN0YXR1c0J5Um9vbS5zZXQocm9vbS5pZCwgdHJ1ZSk7XG4gICAgICBjb25zdCBjb21tZW50c0FQSSA9IHJvb21ba0ludGVybmFsMl0uY29tbWVudHM7XG4gICAgICBjb25zdCB1cGRhdGVzID0gYXdhaXQgY29tbWVudHNBUEkuZ2V0VGhyZWFkcyh7IHNpbmNlIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RTdGF0dXNCeVJvb20uc2V0KHJvb20uaWQsIGZhbHNlKTtcbiAgICAgIH0sIERFRkFVTFRfREVEVVBJTkdfSU5URVJWQUwpO1xuICAgICAgc3RvcmUudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICAgIHVwZGF0ZXMudGhyZWFkcyxcbiAgICAgICAgdXBkYXRlcy5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgIHVwZGF0ZXMuZGVsZXRlZFRocmVhZHMsXG4gICAgICAgIHVwZGF0ZXMuZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgKTtcbiAgICAgIGxhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQocm9vbS5pZCwgdXBkYXRlcy5tZXRhLnJlcXVlc3RlZEF0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlcXVlc3RTdGF0dXNCeVJvb20uc2V0KHJvb20uaWQsIGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc0FuZEluYm94Tm90aWZpY2F0aW9ucyhyb29tLCBxdWVyeUtleSwgb3B0aW9ucywgeyByZXRyeUNvdW50IH0gPSB7IHJldHJ5Q291bnQ6IDAgfSkge1xuICAgIGNvbnN0IGV4aXN0aW5nUmVxdWVzdCA9IHJlcXVlc3RzQnlRdWVyeS5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChleGlzdGluZ1JlcXVlc3QgIT09IHZvaWQgMCkgcmV0dXJuIGV4aXN0aW5nUmVxdWVzdDtcbiAgICBjb25zdCBjb21tZW50c0FQSSA9IHJvb21ba0ludGVybmFsMl0uY29tbWVudHM7XG4gICAgY29uc3QgcmVxdWVzdCA9IGNvbW1lbnRzQVBJLmdldFRocmVhZHMob3B0aW9ucyk7XG4gICAgcmVxdWVzdHNCeVF1ZXJ5LnNldChxdWVyeUtleSwgcmVxdWVzdCk7XG4gICAgc3RvcmUuc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwge1xuICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q7XG4gICAgICBzdG9yZS51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgICAgcmVzdWx0LnRocmVhZHMsXG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgIHJlc3VsdC5kZWxldGVkVGhyZWFkcyxcbiAgICAgICAgcmVzdWx0LmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgIHF1ZXJ5S2V5XG4gICAgICApO1xuICAgICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gbGFzdFJlcXVlc3RlZEF0QnlSb29tLmdldChyb29tLmlkKTtcbiAgICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IHZvaWQgMCB8fCBsYXN0UmVxdWVzdGVkQXQgPiByZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdCkge1xuICAgICAgICBsYXN0UmVxdWVzdGVkQXRCeVJvb20uc2V0KHJvb20uaWQsIHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KTtcbiAgICAgIH1cbiAgICAgIHBvbGxlci5zdGFydChQT0xMSU5HX0lOVEVSVkFMMik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXF1ZXN0c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5S2V5KTtcbiAgICAgIHJldHJ5RXJyb3IoKCkgPT4ge1xuICAgICAgICB2b2lkIGdldFRocmVhZHNBbmRJbmJveE5vdGlmaWNhdGlvbnMocm9vbSwgcXVlcnlLZXksIG9wdGlvbnMsIHtcbiAgICAgICAgICByZXRyeUNvdW50OiByZXRyeUNvdW50ICsgMVxuICAgICAgICB9KTtcbiAgICAgIH0sIHJldHJ5Q291bnQpO1xuICAgICAgc3RvcmUuc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbSwgcXVlcnlLZXksIHsgcmV0cnlDb3VudCB9ID0geyByZXRyeUNvdW50OiAwIH0pIHtcbiAgICBjb25zdCBleGlzdGluZ1JlcXVlc3QgPSByZXF1ZXN0c0J5UXVlcnkuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdSZXF1ZXN0ICE9PSB2b2lkIDApIHJldHVybiBleGlzdGluZ1JlcXVlc3Q7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByb29tW2tJbnRlcm5hbDJdLm5vdGlmaWNhdGlvbnMuZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gICAgICByZXF1ZXN0c0J5UXVlcnkuc2V0KHF1ZXJ5S2V5LCByZXF1ZXN0KTtcbiAgICAgIHN0b3JlLnNldFF1ZXJ5U3RhdGUocXVlcnlLZXksIHtcbiAgICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgcmVxdWVzdDtcbiAgICAgIHN0b3JlLnVwZGF0ZVJvb21JbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20uaWQsIHNldHRpbmdzLCBxdWVyeUtleSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXF1ZXN0c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5S2V5KTtcbiAgICAgIHJldHJ5RXJyb3IoKCkgPT4ge1xuICAgICAgICB2b2lkIGdldEluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbSwgcXVlcnlLZXksIHtcbiAgICAgICAgICByZXRyeUNvdW50OiByZXRyeUNvdW50ICsgMVxuICAgICAgICB9KTtcbiAgICAgIH0sIHJldHJ5Q291bnQpO1xuICAgICAgc3RvcmUuc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBvbk11dGF0aW9uRmFpbHVyZShpbm5lckVycm9yLCBvcHRpbWlzdGljVXBkYXRlSWQsIGNyZWF0ZVB1YmxpY0Vycm9yKSB7XG4gICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgIClcbiAgICB9KSk7XG4gICAgaWYgKGlubmVyRXJyb3IgaW5zdGFuY2VvZiBDb21tZW50c0FwaUVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGhhbmRsZUFwaUVycm9yKGlubmVyRXJyb3IpO1xuICAgICAgY29tbWVudHNFcnJvckV2ZW50U291cmNlLm5vdGlmeShjcmVhdGVQdWJsaWNFcnJvcihlcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5uZXJFcnJvciBpbnN0YW5jZW9mIE5vdGlmaWNhdGlvbnNBcGlFcnJvcikge1xuICAgICAgaGFuZGxlQXBpRXJyb3IoaW5uZXJFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGlubmVyRXJyb3I7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdG9yZSxcbiAgICBpbmNyZW1lbnRRdWVyeVN1YnNjcmliZXJzLFxuICAgIGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZSxcbiAgICBnZXRUaHJlYWRzVXBkYXRlcyxcbiAgICBnZXRUaHJlYWRzQW5kSW5ib3hOb3RpZmljYXRpb25zLFxuICAgIGdldEluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgb25NdXRhdGlvbkZhaWx1cmVcbiAgfTtcbn1cbnZhciBSb29tQ29udGV4dCA9IFJlYWN0NC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gbWFrZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCkge1xuICBmdW5jdGlvbiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyKHByb3BzKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChMaXZlYmxvY2tzUHJvdmlkZXJXaXRoQ2xpZW50LCB7IGNsaWVudCwgYWxsb3dOZXN0aW5nOiB0cnVlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSb29tUHJvdmlkZXIsIHsgLi4ucHJvcHMgfSkpO1xuICB9XG4gIGNvbnN0IHNoYXJlZCA9IGNyZWF0ZVNoYXJlZENvbnRleHQoY2xpZW50KTtcbiAgY29uc3QgYnVuZGxlID0ge1xuICAgIFJvb21Db250ZXh0LFxuICAgIFJvb21Qcm92aWRlcjogUm9vbVByb3ZpZGVyX3dpdGhJbXBsaWNpdExpdmVibG9ja3NQcm92aWRlcixcbiAgICB1c2VSb29tLFxuICAgIHVzZVN0YXR1cyxcbiAgICB1c2VTdG9yYWdlU3RhdHVzLFxuICAgIHVzZUJhdGNoLFxuICAgIHVzZUJyb2FkY2FzdEV2ZW50LFxuICAgIHVzZU90aGVyc0xpc3RlbmVyLFxuICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgIHVzZUhpc3RvcnksXG4gICAgdXNlVW5kbyxcbiAgICB1c2VSZWRvLFxuICAgIHVzZUNhblJlZG8sXG4gICAgdXNlQ2FuVW5kbyxcbiAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICB1c2VTdG9yYWdlLFxuICAgIHVzZVNlbGYsXG4gICAgdXNlTXlQcmVzZW5jZSxcbiAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgIHVzZU90aGVycyxcbiAgICB1c2VPdGhlcnNNYXBwZWQsXG4gICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkcyxcbiAgICB1c2VPdGhlcixcbiAgICB1c2VNdXRhdGlvbixcbiAgICB1c2VUaHJlYWRzLFxuICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICB1c2VEZWxldGVUaHJlYWQsXG4gICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgIHVzZU1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICB1c2VFZGl0Q29tbWVudCxcbiAgICB1c2VEZWxldGVDb21tZW50LFxuICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgIHVzZU1hcmtUaHJlYWRBc1JlYWQsXG4gICAgdXNlVGhyZWFkU3Vic2NyaXB0aW9uLFxuICAgIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgLi4uc2hhcmVkLmNsYXNzaWMsXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIFJvb21Db250ZXh0LFxuICAgICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICAgICAgdXNlUm9vbSxcbiAgICAgIHVzZVN0YXR1cyxcbiAgICAgIHVzZVN0b3JhZ2VTdGF0dXM6IHVzZVN0b3JhZ2VTdGF0dXNTdXNwZW5zZSxcbiAgICAgIHVzZUJhdGNoLFxuICAgICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICAgIHVzZUhpc3RvcnksXG4gICAgICB1c2VVbmRvLFxuICAgICAgdXNlUmVkbyxcbiAgICAgIHVzZUNhblJlZG8sXG4gICAgICB1c2VDYW5VbmRvLFxuICAgICAgdXNlU3RvcmFnZVJvb3QsXG4gICAgICB1c2VTdG9yYWdlOiB1c2VTdG9yYWdlU3VzcGVuc2UsXG4gICAgICB1c2VTZWxmOiB1c2VTZWxmU3VzcGVuc2UsXG4gICAgICB1c2VNeVByZXNlbmNlLFxuICAgICAgdXNlVXBkYXRlTXlQcmVzZW5jZSxcbiAgICAgIHVzZU90aGVyczogdXNlT3RoZXJzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNNYXBwZWQ6IHVzZU90aGVyc01hcHBlZFN1c3BlbnNlLFxuICAgICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkczogdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlLFxuICAgICAgdXNlT3RoZXI6IHVzZU90aGVyU3VzcGVuc2UsXG4gICAgICB1c2VNdXRhdGlvbixcbiAgICAgIHVzZVRocmVhZHM6IHVzZVRocmVhZHNTdXNwZW5zZSxcbiAgICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICAgIHVzZURlbGV0ZVRocmVhZCxcbiAgICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgICAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgICB1c2VFZGl0Q29tbWVudCxcbiAgICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgICB1c2VBZGRSZWFjdGlvbixcbiAgICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgICAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgICAgIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgICAgIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nczogdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UsXG4gICAgICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICAuLi5zaGFyZWQuc3VzcGVuc2VcbiAgICB9LFxuICAgIHVzZUNvbW1lbnRzRXJyb3JMaXN0ZW5lclxuICB9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1bmRsZSwga0ludGVybmFsMiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gUm9vbVByb3ZpZGVyKHByb3BzKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBbY2FjaGVdID0gUmVhY3Q0LnVzZVN0YXRlKFxuICAgICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgKTtcbiAgY29uc3Qgc3RhYmxlRW50ZXJSb29tID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChyb29tSWQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChyb29tSWQpO1xuICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgIGNvbnN0IHJ2ID0gY2xpZW50LmVudGVyUm9vbShyb29tSWQsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgb3JpZ0xlYXZlID0gcnYubGVhdmU7XG4gICAgICBydi5sZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgb3JpZ0xlYXZlKCk7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShyb29tSWQpO1xuICAgICAgfTtcbiAgICAgIGNhY2hlLnNldChyb29tSWQsIHJ2KTtcbiAgICAgIHJldHVybiBydjtcbiAgICB9LFxuICAgIFtjbGllbnQsIGNhY2hlXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFxuICAgIFJvb21Qcm92aWRlcklubmVyLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3RhYmxlRW50ZXJSb29tXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gUm9vbVByb3ZpZGVySW5uZXIocHJvcHMpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHsgaWQ6IHJvb21JZCwgc3RhYmxlRW50ZXJSb29tIH0gPSBwcm9wcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghcm9vbUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiUm9vbVByb3ZpZGVyIGlkIHByb3BlcnR5IGlzIHJlcXVpcmVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtcmVhY3QvUm9vbVByb3ZpZGVyLWlkLXByb3BlcnR5LWlzLXJlcXVpcmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygcm9vbUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgc2hvdWxkIGJlIGEgc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbWFqb3JSZWFjdFZlcnNpb24gPSBwYXJzZUludChSZWFjdDQudmVyc2lvbikgfHwgMTtcbiAgICBjb25zdCBvbGRSZWFjdFZlcnNpb24gPSBtYWpvclJlYWN0VmVyc2lvbiA8IDE4O1xuICAgIGVycm9ySWYoXG4gICAgICBvbGRSZWFjdFZlcnNpb24gJiYgcHJvcHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPT09IHZvaWQgMCxcbiAgICAgIG1pc3NpbmdfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMobWFqb3JSZWFjdFZlcnNpb24sIHJvb21JZClcbiAgICApO1xuICAgIGRlcHJlY2F0ZUlmKFxuICAgICAgIW9sZFJlYWN0VmVyc2lvbiAmJiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyAhPT0gdm9pZCAwLFxuICAgICAgc3VwZXJmbHVvdXNfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbiAgICApO1xuICB9XG4gIGNvbnN0IGZyb3plblByb3BzID0gdXNlSW5pdGlhbCh7XG4gICAgaW5pdGlhbFByZXNlbmNlOiBwcm9wcy5pbml0aWFsUHJlc2VuY2UsXG4gICAgaW5pdGlhbFN0b3JhZ2U6IHByb3BzLmluaXRpYWxTdG9yYWdlLFxuICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICBhdXRvQ29ubmVjdDogcHJvcHMuYXV0b0Nvbm5lY3QgPz8gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICB9KTtcbiAgY29uc3QgW3sgcm9vbSB9LCBzZXRSb29tTGVhdmVQYWlyXSA9IFJlYWN0NC51c2VTdGF0ZShcbiAgICAoKSA9PiBzdGFibGVFbnRlclJvb20ocm9vbUlkLCB7XG4gICAgICAuLi5mcm96ZW5Qcm9wcyxcbiAgICAgIGF1dG9Db25uZWN0OiBmYWxzZVxuICAgICAgLy8gRGVsaWJlcmF0ZWx5IHVzaW5nIGZhbHNlIGhlcmUgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlIGJlbG93XG4gICAgfSlcbiAgKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKSB7XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSBTZXJ2ZXJNc2dDb2RlLlRIUkVBRF9ERUxFVEVEKSB7XG4gICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZChtZXNzYWdlLnRocmVhZElkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHJvb21ba0ludGVybmFsMl0uY29tbWVudHMuZ2V0VGhyZWFkKHtcbiAgICAgICAgdGhyZWFkSWQ6IG1lc3NhZ2UudGhyZWFkSWRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZChtZXNzYWdlLnRocmVhZElkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdG9yZS5nZXQoKS50aHJlYWRzW21lc3NhZ2UudGhyZWFkSWRdO1xuICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfRURJVEVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuVEhSRUFEX01FVEFEQVRBX1VQREFURUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5USFJFQURfVVBEQVRFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfUkVBQ1RJT05fQURERUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0RFTEVURUQ6XG4gICAgICAgICAgaWYgKCFleGlzdGluZ1RocmVhZCkgYnJlYWs7XG4gICAgICAgICAgc3RvcmUudXBkYXRlVGhyZWFkQW5kTm90aWZpY2F0aW9uKHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9DUkVBVEVEOlxuICAgICAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZEFuZE5vdGlmaWNhdGlvbih0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvb20uZXZlbnRzLmNvbW1lbnRzLnN1YnNjcmliZShcbiAgICAgIChtZXNzYWdlKSA9PiB2b2lkIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKVxuICAgICk7XG4gIH0sIFtjbGllbnQsIHJvb21dKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBnZXRUaHJlYWRzVXBkYXRlcyB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICAgIHZvaWQgZ2V0VGhyZWFkc1VwZGF0ZXMocm9vbS5pZCk7XG4gIH0sIFtjbGllbnQsIHJvb20uaWRdKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gaGFuZGxlSXNPbmxpbmUoKSB7XG4gICAgICBjb25zdCB7IGdldFRocmVhZHNVcGRhdGVzIH0gPSBnZXRFeHRyYXNGb3JDbGllbnQyKGNsaWVudCk7XG4gICAgICB2b2lkIGdldFRocmVhZHNVcGRhdGVzKHJvb20uaWQpO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZUlzT25saW5lKTtcbiAgICB9O1xuICB9LCBbY2xpZW50LCByb29tLmlkXSk7XG4gIFJlYWN0NC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHBhaXIgPSBzdGFibGVFbnRlclJvb20ocm9vbUlkLCBmcm96ZW5Qcm9wcyk7XG4gICAgc2V0Um9vbUxlYXZlUGFpcihwYWlyKTtcbiAgICBjb25zdCB7IHJvb206IHJvb20yLCBsZWF2ZSB9ID0gcGFpcjtcbiAgICBpZiAoZnJvemVuUHJvcHMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIHJvb20yLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxlYXZlKCk7XG4gICAgfTtcbiAgfSwgW3Jvb21JZCwgZnJvemVuUHJvcHMsIHN0YWJsZUVudGVyUm9vbV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFJvb21Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByb29tIH0sIHByb3BzLmNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb20oKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tT3JOdWxsKCk7XG4gIGlmIChyb29tID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gIH1cbiAgcmV0dXJuIHJvb207XG59XG5mdW5jdGlvbiB1c2VTdGF0dXMoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xufVxuZnVuY3Rpb24gdXNlU3RvcmFnZVN0YXR1cyhvcHRpb25zKSB7XG4gIGNvbnN0IHNtb290aCA9IHVzZUluaXRpYWwob3B0aW9ucz8uc21vb3RoID8/IGZhbHNlKTtcbiAgaWYgKHNtb290aCkge1xuICAgIHJldHVybiB1c2VTdG9yYWdlU3RhdHVzU21vb3RoKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVzZVN0b3JhZ2VTdGF0dXNJbW1lZGlhdGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlU3RvcmFnZVN0YXR1c0ltbWVkaWF0ZSgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RvcmFnZVN0YXR1cy5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTdG9yYWdlU3RhdHVzO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IHJvb20uZ2V0U3RvcmFnZVN0YXR1cztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3RhdHVzU21vb3RoKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gUmVhY3Q0LnVzZVN0YXRlKHJvb20uZ2V0U3RvcmFnZVN0YXR1cyk7XG4gIGNvbnN0IG9sZFN0YXR1cyA9IHVzZUxhdGVzdChyb29tLmdldFN0b3JhZ2VTdGF0dXMoKSk7XG4gIFJlYWN0NC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3QgdW5zdWIgPSByb29tLmV2ZW50cy5zdG9yYWdlU3RhdHVzLnN1YnNjcmliZSgobmV3U3RhdHVzKSA9PiB7XG4gICAgICBpZiAob2xkU3RhdHVzLmN1cnJlbnQgPT09IFwic3luY2hyb25pemluZ1wiICYmIG5ld1N0YXR1cyA9PT0gXCJzeW5jaHJvbml6ZWRcIikge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHNldFN0YXR1cyhuZXdTdGF0dXMpLCBTTU9PVEhfREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHNldFN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHVuc3ViKCk7XG4gICAgfTtcbiAgfSwgW3Jvb20sIG9sZFN0YXR1c10pO1xuICByZXR1cm4gc3RhdHVzO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2goKSB7XG4gIHJldHVybiB1c2VSb29tKCkuYmF0Y2g7XG59XG5mdW5jdGlvbiB1c2VCcm9hZGNhc3RFdmVudCgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQsIG9wdGlvbnMgPSB7IHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZSB9KSA9PiB7XG4gICAgICByb29tLmJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFtyb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gIFJlYWN0NC51c2VFZmZlY3QoXG4gICAgKCkgPT4gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudCkpLFxuICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdChcbiAgICAoKSA9PiByb29tLmV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudClcbiAgICApLFxuICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRXJyb3JMaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdChcbiAgICAoKSA9PiByb29tLmV2ZW50cy5lcnJvci5zdWJzY3JpYmUoKGUpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChlKSksXG4gICAgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VFdmVudExpc3RlbmVyKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudERhdGEpID0+IHtcbiAgICAgIHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudERhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShsaXN0ZW5lcik7XG4gIH0sIFtyb29tLCBzYXZlZENhbGxiYWNrXSk7XG59XG5mdW5jdGlvbiB1c2VIaXN0b3J5KCkge1xuICByZXR1cm4gdXNlUm9vbSgpLmhpc3Rvcnk7XG59XG5mdW5jdGlvbiB1c2VVbmRvKCkge1xuICByZXR1cm4gdXNlSGlzdG9yeSgpLnVuZG87XG59XG5mdW5jdGlvbiB1c2VSZWRvKCkge1xuICByZXR1cm4gdXNlSGlzdG9yeSgpLnJlZG87XG59XG5mdW5jdGlvbiB1c2VDYW5VbmRvKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZTtcbiAgY29uc3QgY2FuVW5kbyA9IHJvb20uaGlzdG9yeS5jYW5VbmRvO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZSwgY2FuVW5kbywgY2FuVW5kbyk7XG59XG5mdW5jdGlvbiB1c2VDYW5SZWRvKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZTtcbiAgY29uc3QgY2FuUmVkbyA9IHJvb20uaGlzdG9yeS5jYW5SZWRvO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZSwgY2FuUmVkbywgY2FuUmVkbyk7XG59XG5mdW5jdGlvbiB1c2VTZWxmKG1heWJlU2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTZWxmO1xuICBjb25zdCBzZWxlY3RvciA9IG1heWJlU2VsZWN0b3IgPz8gaWRlbnRpdHk7XG4gIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAobWUpID0+IG1lICE9PSBudWxsID8gc2VsZWN0b3IobWUpIDogbnVsbCxcbiAgICBbc2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU15UHJlc2VuY2UoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLm15UHJlc2VuY2Uuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0UHJlc2VuY2U7XG4gIGNvbnN0IHByZXNlbmNlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNuYXBzaG90KTtcbiAgY29uc3Qgc2V0UHJlc2VuY2UgPSByb29tLnVwZGF0ZVByZXNlbmNlO1xuICByZXR1cm4gW3ByZXNlbmNlLCBzZXRQcmVzZW5jZV07XG59XG5mdW5jdGlvbiB1c2VVcGRhdGVNeVByZXNlbmNlKCkge1xuICByZXR1cm4gdXNlUm9vbSgpLnVwZGF0ZVByZXNlbmNlO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRPdGhlcnM7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzRW1wdHlMaXN0O1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTbmFwc2hvdCxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICBzZWxlY3RvciA/PyBpZGVudGl0eSxcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNNYXBwZWQoaXRlbVNlbGVjdG9yLCBpdGVtSXNFcXVhbCkge1xuICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKG90aGVycykgPT4gb3RoZXJzLm1hcCgob3RoZXIpID0+IFtvdGhlci5jb25uZWN0aW9uSWQsIGl0ZW1TZWxlY3RvcihvdGhlcildKSxcbiAgICBbaXRlbVNlbGVjdG9yXVxuICApO1xuICBjb25zdCB3cmFwcGVkSXNFcXVhbCA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoYSwgYikgPT4ge1xuICAgICAgY29uc3QgZXEgPSBpdGVtSXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGF0dXBsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgYnR1cGxlID0gYltpbmRleF07XG4gICAgICAgIHJldHVybiBhdHVwbGVbMF0gPT09IGJ0dXBsZVswXSAmJiBlcShhdHVwbGVbMV0sIGJ0dXBsZVsxXSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtpdGVtSXNFcXVhbF1cbiAgKTtcbiAgcmV0dXJuIHVzZU90aGVycyh3cmFwcGVkU2VsZWN0b3IsIHdyYXBwZWRJc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMoKSB7XG4gIHJldHVybiB1c2VPdGhlcnMoc2VsZWN0b3JGb3JfdXNlT3RoZXJzQ29ubmVjdGlvbklkcywgc2hhbGxvdzIpO1xufVxudmFyIE5PVF9GT1VORCA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gdXNlT3RoZXIoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKG90aGVycykgPT4ge1xuICAgICAgY29uc3Qgb3RoZXIyID0gb3RoZXJzLmZpbmQoKG90aGVyMykgPT4gb3RoZXIzLmNvbm5lY3Rpb25JZCA9PT0gY29ubmVjdGlvbklkKTtcbiAgICAgIHJldHVybiBvdGhlcjIgIT09IHZvaWQgMCA/IHNlbGVjdG9yKG90aGVyMikgOiBOT1RfRk9VTkQ7XG4gICAgfSxcbiAgICBbY29ubmVjdGlvbklkLCBzZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3Qgd3JhcHBlZElzRXF1YWwgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHByZXYsIGN1cnIpID0+IHtcbiAgICAgIGlmIChwcmV2ID09PSBOT1RfRk9VTkQgfHwgY3VyciA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICAgIHJldHVybiBwcmV2ID09PSBjdXJyO1xuICAgICAgfVxuICAgICAgY29uc3QgZXEgPSBpc0VxdWFsID8/IE9iamVjdC5pcztcbiAgICAgIHJldHVybiBlcShwcmV2LCBjdXJyKTtcbiAgICB9LFxuICAgIFtpc0VxdWFsXVxuICApO1xuICBjb25zdCBvdGhlciA9IHVzZU90aGVycyh3cmFwcGVkU2VsZWN0b3IsIHdyYXBwZWRJc0VxdWFsKTtcbiAgaWYgKG90aGVyID09PSBOT1RfRk9VTkQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTm8gc3VjaCBvdGhlciB1c2VyIHdpdGggY29ubmVjdGlvbiBpZCAke2Nvbm5lY3Rpb25JZH0gZXhpc3RzYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG90aGVyO1xufVxuZnVuY3Rpb24gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zdG9yYWdlRGlkTG9hZC5zdWJzY3JpYmVPbmNlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90O1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xufVxuZnVuY3Rpb24gdXNlU3RvcmFnZVJvb3QoKSB7XG4gIHJldHVybiBbdXNlTXV0YWJsZVN0b3JhZ2VSb290KCldO1xufVxuZnVuY3Rpb24gdXNlU3RvcmFnZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCByb290T3JOdWxsID0gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCk7XG4gIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAocm9vdE9yTnVsbDIpID0+IHJvb3RPck51bGwyICE9PSBudWxsID8gc2VsZWN0b3Iocm9vdE9yTnVsbDIpIDogbnVsbCxcbiAgICBbc2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAob25TdG9yZUNoYW5nZSkgPT4gcm9vdE9yTnVsbCAhPT0gbnVsbCA/IHJvb20uc3Vic2NyaWJlKHJvb3RPck51bGwsIG9uU3RvcmVDaGFuZ2UsIHsgaXNEZWVwOiB0cnVlIH0pIDogbm9vcDIsXG4gICAgW3Jvb20sIHJvb3RPck51bGxdXG4gICk7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gUmVhY3Q0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvb3QgPSByb290T3JOdWxsO1xuICAgICAgY29uc3QgaW1tID0gcm9vdC50b0ltbXV0YWJsZSgpO1xuICAgICAgcmV0dXJuIGltbTtcbiAgICB9XG4gIH0sIFtyb290T3JOdWxsXSk7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU11dGF0aW9uKGNhbGxiYWNrLCBkZXBzKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlTWVtbyhcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJvb20uYmF0Y2goXG4gICAgICAgICAgKCkgPT4gKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSxcbiAgICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbcm9vbSwgLi4uZGVwc11cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZHMob3B0aW9ucyA9IHtcbiAgcXVlcnk6IHsgbWV0YWRhdGE6IHt9IH1cbn0pIHtcbiAgY29uc3QgeyBzY3JvbGxPbkxvYWQgPSB0cnVlIH0gPSBvcHRpb25zO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgcXVlcnlLZXkgPSBSZWFjdDQudXNlTWVtbyhcbiAgICAoKSA9PiBnZW5lcmF0ZVF1ZXJ5S2V5KHJvb20uaWQsIG9wdGlvbnMucXVlcnkpLFxuICAgIFtyb29tLCBvcHRpb25zXVxuICApO1xuICBjb25zdCB7IHN0b3JlLCBnZXRUaHJlYWRzQW5kSW5ib3hOb3RpZmljYXRpb25zLCBpbmNyZW1lbnRRdWVyeVN1YnNjcmliZXJzIH0gPSBnZXRFeHRyYXNGb3JDbGllbnQyKGNsaWVudCk7XG4gIFJlYWN0NC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZvaWQgZ2V0VGhyZWFkc0FuZEluYm94Tm90aWZpY2F0aW9ucyhyb29tLCBxdWVyeUtleSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGluY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMocXVlcnlLZXkpO1xuICB9LCBbcm9vbSwgcXVlcnlLZXldKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHN0YXRlMikgPT4ge1xuICAgICAgY29uc3QgcXVlcnkgPSBzdGF0ZTIucXVlcmllc1txdWVyeUtleV07XG4gICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IHNlbGVjdGVkVGhyZWFkcyhyb29tLmlkLCBzdGF0ZTIsIG9wdGlvbnMpLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogcXVlcnkuZXJyb3JcbiAgICAgIH07XG4gICAgfSxcbiAgICBbcm9vbSwgcXVlcnlLZXldXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgKTtcbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgIHN0b3JlLmdldCxcbiAgICBzdG9yZS5nZXQsXG4gICAgc2VsZWN0b3JcbiAgKTtcbiAgdXNlU2Nyb2xsVG9Db21tZW50T25Mb2FkRWZmZWN0KHNjcm9sbE9uTG9hZCwgc3RhdGUpO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VDb21tZW50c0Vycm9yTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICBjb25zdCB7IGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZSB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gY29tbWVudHNFcnJvckV2ZW50U291cmNlLnN1YnNjcmliZShzYXZlZENhbGxiYWNrLmN1cnJlbnQpO1xuICB9LCBbc2F2ZWRDYWxsYmFjaywgY29tbWVudHNFcnJvckV2ZW50U291cmNlXSk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVUaHJlYWQoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhID8/IHt9O1xuICAgICAgY29uc3QgdGhyZWFkSWQgPSBjcmVhdGVUaHJlYWRJZCgpO1xuICAgICAgY29uc3QgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG5ld0NvbW1lbnQgPSB7XG4gICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIHVzZXJJZDogZ2V0Q3VycmVudFVzZXJJZChyb29tKSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgcmVhY3Rpb25zOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG5ld1RocmVhZCA9IHtcbiAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICB0eXBlOiBcInRocmVhZFwiLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIHVwZGF0ZWRBdDogY3JlYXRlZEF0LFxuICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBjb21tZW50czogW25ld0NvbW1lbnRdLFxuICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQzKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImNyZWF0ZS10aHJlYWRcIixcbiAgICAgICAgdGhyZWFkOiBuZXdUaHJlYWQsXG4gICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBjb21tZW50c0FQSSA9IHJvb21ba0ludGVybmFsMl0uY29tbWVudHM7XG4gICAgICBjb21tZW50c0FQSS5jcmVhdGVUaHJlYWQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBtZXRhZGF0YSB9KS50aGVuKFxuICAgICAgICAodGhyZWFkKSA9PiB7XG4gICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICBbdGhyZWFkSWRdOiB0aHJlYWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyMikgPT4gbmV3IENyZWF0ZVRocmVhZEVycm9yKGVycjIsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdUaHJlYWQ7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlVGhyZWFkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDMoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRFeHRyYXNGb3JDbGllbnQyKGNsaWVudCk7XG4gICAgICBjb25zdCB0aHJlYWQgPSBzdG9yZS5nZXQoKS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQocm9vbSk7XG4gICAgICBpZiAodGhyZWFkPy5jb21tZW50cz8uWzBdPy51c2VySWQgIT09IHVzZXJJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHRoZSB0aHJlYWQgY3JlYXRvciBjYW4gZGVsZXRlIHRoZSB0aHJlYWRcIik7XG4gICAgICB9XG4gICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLXRocmVhZFwiLFxuICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBkZWxldGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNvbW1lbnRzQVBJID0gcm9vbVtrSW50ZXJuYWwyXS5jb21tZW50cztcbiAgICAgIGNvbW1lbnRzQVBJLmRlbGV0ZVRocmVhZCh7IHRocmVhZElkIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IHtcbiAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nVGhyZWFkLFxuICAgICAgICAgICAgICAgICAgdXBkYXRlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyMikgPT4gbmV3IERlbGV0ZVRocmVhZEVycm9yKGVycjIsIHsgcm9vbUlkOiByb29tLmlkLCB0aHJlYWRJZCB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmICghb3B0aW9ucy5tZXRhZGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0aHJlYWRJZCA9IG9wdGlvbnMudGhyZWFkSWQ7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IG9wdGlvbnMubWV0YWRhdGE7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDMoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRFeHRyYXNGb3JDbGllbnQyKGNsaWVudCk7XG4gICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiZWRpdC10aHJlYWQtbWV0YWRhdGFcIixcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICB1cGRhdGVkQXRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY29tbWVudHNBUEkgPSByb29tW2tJbnRlcm5hbDJdLmNvbW1lbnRzO1xuICAgICAgY29tbWVudHNBUEkuZWRpdFRocmVhZE1ldGFkYXRhKHsgbWV0YWRhdGEsIHRocmVhZElkIH0pLnRoZW4oXG4gICAgICAgIChtZXRhZGF0YTIpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkLnVwZGF0ZWRBdCAmJiBleGlzdGluZ1RocmVhZC51cGRhdGVkQXQgPiB1cGRhdGVkQXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgW3RocmVhZElkXToge1xuICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdUaHJlYWQsXG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnJvcikgPT4gbmV3IEVkaXRUaHJlYWRNZXRhZGF0YUVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVDb21tZW50KCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoeyB0aHJlYWRJZCwgYm9keSB9KSA9PiB7XG4gICAgICBjb25zdCBjb21tZW50SWQgPSBjcmVhdGVDb21tZW50SWQoKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgdXNlcklkOiBnZXRDdXJyZW50VXNlcklkKHJvb20pLFxuICAgICAgICBib2R5LFxuICAgICAgICByZWFjdGlvbnM6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMygpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldEV4dHJhc0ZvckNsaWVudDIoY2xpZW50KTtcbiAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJjcmVhdGUtY29tbWVudFwiLFxuICAgICAgICBjb21tZW50LFxuICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICB9KTtcbiAgICAgIHJvb21ba0ludGVybmFsMl0uY29tbWVudHMuY3JlYXRlQ29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHkgfSkudGhlbihcbiAgICAgICAgKG5ld0NvbW1lbnQpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKFxuICAgICAgICAgICAgICBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgICAgICkuZmluZChcbiAgICAgICAgICAgICAgKG5vdGlmaWNhdGlvbikgPT4gbm90aWZpY2F0aW9uLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgbm90aWZpY2F0aW9uLnRocmVhZElkID09PSB0aHJlYWRJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMgPSBpbmJveE5vdGlmaWNhdGlvbiAhPT0gdm9pZCAwID8ge1xuICAgICAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICAgIFtpbmJveE5vdGlmaWNhdGlvbi5pZF06IHtcbiAgICAgICAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICAgICAgICBub3RpZmllZEF0OiBuZXdDb21tZW50LmNyZWF0ZWRBdCxcbiAgICAgICAgICAgICAgICByZWFkQXQ6IG5ld0NvbW1lbnQuY3JlYXRlZEF0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgW3RocmVhZElkXTogdXBzZXJ0Q29tbWVudChleGlzdGluZ1RocmVhZCwgbmV3Q29tbWVudClcbiAgICAgICAgICAgICAgICAvLyBVcHNlcnQgdGhlIG5ldyBjb21tZW50IGludG8gdGhlIHRocmVhZCBjb21tZW50cyBsaXN0IChpZiBhcHBsaWNhYmxlKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycjIpID0+IG5ldyBDcmVhdGVDb21tZW50RXJyb3IoZXJyMiwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRDb21tZW50KCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5IH0pID0+IHtcbiAgICAgIGNvbnN0IGVkaXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQzKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICAgICAgY29uc3QgdGhyZWFkID0gc3RvcmUuZ2V0KCkudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZTIud2FybihcbiAgICAgICAgICBgSW50ZXJuYWwgdW5leHBlY3RlZCBiZWhhdmlvci4gQ2Fubm90IGVkaXQgY29tbWVudCBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIHRocmVhZCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGUuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgICAgIChjb21tZW50MikgPT4gY29tbWVudDIuaWQgPT09IGNvbW1lbnRJZFxuICAgICAgKTtcbiAgICAgIGlmIChjb21tZW50ID09PSB2b2lkIDAgfHwgY29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlMi53YXJuKFxuICAgICAgICAgIGBJbnRlcm5hbCB1bmV4cGVjdGVkIGJlaGF2aW9yLiBDYW5ub3QgZWRpdCBjb21tZW50IFwiJHtjb21tZW50SWR9XCIgaW4gdGhyZWFkIFwiJHt0aHJlYWRJZH1cIiBiZWNhdXNlIHRoZSBjb21tZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZS5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJlZGl0LWNvbW1lbnRcIixcbiAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgIC4uLmNvbW1lbnQsXG4gICAgICAgICAgZWRpdGVkQXQsXG4gICAgICAgICAgYm9keVxuICAgICAgICB9LFxuICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICB9KTtcbiAgICAgIHJvb21ba0ludGVybmFsMl0uY29tbWVudHMuZWRpdENvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5IH0pLnRoZW4oXG4gICAgICAgIChlZGl0ZWRDb21tZW50KSA9PiB7XG4gICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlcyA9IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICB0aHJlYWRzOiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICAgICAgICBbdGhyZWFkSWRdOiB1cHNlcnRDb21tZW50KGV4aXN0aW5nVGhyZWFkLCBlZGl0ZWRDb21tZW50KVxuICAgICAgICAgICAgICAgIC8vIFVwc2VydCB0aGUgZWRpdGVkIGNvbW1lbnQgaW50byB0aGUgdGhyZWFkIGNvbW1lbnRzIGxpc3QgKGlmIGFwcGxpY2FibGUpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgRWRpdENvbW1lbnRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVDb21tZW50KCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkIH0pID0+IHtcbiAgICAgIGNvbnN0IGRlbGV0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMygpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldEV4dHJhc0ZvckNsaWVudDIoY2xpZW50KTtcbiAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJkZWxldGUtY29tbWVudFwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICBkZWxldGVkQXQsXG4gICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZFxuICAgICAgfSk7XG4gICAgICByb29tW2tJbnRlcm5hbDJdLmNvbW1lbnRzLmRlbGV0ZUNvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IGRlbGV0ZUNvbW1lbnQoZXhpc3RpbmdUaHJlYWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnJvcikgPT4gbmV3IERlbGV0ZUNvbW1lbnRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUFkZFJlYWN0aW9uKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSA9PiB7XG4gICAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQocm9vbSk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQzKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImFkZC1yZWFjdGlvblwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICByZWFjdGlvbjoge1xuICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgfSk7XG4gICAgICByb29tW2tJbnRlcm5hbDJdLmNvbW1lbnRzLmFkZFJlYWN0aW9uKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkudGhlbihcbiAgICAgICAgKGFkZGVkUmVhY3Rpb24pID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IGFkZFJlYWN0aW9uKFxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUaHJlYWQsXG4gICAgICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgICAgICBhZGRlZFJlYWN0aW9uXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnJvcikgPT4gbmV3IEFkZFJlYWN0aW9uRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJlbW92ZVJlYWN0aW9uKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgY29uc3QgcmVtb3ZlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQzKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcInJlbW92ZS1yZWFjdGlvblwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICBlbW9qaSxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICByZW1vdmVkQXQsXG4gICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgIH0pO1xuICAgICAgcm9vbVtrSW50ZXJuYWwyXS5jb21tZW50cy5yZW1vdmVSZWFjdGlvbih7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IHJlbW92ZVJlYWN0aW9uKFxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUaHJlYWQsXG4gICAgICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAgICAgICAgIHJlbW92ZWRBdFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBSZW1vdmVSZWFjdGlvbkVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGVtb2ppXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrVGhyZWFkQXNSZWFkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRFeHRyYXNGb3JDbGllbnQyKGNsaWVudCk7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMoXG4gICAgICAgIHN0b3JlLmdldCgpLmluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgKS5maW5kKFxuICAgICAgICAoaW5ib3hOb3RpZmljYXRpb24yKSA9PiBpbmJveE5vdGlmaWNhdGlvbjIua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBpbmJveE5vdGlmaWNhdGlvbjIudGhyZWFkSWQgPT09IHRocmVhZElkXG4gICAgICApO1xuICAgICAgaWYgKCFpbmJveE5vdGlmaWNhdGlvbikgcmV0dXJuO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMygpO1xuICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiLFxuICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkOiBpbmJveE5vdGlmaWNhdGlvbi5pZCxcbiAgICAgICAgcmVhZEF0OiBub3dcbiAgICAgIH0pO1xuICAgICAgcm9vbVtrSW50ZXJuYWwyXS5ub3RpZmljYXRpb25zLm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbi5pZCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICAgIFtpbmJveE5vdGlmaWNhdGlvbi5pZF06IHtcbiAgICAgICAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICAgICAgICByZWFkQXQ6IG5vd1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChlcnJvcikgPT4gbmV3IE1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQ6IGluYm94Tm90aWZpY2F0aW9uLmlkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDMoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldEV4dHJhc0ZvckNsaWVudDIoY2xpZW50KTtcbiAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLXRocmVhZC1hcy1yZXNvbHZlZFwiLFxuICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgdXBkYXRlZEF0XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNvbW1lbnRzQVBJID0gcm9vbVtrSW50ZXJuYWwyXS5jb21tZW50cztcbiAgICAgIGNvbW1lbnRzQVBJLm1hcmtUaHJlYWRBc1Jlc29sdmVkKHsgdGhyZWFkSWQgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXMgPSBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQudXBkYXRlZEF0ICYmIGV4aXN0aW5nVGhyZWFkLnVwZGF0ZWRBdCA+IHVwZGF0ZWRBdCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICB0aHJlYWRzOiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICAgICAgICBbdGhyZWFkSWRdOiB7XG4gICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ1RocmVhZCxcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnJvcikgPT4gbmV3IE1hcmtUaHJlYWRBc1Jlc29sdmVkRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrVGhyZWFkQXNVbnJlc29sdmVkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDMoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldEV4dHJhc0ZvckNsaWVudDIoY2xpZW50KTtcbiAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLXRocmVhZC1hcy11bnJlc29sdmVkXCIsXG4gICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICB1cGRhdGVkQXRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY29tbWVudHNBUEkgPSByb29tW2tJbnRlcm5hbDJdLmNvbW1lbnRzO1xuICAgICAgY29tbWVudHNBUEkubWFya1RocmVhZEFzVW5yZXNvbHZlZCh7IHRocmVhZElkIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkLnVwZGF0ZWRBdCAmJiBleGlzdGluZ1RocmVhZC51cGRhdGVkQXQgPiB1cGRhdGVkQXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgW3RocmVhZElkXToge1xuICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdUaHJlYWQsXG4gICAgICAgICAgICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgTWFya1RocmVhZEFzVW5yZXNvbHZlZEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlVGhyZWFkU3Vic2NyaXB0aW9uKHRocmVhZElkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRFeHRyYXNGb3JDbGllbnQyKGNsaWVudCk7XG4gIGNvbnN0IHNlbGVjdG9yID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyhzdGF0ZSkuZmluZChcbiAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uMikgPT4gaW5ib3hOb3RpZmljYXRpb24yLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgaW5ib3hOb3RpZmljYXRpb24yLnRocmVhZElkID09PSB0aHJlYWRJZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDAgfHwgdGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IFwibm90LXN1YnNjcmliZWRcIlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcInN1YnNjcmliZWRcIixcbiAgICAgICAgdW5yZWFkU2luY2U6IGluYm94Tm90aWZpY2F0aW9uLnJlYWRBdFxuICAgICAgfTtcbiAgICB9LFxuICAgIFt0aHJlYWRJZF1cbiAgKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgc3RvcmUuZ2V0LFxuICAgIHN0b3JlLmdldCxcbiAgICBzZWxlY3RvclxuICApO1xufVxuZnVuY3Rpb24gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IGdldEluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3MgfSA9IGdldEV4dHJhc0ZvckNsaWVudDIoY2xpZW50KTtcbiAgICBjb25zdCBxdWVyeUtleSA9IG1ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb20uaWQpO1xuICAgIHZvaWQgZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLCBxdWVyeUtleSk7XG4gIH0sIFtjbGllbnQsIHJvb21dKTtcbiAgY29uc3QgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzID0gdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gIGNvbnN0IHNlbGVjdG9yID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgcXVlcnkgPSBzdGF0ZS5xdWVyaWVzW21ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb20uaWQpXTtcbiAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgICByZXR1cm4geyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgICAgIH1cbiAgICAgIGlmIChxdWVyeS5lcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IGlzTG9hZGluZzogZmFsc2UsIGVycm9yOiBxdWVyeS5lcnJvciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgc2V0dGluZ3M6IHNlbGVjdE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20uaWQsIHN0YXRlKVxuICAgICAgfTtcbiAgICB9LFxuICAgIFtyb29tXVxuICApO1xuICBjb25zdCBzZXR0aW5ncyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgc3RvcmUuZ2V0LFxuICAgIHN0b3JlLmdldCxcbiAgICBzZWxlY3RvclxuICApO1xuICByZXR1cm4gUmVhY3Q0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc107XG4gIH0sIFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXSk7XG59XG5mdW5jdGlvbiB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChzZXR0aW5ncykgPT4ge1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMygpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldEV4dHJhc0ZvckNsaWVudDIoY2xpZW50KTtcbiAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgdHlwZTogXCJ1cGRhdGUtbm90aWZpY2F0aW9uLXNldHRpbmdzXCIsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgc2V0dGluZ3NcbiAgICAgIH0pO1xuICAgICAgcm9vbVtrSW50ZXJuYWwyXS5ub3RpZmljYXRpb25zLnVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykudGhlbihcbiAgICAgICAgKHNldHRpbmdzMikgPT4ge1xuICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvblNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIFtyb29tLmlkXTogc2V0dGluZ3MyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCB1c2UgdGhlIFN1c3BlbnNlIHZlcnNpb24gb2YgdGhpcyBob29rIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCB0aGVtIG9uIHRoZSBjbGllbnQgc2lkZS5cXG5Gb3IgdGlwcywgc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1yZWFjdCNzdXNwZW5zZS1hdm9pZC1zc3JcIlxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgdXNlKHJvb20ud2FpdFVudGlsUHJlc2VuY2VSZWFkeSgpKTtcbn1cbmZ1bmN0aW9uIHVzZVNlbGZTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VTZWxmKFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc1N1c3BlbnNlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVycyhcbiAgICBzZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UoKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMoKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc01hcHBlZFN1c3BlbnNlKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VSZWFkeSgpO1xuICByZXR1cm4gdXNlT3RoZXJzTWFwcGVkKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJTdXNwZW5zZShjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVyKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpO1xufVxuZnVuY3Rpb24gdXNlU3VzcGVuZFVudGlsU3RvcmFnZVJlYWR5KCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHVzZShyb29tLndhaXRVbnRpbFN0b3JhZ2VSZWFkeSgpKTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxTdG9yYWdlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZVN0b3JhZ2UoXG4gICAgc2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlU3RvcmFnZVN0YXR1c1N1c3BlbnNlKG9wdGlvbnMpIHtcbiAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZVJlYWR5KCk7XG4gIHJldHVybiB1c2VTdG9yYWdlU3RhdHVzKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdXNlVGhyZWFkc1N1c3BlbnNlKG9wdGlvbnMgPSB7XG4gIHF1ZXJ5OiB7IG1ldGFkYXRhOiB7fSB9XG59KSB7XG4gIGNvbnN0IHsgc2Nyb2xsT25Mb2FkID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHF1ZXJ5S2V5ID0gUmVhY3Q0LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2VuZXJhdGVRdWVyeUtleShyb29tLmlkLCBvcHRpb25zLnF1ZXJ5KSxcbiAgICBbcm9vbSwgb3B0aW9uc11cbiAgKTtcbiAgY29uc3QgeyBzdG9yZSwgZ2V0VGhyZWFkc0FuZEluYm94Tm90aWZpY2F0aW9ucyB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICBjb25zdCBxdWVyeSA9IHN0b3JlLmdldCgpLnF1ZXJpZXNbcXVlcnlLZXldO1xuICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICB0aHJvdyBnZXRUaHJlYWRzQW5kSW5ib3hOb3RpZmljYXRpb25zKHJvb20sIHF1ZXJ5S2V5LCBvcHRpb25zKTtcbiAgfVxuICBpZiAocXVlcnkuZXJyb3IpIHtcbiAgICB0aHJvdyBxdWVyeS5lcnJvcjtcbiAgfVxuICBjb25zdCBzZWxlY3RvciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoc3RhdGUyKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiBzZWxlY3RlZFRocmVhZHMocm9vbS5pZCwgc3RhdGUyLCBvcHRpb25zKSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIFtyb29tLCBxdWVyeUtleV1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICApO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IGluY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMgfSA9IGdldEV4dHJhc0ZvckNsaWVudDIoY2xpZW50KTtcbiAgICByZXR1cm4gaW5jcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSk7XG4gIH0sIFtjbGllbnQsIHF1ZXJ5S2V5XSk7XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICBzdG9yZS5nZXQsXG4gICAgc3RvcmUuZ2V0LFxuICAgIHNlbGVjdG9yXG4gICk7XG4gIHVzZVNjcm9sbFRvQ29tbWVudE9uTG9hZEVmZmVjdChzY3JvbGxPbkxvYWQsIHN0YXRlKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UoKSB7XG4gIGNvbnN0IHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyA9IHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgcXVlcnlLZXkgPSBtYWtlTm90aWZpY2F0aW9uU2V0dGluZ3NRdWVyeUtleShyb29tLmlkKTtcbiAgY29uc3QgeyBzdG9yZSwgZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyB9ID0gZ2V0RXh0cmFzRm9yQ2xpZW50MihjbGllbnQpO1xuICBjb25zdCBxdWVyeSA9IHN0b3JlLmdldCgpLnF1ZXJpZXNbcXVlcnlLZXldO1xuICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICB0aHJvdyBnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20sIHF1ZXJ5S2V5KTtcbiAgfVxuICBpZiAocXVlcnkuZXJyb3IpIHtcbiAgICB0aHJvdyBxdWVyeS5lcnJvcjtcbiAgfVxuICBjb25zdCBzZWxlY3RvciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoc3RhdGUpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIHNldHRpbmdzOiBzZWxlY3ROb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLmlkLCBzdGF0ZSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBbcm9vbV1cbiAgKTtcbiAgY29uc3Qgc2V0dGluZ3MgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgIHN0b3JlLmdldCxcbiAgICBzdG9yZS5nZXQsXG4gICAgc2VsZWN0b3JcbiAgKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICB9LCBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc10pO1xufVxuZnVuY3Rpb24gdXNlUm9vbU9yTnVsbCgpIHtcbiAgcmV0dXJuIFJlYWN0NC51c2VDb250ZXh0KFJvb21Db250ZXh0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb21Db250ZXh0KGNsaWVudCkge1xuICByZXR1cm4gZ2V0T3JDcmVhdGVSb29tQ29udGV4dEJ1bmRsZShjbGllbnQpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVRdWVyeUtleShyb29tSWQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGAke3Jvb21JZH0tJHtzdHJpbmdpZnkob3B0aW9ucyA/PyB7fSl9YDtcbn1cbnZhciBfUm9vbVByb3ZpZGVyID0gUm9vbVByb3ZpZGVyO1xudmFyIF91c2VCcm9hZGNhc3RFdmVudCA9IHVzZUJyb2FkY2FzdEV2ZW50O1xudmFyIF91c2VPdGhlcnNMaXN0ZW5lciA9IHVzZU90aGVyc0xpc3RlbmVyO1xudmFyIF91c2VSb29tID0gdXNlUm9vbTtcbnZhciBfdXNlQWRkUmVhY3Rpb24gPSB1c2VBZGRSZWFjdGlvbjtcbnZhciBfdXNlTXV0YXRpb24gPSB1c2VNdXRhdGlvbjtcbnZhciBfdXNlQ3JlYXRlVGhyZWFkID0gdXNlQ3JlYXRlVGhyZWFkO1xudmFyIF91c2VEZWxldGVUaHJlYWQgPSB1c2VEZWxldGVUaHJlYWQ7XG52YXIgX3VzZUVkaXRUaHJlYWRNZXRhZGF0YSA9IHVzZUVkaXRUaHJlYWRNZXRhZGF0YTtcbnZhciBfdXNlRXZlbnRMaXN0ZW5lciA9IHVzZUV2ZW50TGlzdGVuZXI7XG52YXIgX3VzZU15UHJlc2VuY2UgPSB1c2VNeVByZXNlbmNlO1xudmFyIF91c2VPdGhlcnNNYXBwZWQgPSB1c2VPdGhlcnNNYXBwZWQ7XG52YXIgX3VzZU90aGVyc01hcHBlZFN1c3BlbnNlID0gdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2U7XG52YXIgX3VzZVRocmVhZHMgPSB1c2VUaHJlYWRzO1xudmFyIF91c2VUaHJlYWRzU3VzcGVuc2UgPSB1c2VUaHJlYWRzU3VzcGVuc2U7XG52YXIgX3VzZU90aGVyID0gdXNlT3RoZXI7XG5mdW5jdGlvbiBfdXNlT3RoZXJzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHVzZU90aGVycyguLi5hcmdzKTtcbn1cbnZhciBfdXNlT3RoZXJTdXNwZW5zZSA9IHVzZU90aGVyU3VzcGVuc2U7XG5mdW5jdGlvbiBfdXNlT3RoZXJzU3VzcGVuc2UoLi4uYXJncykge1xuICByZXR1cm4gdXNlT3RoZXJzU3VzcGVuc2UoLi4uYXJncyk7XG59XG52YXIgX3VzZVN0b3JhZ2UgPSB1c2VTdG9yYWdlO1xudmFyIF91c2VTdG9yYWdlU3VzcGVuc2UgPSB1c2VTdG9yYWdlU3VzcGVuc2U7XG5mdW5jdGlvbiBfdXNlU2VsZiguLi5hcmdzKSB7XG4gIHJldHVybiB1c2VTZWxmKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gX3VzZVNlbGZTdXNwZW5zZSguLi5hcmdzKSB7XG4gIHJldHVybiB1c2VTZWxmU3VzcGVuc2UoLi4uYXJncyk7XG59XG52YXIgX3VzZVN0b3JhZ2VSb290ID0gdXNlU3RvcmFnZVJvb3Q7XG52YXIgX3VzZVVwZGF0ZU15UHJlc2VuY2UgPSB1c2VVcGRhdGVNeVByZXNlbmNlO1xuXG5leHBvcnQge1xuICBQS0dfTkFNRSxcbiAgUEtHX1ZFUlNJT04sXG4gIFBLR19GT1JNQVQsXG4gIENsaWVudFNpZGVTdXNwZW5zZSxcbiAgQ2xpZW50Q29udGV4dCxcbiAgdXNlQ2xpZW50LFxuICBMaXZlYmxvY2tzUHJvdmlkZXIsXG4gIGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0LFxuICB1c2VJbmJveE5vdGlmaWNhdGlvbnMsXG4gIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlLFxuICB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyxcbiAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24sXG4gIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlLFxuICB1c2VSb29tSW5mbyxcbiAgdXNlUm9vbUluZm9TdXNwZW5zZSxcbiAgX3VzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkLFxuICBfdXNlVXNlcixcbiAgX3VzZVVzZXJTdXNwZW5zZSxcbiAgQ3JlYXRlVGhyZWFkRXJyb3IsXG4gIHNlbGVjdGVkVGhyZWFkcyxcbiAgUm9vbUNvbnRleHQsXG4gIHVzZVN0YXR1cyxcbiAgdXNlU3RvcmFnZVN0YXR1cyxcbiAgdXNlQmF0Y2gsXG4gIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gIHVzZUVycm9yTGlzdGVuZXIsXG4gIHVzZUhpc3RvcnksXG4gIHVzZVVuZG8sXG4gIHVzZVJlZG8sXG4gIHVzZUNhblVuZG8sXG4gIHVzZUNhblJlZG8sXG4gIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMsXG4gIHVzZUNvbW1lbnRzRXJyb3JMaXN0ZW5lcixcbiAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgdXNlRWRpdENvbW1lbnQsXG4gIHVzZURlbGV0ZUNvbW1lbnQsXG4gIHVzZVJlbW92ZVJlYWN0aW9uLFxuICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICB1c2VNYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgdXNlVGhyZWFkU3Vic2NyaXB0aW9uLFxuICB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlLFxuICB1c2VTdG9yYWdlU3RhdHVzU3VzcGVuc2UsXG4gIGNyZWF0ZVJvb21Db250ZXh0LFxuICBfUm9vbVByb3ZpZGVyLFxuICBfdXNlQnJvYWRjYXN0RXZlbnQsXG4gIF91c2VPdGhlcnNMaXN0ZW5lcixcbiAgX3VzZVJvb20sXG4gIF91c2VBZGRSZWFjdGlvbixcbiAgX3VzZU11dGF0aW9uLFxuICBfdXNlQ3JlYXRlVGhyZWFkLFxuICBfdXNlRGVsZXRlVGhyZWFkLFxuICBfdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICBfdXNlRXZlbnRMaXN0ZW5lcixcbiAgX3VzZU15UHJlc2VuY2UsXG4gIF91c2VPdGhlcnNNYXBwZWQsXG4gIF91c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSxcbiAgX3VzZVRocmVhZHMsXG4gIF91c2VUaHJlYWRzU3VzcGVuc2UsXG4gIF91c2VPdGhlcixcbiAgX3VzZU90aGVycyxcbiAgX3VzZU90aGVyU3VzcGVuc2UsXG4gIF91c2VPdGhlcnNTdXNwZW5zZSxcbiAgX3VzZVN0b3JhZ2UsXG4gIF91c2VTdG9yYWdlU3VzcGVuc2UsXG4gIF91c2VTZWxmLFxuICBfdXNlU2VsZlN1c3BlbnNlLFxuICBfdXNlU3RvcmFnZVJvb3QsXG4gIF91c2VVcGRhdGVNeVByZXNlbmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstTjJFRTJVT1gubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/chunk-N2EE2UOX.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/node_modules/nanoid/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@liveblocks/react/node_modules/nanoid/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   customRandom: () => (/* binding */ customRandom),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   urlAlphabet: () => (/* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__.urlAlphabet)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url-alphabet/index.js */ \"(ssr)/./node_modules/@liveblocks/react/node_modules/nanoid/url-alphabet/index.js\");\n\n\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\nlet random = bytes => {\n  fillPool((bytes -= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) => {\n  fillPool((size -= 0))\n  let id = ''\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__.urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3Qvbm9kZV9tb2R1bGVzL25hbm9pZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTJCO0FBQzBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFxQjtBQUN6QjtBQUNBLElBQUk7QUFDSixJQUFJLGtEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQsVUFBVSwrREFBVztBQUNyQjtBQUNBO0FBQ0E7QUFDb0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3Qvbm9kZV9tb2R1bGVzL25hbm9pZC9pbmRleC5qcz82OTc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJ1xuaW1wb3J0IHsgdXJsQWxwaGFiZXQgfSBmcm9tICcuL3VybC1hbHBoYWJldC9pbmRleC5qcydcbmNvbnN0IFBPT0xfU0laRV9NVUxUSVBMSUVSID0gMTI4XG5sZXQgcG9vbCwgcG9vbE9mZnNldFxubGV0IGZpbGxQb29sID0gYnl0ZXMgPT4ge1xuICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggPCBieXRlcykge1xuICAgIHBvb2wgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMgKiBQT09MX1NJWkVfTVVMVElQTElFUilcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocG9vbClcbiAgICBwb29sT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKHBvb2xPZmZzZXQgKyBieXRlcyA+IHBvb2wubGVuZ3RoKSB7XG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHBvb2wpXG4gICAgcG9vbE9mZnNldCA9IDBcbiAgfVxuICBwb29sT2Zmc2V0ICs9IGJ5dGVzXG59XG5sZXQgcmFuZG9tID0gYnl0ZXMgPT4ge1xuICBmaWxsUG9vbCgoYnl0ZXMgLT0gMCkpXG4gIHJldHVybiBwb29sLnN1YmFycmF5KHBvb2xPZmZzZXQgLSBieXRlcywgcG9vbE9mZnNldClcbn1cbmxldCBjdXN0b21SYW5kb20gPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplLCBnZXRSYW5kb20pID0+IHtcbiAgbGV0IG1hc2sgPSAoMiA8PCAoMzEgLSBNYXRoLmNsejMyKChhbHBoYWJldC5sZW5ndGggLSAxKSB8IDEpKSkgLSAxXG4gIGxldCBzdGVwID0gTWF0aC5jZWlsKCgxLjYgKiBtYXNrICogZGVmYXVsdFNpemUpIC8gYWxwaGFiZXQubGVuZ3RoKVxuICByZXR1cm4gKHNpemUgPSBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBieXRlcyA9IGdldFJhbmRvbShzdGVwKVxuICAgICAgbGV0IGkgPSBzdGVwXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlkICs9IGFscGhhYmV0W2J5dGVzW2ldICYgbWFza10gfHwgJydcbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gc2l6ZSkgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIHNpemUgPSAyMSkgPT5cbiAgY3VzdG9tUmFuZG9tKGFscGhhYmV0LCBzaXplLCByYW5kb20pXG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBmaWxsUG9vbCgoc2l6ZSAtPSAwKSlcbiAgbGV0IGlkID0gJydcbiAgZm9yIChsZXQgaSA9IHBvb2xPZmZzZXQgLSBzaXplOyBpIDwgcG9vbE9mZnNldDsgaSsrKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbcG9vbFtpXSAmIDYzXVxuICB9XG4gIHJldHVybiBpZFxufVxuZXhwb3J0IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCwgY3VzdG9tUmFuZG9tLCB1cmxBbHBoYWJldCwgcmFuZG9tIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/node_modules/nanoid/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/node_modules/nanoid/url-alphabet/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react/node_modules/nanoid/url-alphabet/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   urlAlphabet: () => (/* binding */ urlAlphabet)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3Qvbm9kZV9tb2R1bGVzL25hbm9pZC91cmwtYWxwaGFiZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3Qvbm9kZV9tb2R1bGVzL25hbm9pZC91cmwtYWxwaGFiZXQvaW5kZXguanM/NDRmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgdXJsQWxwaGFiZXQgPVxuICAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCdcbmV4cG9ydCB7IHVybEFscGhhYmV0IH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/node_modules/nanoid/url-alphabet/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   addReaction: () => (/* binding */ addReaction),\n/* harmony export */   applyOptimisticUpdates: () => (/* binding */ applyOptimisticUpdates),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   deleteComment: () => (/* binding */ deleteComment),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   removeReaction: () => (/* binding */ removeReaction),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   upsertComment: () => (/* binding */ upsertComment),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.3.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function clear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    clear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options.size ?? DEFAULT_SIZE;\n    this.delay = options.delay;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.input) === stringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(callback, options) {\n  const batch = new Batch(callback, options);\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    cache.set(cacheKey, state);\n    eventSource2.notify();\n  }\n  async function get(input) {\n    const cacheKey = getCacheKey(input);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(input);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(input) {\n    const cacheKey = getCacheKey(input);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2.observable,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const newState = callback(state);\n    if (state === newState) {\n      return;\n    }\n    state = newState;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    callback(state);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    subscribe\n  };\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url.toString();\n}\n\n// src/notifications.ts\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url = urljoin(baseUrl, `/v2/c${endpoint}`, params);\n    const response = await fetcher(url.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const json = await fetchJson(\"/inbox-notifications\", void 0, {\n      limit: options?.limit,\n      since: options?.since?.toISOString()\n    });\n    return {\n      threads: json.threads.map((thread) => convertToThreadData(thread)),\n      inboxNotifications: json.inboxNotifications.map(\n        (notification) => convertToInboxNotificationData(notification)\n      ),\n      deletedThreads: json.deletedThreads.map(\n        (info) => convertToThreadDeleteInfo(info)\n      ),\n      deletedInboxNotifications: json.deletedInboxNotifications.map(\n        (info) => convertToInboxNotificationDeleteInfo(info)\n      ),\n      meta: {\n        requestedAt: new Date(json.meta.requestedAt)\n      }\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(\"/inbox-notifications/count\");\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await fetchJson(\"/inbox-notifications\", {\n      method: \"DELETE\"\n    });\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await fetchJson(\n      `/inbox-notifications/${encodeURIComponent(inboxNotificationId)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n  const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n  const len = alphabet.length;\n  return Array.from(\n    { length },\n    () => alphabet.charAt(Math.floor(Math.random() * len))\n  ).join(\"\");\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isValueWithOperator(value)) {\n      keyValuePairsWithOperator.push([key, value]);\n    } else if (typeof value === \"object\" && !(\"startsWith\" in value)) {\n      indexedKeys.push([key, value]);\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isValueWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(\n    ({ key, operator, value }) => formatFilter(key, operator, formatFilterValue(value))\n  ).join(\" AND \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  return false;\n};\nvar isValueWithOperator = (value) => {\n  if (typeof value === \"object\" && value !== null && \"startsWith\" in value) {\n    return true;\n  }\n  return false;\n};\nvar formatFilter = (key, operator, value) => {\n  return `${key}${operator}${value}`;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${JSON.stringify(nestedKey)}]`;\n  }\n  return key;\n};\nvar formatFilterValue = (value) => {\n  if (typeof value === \"string\") {\n    if (isStringEmpty(value)) {\n      throw new Error(\"Value cannot be empty\");\n    }\n    return JSON.stringify(value);\n  }\n  return value.toString();\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createCommentsApi(roomId, getAuthValue, fetchClientApi) {\n  async function fetchCommentsApi(endpoint, params, options) {\n    const authValue = await getAuthValue();\n    return fetchClientApi(roomId, endpoint, authValue, options, params);\n  }\n  async function fetchJson(endpoint, options, params) {\n    const response = await fetchCommentsApi(endpoint, params, options);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreads(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const response = await fetchCommentsApi(\n      \"/threads\",\n      {\n        since: options?.since?.toISOString(),\n        query\n      },\n      {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map((thread) => convertToThreadData(thread)),\n        inboxNotifications: json.inboxNotifications.map(\n          (notification) => convertToInboxNotificationData(notification)\n        ),\n        deletedThreads: json.deletedThreads.map(\n          (info) => convertToThreadDeleteInfo(info)\n        ),\n        deletedInboxNotifications: json.deletedInboxNotifications.map(\n          (info) => convertToInboxNotificationDeleteInfo(info)\n        ),\n        meta: {\n          requestedAt: new Date(json.meta.requestedAt)\n        }\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        meta: {\n          requestedAt: /* @__PURE__ */ new Date()\n        }\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread({ threadId }) {\n    const response = await fetchCommentsApi(\n      `/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return;\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId,\n    threadId\n  }) {\n    const thread = await fetchJson(\"/threads\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        id: threadId,\n        comment: {\n          id: commentId,\n          body\n        },\n        metadata\n      })\n    });\n    return convertToThreadData(thread);\n  }\n  async function deleteThread({ threadId }) {\n    await fetchJson(`/threads/${encodeURIComponent(threadId)}`, {\n      method: \"DELETE\"\n    });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function markThreadAsResolved({ threadId }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/mark-as-resolved`,\n      {\n        method: \"POST\"\n      }\n    );\n  }\n  async function markThreadAsUnresolved({ threadId }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/mark-as-unresolved`,\n      {\n        method: \"POST\"\n      }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment2({\n    threadId,\n    commentId\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function addReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions/${encodeURIComponent(emoji)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getThreads,\n    getThread,\n    createThread,\n    deleteThread,\n    editThreadMetadata,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    createComment,\n    editComment,\n    deleteComment: deleteComment2,\n    addReaction: addReaction2,\n    removeReaction: removeReaction2\n  };\n}\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 = 50;\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getAuthBearerHeaderFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(roomId, endpoint, authValue, options2, params) {\n    const url = urljoin(\n      config.baseUrl,\n      `/v2/c/rooms/${encodeURIComponent(roomId)}${endpoint}`,\n      params\n    );\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(roomId, \"/storage\", authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(config.roomId, endpoint, managedSocket.authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    });\n  }\n  async function createTextMention(userId, mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      config.roomId,\n      \"/text-mentions\",\n      managedSocket.authValue,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          userId,\n          mentionId\n        })\n      }\n    );\n  }\n  async function deleteTextMention(mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      config.roomId,\n      `/text-mentions/${mentionId}`,\n      managedSocket.authValue,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function reportTextEditor(type, rootKey) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(config.roomId, \"/text-metadata\", authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        type,\n        rootKey\n      })\n    });\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = self.current?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storageBatch.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (true) {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 407 /* THREAD_DELETED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 408 /* THREAD_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  function isPresenceReady() {\n    return self.current !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  const commentsApi = createCommentsApi(\n    config.roomId,\n    delegates.authenticate,\n    fetchClientApi\n  );\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(\n      config.roomId,\n      endpoint,\n      authValue,\n      options2\n    );\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getRoomNotificationSettings() {\n    return fetchNotificationsJson(\n      \"/notification-settings\"\n    );\n  }\n  function updateRoomNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      \"/notification-settings\",\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        comments: {\n          ...commentsApi\n        },\n        notifications: {\n          getRoomNotificationSettings,\n          updateRoomNotificationSettings,\n          markInboxNotificationAsRead\n        }\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n\n// src/store.ts\nfunction createClientStore() {\n  const store = createStore({\n    threads: {},\n    queries: {},\n    optimisticUpdates: [],\n    inboxNotifications: {},\n    notificationSettings: {}\n  });\n  const optimisticUpdatesEventSource = makeEventSource();\n  return {\n    ...store,\n    deleteThread(threadId) {\n      store.set((state) => {\n        return {\n          ...state,\n          threads: deleteKeyImmutable(state.threads, threadId),\n          inboxNotifications: Object.fromEntries(\n            Object.entries(state.inboxNotifications).filter(\n              ([_id, notification]) => notification.kind === \"thread\" && notification.threadId === threadId\n            )\n          )\n        };\n      });\n    },\n    updateThreadAndNotification(thread, inboxNotification) {\n      store.set((state) => {\n        const existingThread = state.threads[thread.id];\n        return {\n          ...state,\n          threads: existingThread === void 0 || compareThreads(thread, existingThread) === 1 ? { ...state.threads, [thread.id]: thread } : state.threads,\n          inboxNotifications: inboxNotification === void 0 ? state.inboxNotifications : {\n            ...state.inboxNotifications,\n            [inboxNotification.id]: inboxNotification\n          }\n        };\n      });\n    },\n    updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads, deletedInboxNotifications, queryKey) {\n      store.set((state) => ({\n        ...state,\n        threads: applyThreadUpdates(state.threads, {\n          newThreads: threads,\n          deletedThreads\n        }),\n        inboxNotifications: applyNotificationsUpdates(\n          state.inboxNotifications,\n          {\n            newInboxNotifications: inboxNotifications,\n            deletedNotifications: deletedInboxNotifications\n          }\n        ),\n        queries: queryKey !== void 0 ? {\n          ...state.queries,\n          [queryKey]: { isLoading: false, data: void 0 }\n        } : state.queries\n      }));\n    },\n    updateRoomInboxNotificationSettings(roomId, settings, queryKey) {\n      store.set((state) => ({\n        ...state,\n        notificationSettings: {\n          ...state.notificationSettings,\n          [roomId]: settings\n        },\n        queries: {\n          ...state.queries,\n          [queryKey]: { isLoading: false, data: void 0 }\n        }\n      }));\n    },\n    pushOptimisticUpdate(optimisticUpdate) {\n      optimisticUpdatesEventSource.notify(optimisticUpdate);\n      store.set((state) => ({\n        ...state,\n        optimisticUpdates: [...state.optimisticUpdates, optimisticUpdate]\n      }));\n    },\n    setQueryState(queryKey, queryState) {\n      store.set((state) => ({\n        ...state,\n        queries: {\n          ...state.queries,\n          [queryKey]: queryState\n        }\n      }));\n    },\n    optimisticUpdatesEventSource\n  };\n}\nfunction deleteKeyImmutable(record, key) {\n  if (Object.prototype.hasOwnProperty.call(record, key)) {\n    const { [key]: _toDelete, ...rest } = record;\n    return rest;\n  }\n  return record;\n}\nfunction compareThreads(thread1, thread2) {\n  if (thread1.updatedAt && thread2.updatedAt) {\n    return thread1.updatedAt > thread2.updatedAt ? 1 : thread1.updatedAt < thread2.updatedAt ? -1 : 0;\n  } else if (thread1.updatedAt || thread2.updatedAt) {\n    return thread1.updatedAt ? 1 : -1;\n  }\n  if (thread1.createdAt > thread2.createdAt) {\n    return 1;\n  } else if (thread1.createdAt < thread2.createdAt) {\n    return -1;\n  }\n  return 0;\n}\nfunction applyOptimisticUpdates(state) {\n  const result = {\n    threads: {\n      ...state.threads\n    },\n    inboxNotifications: {\n      ...state.inboxNotifications\n    },\n    notificationSettings: {\n      ...state.notificationSettings\n    }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        result.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        };\n        break;\n      }\n      case \"mark-thread-as-resolved\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          resolved: true\n        };\n        break;\n      }\n      case \"mark-thread-as-unresolved\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          resolved: false\n        };\n        break;\n      }\n      case \"create-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        const inboxNotification = Object.values(result.inboxNotifications).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        result.inboxNotifications[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = deleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[optimisticUpdate.threadId] = {\n          ...result.threads[optimisticUpdate.threadId],\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        };\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = addReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = removeReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        result.inboxNotifications[optimisticUpdate.inboxNotificationId] = {\n          ...state.inboxNotifications[optimisticUpdate.inboxNotificationId],\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in result.inboxNotifications) {\n          result.inboxNotifications[id] = {\n            ...result.inboxNotifications[id],\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        const {\n          [optimisticUpdate.inboxNotificationId]: _,\n          ...inboxNotifications\n        } = result.inboxNotifications;\n        result.inboxNotifications = inboxNotifications;\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        result.inboxNotifications = {};\n        break;\n      }\n      case \"update-notification-settings\": {\n        result.notificationSettings[optimisticUpdate.roomId] = {\n          ...result.notificationSettings[optimisticUpdate.roomId],\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return result;\n}\nfunction applyThreadUpdates(existingThreads, updates) {\n  const updatedThreads = { ...existingThreads };\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n    if (existingThread) {\n      const result = compareThreads(existingThread, thread);\n      if (result === 1) return;\n    }\n    updatedThreads[thread.id] = thread;\n  });\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === void 0) return;\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n  return updatedThreads;\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1) return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction upsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction deleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      body: void 0\n    } : comment\n  );\n  if (!updatedComments.some((comment) => comment.deletedAt === void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n      comments: []\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction addReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction removeReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification\n  } = createNotificationsApi({\n    baseUrl,\n    fetcher: clientOptions.polyfills?.fetch || /* istanbul ignore next */\n    fetch,\n    authManager,\n    currentUserIdStore\n  });\n  const cacheStore = createClientStore();\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const usersStore = createBatchStore(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const roomsInfoStore = createBatchStore(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  return Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Internal\n      [kInternal]: {\n        notifications: {\n          getInboxNotifications,\n          getUnreadInboxNotificationsCount,\n          markAllInboxNotificationsAsRead,\n          markInboxNotificationAsRead,\n          deleteAllInboxNotifications,\n          deleteInboxNotification\n        },\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        cacheStore,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    return \"https://\" + url;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ?? element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n  let context = {\n    state: \"stopped\",\n    timeoutHandle: null,\n    interval: null,\n    lastScheduledAt: null,\n    remainingInterval: null\n  };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule(context.interval);\n    }\n    void callback();\n  }\n  function schedule(interval) {\n    context = {\n      state: \"running\",\n      interval: context.state !== \"stopped\" ? context.interval : interval,\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval),\n      remainingInterval: null\n    };\n  }\n  function scheduleRemaining(remaining) {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    context = {\n      state: \"running\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: setTimeout(poll, remaining),\n      remainingInterval: null\n    };\n  }\n  function start(interval) {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule(interval);\n  }\n  function restart(interval) {\n    stop();\n    start(interval);\n  }\n  function pause() {\n    if (context.state !== \"running\") {\n      return;\n    }\n    clearTimeout(context.timeoutHandle);\n    context = {\n      state: \"paused\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: null,\n      remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n    };\n  }\n  function resume() {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    scheduleRemaining(context.remainingInterval);\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = {\n      state: \"stopped\",\n      interval: null,\n      lastScheduledAt: null,\n      timeoutHandle: null,\n      remainingInterval: null\n    };\n  }\n  return {\n    start,\n    restart,\n    pause,\n    resume,\n    stop\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCLEdBQUcsVUFBVTtBQUN4RTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBLHFHQUFxRyxrQkFBa0I7QUFDdkg7QUFDQTtBQUNBLFdBQVcsU0FBUyxFQUFFLFVBQVU7QUFDaEMsV0FBVyxTQUFTLEVBQUUsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsd0JBQXdCO0FBQzNHO0FBQ0E7QUFDQSxhQUFhLFVBQVUsUUFBUSxZQUFZO0FBQzNDLGFBQWEsU0FBUyxRQUFRLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdDQUFnQyxxQkFBcUIsV0FBVyxnQkFBZ0IsdUJBQXVCLGdCQUFnQjtBQUN2SDtBQUNBO0FBQ0EsMENBQTBDLGFBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQW9CO0FBQzlEO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw4QkFBOEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSyxRQUFRLFNBQVMsVUFBVSxjQUFjO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDBCQUEwQjtBQUM1RTtBQUNBLDBDQUEwQywrQkFBK0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUI7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUyxHQUFHLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNEdBQTRHLGFBQWEsWUFBWSxlQUFlO0FBQ3BKO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLDZCQUE2QjtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0EsTUFBTSxRQUFRO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCLElBQUk7QUFDNUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLG1DQUFtQyxtQkFBbUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxhQUFhLE1BQXFDO0FBQ2xEO0FBQ0EsRUFBRSxDQUFRO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLGtEQUFrRDtBQUNyRSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHVCQUF1QiwwQ0FBMEM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQkFBMEIsb0RBQW9EO0FBQzlFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHFCQUFxQixPQUFPLEdBQUcsS0FBSztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQXFDLEdBQUcsQ0FBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxzQkFBc0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksR0FBRywwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQiw2QkFBNkIsWUFBWTtBQUMzRDtBQUNBLFFBQVEsYUFBYSwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQXFDLCtCQUErQixDQUFNO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXLGVBQWUsR0FBRztBQUNoRCxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLGdDQUFnQztBQUNsQztBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhDQUE4QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLHNCQUFzQjtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWSw0QkFBNEIsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkUsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxjQUFjLDRDQUE0QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCLFlBQVk7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUE2REU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9jb3JlL2Rpc3QvaW5kZXgubWpzPzQ5YWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBQS0dfTkFNRSA9IFwiQGxpdmVibG9ja3MvY29yZVwiO1xudmFyIFBLR19WRVJTSU9OID0gXCIyLjMuMFwiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvZHVwZS1kZXRlY3Rpb24udHNcbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fTtcbnZhciBjcm9zc0xpbmtlZERvY3MgPSBcImh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9jcm9zcy1saW5rZWRcIjtcbnZhciBkdXBlc0RvY3MgPSBcImh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9kdXBlc1wiO1xudmFyIFNQQUNFID0gXCIgXCI7XG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZWN0RHVwZXMocGtnTmFtZSwgcGtnVmVyc2lvbiwgcGtnRm9ybWF0KSB7XG4gIGNvbnN0IHBrZ0lkID0gU3ltYm9sLmZvcihwa2dOYW1lKTtcbiAgY29uc3QgcGtnQnVpbGRJbmZvID0gcGtnRm9ybWF0ID8gYCR7cGtnVmVyc2lvbiB8fCBcImRldlwifSAoJHtwa2dGb3JtYXR9KWAgOiBwa2dWZXJzaW9uIHx8IFwiZGV2XCI7XG4gIGlmICghZ1twa2dJZF0pIHtcbiAgICBnW3BrZ0lkXSA9IHBrZ0J1aWxkSW5mbztcbiAgfSBlbHNlIGlmIChnW3BrZ0lkXSA9PT0gcGtnQnVpbGRJbmZvKSB7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbXNnID0gW1xuICAgICAgYE11bHRpcGxlIGNvcGllcyBvZiBMaXZlYmxvY2tzIGFyZSBiZWluZyBsb2FkZWQgaW4geW91ciBwcm9qZWN0LiBUaGlzIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtkdXBlc0RvY3MgKyBTUEFDRX1gLFxuICAgICAgXCJcIixcbiAgICAgIFwiQ29uZmxpY3RzOlwiLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke2dbcGtnSWRdfSAoYWxyZWFkeSBsb2FkZWQpYCxcbiAgICAgIGAtICR7cGtnTmFtZX0gJHtwa2dCdWlsZEluZm99ICh0cnlpbmcgdG8gbG9hZCB0aGlzIG5vdylgXG4gICAgXS5qb2luKFwiXFxuXCIpO1xuICAgIGVycm9yKG1zZyk7XG4gIH1cbiAgaWYgKHBrZ1ZlcnNpb24gJiYgUEtHX1ZFUlNJT04gJiYgcGtnVmVyc2lvbiAhPT0gUEtHX1ZFUlNJT04pIHtcbiAgICBlcnJvcihcbiAgICAgIFtcbiAgICAgICAgYENyb3NzLWxpbmtlZCB2ZXJzaW9ucyBvZiBMaXZlYmxvY2tzIGZvdW5kLCB3aGljaCB3aWxsIGNhdXNlIGlzc3VlcyEgU2VlICR7Y3Jvc3NMaW5rZWREb2NzICsgU1BBQ0V9YCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICAgIGAtICR7UEtHX05BTUV9IGlzIGF0ICR7UEtHX1ZFUlNJT059YCxcbiAgICAgICAgYC0gJHtwa2dOYW1lfSBpcyBhdCAke3BrZ1ZlcnNpb259YCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCJBbHdheXMgdXBncmFkZSBhbGwgTGl2ZWJsb2NrcyBwYWNrYWdlcyB0byB0aGUgc2FtZSB2ZXJzaW9uIG51bWJlci5cIlxuICAgICAgXS5qb2luKFwiXFxuXCIpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2Fzc2VydC50c1xuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3ZhbHVlLCBlcnJtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBlcnJtc2cpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIGVyci5uYW1lID0gXCJBc3NlcnRpb24gZmFpbHVyZVwiO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbm4odmFsdWUsIGVycm1zZyA9IFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgbm9uLW51bGxhYmxlXCIpIHtcbiAgYXNzZXJ0KHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAsIGVycm1zZyk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL2xpYi9jb250cm9sbGVkUHJvbWlzZS50c1xuZnVuY3Rpb24gY29udHJvbGxlZFByb21pc2UoKSB7XG4gIGxldCByZXNvbHZlO1xuICBsZXQgcmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4gW3Byb21pc2UsIHJlc29sdmUsIHJlamVjdF07XG59XG5mdW5jdGlvbiBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKSB7XG4gIGNvbnN0IFtwcm9taXNlLCByZXNvbHZlLCByZWplY3RdID0gY29udHJvbGxlZFByb21pc2UoKTtcbiAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG59XG5cbi8vIHNyYy9saWIvRXZlbnRTb3VyY2UudHNcbmZ1bmN0aW9uIG1ha2VFdmVudFNvdXJjZSgpIHtcbiAgY29uc3QgX29uZXRpbWVPYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBfb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IF9idWZmZXIgPSBudWxsO1xuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBfYnVmZmVyID0gW107XG4gIH1cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoX2J1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIF9idWZmZXIpIHtcbiAgICAgIG5vdGlmeShldmVudCk7XG4gICAgfVxuICAgIF9idWZmZXIgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIF9vYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29ic2VydmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZU9uY2UoY2FsbGJhY2spIHtcbiAgICBfb25ldGltZU9ic2VydmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBfb25ldGltZU9ic2VydmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbChwcmVkaWNhdGUpIHtcbiAgICBsZXQgdW5zdWI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHVuc3ViID0gc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlID09PSB2b2lkIDAgfHwgcHJlZGljYXRlKGV2ZW50KSkge1xuICAgICAgICAgIHJlcyhldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdW5zdWI/LigpKTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlPckJ1ZmZlcihldmVudCkge1xuICAgIGlmIChfYnVmZmVyICE9PSBudWxsKSB7XG4gICAgICBfYnVmZmVyLnB1c2goZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3RpZnkoZXZlbnQpIHtcbiAgICBfb25ldGltZU9ic2VydmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgICBfb25ldGltZU9ic2VydmVycy5jbGVhcigpO1xuICAgIF9vYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBfb2JzZXJ2ZXJzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gY291bnQoKSB7XG4gICAgcmV0dXJuIF9vbmV0aW1lT2JzZXJ2ZXJzLnNpemUgKyBfb2JzZXJ2ZXJzLnNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAvLyBQcml2YXRlL2ludGVybmFsIGNvbnRyb2wgb3ZlciBldmVudCBlbWlzc2lvblxuICAgIG5vdGlmeTogbm90aWZ5T3JCdWZmZXIsXG4gICAgc3Vic2NyaWJlLFxuICAgIHN1YnNjcmliZU9uY2UsXG4gICAgY2xlYXIsXG4gICAgY291bnQsXG4gICAgd2FpdFVudGlsLFxuICAgIHBhdXNlLFxuICAgIHVucGF1c2UsXG4gICAgLy8gUHVibGljbHkgZXhwb3NhYmxlIHN1YnNjcmlwdGlvbiBBUElcbiAgICBvYnNlcnZhYmxlOiB7XG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBzdWJzY3JpYmVPbmNlLFxuICAgICAgd2FpdFVudGlsXG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2ZhbmN5LWNvbnNvbGUudHNcbnZhciBmYW5jeV9jb25zb2xlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZhbmN5X2NvbnNvbGVfZXhwb3J0cywge1xuICBlcnJvcjogKCkgPT4gZXJyb3IyLFxuICBlcnJvcldpdGhUaXRsZTogKCkgPT4gZXJyb3JXaXRoVGl0bGUsXG4gIHdhcm46ICgpID0+IHdhcm4sXG4gIHdhcm5XaXRoVGl0bGU6ICgpID0+IHdhcm5XaXRoVGl0bGVcbn0pO1xudmFyIGJhZGdlID0gXCJiYWNrZ3JvdW5kOiMwZTBkMTI7Ym9yZGVyLXJhZGl1czo5OTk5cHg7Y29sb3I6I2ZmZjtwYWRkaW5nOjNweCA3cHg7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtmb250LXdlaWdodDo2MDA7XCI7XG52YXIgYm9sZCA9IFwiZm9udC13ZWlnaHQ6NjAwXCI7XG5mdW5jdGlvbiB3cmFwKG1ldGhvZCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyBjb25zb2xlW21ldGhvZF0gOiAoXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAobWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFwiJWNMaXZlYmxvY2tzXCIsIGJhZGdlLCBtZXNzYWdlLCAuLi5hcmdzKVxuICApO1xufVxudmFyIHdhcm4gPSB3cmFwKFwid2FyblwiKTtcbnZhciBlcnJvcjIgPSB3cmFwKFwiZXJyb3JcIik7XG5mdW5jdGlvbiB3cmFwV2l0aFRpdGxlKG1ldGhvZCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyBjb25zb2xlW21ldGhvZF0gOiAoXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAodGl0bGUsIG1lc3NhZ2UsIC4uLmFyZ3MpID0+IGNvbnNvbGVbbWV0aG9kXShcbiAgICAgIGAlY0xpdmVibG9ja3MlYyAke3RpdGxlfWAsXG4gICAgICBiYWRnZSxcbiAgICAgIGJvbGQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgLi4uYXJnc1xuICAgIClcbiAgKTtcbn1cbnZhciB3YXJuV2l0aFRpdGxlID0gd3JhcFdpdGhUaXRsZShcIndhcm5cIik7XG52YXIgZXJyb3JXaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwiZXJyb3JcIik7XG5cbi8vIHNyYy9saWIvZnNtLnRzXG5mdW5jdGlvbiBkaXN0YW5jZShzdGF0ZTEsIHN0YXRlMikge1xuICBpZiAoc3RhdGUxID09PSBzdGF0ZTIpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGNvbnN0IGNodW5rczEgPSBzdGF0ZTEuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBjaHVua3MyID0gc3RhdGUyLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgbWluTGVuID0gTWF0aC5taW4oY2h1bmtzMS5sZW5ndGgsIGNodW5rczIubGVuZ3RoKTtcbiAgbGV0IHNoYXJlZCA9IDA7XG4gIGZvciAoOyBzaGFyZWQgPCBtaW5MZW47IHNoYXJlZCsrKSB7XG4gICAgaWYgKGNodW5rczFbc2hhcmVkXSAhPT0gY2h1bmtzMltzaGFyZWRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgdXAgPSBjaHVua3MxLmxlbmd0aCAtIHNoYXJlZDtcbiAgY29uc3QgZG93biA9IGNodW5rczIubGVuZ3RoIC0gc2hhcmVkO1xuICByZXR1cm4gW3VwLCBkb3duXTtcbn1cbmZ1bmN0aW9uIHBhdHRlcm5zKHRhcmdldFN0YXRlLCBsZXZlbHMpIHtcbiAgY29uc3QgcGFydHMgPSB0YXJnZXRTdGF0ZS5zcGxpdChcIi5cIik7XG4gIGlmIChsZXZlbHMgPCAxIHx8IGxldmVscyA+IHBhcnRzLmxlbmd0aCArIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBsZXZlbHNcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChsZXZlbHMgPiBwYXJ0cy5sZW5ndGgpIHtcbiAgICByZXN1bHQucHVzaChcIipcIik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHBhcnRzLmxlbmd0aCAtIGxldmVscyArIDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsaWNlID0gcGFydHMuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmpvaW4oXCIuXCIpICsgXCIuKlwiKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnB1c2godGFyZ2V0U3RhdGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFNhZmVDb250ZXh0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuY3VyciA9IGluaXRpYWxDb250ZXh0O1xuICB9XG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnI7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGFsbG93cyBwYXRjaGluZyBvZiB0aGUgY29udGV4dCwgYnlcbiAgICogY2FsbGluZyBgY29udGV4dC5wYXRjaCgpYC4gUGF0Y2hpbmcgaXMgb25seSBhbGxvd2VkIGZvciB0aGUgZHVyYXRpb25cbiAgICogb2YgdGhpcyB3aW5kb3cuXG4gICAqL1xuICBhbGxvd1BhdGNoaW5nKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGFsbG93ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHBhdGNoYWJsZUNvbnRleHQgPSB7XG4gICAgICAuLi50aGlzLmN1cnIsXG4gICAgICBwYXRjaChwYXRjaCkge1xuICAgICAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgICAgIHNlbGYuY3VyciA9IE9iamVjdC5hc3NpZ24oe30sIHNlbGYuY3VyciwgcGF0Y2gpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBPYmplY3QuZW50cmllcyhwYXRjaCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcInBhdGNoXCIpIHtcbiAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBubyBsb25nZXIgcGF0Y2ggc3RhbGUgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2FsbGJhY2socGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgYWxsb3dlZCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxufTtcbnZhciBuZXh0SWQgPSAxO1xudmFyIEZTTSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgc3RhdGUsIHdoaWNoIGlzIGRlZmluZWQgYnkgdGhlIGZpcnN0IGNhbGwgbWFkZSB0b1xuICAgKiAuYWRkU3RhdGUoKS5cbiAgICovXG4gIGdldCBpbml0aWFsU3RhdGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zdGF0ZXMudmFsdWVzKClbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN0YXRlcyBkZWZpbmVkIHlldFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U3RhdGVPck51bGwgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN0YXJ0ZWQgeWV0XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdG9wcGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdGVPck51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgbWFjaGluZSBieSBlbnRlcmluZyB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIG1hY2hpbmUgaGFzIGFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5ydW5uaW5nU3RhdGUgPSAxIC8qIFNUQVJURUQgKi87XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICB0aGlzLmVudGVyKG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgc3RhdGUgbWFjaGluZS4gU3RvcHBpbmcgdGhlIHN0YXRlIG1hY2hpbmUgd2lsbCBjYWxsIGV4aXRcbiAgICogaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHN0YXRlLCBidXQgbm90IGVudGVyIGEgbmV3IHN0YXRlLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDEgLyogU1RBUlRFRCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0b3AgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgaGFzbid0IHN0YXJ0ZWQgeWV0XCIpO1xuICAgIH1cbiAgICB0aGlzLmV4aXQobnVsbCk7XG4gICAgdGhpcy5ydW5uaW5nU3RhdGUgPSAyIC8qIFNUT1BQRUQgKi87XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxDb250ZXh0KSB7XG4gICAgdGhpcy5pZCA9IG5leHRJZCsrO1xuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi87XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSBudWxsO1xuICAgIHRoaXMuc3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmVudGVyRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmNsZWFudXBTdGFjayA9IFtdO1xuICAgIHRoaXMua25vd25FdmVudFR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dCA9IG5ldyBTYWZlQ29udGV4dChpbml0aWFsQ29udGV4dCk7XG4gICAgdGhpcy5ldmVudEh1YiA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsVHJhbnNpdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRJZ25vcmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsRXhpdFN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZEVudGVyU3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpXG4gICAgfTtcbiAgICB0aGlzLmV2ZW50cyA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogdGhpcy5ldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiB0aGlzLmV2ZW50SHViLndpbGxUcmFuc2l0aW9uLm9ic2VydmFibGUsXG4gICAgICBkaWRJZ25vcmVFdmVudDogdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5vYnNlcnZhYmxlLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogdGhpcy5ldmVudEh1Yi53aWxsRXhpdFN0YXRlLm9ic2VydmFibGUsXG4gICAgICBkaWRFbnRlclN0YXRlOiB0aGlzLmV2ZW50SHViLmRpZEVudGVyU3RhdGUub2JzZXJ2YWJsZVxuICAgIH07XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudDtcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFuIGV4cGxpY2l0IGZpbml0ZSBzdGF0ZSBpbiB0aGUgc3RhdGUgbWFjaGluZS5cbiAgICovXG4gIGFkZFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlcy5hZGQoc3RhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uRW50ZXIobmFtZU9yUGF0dGVybiwgZW50ZXJGbikge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZW50ZXJGbnMuaGFzKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIFRPRE8gV2UgX2N1cnJlbnRseV8gZG9uJ3Qgc3VwcG9ydCBtdWx0aXBsZSAub25FbnRlcnMoKSBmb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gc3RhdGUsIGJ1dCB0aGlzIGlzIG5vdCBhIGZ1bmRhbWVudGFsIGxpbWl0YXRpb24uIEp1c3Qgbm90XG4gICAgICAgIC8vIGltcGxlbWVudGVkIHlldC4gSWYgd2Ugd2FudGVkIHRvLCB3ZSBjb3VsZCBtYWtlIHRoaXMgYW4gYXJyYXkuXG4gICAgICAgIGBlbnRlci9leGl0IGZ1bmN0aW9uIGZvciAke25hbWVPclBhdHRlcm59IGFscmVhZHkgZXhpc3RzYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5lbnRlckZucy5zZXQobmFtZU9yUGF0dGVybiwgZW50ZXJGbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25FbnRlckFzeW5jKG5hbWVPclBhdHRlcm4sIHByb21pc2VGbiwgb25PSywgb25FcnJvcikge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIobmFtZU9yUGF0dGVybiwgKCkgPT4ge1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB2b2lkIHByb21pc2VGbih0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQsIHNpZ25hbCkudGhlbihcbiAgICAgICAgLy8gT24gT0tcbiAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfT0tcIiwgZGF0YSB9LCBvbk9LKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE9uIEVycm9yXG4gICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfRVJST1JcIiwgcmVhc29uIH0sIG9uRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGdldFN0YXRlc01hdGNoaW5nKG5hbWVPclBhdHRlcm4pIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgaWYgKG5hbWVPclBhdHRlcm4gPT09IFwiKlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lT3JQYXR0ZXJuLmVuZHNXaXRoKFwiLipcIikpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWVPclBhdHRlcm4uc2xpY2UoMCwgLTEpO1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBpZiAoc3RhdGUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuYW1lID0gbmFtZU9yUGF0dGVybjtcbiAgICAgIGlmICh0aGlzLnN0YXRlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhdGVzIG1hdGNoICR7SlNPTi5zdHJpbmdpZnkobmFtZU9yUGF0dGVybil9YCk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYWxsIGFsbG93ZWQgb3V0Z29pbmcgdHJhbnNpdGlvbnMgZm9yIGEgc3RhdGUuXG4gICAqXG4gICAqIFRoZSB0YXJnZXRzIGZvciBlYWNoIGV2ZW50IGNhbiBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGVcbiAgICogbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLiBUaGVzZSBmdW5jdGlvbnMgY2FuIGxvb2sgYXQgdGhlIGBldmVudGAgb3JcbiAgICogYGNvbnRleHRgIHBhcmFtcyB0byBjb25kaXRpb25hbGx5IGRlY2lkZSB3aGljaCBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb25cbiAgICogdG8uXG4gICAqXG4gICAqIElmIHlvdSBzZXQgaXQgdG8gYG51bGxgLCB0aGVuIHRoZSB0cmFuc2l0aW9uIHdpbGwgYmUgZXhwbGljaXRseSBmb3JiaWRkZW5cbiAgICogYW5kIHRocm93IGFuIGVycm9yLiBJZiB5b3UgZG9uJ3QgZGVmaW5lIGEgdGFyZ2V0IGZvciBhIHRyYW5zaXRpb24sIHRoZW5cbiAgICogc3VjaCBldmVudHMgd2lsbCBnZXQgaWdub3JlZC5cbiAgICovXG4gIGFkZFRyYW5zaXRpb25zKG5hbWVPclBhdHRlcm4sIG1hcHBpbmcpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3JjU3RhdGUgb2YgdGhpcy5nZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgbGV0IG1hcCA9IHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldChzcmNTdGF0ZSk7XG4gICAgICBpZiAobWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMuc2V0KHNyY1N0YXRlLCBtYXApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbdHlwZSwgdGFyZ2V0X10gb2YgT2JqZWN0LmVudHJpZXMobWFwcGluZykpIHtcbiAgICAgICAgaWYgKG1hcC5oYXModHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVHJ5aW5nIHRvIHNldCB0cmFuc2l0aW9uIFwiJHt0eXBlfVwiIG9uIFwiJHtzcmNTdGF0ZX1cIiAodmlhIFwiJHtuYW1lT3JQYXR0ZXJufVwiKSwgYnV0IGEgdHJhbnNpdGlvbiBhbHJlYWR5IGV4aXN0cyB0aGVyZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRfO1xuICAgICAgICB0aGlzLmtub3duRXZlbnRUeXBlcy5hZGQodHlwZSk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEZuID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0IDogKCkgPT4gdGFyZ2V0O1xuICAgICAgICAgIG1hcC5zZXQodHlwZSwgdGFyZ2V0Rm4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBMaWtlIGAuYWRkVHJhbnNpdGlvbigpYCwgYnV0IHRha2VzIGFuIChhbm9ueW1vdXMpIHRyYW5zaXRpb24gd2hlbmV2ZXIgdGhlXG4gICAqIHRpbWVyIGZpcmVzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGVPclBhdHRlcm4gVGhlIHN0YXRlIG5hbWUsIG9yIHN0YXRlIGdyb3VwIHBhdHRlcm4gbmFtZS5cbiAgICogQHBhcmFtIGFmdGVyICAgICAgICAgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdG8gdGFrZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uIElmIGluIHRoZSBtZWFuIHRpbWUsIGFub3RoZXIgdHJhbnNpdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgaXMgdGFrZW4sIHRoZSB0aW1lciB3aWxsIGdldCBjYW5jZWxsZWQuXG4gICAqIEBwYXJhbSB0YXJnZXQgICAgIFRoZSB0YXJnZXQgc3RhdGUgdG8gZ28gdG8uXG4gICAqL1xuICBhZGRUaW1lZFRyYW5zaXRpb24oc3RhdGVPclBhdHRlcm4sIGFmdGVyMiwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMub25FbnRlcihzdGF0ZU9yUGF0dGVybiwgKCkgPT4ge1xuICAgICAgY29uc3QgbXMgPSB0eXBlb2YgYWZ0ZXIyID09PSBcImZ1bmN0aW9uXCIgPyBhZnRlcjIodGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50KSA6IGFmdGVyMjtcbiAgICAgIGNvbnN0IHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIlRJTUVSXCIgfSwgdGFyZ2V0KTtcbiAgICAgIH0sIG1zKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRUYXJnZXRGbihldmVudE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHRoaXMuY3VycmVudFN0YXRlKT8uZ2V0KGV2ZW50TmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4aXRzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAgICogQ2FsbCB0aGlzIGJlZm9yZSBjaGFuZ2luZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIGxldmVscyBEZWZpbmVzIGhvdyBtYW55IFwibGV2ZWxzXCIgb2YgbmVzdGluZyB3aWxsIGJlXG4gICAqIGV4aXRlZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSB0cmFuc2l0aW9uIGZyb20gYGZvby5iYXIucXV4YCB0b1xuICAgKiBgZm9vLmJhci5iYXpgLCB0aGVuIHRoZSBsZXZlbCBpcyAxLiBCdXQgaWYgeW91IHRyYW5zaXRpb24gZnJvbVxuICAgKiBgZm9vLmJhci5xdXhgIHRvIGBibGEuYmxhYCwgdGhlbiB0aGUgbGV2ZWwgaXMgMy5cbiAgICogSWYgYG51bGxgLCBpdCB3aWxsIGV4aXQgYWxsIGxldmVscy5cbiAgICovXG4gIGV4aXQobGV2ZWxzKSB7XG4gICAgdGhpcy5ldmVudEh1Yi53aWxsRXhpdFN0YXRlLm5vdGlmeSh0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMgPz8gdGhpcy5jbGVhbnVwU3RhY2subGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHM7IGkrKykge1xuICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wb3AoKT8uKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbnRlcnMgdGhlIGN1cnJlbnQgc3RhdGUsIGFuZCBleGVjdXRlcyBhbnkgbmVjZXNzYXJ5IG9uRW50ZXIgaGFuZGxlcnMuXG4gICAqIENhbGwgdGhpcyBkaXJlY3RseSBfYWZ0ZXJfIHNldHRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqL1xuICBlbnRlcihsZXZlbHMpIHtcbiAgICBjb25zdCBlbnRlclBhdHRlcm5zID0gcGF0dGVybnMoXG4gICAgICB0aGlzLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGxldmVscyA/PyB0aGlzLmN1cnJlbnRTdGF0ZS5zcGxpdChcIi5cIikubGVuZ3RoICsgMVxuICAgICk7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgZW50ZXJQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBlbnRlckZuID0gdGhpcy5lbnRlckZucy5nZXQocGF0dGVybik7XG4gICAgICAgIGNvbnN0IGNsZWFudXBGbiA9IGVudGVyRm4/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhbnVwRm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuY2xlYW51cFN0YWNrLnB1c2goY2xlYW51cEZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5ldmVudEh1Yi5kaWRFbnRlclN0YXRlLm5vdGlmeSh0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoZSBtYWNoaW5lLCB3aGljaCBtYXkgY2F1c2UgYW4gaW50ZXJuYWwgc3RhdGVcbiAgICogdHJhbnNpdGlvbiB0byBoYXBwZW4uIFdoZW4gdGhhdCBoYXBwZW5zLCB3aWxsIHRyaWdnZXIgc2lkZSBlZmZlY3RzLlxuICAgKi9cbiAgc2VuZChldmVudCkge1xuICAgIGlmICghdGhpcy5rbm93bkV2ZW50VHlwZXMuaGFzKGV2ZW50LnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXZlbnQgJHtKU09OLnN0cmluZ2lmeShldmVudC50eXBlKX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlID09PSAyIC8qIFNUT1BQRUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0aGlzLmdldFRhcmdldEZuKGV2ZW50LnR5cGUpO1xuICAgIGlmICh0YXJnZXRGbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uKGV2ZW50LCB0YXJnZXRGbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgdHJhbnNpdGlvbihldmVudCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5ldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuY3VycmVudFN0YXRlO1xuICAgIGNvbnN0IHRhcmdldEZuID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0IDogKCkgPT4gdGFyZ2V0O1xuICAgIGNvbnN0IG5leHRUYXJnZXQgPSB0YXJnZXRGbihldmVudCwgdGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50KTtcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGxldCBlZmZlY3RzID0gdm9pZCAwO1xuICAgIGlmIChuZXh0VGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV4dFRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dFRhcmdldC50YXJnZXQ7XG4gICAgICBlZmZlY3RzID0gQXJyYXkuaXNBcnJheShuZXh0VGFyZ2V0LmVmZmVjdCkgPyBuZXh0VGFyZ2V0LmVmZmVjdCA6IFtuZXh0VGFyZ2V0LmVmZmVjdF07XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGF0ZXMuaGFzKG5leHRTdGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXh0IHN0YXRlIG5hbWU6ICR7SlNPTi5zdHJpbmdpZnkobmV4dFN0YXRlKX1gKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5ub3RpZnkoeyBmcm9tOiBvbGRTdGF0ZSwgdG86IG5leHRTdGF0ZSB9KTtcbiAgICBjb25zdCBbdXAsIGRvd25dID0gZGlzdGFuY2UodGhpcy5jdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgaWYgKHVwID4gMCkge1xuICAgICAgdGhpcy5leGl0KHVwKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSBuZXh0U3RhdGU7XG4gICAgaWYgKGVmZmVjdHMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZWZmZWN0c1RvUnVuID0gZWZmZWN0cztcbiAgICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzVG9SdW4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBlZmZlY3QocGF0Y2hhYmxlQ29udGV4dCwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRjaGFibGVDb250ZXh0LnBhdGNoKGVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRvd24gPiAwKSB7XG4gICAgICB0aGlzLmVudGVyKGRvd24pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2xpYi91dGlscy50c1xuZnVuY3Rpb24gcmFpc2UobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChibG9iKSB7XG4gIHJldHVybiBibG9iICE9PSBudWxsICYmIHR5cGVvZiBibG9iID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChibG9iKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopO1xufVxuZnVuY3Rpb24gdHJ5UGFyc2VKc29uKHJhd01lc3NhZ2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyYXdNZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYjY0ZGVjb2RlKGI2NHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9ybWF0dGVkVmFsdWUgPSBiNjR2YWx1ZS5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgICBjb25zdCBkZWNvZGVkVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoXG4gICAgICBhdG9iKGZvcm1hdHRlZFZhbHVlKS5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gXCIlXCIgKyAoXCIwMFwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgfSkuam9pbihcIlwiKVxuICAgICk7XG4gICAgcmV0dXJuIGRlY29kZWRWYWx1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGF0b2IoYjY0dmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wYWN0KGl0ZW1zKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoXG4gICAgKGl0ZW0pID0+IGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdm9pZCAwXG4gICk7XG59XG5mdW5jdGlvbiBjb21wYWN0T2JqZWN0KG9iaikge1xuICBjb25zdCBuZXdPYmogPSB7IC4uLm9iaiB9O1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGspID0+IHtcbiAgICBjb25zdCBrZXkgPSBrO1xuICAgIGlmIChuZXdPYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxldGUgbmV3T2JqW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld09iajtcbn1cbmZ1bmN0aW9uIHdhaXQobWlsbGlzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgbWlsbGlzKSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dChwcm9taXNlLCBtaWxsaXMsIGVycm1zZykge1xuICBsZXQgdGltZXJJRDtcbiAgY29uc3QgdGltZXIkID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgIHRpbWVySUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJybXNnKSk7XG4gICAgfSwgbWlsbGlzKTtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVyJF0pLmZpbmFsbHkoKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVySUQpKTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVPblN1Y2Nlc3MoZmFjdG9yeUZuKSB7XG4gIGxldCBjYWNoZWQgPSBudWxsO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChjYWNoZWQgPT09IG51bGwpIHtcbiAgICAgIGNhY2hlZCA9IGZhY3RvcnlGbigpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY2FjaGVkID0gbnVsbDtcbiAgICAgICAgfSwgNWUzKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWQ7XG4gIH07XG59XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJ2ZXJNc2cudHNcbnZhciBTZXJ2ZXJNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoU2VydmVyTXNnQ29kZTIpID0+IHtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0pPSU5FRFwiXSA9IDEwMV0gPSBcIlVTRVJfSk9JTkVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9MRUZUXCJdID0gMTAyXSA9IFwiVVNFUl9MRUZUXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQlJPQURDQVNURURfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RFRF9FVkVOVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJPT01fU1RBVEVcIl0gPSAxMDRdID0gXCJST09NX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCJdID0gMjAwXSA9IFwiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJFSkVDVF9TVE9SQUdFX09QXCJdID0gMjk5XSA9IFwiUkVKRUNUX1NUT1JBR0VfT1BcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMF0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX0NSRUFURURcIl0gPSA0MDBdID0gXCJUSFJFQURfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9ERUxFVEVEXCJdID0gNDA3XSA9IFwiVEhSRUFEX0RFTEVURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiXSA9IDQwMV0gPSBcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX1VQREFURURcIl0gPSA0MDhdID0gXCJUSFJFQURfVVBEQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfQ1JFQVRFRFwiXSA9IDQwMl0gPSBcIkNPTU1FTlRfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfRURJVEVEXCJdID0gNDAzXSA9IFwiQ09NTUVOVF9FRElURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0RFTEVURURcIl0gPSA0MDRdID0gXCJDT01NRU5UX0RFTEVURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCJdID0gNDA1XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiXSA9IDQwNl0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiO1xuICByZXR1cm4gU2VydmVyTXNnQ29kZTI7XG59KShTZXJ2ZXJNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL0lXZWJTb2NrZXQudHNcbnZhciBXZWJzb2NrZXRDbG9zZUNvZGVzID0gLyogQF9fUFVSRV9fICovICgoV2Vic29ja2V0Q2xvc2VDb2RlczIpID0+IHtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9OT1JNQUxcIl0gPSAxZTNdID0gXCJDTE9TRV9OT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9BQk5PUk1BTFwiXSA9IDEwMDZdID0gXCJDTE9TRV9BQk5PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlVORVhQRUNURURfQ09ORElUSU9OXCJdID0gMTAxMV0gPSBcIlVORVhQRUNURURfQ09ORElUSU9OXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVFJZX0FHQUlOX0xBVEVSXCJdID0gMTAxM10gPSBcIlRSWV9BR0FJTl9MQVRFUlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIl0gPSA0ZTNdID0gXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTk9UX0FMTE9XRURcIl0gPSA0MDAxXSA9IFwiTk9UX0FMTE9XRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCJdID0gNDAwMl0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIl0gPSA0MDAzXSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIl0gPSA0MDA0XSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIl0gPSA0MDA1XSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiUk9PTV9JRF9VUERBVEVEXCJdID0gNDAwNl0gPSBcIlJPT01fSURfVVBEQVRFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIktJQ0tFRFwiXSA9IDQxMDBdID0gXCJLSUNLRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUT0tFTl9FWFBJUkVEXCJdID0gNDEwOV0gPSBcIlRPS0VOX0VYUElSRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCJdID0gNDk5OV0gPSBcIkNMT1NFX1dJVEhPVVRfUkVUUllcIjtcbiAgcmV0dXJuIFdlYnNvY2tldENsb3NlQ29kZXMyO1xufSkoV2Vic29ja2V0Q2xvc2VDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBzaG91bGREaXNjb25uZWN0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDQ5OTkgLyogQ0xPU0VfV0lUSE9VVF9SRVRSWSAqLyB8fCBjb2RlID49IDRlMyAmJiBjb2RlIDwgNDEwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQxMDAgJiYgY29kZSA8IDQyMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAxMyAvKiBUUllfQUdBSU5fTEFURVIgKi8gfHwgY29kZSA+PSA0MjAwICYmIGNvZGUgPCA0MzAwO1xufVxuXG4vLyBzcmMvY29ubmVjdGlvbi50c1xuZnVuY3Rpb24gaXNJZGxlKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSBcImluaXRpYWxcIiB8fCBzdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCI7XG59XG5mdW5jdGlvbiB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSkge1xuICBjb25zdCBzdGF0ZSA9IG1hY2hpbmUuY3VycmVudFN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBcIkBvay5jb25uZWN0ZWRcIjpcbiAgICBjYXNlIFwiQG9rLmF3YWl0aW5nLXBvbmdcIjpcbiAgICAgIHJldHVybiBcImNvbm5lY3RlZFwiO1xuICAgIGNhc2UgXCJAaWRsZS5pbml0aWFsXCI6XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgY2FzZSBcIkBhdXRoLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGF1dGguYmFja29mZlwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5idXN5XCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGlkbGUuem9tYmllXCI6XG4gICAgICByZXR1cm4gbWFjaGluZS5jb250ZXh0LnN1Y2Nlc3NDb3VudCA+IDAgPyBcInJlY29ubmVjdGluZ1wiIDogXCJjb25uZWN0aW5nXCI7XG4gICAgY2FzZSBcIkBpZGxlLmZhaWxlZFwiOlxuICAgICAgcmV0dXJuIFwiZGlzY29ubmVjdGVkXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihzdGF0ZSwgXCJVbmtub3duIHN0YXRlXCIpO1xuICB9XG59XG52YXIgQkFDS09GRl9ERUxBWVMgPSBbMjUwLCA1MDAsIDFlMywgMmUzLCA0ZTMsIDhlMywgMWU0XTtcbnZhciBSRVNFVF9ERUxBWSA9IEJBQ0tPRkZfREVMQVlTWzBdIC0gMTtcbnZhciBCQUNLT0ZGX0RFTEFZU19TTE9XID0gWzJlMywgM2U0LCA2ZTQsIDNlNV07XG52YXIgSEVBUlRCRUFUX0lOVEVSVkFMID0gM2U0O1xudmFyIFBPTkdfVElNRU9VVCA9IDJlMztcbnZhciBBVVRIX1RJTUVPVVQgPSAxZTQ7XG52YXIgU09DS0VUX0NPTk5FQ1RfVElNRU9VVCA9IDFlNDtcbnZhciBTdG9wUmV0cnlpbmcgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIocmVhc29uKTtcbiAgfVxufTtcbnZhciBMaXZlYmxvY2tzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufTtcbmZ1bmN0aW9uIG5leHRCYWNrb2ZmRGVsYXkoY3VycmVudERlbGF5LCBkZWxheXMpIHtcbiAgcmV0dXJuIGRlbGF5cy5maW5kKChkZWxheSkgPT4gZGVsYXkgPiBjdXJyZW50RGVsYXkpID8/IGRlbGF5c1tkZWxheXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVMpXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHkoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHtcbiAgICBiYWNrb2ZmRGVsYXk6IG5leHRCYWNrb2ZmRGVsYXkoY29udGV4dC5iYWNrb2ZmRGVsYXksIEJBQ0tPRkZfREVMQVlTX1NMT1cpXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzZXRTdWNjZXNzQ291bnQoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiAwIH0pO1xufVxuZnVuY3Rpb24gbG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGxldmVsID09PSAyIC8qIEVSUk9SICovID8gZXJyb3IyIDogbGV2ZWwgPT09IDEgLyogV0FSTiAqLyA/IHdhcm4gOiAoXG4gICAgLyogYmxhY2sgaG9sZSAqL1xuICAgICgpID0+IHtcbiAgICB9XG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbG9nZ2VyKG1lc3NhZ2UpO1xuICB9O1xufVxuZnVuY3Rpb24gbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZSkge1xuICBjb25zdCBjb25uID0gXCJDb25uZWN0aW9uIHRvIExpdmVibG9ja3Mgd2Vic29ja2V0IHNlcnZlclwiO1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHdhcm4oYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLiAke1N0cmluZyhlKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgaXNDbG9zZUV2ZW50KGUpID8gYCR7Y29ubn0gY2xvc2VkIHByZW1hdHVyZWx5IChjb2RlOiAke2UuY29kZX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYCA6IGAke2Nvbm59IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ0Nsb3NlRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZGV0YWlscyA9IFtgY29kZTogJHtldmVudC5jb2RlfWBdO1xuICBpZiAoZXZlbnQucmVhc29uKSB7XG4gICAgZGV0YWlscy5wdXNoKGByZWFzb246ICR7ZXZlbnQucmVhc29ufWApO1xuICB9XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBDb25uZWN0aW9uIHRvIExpdmVibG9ja3Mgd2Vic29ja2V0IHNlcnZlciBjbG9zZWQgKCR7ZGV0YWlscy5qb2luKFwiLCBcIil9KS4gUmV0cnlpbmcgaW4gJHtjdHguYmFja29mZkRlbGF5fW1zLmBcbiAgICApO1xuICB9O1xufVxudmFyIGxvZ1Blcm1hbmVudENsb3NlID0gbG9nKFxuICAxIC8qIFdBUk4gKi8sXG4gIFwiQ29ubmVjdGlvbiB0byBXZWJTb2NrZXQgY2xvc2VkIHBlcm1hbmVudGx5LiBXb24ndCByZXRyeS5cIlxuKTtcbmZ1bmN0aW9uIGlzQ2xvc2VFdmVudChlcnJvcjMpIHtcbiAgcmV0dXJuICEoZXJyb3IzIGluc3RhbmNlb2YgRXJyb3IpICYmIGVycm9yMy50eXBlID09PSBcImNsb3NlXCI7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFjaW5nKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhcnQgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgZnVuY3Rpb24gbG9nMiguLi5hcmdzKSB7XG4gICAgd2FybihcbiAgICAgIGAkeygoKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyAxZTMpLnRvRml4ZWQoMil9IFtGU00gIyR7bWFjaGluZS5pZH1dYCxcbiAgICAgIC4uLmFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IHVuc3VicyA9IFtcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRSZWNlaXZlRXZlbnQuc3Vic2NyaWJlKChlKSA9PiBsb2cyKGBFdmVudCAke2UudHlwZX1gKSksXG4gICAgbWFjaGluZS5ldmVudHMud2lsbFRyYW5zaXRpb24uc3Vic2NyaWJlKFxuICAgICAgKHsgZnJvbSwgdG8gfSkgPT4gbG9nMihcIlRyYW5zaXRpb25pbmdcIiwgZnJvbSwgXCJcXHUyMTkyXCIsIHRvKVxuICAgICksXG4gICAgbWFjaGluZS5ldmVudHMuZGlkSWdub3JlRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGUpID0+IGxvZzIoXCJJZ25vcmVkIGV2ZW50XCIsIGUudHlwZSwgZSwgXCIoY3VycmVudCBzdGF0ZSB3b24ndCBoYW5kbGUgaXQpXCIpXG4gICAgKVxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLndpbGxFeGl0U3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFeGl0aW5nIHN0YXRlXCIsIHMpKSxcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRW50ZXJpbmcgc3RhdGVcIiwgcykpLFxuICBdO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgICB1bnN1YigpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXR1c0RpZENoYW5nZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWRDb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZERpc2Nvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgbGV0IGxhc3RTdGF0dXMgPSBudWxsO1xuICBjb25zdCB1bnN1YnNjcmliZSA9IG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCBjdXJyU3RhdHVzID0gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpO1xuICAgIGlmIChjdXJyU3RhdHVzICE9PSBsYXN0U3RhdHVzKSB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2Uubm90aWZ5KGN1cnJTdGF0dXMpO1xuICAgIH1cbiAgICBpZiAobGFzdFN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWREaXNjb25uZWN0Lm5vdGlmeSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdFN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWRDb25uZWN0Lm5vdGlmeSgpO1xuICAgIH1cbiAgICBsYXN0U3RhdHVzID0gY3VyclN0YXR1cztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzRGlkQ2hhbmdlOiBzdGF0dXNEaWRDaGFuZ2Uub2JzZXJ2YWJsZSxcbiAgICBkaWRDb25uZWN0OiBkaWRDb25uZWN0Lm9ic2VydmFibGUsXG4gICAgZGlkRGlzY29ubmVjdDogZGlkRGlzY29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIHVuc3Vic2NyaWJlXG4gIH07XG59XG52YXIgYXNzaWduID0gKHBhdGNoKSA9PiAoY3R4KSA9PiBjdHgucGF0Y2gocGF0Y2gpO1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShkZWxlZ2F0ZXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb25NZXNzYWdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIG9uTWVzc2FnZS5wYXVzZSgpO1xuICBjb25zdCBvbkxpdmVibG9ja3NFcnJvciA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBmaXJlRXJyb3JFdmVudChlcnJtc2csIGVycmNvZGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gbmV3IExpdmVibG9ja3NFcnJvcihlcnJtc2csIGVycmNvZGUpO1xuICAgICAgb25MaXZlYmxvY2tzRXJyb3Iubm90aWZ5KGVycik7XG4gICAgfTtcbiAgfVxuICBjb25zdCBpbml0aWFsQ29udGV4dCA9IHtcbiAgICBzdWNjZXNzQ291bnQ6IDAsXG4gICAgYXV0aFZhbHVlOiBudWxsLFxuICAgIHNvY2tldDogbnVsbCxcbiAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gIH07XG4gIGNvbnN0IG1hY2hpbmUgPSBuZXcgRlNNKGluaXRpYWxDb250ZXh0KS5hZGRTdGF0ZShcIkBpZGxlLmluaXRpYWxcIikuYWRkU3RhdGUoXCJAaWRsZS5mYWlsZWRcIikuYWRkU3RhdGUoXCJAaWRsZS56b21iaWVcIikuYWRkU3RhdGUoXCJAYXV0aC5idXN5XCIpLmFkZFN0YXRlKFwiQGF1dGguYmFja29mZlwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJ1c3lcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQG9rLmNvbm5lY3RlZFwiKS5hZGRTdGF0ZShcIkBvay5hd2FpdGluZy1wb25nXCIpO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiKlwiLCB7XG4gICAgUkVDT05ORUNUOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIHJlc2V0U3VjY2Vzc0NvdW50XVxuICAgIH0sXG4gICAgRElTQ09OTkVDVDogXCJAaWRsZS5pbml0aWFsXCJcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBpZGxlLipcIiwgcmVzZXRTdWNjZXNzQ291bnQpLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuKlwiLCB7XG4gICAgQ09OTkVDVDogKF8sIGN0eCkgPT4gKFxuICAgICAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSBhIGtub3duIGF1dGhWYWx1ZSwgdHJ5IHRvIHJlY29ubmVjdCB0byB0aGUgc29ja2V0IGRpcmVjdGx5LFxuICAgICAgLy8gb3RoZXJ3aXNlLCB0cnkgdG8gb2J0YWluIGEgbmV3IGF1dGhWYWx1ZVxuICAgICAgY3R4LmF1dGhWYWx1ZSAhPT0gbnVsbCA/IFwiQGNvbm5lY3RpbmcuYnVzeVwiIDogXCJAYXV0aC5idXN5XCJcbiAgICApXG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGF1dGguYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGF1dGguYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAYXV0aC5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAYXV0aC5idXN5XCIsXG4gICAgKCkgPT4gd2l0aFRpbWVvdXQoXG4gICAgICBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCksXG4gICAgICBBVVRIX1RJTUVPVVQsXG4gICAgICBcIlRpbWVkIG91dCBkdXJpbmcgYXV0aFwiXG4gICAgKSxcbiAgICAvLyBPbiBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBhdXRoVmFsdWU6IG9rRXZlbnQuZGF0YVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBBdXRoIGZhaWxlZFxuICAgIChmYWlsZWRFdmVudCkgPT4ge1xuICAgICAgaWYgKGZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXksXG4gICAgICAgICAgbG9nKFxuICAgICAgICAgICAgMiAvKiBFUlJPUiAqLyxcbiAgICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSA6IFN0cmluZyhmYWlsZWRFdmVudC5yZWFzb24pfWBcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBvblNvY2tldEVycm9yID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9FUlJPUlwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRDbG9zZSA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0TWVzc2FnZSA9IChldmVudCkgPT4gZXZlbnQuZGF0YSA9PT0gXCJwb25nXCIgPyBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlBPTkdcIiB9KSA6IG9uTWVzc2FnZS5ub3RpZnkoZXZlbnQpO1xuICBmdW5jdGlvbiB0ZWFyZG93blNvY2tldChzb2NrZXQpIHtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvL1xuICAgIC8vIFVzZSB0aGUgXCJjcmVhdGVTb2NrZXRcIiBkZWxlZ2F0ZSBmdW5jdGlvbiAocHJvdmlkZWQgdG8gdGhlXG4gICAgLy8gTWFuYWdlZFNvY2tldCkgdG8gY3JlYXRlIHRoZSBhY3R1YWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgLy8gVGhlbiwgc2V0IHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycywgYW5kIHdhaXQgZm9yIHRoZVxuICAgIC8vIFwib3BlblwiIGV2ZW50IHRvIG9jY3VyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgXCJvcGVuXCIgZXZlbnQgaGFwcGVucywgd2UncmUgcmVhZHkgdG8gdHJhbnNpdGlvbiB0byB0aGVcbiAgICAvLyBPSyBzdGF0ZS4gVGhpcyBpcyBkb25lIGJ5IHJlc29sdmluZyB0aGUgUHJvbWlzZS5cbiAgICAvL1xuICAgIGFzeW5jIChjdHgsIHNpZ25hbCkgPT4ge1xuICAgICAgbGV0IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBudWxsO1xuICAgICAgbGV0IHVuY29uZmlybWVkU29ja2V0ID0gbnVsbDtcbiAgICAgIGNvbnN0IGNvbm5lY3QkID0gbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlLCByZWopID0+IHtcbiAgICAgICAgICBpZiAoY3R4LmF1dGhWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCBhdXRoVmFsdWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNvY2tldCA9IGRlbGVnYXRlcy5jcmVhdGVTb2NrZXQoY3R4LmF1dGhWYWx1ZSk7XG4gICAgICAgICAgdW5jb25maXJtZWRTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGV2ZW50KSB7XG4gICAgICAgICAgICBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlaihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFthY3RvciQsIGRpZFJlY2VpdmVBY3Rvcl0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICAgICAgICAgIGlmICghb3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JBY3RvcklkKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJNc2cgPSB0cnlQYXJzZUpzb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAoc2VydmVyTXNnPy50eXBlID09PSAxMDQgLyogUk9PTV9TVEFURSAqLykge1xuICAgICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZvaWQgYWN0b3IkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKFtzb2NrZXQsIHVuc3ViXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB3aXRoVGltZW91dChcbiAgICAgICAgY29ubmVjdCQsXG4gICAgICAgIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQsXG4gICAgICAgIFwiVGltZWQgb3V0IGR1cmluZyB3ZWJzb2NrZXQgY29ubmVjdGlvblwiXG4gICAgICApLnRoZW4oXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnQgMzpcbiAgICAgICAgLy8gQnkgbm93LCBvdXIgXCJvcGVuXCIgZXZlbnQgaGFzIGZpcmVkLCBhbmQgdGhlIHByb21pc2UgaGFzIGJlZW5cbiAgICAgICAgLy8gcmVzb2x2ZWQuIFR3byBwb3NzaWJsZSBzY2VuYXJpb3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIFRoZSBoYXBweSBwYXRoLiBNb3N0IGxpa2VseS5cbiAgICAgICAgLy8gMi4gVWgtb2guIEEgcHJlbWF0dXJlIGNsb3NlL2Vycm9yIGV2ZW50IGhhcyBiZWVuIG9ic2VydmVkLiBMZXQnc1xuICAgICAgICAvLyAgICByZWplY3QgdGhlIHByb21pc2UgYWZ0ZXIgYWxsLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbnkgY2xvc2UvZXJyb3IgZXZlbnQgdGhhdCB3aWxsIGdldCBzY2hlZHVsZWQgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBvbndhcmRzLCB3aWxsIGJlIGNhdWdodCBpbiB0aGUgT0sgc3RhdGUsIGFuZCBkZWFsdCB3aXRoXG4gICAgICAgIC8vIGFjY29yZGluZ2x5LlxuICAgICAgICAvL1xuICAgICAgICAoW3NvY2tldCwgdW5zdWJdKSA9PiB7XG4gICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFib3J0ZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXB0dXJlZFByZW1hdHVyZUV2ZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBjYXB0dXJlZFByZW1hdHVyZUV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9XG4gICAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KHVuY29uZmlybWVkU29ja2V0KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gT25seSB0cmFuc2l0aW9uIHRvIE9LIHN0YXRlIGFmdGVyIGEgc3VjY2Vzc2Z1bGx5IG9wZW5lZCBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBvay5jb25uZWN0ZWRcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgc29ja2V0OiBva0V2ZW50LmRhdGEsXG4gICAgICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZFxuICAgIChmYWlsdXJlKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBmYWlsdXJlLnJlYXNvbjtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3NlRXZlbnQoZXJyKSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LFxuICAgICAgICAgICAgICBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIucmVhc29uKSxcbiAgICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLnJlYXNvbiwgZXJyLmNvZGUpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycildXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgc2VuZEhlYXJ0YmVhdCA9IHtcbiAgICB0YXJnZXQ6IFwiQG9rLmF3YWl0aW5nLXBvbmdcIixcbiAgICBlZmZlY3Q6IChjdHgpID0+IHtcbiAgICAgIGN0eC5zb2NrZXQ/LnNlbmQoXCJwaW5nXCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWF5YmVIZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FuWm9tYmllID0gZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIgJiYgZGVsZWdhdGVzLmNhblpvbWJpZSgpO1xuICAgIHJldHVybiBjYW5ab21iaWUgPyBcIkBpZGxlLnpvbWJpZVwiIDogc2VuZEhlYXJ0YmVhdDtcbiAgfTtcbiAgbWFjaGluZS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suY29ubmVjdGVkXCIsIEhFQVJUQkVBVF9JTlRFUlZBTCwgbWF5YmVIZWFydGJlYXQpLmFkZFRyYW5zaXRpb25zKFwiQG9rLmNvbm5lY3RlZFwiLCB7XG4gICAgTkFWSUdBVE9SX09GRkxJTkU6IG1heWJlSGVhcnRiZWF0LFxuICAgIC8vIERvbid0IHRha2UgdGhlIGJyb3dzZXIncyB3b3JkIGZvciBpdCB3aGVuIGl0IHNheXMgaXQncyBvZmZsaW5lLiBEbyBhIHBpbmcvcG9uZyB0byBtYWtlIHN1cmUuXG4gICAgV0lORE9XX0dPVF9GT0NVUzogc2VuZEhlYXJ0YmVhdFxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLnpvbWJpZVwiLCB7XG4gICAgV0lORE9XX0dPVF9GT0NVUzogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCJcbiAgICAvLyBXaGVuIGluIHpvbWJpZSBzdGF0ZSwgdGhlIGNsaWVudCB3aWxsIHRyeSB0byB3YWtlIHVwIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBvay4qXCIsIChjdHgpID0+IHtcbiAgICBjdHgucGF0Y2goeyBzdWNjZXNzQ291bnQ6IGN0eC5zdWNjZXNzQ291bnQgKyAxIH0pO1xuICAgIGNvbnN0IHRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgLy8gT24gdGhlIG5leHQgdGljaywgc3RhcnQgZGVsaXZlcmluZyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGFscmVhZHlcbiAgICAgIC8vIGJlZW4gcmVjZWl2ZWQsIGFuZCBjb250aW51ZSBzeW5jaHJvbm91cyBkZWxpdmVyeSBvZiBhbGwgZnV0dXJlXG4gICAgICAvLyBpbmNvbWluZyBtZXNzYWdlcy5cbiAgICAgIG9uTWVzc2FnZS51bnBhdXNlLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIChjdHgyKSA9PiB7XG4gICAgICB0ZWFyZG93blNvY2tldChjdHgyLnNvY2tldCk7XG4gICAgICBjdHgyLnBhdGNoKHsgc29ja2V0OiBudWxsIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgICAgb25NZXNzYWdlLnBhdXNlKCk7XG4gICAgfTtcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suYXdhaXRpbmctcG9uZ1wiLCB7IFBPTkc6IFwiQG9rLmNvbm5lY3RlZFwiIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5hd2FpdGluZy1wb25nXCIsIFBPTkdfVElNRU9VVCwge1xuICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy8gTG9nIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcyBhbmQgZHJvcCB0aGUgY3VycmVudCBvcGVuIHNvY2tldFxuICAgIGVmZmVjdDogbG9nKFxuICAgICAgMSAvKiBXQVJOICovLFxuICAgICAgXCJSZWNlaXZlZCBubyBwb25nIGZyb20gc2VydmVyLCBhc3N1bWUgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzLlwiXG4gICAgKVxuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay4qXCIsIHtcbiAgICAvLyBXaGVuIGEgc29ja2V0IHJlY2VpdmVzIGFuIGVycm9yLCB0aGlzIGNhbiBjYXVzZSB0aGUgY2xvc2luZyBvZiB0aGVcbiAgICAvLyBzb2NrZXQsIG9yIG5vdC4gU28gYWx3YXlzIGNoZWNrIHRvIHNlZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIE9QRU4gb3JcbiAgICAvLyBub3QuIFdoZW4gc3RpbGwgT1BFTiwgZG9uJ3QgdHJhbnNpdGlvbi5cbiAgICBFWFBMSUNJVF9TT0NLRVRfRVJST1I6IChfLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5zb2NrZXQ/LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IGluY3JlYXNlQmFja29mZkRlbGF5XG4gICAgICB9O1xuICAgIH0sXG4gICAgRVhQTElDSVRfU09DS0VUX0NMT1NFOiAoZSkgPT4ge1xuICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZ1Blcm1hbmVudENsb3NlLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZS5ldmVudC5yZWFzb24sIGUuZXZlbnQuY29kZSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgaWYgKGUuZXZlbnQuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgICBjb25zdCByb290ID0gd2luID8/IGRvYztcbiAgICBtYWNoaW5lLm9uRW50ZXIoXCIqXCIsIChjdHgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya09mZmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09GRkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya0JhY2tPbmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09OTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJXSU5ET1dfR09UX0ZPQ1VTXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICByb290Py5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcm9vdD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgICB0ZWFyZG93blNvY2tldChjdHguc29ja2V0KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgeyBzdGF0dXNEaWRDaGFuZ2UsIGRpZENvbm5lY3QsIGRpZERpc2Nvbm5lY3QsIHVuc3Vic2NyaWJlIH0gPSBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSk7XG4gIGNsZWFudXBzLnB1c2godW5zdWJzY3JpYmUpO1xuICBpZiAob3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcpIHtcbiAgICBjbGVhbnVwcy5wdXNoKGVuYWJsZVRyYWNpbmcobWFjaGluZSkpO1xuICB9XG4gIG1hY2hpbmUuc3RhcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBtYWNoaW5lLFxuICAgIGNsZWFudXBzLFxuICAgIC8vIE9ic2VydmFibGUgZXZlbnRzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoaXMgbWFjaGluZVxuICAgIGV2ZW50czoge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLFxuICAgICAgZGlkQ29ubmVjdCxcbiAgICAgIGRpZERpc2Nvbm5lY3QsXG4gICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZS5vYnNlcnZhYmxlLFxuICAgICAgb25MaXZlYmxvY2tzRXJyb3I6IG9uTGl2ZWJsb2Nrc0Vycm9yLm9ic2VydmFibGVcbiAgICB9XG4gIH07XG59XG52YXIgTWFuYWdlZFNvY2tldCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGVsZWdhdGVzLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgPSBmYWxzZSwgd2FpdEZvckFjdG9ySWQgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBtYWNoaW5lLCBldmVudHMsIGNsZWFudXBzIH0gPSBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKFxuICAgICAgZGVsZWdhdGVzLFxuICAgICAgeyB3YWl0Rm9yQWN0b3JJZCwgZW5hYmxlRGVidWdMb2dnaW5nIH1cbiAgICApO1xuICAgIHRoaXMubWFjaGluZSA9IG1hY2hpbmU7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5jbGVhbnVwcyA9IGNsZWFudXBzO1xuICB9XG4gIGdldFN0YXR1cygpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRvTmV3Q29ubmVjdGlvblN0YXR1cyh0aGlzLm1hY2hpbmUpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBhdXRoIGF1dGhWYWx1ZS5cbiAgICovXG4gIGdldCBhdXRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFjaGluZS5jb250ZXh0LmF1dGhWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byB0cnkgdG8gY29ubmVjdCB0byBhIFdlYlNvY2tldC4gVGhpcyBvbmx5IGhhcyBhbiBlZmZlY3RcbiAgICogaWYgdGhlIG1hY2hpbmUgaXMgaWRsZSBhdCB0aGUgbW9tZW50LCBvdGhlcndpc2UgdGhpcyBpcyBhIG5vLW9wLlxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJZiBpZGxlLCB3aWxsIHRyeSB0byBjb25uZWN0LiBPdGhlcndpc2UsIGl0IHdpbGwgYXR0ZW1wdCB0byByZWNvbm5lY3QgdG9cbiAgICogdGhlIHNvY2tldCwgcG90ZW50aWFsbHkgb2J0YWluaW5nIGEgbmV3IGF1dGhWYWx1ZSBmaXJzdCwgaWYgbmVlZGVkLlxuICAgKi9cbiAgcmVjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJSRUNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byBkaXNjb25uZWN0IGZyb20gdGhlIGN1cnJlbnQgV2ViU29ja2V0LiBJcyBnb2luZyB0byBiZVxuICAgKiBhIG5vLW9wIGlmIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRElTQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gc3RvcCB0aGUgbWFjaGluZSBhbmQgcnVuIG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy4gQWZ0ZXJcbiAgICogY2FsbGluZyBkZXN0cm95KCksIHlvdSBjYW4gbm8gbG9uZ2VyIHVzZSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXMgYmVmb3JlXG4gICAqIGxldHRpbmcgdGhlIGluc3RhbmNlIGdldCBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tYWNoaW5lLnN0b3AoKTtcbiAgICBsZXQgY2xlYW51cDtcbiAgICB3aGlsZSAoY2xlYW51cCA9IHRoaXMuY2xlYW51cHMucG9wKCkpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNhZmVseSBzZW5kIGEgbWVzc2FnZSB0byB0aGUgY3VycmVudCBXZWJTb2NrZXQgY29ubmVjdGlvbi4gV2lsbCBlbWl0IGEgbG9nXG4gICAqIG1lc3NhZ2UgaWYgdGhpcyBpcyBzb21laG93IGltcG9zc2libGUuXG4gICAqL1xuICBzZW5kKGRhdGEpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm1hY2hpbmUuY29udGV4dD8uc29ja2V0O1xuICAgIGlmIChzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogbm90IGNvbm5lY3RlZCB5ZXRcIiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gMSkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBXZWJTb2NrZXQgbm8gbG9uZ2VyIG9wZW5cIiwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTk9URTogVXNlZCBieSB0aGUgRTJFIGFwcCBvbmx5LCB0byBzaW11bGF0ZSBleHBsaWNpdCBldmVudHMuXG4gICAqIE5vdCBpZGVhbCB0byBrZWVwIGV4cG9zZWQgOihcbiAgICovXG4gIF9wcml2YXRlU2VuZE1hY2hpbmVFdmVudChldmVudCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKGV2ZW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL0F1dGhUb2tlbi50c1xuZnVuY3Rpb24gY2FuV3JpdGVTdG9yYWdlKHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbW1lbnQoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQXV0aFRva2VuUGF5bG9hZChkYXRhKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGRhdGEpICYmIChkYXRhLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovIHx8IGRhdGEuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovIHx8IGRhdGEuayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyk7XG59XG5mdW5jdGlvbiBwYXJzZUF1dGhUb2tlbihyYXdUb2tlblN0cmluZykge1xuICBjb25zdCB0b2tlblBhcnRzID0gcmF3VG9rZW5TdHJpbmcuc3BsaXQoXCIuXCIpO1xuICBpZiAodG9rZW5QYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogaW52YWxpZCBKV1QgdG9rZW5cIik7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IHRyeVBhcnNlSnNvbihiNjRkZWNvZGUodG9rZW5QYXJ0c1sxXSkpO1xuICBpZiAoIShwYXlsb2FkICYmIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKHBheWxvYWQpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQXV0aGVudGljYXRpb24gZXJyb3I6IGV4cGVjdGVkIGEgdmFsaWQgdG9rZW4gYnV0IGRpZCBub3QgZ2V0IG9uZS4gSGludDogaWYgeW91IGFyZSB1c2luZyBhIGNhbGxiYWNrLCBlbnN1cmUgdGhlIHJvb20gaXMgcGFzc2VkIHdoZW4gY3JlYXRpbmcgdGhlIHRva2VuLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRDYWxsYmFja1wiXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJhdzogcmF3VG9rZW5TdHJpbmcsXG4gICAgcGFyc2VkOiBwYXlsb2FkXG4gIH07XG59XG5cbi8vIHNyYy9hdXRoLW1hbmFnZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUF1dGhNYW5hZ2VyKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IGF1dGhlbnRpY2F0aW9uID0gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKTtcbiAgY29uc3Qgc2VlblRva2VucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBleHBpcnlUaW1lcyA9IFtdO1xuICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBzZWVuVG9rZW5zLmNsZWFyKCk7XG4gICAgdG9rZW5zLmxlbmd0aCA9IDA7XG4gICAgZXhwaXJ5VGltZXMubGVuZ3RoID0gMDtcbiAgICByZXF1ZXN0UHJvbWlzZXMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RlZFNjb3BlLCBzY29wZXMpIHtcbiAgICBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwiY29tbWVudHM6cmVhZFwiKSB7XG4gICAgICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6cmVhZFwiIC8qIENvbW1lbnRzUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwicm9vbTpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpIHtcbiAgICBjb25zdCBub3cgPSBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgZm9yIChsZXQgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBleHBpcnlUaW1lc1tpXTtcbiAgICAgIGlmIChleHBpcmVzQXQgPD0gbm93KSB7XG4gICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGV4cGlyeVRpbWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCAmJiBPYmplY3QuZW50cmllcyh0b2tlbi5wYXJzZWQucGVybXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtyZXNvdXJjZSwgc2NvcGVzXSBvZiBPYmplY3QuZW50cmllcyh0b2tlbi5wYXJzZWQucGVybXMpKSB7XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgcmVxdWVzdE9wdGlvbnMucm9vbUlkLnN0YXJ0c1dpdGgocmVzb3VyY2UucmVwbGFjZShcIipcIiwgXCJcIikpIHx8IHJlcXVlc3RPcHRpb25zLnJvb21JZCA9PT0gcmVzb3VyY2UgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1ha2VBdXRoUmVxdWVzdChvcHRpb25zKSB7XG4gICAgY29uc3QgZmV0Y2hlciA9IGF1dGhPcHRpb25zLnBvbHlmaWxscz8uZmV0Y2ggPz8gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiB3aW5kb3cuZmV0Y2gpO1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInByaXZhdGVcIikge1xuICAgICAgaWYgKGZldGNoZXIgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCB3aXRoIGEgdXJsIGFzIGF1dGggZW5kcG9pbnQsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBmZXRjaCBwb2x5ZmlsbC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEF1dGhFbmRwb2ludChmZXRjaGVyLCBhdXRoZW50aWNhdGlvbi51cmwsIHtcbiAgICAgICAgcm9vbTogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgaWYgKHNlZW5Ub2tlbnMuaGFzKHBhcnNlZC5yYXcpKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUaGUgc2FtZSBMaXZlYmxvY2tzIGF1dGggdG9rZW4gd2FzIGlzc3VlZCBmcm9tIHRoZSBiYWNrZW5kIGJlZm9yZS4gQ2FjaGluZyBMaXZlYmxvY2tzIHRva2VucyBpcyBub3Qgc3VwcG9ydGVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGlvbi5jYWxsYmFjayhvcHRpb25zLnJvb21JZCk7XG4gICAgICBpZiAocmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UudG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke1wicmVhc29uXCIgaW4gcmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlLnJlYXNvbiA9PT0gXCJzdHJpbmdcIiA/IHJlc3BvbnNlLnJlYXNvbiA6IFwiRm9yYmlkZGVuXCJ9YDtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IgPT09IFwiZm9yYmlkZGVuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcocmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3VyIGF1dGhlbnRpY2F0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSB0b2tlbiwgYnV0IGl0IGRpZCBub3QuIEhpbnQ6IHRoZSByZXR1cm4gdmFsdWUgc2hvdWxkIGxvb2sgbGlrZTogeyB0b2tlbjogXCIuLi5cIiB9J1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJVbmV4cGVjdGVkIGF1dGhlbnRpY2F0aW9uIHR5cGUuIE11c3QgYmUgcHJpdmF0ZSBvciBjdXN0b20uXCJcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEF1dGhWYWx1ZShyZXF1ZXN0T3B0aW9ucykge1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInB1YmxpY1wiLCBwdWJsaWNBcGlLZXk6IGF1dGhlbnRpY2F0aW9uLnB1YmxpY0FwaUtleSB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRUb2tlbiA9IGdldENhY2hlZFRva2VuKHJlcXVlc3RPcHRpb25zKTtcbiAgICBpZiAoY2FjaGVkVG9rZW4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW46IGNhY2hlZFRva2VuIH07XG4gICAgfVxuICAgIGxldCBjdXJyZW50UHJvbWlzZTtcbiAgICBpZiAocmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQocmVxdWVzdE9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChjdXJyZW50UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlID0gbWFrZUF1dGhSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLnNldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZXMuZ2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgY3VycmVudFByb21pc2U7XG4gICAgICBjb25zdCBCVUZGRVIgPSAzMDtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykgKyAodG9rZW4ucGFyc2VkLmV4cCAtIHRva2VuLnBhcnNlZC5pYXQpIC0gQlVGRkVSO1xuICAgICAgc2VlblRva2Vucy5hZGQodG9rZW4ucmF3KTtcbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayAhPT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLykge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGV4cGlyeVRpbWVzLnB1c2goZXhwaXJlc0F0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShcImxpdmVibG9ja3MtdXNlci10b2tlblwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNldCxcbiAgICBnZXRBdXRoVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVBdXRoZW50aWNhdGlvbihhdXRoT3B0aW9ucykge1xuICBjb25zdCB7IHB1YmxpY0FwaUtleSwgYXV0aEVuZHBvaW50IH0gPSBhdXRoT3B0aW9ucztcbiAgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwICYmIHB1YmxpY0FwaUtleSAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IHNpbXVsdGFuZW91c2x5IHVzZSBgcHVibGljQXBpS2V5YCBhbmQgYGF1dGhFbmRwb2ludGAgb3B0aW9ucy4gUGxlYXNlIHBpY2sgb25lIGFuZCBsZWF2ZSB0aGUgb3RoZXIgb3B0aW9uIHVuc3BlY2lmaWVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwdWJsaWNBcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJza19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGBwdWJsaWNBcGlLZXlgIG9wdGlvbi4gVGhlIHZhbHVlIHlvdSBwYXNzZWQgaXMgYSBzZWNyZXQga2V5LCB3aGljaCBzaG91bGQgbm90IGJlIHVzZWQgZnJvbSB0aGUgY2xpZW50LiBQbGVhc2Ugb25seSBldmVyIHBhc3MgYSBwdWJsaWMga2V5IGhlcmUuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIXB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwicGtfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBrZXkuIFBsZWFzZSB1c2UgdGhlIHB1YmxpYyBrZXkgZm9ybWF0OiBwa188cHVibGljIGtleT4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwdWJsaWNcIixcbiAgICAgIHB1YmxpY0FwaUtleVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwcml2YXRlXCIsXG4gICAgICB1cmw6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICBjYWxsYmFjazogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIGBhdXRoRW5kcG9pbnRgIG9wdGlvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudEF1dGhFbmRwb2ludFwiXG4gICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJJbnZhbGlkIExpdmVibG9ja3MgY2xpZW50IG9wdGlvbnMuIFBsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBwdWJsaWNBcGlLZXlgIG9yIGBhdXRoRW5kcG9pbnRgIG9wdGlvbi4gVGhleSBjYW5ub3QgYm90aCBiZSBlbXB0eS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQXV0aEVuZHBvaW50KGZldGNoMiwgZW5kcG9pbnQsIGJvZHkpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2gyKGVuZHBvaW50LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgcmVhc29uID0gYCR7KGF3YWl0IHJlcy50ZXh0KCkpLnRyaW0oKSB8fCBcInJlYXNvbiBub3QgcHJvdmlkZWQgaW4gYXV0aCByZXNwb25zZVwifSAoJHtyZXMuc3RhdHVzfSByZXR1cm5lZCBieSBQT1NUICR7ZW5kcG9pbnR9KWA7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSB8fCByZXMuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoYFVuYXV0aG9yaXplZDogJHtyZWFzb259YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZTogJHtyZWFzb259YCk7XG4gICAgfVxuICB9XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIuICR7U3RyaW5nKFxuICAgICAgICBlclxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkgfHwgdHlwZW9mIGRhdGEudG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIG9mIHRoZSBmb3JtIFxcYHsgdG9rZW46IFwiLi4uXCIgfVxcYCB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIiwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBkYXRhXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRhdGE7XG4gIHJldHVybiB7IHRva2VuIH07XG59XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5saXZlYmxvY2tzLmlvXCI7XG5cbi8vIHNyYy9pbnRlcm5hbC50c1xudmFyIGtJbnRlcm5hbCA9IFN5bWJvbCgpO1xuXG4vLyBzcmMvZGV2dG9vbHMvYnJpZGdlLnRzXG52YXIgX2JyaWRnZUFjdGl2ZSA9IGZhbHNlO1xuZnVuY3Rpb24gYWN0aXZhdGVCcmlkZ2UoYWxsb3dlZCkge1xuICBfYnJpZGdlQWN0aXZlID0gYWxsb3dlZDtcbn1cbmZ1bmN0aW9uIHNlbmRUb1BhbmVsKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZ1bGxNc2cgPSB7XG4gICAgLi4ubWVzc2FnZSxcbiAgICBzb3VyY2U6IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1jbGllbnRcIlxuICB9O1xuICBpZiAoIShvcHRpb25zPy5mb3JjZSB8fCBfYnJpZGdlQWN0aXZlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cucG9zdE1lc3NhZ2UoZnVsbE1zZywgXCIqXCIpO1xufVxudmFyIGV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhPy5zb3VyY2UgPT09IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1wYW5lbFwiKSB7XG4gICAgICBldmVudFNvdXJjZS5ub3RpZnkoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9uTWVzc2FnZUZyb21QYW5lbCA9IGV2ZW50U291cmNlLm9ic2VydmFibGU7XG5cbi8vIHNyYy9kZXZ0b29scy9pbmRleC50c1xudmFyIFZFUlNJT04gPSBQS0dfVkVSU0lPTiB8fCBcImRldlwiO1xudmFyIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cERldlRvb2xzKGdldEFsbFJvb21zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoX2RldnRvb2xzU2V0dXBIYXNSdW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSB0cnVlO1xuICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgIGNhc2UgXCJjb25uZWN0XCI6IHtcbiAgICAgICAgYWN0aXZhdGVCcmlkZ2UodHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIGdldEFsbFJvb21zKCkpIHtcbiAgICAgICAgICBzZW5kVG9QYW5lbCh7XG4gICAgICAgICAgICBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiBWRVJTSU9OXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwid2FrZS11cC1kZXZ0b29sc1wiIH0sIHsgZm9yY2U6IHRydWUgfSk7XG59XG52YXIgdW5zdWJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFN5bmNTdHJlYW0ocm9vbUlkKSB7XG4gIGNvbnN0IHVuc3VicyA9IHVuc3Vic0J5Um9vbUlkLmdldChyb29tSWQpID8/IFtdO1xuICB1bnN1YnNCeVJvb21JZC5kZWxldGUocm9vbUlkKTtcbiAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICB1bnN1YigpO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFN5bmNTdHJlYW0ocm9vbSkge1xuICBzdG9wU3luY1N0cmVhbShyb29tLmlkKTtcbiAgZnVsbFN5bmMocm9vbSk7XG4gIHVuc3Vic0J5Um9vbUlkLnNldChyb29tLmlkLCBbXG4gICAgLy8gV2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pKSxcbiAgICAvLyBXaGVuIHN0b3JhZ2UgaW5pdGlhbGl6ZXMsIHNlbmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBzdG9yYWdlIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyBzdG9yYWdlIHJvb3RcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgXCJtZVwiIG9yIFwib3RoZXJzXCIgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHZhbHVlcyBhY2NvcmRpbmdseVxuICAgIHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jTWUocm9vbSkpLFxuICAgIHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHlkb2MgaXMgdXBkYXRlZCwgZm9yd2FyZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMueWRvYy5zdWJzY3JpYmUoKHVwZGF0ZSkgPT4gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSksXG4gICAgLy8gQW55IHRpbWUgYSBjdXN0b20gcm9vbSBldmVudCBpcyByZWNlaXZlZCwgZm9yd2FyZCBpdFxuICAgIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChldmVudERhdGEpID0+IGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpXG4gICAgKVxuICBdKTtcbn1cbmZ1bmN0aW9uIHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6Onlkb2NcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgdXBkYXRlXG4gIH0pO1xufVxudmFyIGxvYWRlZEF0ID0gRGF0ZS5ub3coKTtcbnZhciBldmVudENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbmV4dEV2ZW50SWQoKSB7XG4gIHJldHVybiBgZXZlbnQtJHtsb2FkZWRBdH0tJHtldmVudENvdW50ZXIrK31gO1xufVxuZnVuY3Rpb24gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OmV2ZW50czo6Y3VzdG9tLWV2ZW50XCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBcIkN1c3RvbUV2ZW50XCIsXG4gICAgICBpZDogbmV4dEV2ZW50SWQoKSxcbiAgICAgIGtleTogXCJFdmVudFwiLFxuICAgICAgY29ubmVjdGlvbklkOiBldmVudERhdGEuY29ubmVjdGlvbklkLFxuICAgICAgcGF5bG9hZDogZXZlbnREYXRhLmV2ZW50XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKClcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgaWYgKHJvb3QpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgc3RvcmFnZTogcm9vdC50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jTWUocm9vbSkge1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGlmIChtZSkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBtZVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY090aGVycyhyb29tKSB7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG90aGVycykge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBvdGhlcnNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZnVsbFN5bmMocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgY29uc3QgbWUgPSByb29tW2tJbnRlcm5hbF0uZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBjb25zdCBvdGhlcnMgPSByb29tW2tJbnRlcm5hbF0uZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIHJvb20uZmV0Y2hZRG9jKFwiXCIpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OmZ1bGxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpLFxuICAgIHN0b3JhZ2U6IHJvb3Q/LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWQgPz8gbnVsbCxcbiAgICBtZSxcbiAgICBvdGhlcnNcbiAgfSk7XG59XG52YXIgcm9vbUNoYW5uZWxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZ2V0KHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLmRlbGV0ZShyb29tSWQpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBsaW5rRGV2VG9vbHMocm9vbUlkLCByb29tKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJyb29tOjphdmFpbGFibGVcIiwgcm9vbUlkLCBjbGllbnRWZXJzaW9uOiBWRVJTSU9OIH0pO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5zZXQoXG4gICAgcm9vbUlkLFxuICAgIC8vIFJldHVybnMgdGhlIHVuc3Vic2NyaWJlIGNhbGxiYWNrLCB0aGF0IHdlIHN0b3JlIGluIHRoZVxuICAgIC8vIHJvb21DaGFubmVsTGlzdGVuZXJzIHJlZ2lzdHJ5XG4gICAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgICAgY2FzZSBcInJvb206OnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RhcnRTeW5jU3RyZWFtKHJvb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicm9vbTo6dW5zdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHVubGlua0RldlRvb2xzKHJvb21JZCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjp1bmF2YWlsYWJsZVwiLFxuICAgIHJvb21JZFxuICB9KTtcbn1cblxuLy8gc3JjL2xpYi9zdHJpbmdpZnkudHNcbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmplY3QsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgfHwgb2JqZWN0ID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmplY3QsIC4uLmFyZ3MpO1xuICB9XG4gIGNvbnN0IHNvcnRlZE9iamVjdCA9IE9iamVjdC5rZXlzKG9iamVjdCkuc29ydCgpLnJlZHVjZShcbiAgICAoc29ydGVkT2JqZWN0Miwga2V5KSA9PiB7XG4gICAgICBzb3J0ZWRPYmplY3QyW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgIHJldHVybiBzb3J0ZWRPYmplY3QyO1xuICAgIH0sXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNvcnRlZE9iamVjdCwgLi4uYXJncyk7XG59XG5cbi8vIHNyYy9saWIvYmF0Y2gudHNcbnZhciBERUZBVUxUX1NJWkUgPSA1MDtcbnZhciBCYXRjaENhbGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gIH1cbn07XG52YXIgQmF0Y2ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplID8/IERFRkFVTFRfU0laRTtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgfVxuICBjbGVhckRlbGF5VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5kZWxheVRpbWVvdXRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7XG4gICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBzY2hlZHVsZSgpIHtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IHRoaXMuc2l6ZSkge1xuICAgICAgdm9pZCB0aGlzLmZsdXNoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5jbGVhckRlbGF5VGltZW91dCgpO1xuICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gdm9pZCB0aGlzLmZsdXNoKCksIHRoaXMuZGVsYXkpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FsbHMgPSB0aGlzLnF1ZXVlLnNwbGljZSgwKTtcbiAgICBjb25zdCBpbnB1dHMgPSBjYWxscy5tYXAoKGNhbGwpID0+IGNhbGwuaW5wdXQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5jYWxsYmFjayhpbnB1dHMpO1xuICAgICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0cz8uW2luZGV4XTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QobmV3IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXkuXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxscy5sZW5ndGggIT09IHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBDYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG51bWJlciBvZiBwcm92aWRlZCBpdGVtcy4gRXhwZWN0ZWQgJHtjYWxscy5sZW5ndGh9LCBidXQgZ290ICR7cmVzdWx0cy5sZW5ndGh9LmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICB0aGlzLmVycm9yID0gdHJ1ZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICAgICAgY2FsbC5yZWplY3QoZXJyb3IzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQoaW5wdXQpIHtcbiAgICBjb25zdCBleGlzdGluZ0NhbGwgPSB0aGlzLnF1ZXVlLmZpbmQoXG4gICAgICAoY2FsbDIpID0+IHN0cmluZ2lmeShjYWxsMi5pbnB1dCkgPT09IHN0cmluZ2lmeShpbnB1dClcbiAgICApO1xuICAgIGlmIChleGlzdGluZ0NhbGwpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0NhbGwucHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgY2FsbCA9IG5ldyBCYXRjaENhbGwoaW5wdXQpO1xuICAgIHRoaXMucXVldWUucHVzaChjYWxsKTtcbiAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgcmV0dXJuIGNhbGwucHJvbWlzZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVvdXQoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoU3RvcmUoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgY29uc3QgYmF0Y2ggPSBuZXcgQmF0Y2goY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGV2ZW50U291cmNlMiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBnZXRDYWNoZUtleShhcmdzKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgc3RhdGUpIHtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHN0YXRlKTtcbiAgICBldmVudFNvdXJjZTIubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0KGlucHV0KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShpbnB1dCk7XG4gICAgaWYgKGNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoLmdldChpbnB1dCk7XG4gICAgICBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgeyBpc0xvYWRpbmc6IGZhbHNlLCBkYXRhOiByZXN1bHQgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoaW5wdXQpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGlucHV0KTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50U291cmNlMi5vYnNlcnZhYmxlLFxuICAgIGdldCxcbiAgICBnZXRTdGF0ZVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2NyZWF0ZS1zdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUoaW5pdGlhbFN0YXRlKSB7XG4gIGxldCBzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIHNldChjYWxsYmFjaykge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY2FsbGJhY2soc3RhdGUpO1xuICAgIGlmIChzdGF0ZSA9PT0gbmV3U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBmb3IgKGNvbnN0IHN1YnNjcmliZXIgb2Ygc3Vic2NyaWJlcnMpIHtcbiAgICAgIHN1YnNjcmliZXIoc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrKHN0YXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaWJlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0LFxuICAgIHNldCxcbiAgICBzdWJzY3JpYmVcbiAgfTtcbn1cblxuLy8gc3JjL2NvbnZlcnQtcGxhaW4tZGF0YS50c1xuZnVuY3Rpb24gY29udmVydFRvQ29tbWVudERhdGEoZGF0YSkge1xuICBjb25zdCBlZGl0ZWRBdCA9IGRhdGEuZWRpdGVkQXQgPyBuZXcgRGF0ZShkYXRhLmVkaXRlZEF0KSA6IHZvaWQgMDtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCByZWFjdGlvbnMgPSBkYXRhLnJlYWN0aW9ucy5tYXAoKHJlYWN0aW9uKSA9PiAoe1xuICAgIC4uLnJlYWN0aW9uLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUocmVhY3Rpb24uY3JlYXRlZEF0KVxuICB9KSk7XG4gIGlmIChkYXRhLmJvZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHJlYWN0aW9ucyxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGVkaXRlZEF0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdCxcbiAgICAgIGRlbGV0ZWRBdFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1RocmVhZERhdGEoZGF0YSkge1xuICBjb25zdCB1cGRhdGVkQXQgPSBkYXRhLnVwZGF0ZWRBdCA/IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KSA6IHZvaWQgMDtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCBjb21tZW50cyA9IGRhdGEuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KVxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgY3JlYXRlZEF0LFxuICAgIHVwZGF0ZWRBdCxcbiAgICBjb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihkYXRhKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKGRhdGEpIHtcbiAgY29uc3Qgbm90aWZpZWRBdCA9IG5ldyBEYXRlKGRhdGEubm90aWZpZWRBdCk7XG4gIGNvbnN0IHJlYWRBdCA9IGRhdGEucmVhZEF0ID8gbmV3IERhdGUoZGF0YS5yZWFkQXQpIDogbnVsbDtcbiAgaWYgKFwiYWN0aXZpdGllc1wiIGluIGRhdGEpIHtcbiAgICBjb25zdCBhY3Rpdml0aWVzID0gZGF0YS5hY3Rpdml0aWVzLm1hcCgoYWN0aXZpdHkpID0+ICh7XG4gICAgICAuLi5hY3Rpdml0eSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoYWN0aXZpdHkuY3JlYXRlZEF0KVxuICAgIH0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIG5vdGlmaWVkQXQsXG4gICAgICByZWFkQXQsXG4gICAgICBhY3Rpdml0aWVzXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgbm90aWZpZWRBdCxcbiAgICByZWFkQXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8oZGF0YSkge1xuICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBkZWxldGVkQXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mbyhkYXRhKSB7XG4gIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGRlbGV0ZWRBdFxuICB9O1xufVxuXG4vLyBzcmMvbGliL3VybC50c1xuZnVuY3Rpb24gdG9VUkxTZWFyY2hQYXJhbXMocGFyYW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cmxqb2luKGJhc2VVcmwsIHBhdGgsIHBhcmFtcykge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGgsIGJhc2VVcmwpO1xuICBpZiAocGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICB1cmwuc2VhcmNoID0gKHBhcmFtcyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IHBhcmFtcyA6IHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuXG4vLyBzcmMvbm90aWZpY2F0aW9ucy50c1xudmFyIE1BUktfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0JBVENIX0RFTEFZID0gNTA7XG5mdW5jdGlvbiBjcmVhdGVOb3RpZmljYXRpb25zQXBpKHtcbiAgYmFzZVVybCxcbiAgYXV0aE1hbmFnZXIsXG4gIGN1cnJlbnRVc2VySWRTdG9yZSxcbiAgZmV0Y2hlclxufSkge1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaEpzb24oZW5kcG9pbnQsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCJcbiAgICB9KTtcbiAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIgJiYgYXV0aFZhbHVlLnRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgY29uc3QgdXNlcklkID0gYXV0aFZhbHVlLnRva2VuLnBhcnNlZC51aWQ7XG4gICAgICBjdXJyZW50VXNlcklkU3RvcmUuc2V0KCgpID0+IHVzZXJJZCk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHVybGpvaW4oYmFzZVVybCwgYC92Mi9jJHtlbmRwb2ludH1gLCBwYXJhbXMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hlcih1cmwudG9TdHJpbmcoKSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSl9YFxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICBsZXQgZXJyb3IzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgZXJyb3JCb2R5Lm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvckJvZHlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnNcIiwgdm9pZCAwLCB7XG4gICAgICBsaW1pdDogb3B0aW9ucz8ubGltaXQsXG4gICAgICBzaW5jZTogb3B0aW9ucz8uc2luY2U/LnRvSVNPU3RyaW5nKClcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhyZWFkczoganNvbi50aHJlYWRzLm1hcCgodGhyZWFkKSA9PiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCkpLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIChub3RpZmljYXRpb24pID0+IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShub3RpZmljYXRpb24pXG4gICAgICApLFxuICAgICAgZGVsZXRlZFRocmVhZHM6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKFxuICAgICAgICAoaW5mbykgPT4gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhpbmZvKVxuICAgICAgKSxcbiAgICAgIGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnM6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIChpbmZvKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oaW5mbylcbiAgICAgICksXG4gICAgICBtZXRhOiB7XG4gICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCgpIHtcbiAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBmZXRjaEpzb24oXCIvaW5ib3gtbm90aWZpY2F0aW9ucy9jb3VudFwiKTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXCIvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbmJveE5vdGlmaWNhdGlvbklkczogXCJhbGxcIiB9KVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZHMpIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXCIvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbmJveE5vdGlmaWNhdGlvbklkcyB9KVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGJhdGNoZWRNYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMpID0+IHtcbiAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uSWRzID0gYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzLmZsYXQoKTtcbiAgICAgIGF3YWl0IG1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZHMpO1xuICAgICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uSWRzO1xuICAgIH0sXG4gICAgeyBkZWxheTogTUFSS19JTkJPWF9OT1RJRklDQVRJT05TX0FTX1JFQURfQkFUQ0hfREVMQVkgfVxuICApO1xuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGJhdGNoZWRNYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLmdldChpbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnNcIiwge1xuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvaW5ib3gtbm90aWZpY2F0aW9ucy8ke2VuY29kZVVSSUNvbXBvbmVudChpbmJveE5vdGlmaWNhdGlvbklkKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0SW5ib3hOb3RpZmljYXRpb25zLFxuICAgIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQsXG4gICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICAgIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBkZWxldGVJbmJveE5vdGlmaWNhdGlvblxuICB9O1xufVxuXG4vLyBzcmMvbGliL3Bvc2l0aW9uLnRzXG52YXIgTUlOX0NPREUgPSAzMjtcbnZhciBNQVhfQ09ERSA9IDEyNjtcbnZhciBOVU1fRElHSVRTID0gTUFYX0NPREUgLSBNSU5fQ09ERSArIDE7XG52YXIgWkVSTyA9IG50aERpZ2l0KDApO1xudmFyIE9ORSA9IG50aERpZ2l0KDEpO1xudmFyIFpFUk9fTklORSA9IFpFUk8gKyBudGhEaWdpdCgtMSk7XG5mdW5jdGlvbiBudGhEaWdpdChuKSB7XG4gIGNvbnN0IGNvZGUgPSBNSU5fQ09ERSArIChuIDwgMCA/IE5VTV9ESUdJVFMgKyBuIDogbik7XG4gIGlmIChjb2RlIDwgTUlOX0NPREUgfHwgY29kZSA+IE1BWF9DT0RFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG4gdmFsdWU6ICR7bn1gKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbn1cbmZ1bmN0aW9uIG1ha2VQb3NpdGlvbih4LCB5KSB7XG4gIGlmICh4ICE9PSB2b2lkIDAgJiYgeSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJldHdlZW4oeCwgeSk7XG4gIH0gZWxzZSBpZiAoeCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGFmdGVyKHgpO1xuICB9IGVsc2UgaWYgKHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZWZvcmUoeSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9ORTtcbiAgfVxufVxuZnVuY3Rpb24gYmVmb3JlKHBvcykge1xuICBjb25zdCBsYXN0SW5kZXggPSBwb3MubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdEluZGV4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPD0gTUlOX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbGFzdEluZGV4KSB7XG4gICAgICBpZiAoY29kZSA9PT0gTUlOX0NPREUgKyAxKSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgWkVST19OSU5FO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSArIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT05FO1xufVxuZnVuY3Rpb24gYWZ0ZXIocG9zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHBvcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPj0gTUFYX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDEpO1xuICB9XG4gIHJldHVybiBwb3MgKyBPTkU7XG59XG5mdW5jdGlvbiBiZXR3ZWVuKGxvLCBoaSkge1xuICBpZiAobG8gPCBoaSkge1xuICAgIHJldHVybiBfYmV0d2VlbihsbywgaGkpO1xuICB9IGVsc2UgaWYgKGxvID4gaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4oaGksIGxvKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSB2YWx1ZSBiZXR3ZWVuIHR3byBlcXVhbCBwb3NpdGlvbnNcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9iZXR3ZWVuKGxvLCBoaSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBsb0xlbiA9IGxvLmxlbmd0aDtcbiAgY29uc3QgaGlMZW4gPSBoaS5sZW5ndGg7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbG9Db2RlID0gaW5kZXggPCBsb0xlbiA/IGxvLmNoYXJDb2RlQXQoaW5kZXgpIDogTUlOX0NPREU7XG4gICAgY29uc3QgaGlDb2RlID0gaW5kZXggPCBoaUxlbiA/IGhpLmNoYXJDb2RlQXQoaW5kZXgpIDogTUFYX0NPREU7XG4gICAgaWYgKGxvQ29kZSA9PT0gaGlDb2RlKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChoaUNvZGUgLSBsb0NvZGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpbmRleCArIDE7XG4gICAgICBsZXQgcHJlZml4ID0gbG8uc3Vic3RyaW5nKDAsIHNpemUpO1xuICAgICAgaWYgKHByZWZpeC5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIHByZWZpeCArPSBaRVJPLnJlcGVhdChzaXplIC0gcHJlZml4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWZmaXggPSBsby5zdWJzdHJpbmcoc2l6ZSk7XG4gICAgICBjb25zdCBuaW5lcyA9IFwiXCI7XG4gICAgICByZXR1cm4gcHJlZml4ICsgX2JldHdlZW4oc3VmZml4LCBuaW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0YWtlTihsbywgaW5kZXgpICsgU3RyaW5nLmZyb21DaGFyQ29kZShoaUNvZGUgKyBsb0NvZGUgPj4gMSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0YWtlTihwb3MsIG4pIHtcbiAgcmV0dXJuIG4gPCBwb3MubGVuZ3RoID8gcG9zLnN1YnN0cmluZygwLCBuKSA6IHBvcyArIFpFUk8ucmVwZWF0KG4gLSBwb3MubGVuZ3RoKTtcbn1cbnZhciBNSU5fTk9OX1pFUk9fQ09ERSA9IE1JTl9DT0RFICsgMTtcbmZ1bmN0aW9uIGlzUG9zKHN0cikge1xuICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RJZHggPSBzdHIubGVuZ3RoIC0gMTtcbiAgY29uc3QgbGFzdCA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJZHgpO1xuICBpZiAobGFzdCA8IE1JTl9OT05fWkVST19DT0RFIHx8IGxhc3QgPiBNQVhfQ09ERSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJZHg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1BvcyhzdHIpIHtcbiAgY29uc3QgY29kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZXMucHVzaChjb2RlIDwgTUlOX0NPREUgPyBNSU5fQ09ERSA6IGNvZGUgPiBNQVhfQ09ERSA/IE1BWF9DT0RFIDogY29kZSk7XG4gIH1cbiAgd2hpbGUgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbY29kZXMubGVuZ3RoIC0gMV0gPT09IE1JTl9DT0RFKSB7XG4gICAgY29kZXMubGVuZ3RoLS07XG4gIH1cbiAgcmV0dXJuIGNvZGVzLmxlbmd0aCA+IDAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNvZGVzKSA6IChcbiAgICAvLyBFZGdlIGNhc2U6IHRoZSBzdHIgd2FzIGEgMC1vbmx5IHN0cmluZywgd2hpY2ggaXMgaW52YWxpZC4gRGVmYXVsdCBiYWNrIHRvIC4xXG4gICAgT05FXG4gICk7XG59XG5mdW5jdGlvbiBhc1BvcyhzdHIpIHtcbiAgcmV0dXJuIGlzUG9zKHN0cikgPyBzdHIgOiBjb252ZXJ0VG9Qb3Moc3RyKTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL09wLnRzXG52YXIgT3BDb2RlID0gLyogQF9fUFVSRV9fICovICgoT3BDb2RlMikgPT4ge1xuICBPcENvZGUyW09wQ29kZTJbXCJJTklUXCJdID0gMF0gPSBcIklOSVRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiU0VUX1BBUkVOVF9LRVlcIl0gPSAxXSA9IFwiU0VUX1BBUkVOVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX0xJU1RcIl0gPSAyXSA9IFwiQ1JFQVRFX0xJU1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiVVBEQVRFX09CSkVDVFwiXSA9IDNdID0gXCJVUERBVEVfT0JKRUNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9PQkpFQ1RcIl0gPSA0XSA9IFwiQ1JFQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfQ1JEVFwiXSA9IDVdID0gXCJERUxFVEVfQ1JEVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfT0JKRUNUX0tFWVwiXSA9IDZdID0gXCJERUxFVEVfT0JKRUNUX0tFWVwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfTUFQXCJdID0gN10gPSBcIkNSRUFURV9NQVBcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX1JFR0lTVEVSXCJdID0gOF0gPSBcIkNSRUFURV9SRUdJU1RFUlwiO1xuICByZXR1cm4gT3BDb2RlMjtcbn0pKE9wQ29kZSB8fCB7fSk7XG5mdW5jdGlvbiBhY2tPcChvcElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICBpZDogXCJBQ0tcIixcbiAgICAvLyAoSClBQ0tcbiAgICBvcElkXG4gIH07XG59XG5mdW5jdGlvbiBpc0Fja09wKG9wKSB7XG4gIHJldHVybiBvcC50eXBlID09PSA1IC8qIERFTEVURV9DUkRUICovICYmIG9wLmlkID09PSBcIkFDS1wiO1xufVxuXG4vLyBzcmMvY3JkdHMvQWJzdHJhY3RDcmR0LnRzXG5mdW5jdGlvbiBjcmR0QXNMaXZlTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBIYXNQYXJlbnQobm9kZSwga2V5LCBwb3MgPSBhc1BvcyhrZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJIYXNQYXJlbnRcIiwgbm9kZSwga2V5LCBwb3MgfSk7XG59XG52YXIgTm9QYXJlbnQgPSBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJOb1BhcmVudFwiIH0pO1xuZnVuY3Rpb24gT3JwaGFuZWQob2xkS2V5LCBvbGRQb3MgPSBhc1BvcyhvbGRLZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJPcnBoYW5lZFwiLCBvbGRLZXksIG9sZFBvcyB9KTtcbn1cbnZhciBBYnN0cmFjdENyZHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRQYXJlbnRLZXlPclRocm93KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRQb3MoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3M7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRQb3M7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3Bvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sO1xuICB9XG4gIGdldCByb29tSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sID8gdGhpcy5fX3Bvb2wucm9vbUlkIDogbnVsbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50S2V5KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIF9pc0xvY2FsKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZS5fZGV0YWNoQ2hpbGQoY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRQYXJlbnRMaW5rKG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQubm9kZSAhPT0gbmV3UGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcGFyZW50OiBub2RlIGFscmVhZHkgaGFzIGEgcGFyZW50XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9faWQgfHwgdGhpcy5fX3Bvb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggbm9kZTogYWxyZWFkeSBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgcG9vbC5hZGROb2RlKGlkLCBjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgdGhpcy5fX2lkID0gaWQ7XG4gICAgdGhpcy5fX3Bvb2wgPSBwb29sO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBpZiAodGhpcy5fX3Bvb2wgJiYgdGhpcy5fX2lkKSB7XG4gICAgICB0aGlzLl9fcG9vbC5kZWxldGVOb2RlKHRoaXMuX19pZCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IE9ycGhhbmVkKHRoaXMucGFyZW50LmtleSwgdGhpcy5wYXJlbnQucG9zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICAgIHRoaXMuX19wb29sID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQ2xlYXIgdGhlIEltbXV0YWJsZSBjYWNoZSwgc28gdGhhdCB0aGUgbmV4dCBjYWxsIHRvIGAudG9JbW11dGFibGUoKWAgd2lsbFxuICAgKiByZWNvbXB1dGUgdGhlIGVxdWl2YWxlbnQgSW1tdXRhYmxlIHZhbHVlIGFnYWluLiAgQ2FsbCB0aGlzIGFmdGVyIGV2ZXJ5XG4gICAqIG11dGF0aW9uIHRvIHRoZSBMaXZlIG5vZGUuXG4gICAqL1xuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgIT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZWRJbW11dGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFJldHVybiBhbiBzbmFwc2hvdCBvZiB0aGlzIExpdmUgdHJlZSBmb3IgdXNlIGluIERldlRvb2xzLlxuICAgKi9cbiAgdG9UcmVlTm9kZShrZXkpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkVHJlZU5vZGUgPT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSAhPT0ga2V5KSB7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSA9IGtleTtcbiAgICAgIHRoaXMuX2NhY2hlZFRyZWVOb2RlID0gdGhpcy5fdG9UcmVlTm9kZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkVHJlZU5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbW11dGFibGUgc25hcHNob3Qgb2YgdGhpcyBMaXZlIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICovXG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdGhpcy5fdG9JbW11dGFibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEltbXV0YWJsZTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL1NlcmlhbGl6ZWRDcmR0LnRzXG52YXIgQ3JkdFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDcmR0VHlwZTIpID0+IHtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk9CSkVDVFwiXSA9IDBdID0gXCJPQkpFQ1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIkxJU1RcIl0gPSAxXSA9IFwiTElTVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTUFQXCJdID0gMl0gPSBcIk1BUFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiUkVHSVNURVJcIl0gPSAzXSA9IFwiUkVHSVNURVJcIjtcbiAgcmV0dXJuIENyZHRUeXBlMjtcbn0pKENyZHRUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzUm9vdENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC50eXBlID09PSAwIC8qIE9CSkVDVCAqLyAmJiAhaXNDaGlsZENyZHQoY3JkdCk7XG59XG5mdW5jdGlvbiBpc0NoaWxkQ3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnBhcmVudElkICE9PSB2b2lkIDAgJiYgY3JkdC5wYXJlbnRLZXkgIT09IHZvaWQgMDtcbn1cblxuLy8gc3JjL2xpYi9uYW5vaWQudHNcbmZ1bmN0aW9uIG5hbm9pZChsZW5ndGggPSA3KSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSwuLztbXX4hQCMkJSYqKClfKz0tXCI7XG4gIGNvbnN0IGxlbiA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgcmV0dXJuIEFycmF5LmZyb20oXG4gICAgeyBsZW5ndGggfSxcbiAgICAoKSA9PiBhbHBoYWJldC5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKSlcbiAgKS5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvY3JkdHMvTGl2ZVJlZ2lzdGVyLnRzXG52YXIgTGl2ZVJlZ2lzdGVyID0gY2xhc3MgX0xpdmVSZWdpc3RlciBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBfcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gbmV3IF9MaXZlUmVnaXN0ZXIoaXRlbS5kYXRhKTtcbiAgICByZWdpc3Rlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICByZXR1cm4gcmVnaXN0ZXI7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHNlcmlhbGl6ZSByZWdpc3RlciBpZiBwYXJlbnRJZCBvciBwYXJlbnRLZXkgaXMgdW5kZWZpbmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IDggLyogQ1JFQVRFX1JFR0lTVEVSICovLFxuICAgICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlUmVnaXN0ZXIgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAzIC8qIFJFR0lTVEVSICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQoX29wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoX2NyZHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSnNvblwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy5fZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGlzLmRhdGEpO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvTGl2ZUxpc3QudHNcbmZ1bmN0aW9uIGNvbXBhcmVOb2RlUG9zaXRpb24oaXRlbUEsIGl0ZW1CKSB7XG4gIGNvbnN0IHBvc0EgPSBpdGVtQS5fcGFyZW50UG9zO1xuICBjb25zdCBwb3NCID0gaXRlbUIuX3BhcmVudFBvcztcbiAgcmV0dXJuIHBvc0EgPT09IHBvc0IgPyAwIDogcG9zQSA8IHBvc0IgPyAtMSA6IDE7XG59XG52YXIgTGl2ZUxpc3QgPSBjbGFzcyBfTGl2ZUxpc3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcG9zaXRpb24gPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld1Bvc2l0aW9uKTtcbiAgICAgIHRoaXMuX2l0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpc3QgPSBuZXcgX0xpdmVMaXN0KFtdKTtcbiAgICBsaXN0Ll9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXN0LCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBsaXN0Ll9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgcmVzdWx0aW5nIG9wcyB3aWxsIGJlIHNlbnQgdG8gdGhlIHNlcnZlciBpZiB0aGV5IGhhdmUgYW4gJ29wSWQnXG4gICAqIHNvIHdlIG11dGF0ZSBfdW5hY2tub3dsZWRnZWRTZXRzIHRvIGF2b2lkIHBvdGVudGlhbCBmbGlja2VyaW5nXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZlYmxvY2tzL2xpdmVibG9ja3MvcHVsbC8xMTc3XG4gICAqXG4gICAqIFRoaXMgaXMgcXVpdGUgdW5pbnR1aXRpdmUgYW5kIHNob3VsZCBkaXNhcHBlYXIgYXMgc29vbiBhc1xuICAgKiB3ZSBpbnRyb2R1Y2UgYW4gZXhwbGljaXQgTGl2ZUxpc3QuU2V0IG9wZXJhdGlvblxuICAgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgY29uc3QgcGFyZW50S2V5MiA9IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICAgIGNvbnN0IGNoaWxkT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIHBhcmVudEtleTIsIHBvb2wpLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBjb25zdCBjaGlsZE9wSWQgPSBjaGlsZE9wc1swXS5vcElkO1xuICAgICAgaWYgKGNoaWxkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocGFyZW50S2V5MiwgY2hpbGRPcElkKTtcbiAgICAgIH1cbiAgICAgIG9wcy5wdXNoKC4uLmNoaWxkT3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEFkZHMgYSBuZXcgaXRlbSBpbnRvIHRoZSBzb3J0ZWQgbGlzdCwgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24uXG4gICAqL1xuICBfaW5zZXJ0QW5kU29ydChpdGVtKSB7XG4gICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zb3J0SXRlbXMoKSB7XG4gICAgdGhpcy5faXRlbXMuc29ydChjb21wYXJlTm9kZVBvc2l0aW9uKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9pbmRleE9mUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMuZmluZEluZGV4KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSA9PT0gcG9zaXRpb25cbiAgICApO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgaXRlbS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldFJlbW90ZShvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IGRlbGV0ZWRJZCA9IG9wLmRlbGV0ZWRJZDtcbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgY29uc3QgaXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dO1xuICAgICAgaWYgKGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9pZCA9PT0gZGVsZXRlZElkKSB7XG4gICAgICAgIGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9kZXRhY2goKTtcbiAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIHNldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuYWRkKGl0ZW1XaXRoU2FtZVBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICBjb25zdCBkZWx0YSA9IFtcbiAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRlbGV0ZURlbHRhMiA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChkZWxldGVEZWx0YTIpIHtcbiAgICAgICAgdXBkYXRlcy5wdXNoKGRlbGV0ZURlbHRhMik7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHVwZGF0ZXMucHVzaChpbnNlcnREZWx0YSh0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KSwgY2hpbGQpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldmVyc2U6IFtdLFxuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVzKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRBY2sob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgfVxuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BJZCA9IHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5nZXQob3AucGFyZW50S2V5KTtcbiAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh1bmFja25vd2xlZGdlZE9wSWQgIT09IG9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmxlbmd0aCA9PT0gMCA/IHsgbW9kaWZpZWQ6IGZhbHNlIH0gOiB7IG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSwgcmV2ZXJzZTogW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5kZWxldGUob3AucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5faXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0gb3AucGFyZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChcbiAgICAgICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZURlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbikpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBvcC5wYXJlbnRLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGlmIChuZXdJbmRleCAhPT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICBkZWx0YS5wdXNoKG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgZXhpc3RpbmdJdGVtKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZGVsdGEubGVuZ3RoID4gMCA/IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpIDogZmFsc2UsXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSB0aGlzLl9wb29sLmdldE5vZGUob3AuaWQpO1xuICAgICAgaWYgKG9ycGhhbiAmJiB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhvcnBoYW4pKSB7XG4gICAgICAgIG9ycGhhbi5fc2V0UGFyZW50TGluayh0aGlzLCBvcC5wYXJlbnRLZXkpO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShvcnBoYW4pO1xuICAgICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG9ycGhhbik7XG4gICAgICAgIGNvbnN0IHJlY3JlYXRlZEl0ZW1JbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2Yob3JwaGFuKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIGF0IHRoaXMgcG9zaXRpb24sIHVwZGF0ZSBpcyBhIHNldCwgZWxzZSBpdCdzIGFuIGluc2VydFxuICAgICAgICAgICAgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID09PSAtMSA/IGluc2VydERlbHRhKHJlY3JlYXRlZEl0ZW1JbmRleCwgb3JwaGFuKSA6IHNldERlbHRhKHJlY3JlYXRlZEl0ZW1JbmRleCwgb3JwaGFuKSxcbiAgICAgICAgICAgIC4uLmRlbHRhXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy5fY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQoXG4gICAgICAgICAgb3AsXG4gICAgICAgICAgb3AucGFyZW50S2V5XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSkgOiBzZXREZWx0YShuZXdJbmRleCwgbmV3SXRlbSksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1cGRhdGUgZGVsdGEgb2YgdGhlIGRlbGV0aW9uIG9yIG51bGxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihkZWxldGVkSWQpIHtcbiAgICBpZiAoZGVsZXRlZElkID09PSB2b2lkIDAgfHwgdGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVsZXRlZEl0ZW0gPSB0aGlzLl9wb29sLmdldE5vZGUoZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZEl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RldGFjaENoaWxkKGRlbGV0ZWRJdGVtKTtcbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubW9kaWZpZWQudXBkYXRlc1swXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVJlbW90ZUluc2VydChvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihleGlzdGluZ0l0ZW1JbmRleCwga2V5KTtcbiAgICB9XG4gICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy5fY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgIHJldmVyc2U6IFtdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydEFjayhvcCkge1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgY29uc3Qga2V5ID0gYXNQb3Mob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBpdGVtSW5kZXhBdFBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSkge1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbS5fcGFyZW50S2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhpc3RpbmdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICBpZiAobmV3SW5kZXggPT09IG9sZFBvc2l0aW9uSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShvbGRQb3NpdGlvbkluZGV4LCBuZXdJbmRleCwgZXhpc3RpbmdJdGVtKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9ycGhhbiA9IG5uKHRoaXMuX3Bvb2wpLmdldE5vZGUob3AuaWQpO1xuICAgICAgaWYgKG9ycGhhbiAmJiB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhvcnBoYW4pKSB7XG4gICAgICAgIG9ycGhhbi5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShvcnBoYW4pO1xuICAgICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG9ycGhhbik7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBvcnBoYW4pXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy5fY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGxldCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XT8uX3BhcmVudFBvcztcbiAgICAgIGNvbnN0IGFmdGVyMiA9IHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3M7XG4gICAgICBuZXdLZXkgPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgfVxuICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICByZXZlcnNlOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRVbmRvUmVkbyhvcCkge1xuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbD8uZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQoa2V5LCBubihvcC5vcElkKSk7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IG5ld0tleSA9IGtleTtcbiAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVLZXldO1xuICAgICAgZXhpc3RpbmdJdGVtLl9kZXRhY2goKTtcbiAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVLZXldID0gY2hpbGQ7XG4gICAgICBjb25zdCByZXZlcnNlID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyhubih0aGlzLl9pZCksIGtleSwgdGhpcy5fcG9vbCksXG4gICAgICAgIG9wLmlkXG4gICAgICApO1xuICAgICAgY29uc3QgZGVsdGEgPSBbc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSwgY2hpbGQpXTtcbiAgICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChkZWxldGVkRGVsdGEpIHtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLFxuICAgICAgICByZXZlcnNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBjaGlsZCldKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKG9wLmludGVudCA9PT0gXCJzZXRcIikge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlTZXRSZW1vdGUob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVJlbW90ZUluc2VydChvcCk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlJbnNlcnRBY2sob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlJbnNlcnRVbmRvUmVkbyhvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHQubW9kaWZpZWQgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKG5uKHRoaXMuX2lkKSwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IGluZGV4VG9EZWxldGUgPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChpbmRleFRvRGVsZXRlID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4VG9EZWxldGUsIDEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbZGVsZXRlRGVsdGEoaW5kZXhUb0RlbGV0ZSldKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKSB7XG4gICAgaWYgKHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0tleSA9IGNoaWxkLl9wYXJlbnRLZXk7XG4gICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlBY2sobmV3S2V5LCBjaGlsZCkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgaWYgKHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgfVxuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICBpZDogbm4oY2hpbGQuX2lkKSxcbiAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzS2V5XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldENoaWxkS2V5KG5ld0tleSwgY2hpbGQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTGlzdCBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMuXG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHB1c2goZWxlbWVudCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGVsZW1lbnQsIHRoaXMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBvbmUgZWxlbWVudCBhdCBhIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHlvdSB3YW50IHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICovXG4gIGluc2VydChlbGVtZW50LCBpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGluc2VydCBsaXN0IGl0ZW0gYXQgaW5kZXggXCJcdTAwMWQke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuX2l0ZW1zLmxlbmd0aH1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmUyID0gdGhpcy5faXRlbXNbaW5kZXggLSAxXSA/IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tpbmRleF0gPyB0aGlzLl9pdGVtc1tpbmRleF0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmUyLCBhZnRlcjIpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoZWxlbWVudCk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2luc2VydEFuZFNvcnQodmFsdWUpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKGluZGV4LCB2YWx1ZSldKV1cbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNb3ZlIG9uZSBlbGVtZW50IGZyb20gb25lIGluZGV4IHRvIGFub3RoZXIuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gbW92ZVxuICAgKiBAcGFyYW0gdGFyZ2V0SW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZnRlciBtb3ZpbmcuXG4gICAqL1xuICBtb3ZlKGluZGV4LCB0YXJnZXRJbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBjYW5ub3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBsaXN0IGxlbmd0aFwiKTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZVBvc2l0aW9uID0gbnVsbDtcbiAgICBsZXQgYWZ0ZXJQb3NpdGlvbiA9IG51bGw7XG4gICAgaWYgKGluZGV4IDwgdGFyZ2V0SW5kZXgpIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0YXJnZXRJbmRleCA9PT0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSA/IHZvaWQgMCA6IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4ICsgMV0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleF0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IDAgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCAtIDFdLl9wYXJlbnRQb3M7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKGJlZm9yZVBvc2l0aW9uLCBhZnRlclBvc2l0aW9uKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IHByZXZpb3VzUG9zaXRpb24gPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShpbmRleCwgdGFyZ2V0SW5kZXgsIGl0ZW0pXSldXG4gICAgICBdKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgICAgaWQ6IG5uKGl0ZW0uX2lkKSxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHBvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzUG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBkZWxldGUgbGlzdCBpdGVtIGF0IGluZGV4IFwiJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgY29uc3QgY2hpbGRSZWNvcmRJZCA9IGl0ZW0uX2lkO1xuICAgICAgaWYgKGNoaWxkUmVjb3JkSWQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBzdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgbm4odGhpcy5faWQpLFxuICAgICAgICAgIG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4KV0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDogY2hpbGRSZWNvcmRJZCxcbiAgICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpLFxuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgICAgY29uc3QgdXBkYXRlRGVsdGEgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICAgICAgY29uc3QgY2hpbGRJZCA9IGl0ZW0uX2lkO1xuICAgICAgICBpZiAoY2hpbGRJZCkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogY2hpbGRJZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXZlcnNlT3BzLnB1c2goXG4gICAgICAgICAgICAuLi5pdGVtLl90b09wcyhubih0aGlzLl9pZCksIGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHVwZGF0ZURlbHRhLnB1c2goZGVsZXRlRGVsdGEoMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQobm4odGhpcy5faWQpLCBtYWtlVXBkYXRlKHRoaXMsIHVwZGF0ZURlbHRhKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG4gIHNldChpbmRleCwgaXRlbSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGV4aXN0aW5nSXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGNvbnN0IGV4aXN0aW5nSWQgPSBleGlzdGluZ0l0ZW0uX2lkO1xuICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgY29uc3QgdmFsdWUgPSBsc29uVG9MaXZlTm9kZShpdGVtKTtcbiAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5faXRlbXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICB2YWx1ZS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbc2V0RGVsdGEoaW5kZXgsIHZhbHVlKV0pKTtcbiAgICAgIGNvbnN0IG9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIHZhbHVlLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHRoaXMuX3Bvb2wpLFxuICAgICAgICBleGlzdGluZ0lkXG4gICAgICApO1xuICAgICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzLnNldChwb3NpdGlvbiwgbm4ob3BzWzBdLm9wSWQpKTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdm9pZCAwKSxcbiAgICAgICAgaWRcbiAgICAgICk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgIChlbnRyeSkgPT4gbGl2ZU5vZGVUb0xzb24oZW50cnkpXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGFsbCBlbGVtZW50cyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGVsZW1lbnQsIHRha2luZyB0d28gYXJndW1lbnRzICh0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4KS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGV2ZXJ5IGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBldmVyeShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZXZlcnkocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IG9mIHRoZSBMaXZlTGlzdC4gUmV0dXJuIGEgdmFsdWUgdGhhdCBjb2VyY2VzIHRvIHRydWUgdG8ga2VlcCB0aGUgZWxlbWVudCwgb3IgdG8gZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gICAqL1xuICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbHRlcihwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZS5cbiAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBmaW5kKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kKHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgcGFzc2VzIHRoZSB0ZXN0LiBPdGhlcndpc2UsIC0xLlxuICAgKi9cbiAgZmluZEluZGV4KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kSW5kZXgocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFja2ZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2tmbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9uIHRoZSBlbGVtZW50IHRvIGdldC5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIExpdmVMaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuXG4gICAqIEByZXR1cm5zIFRoZSBmaXJzdCBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3Q7IC0xIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuIFRoZSBMaXZlTHNpdCBpcyBzZWFyY2hlZCBiYWNrd2FyZHMsIHN0YXJ0aW5nIGF0IGZyb21JbmRleC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBiYWNrd2FyZHMuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnkgZWxlbWVudC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBldmVyeSBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIG1hcChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnksIGkpID0+IGNhbGxiYWNrKFxuICAgICAgICBsaXZlTm9kZVRvTHNvbihlbnRyeSksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICAgICAgaVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHBhc3NlcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIHNvbWUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLnNvbWUocHJlZGljYXRlKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0SXRlcmF0b3IodGhpcy5faXRlbXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpIHtcbiAgICBjb25zdCBuZXdJdGVtID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIG5ld0l0ZW0uX2F0dGFjaChvcC5pZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIG5ld0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG5ld0l0ZW0pO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgcmV0dXJuIHsgbmV3SXRlbSwgbmV3SW5kZXggfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zaGlmdEl0ZW1Qb3NpdGlvbihpbmRleCwga2V5KSB7XG4gICAgY29uc3Qgc2hpZnRlZFBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKFxuICAgICAga2V5LFxuICAgICAgdGhpcy5faXRlbXMubGVuZ3RoID4gaW5kZXggKyAxID8gdGhpcy5faXRlbXNbaW5kZXggKyAxXT8uX3BhcmVudFBvcyA6IHZvaWQgMFxuICAgICk7XG4gICAgdGhpcy5faXRlbXNbaW5kZXhdLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHNoaWZ0ZWRQb3NpdGlvbik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy5faXRlbXMubWFwKFxuICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGl0ZW0udG9UcmVlTm9kZShpbmRleC50b1N0cmluZygpKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faXRlbXMubWFwKChub2RlKSA9PiBub2RlLnRvSW1tdXRhYmxlKCkpO1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZUxpc3QodGhpcy5faXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLmNsb25lKCkpKTtcbiAgfVxufTtcbnZhciBMaXZlTGlzdEl0ZXJhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHRoaXMuX2lubmVySXRlcmF0b3IgPSBpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9pbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24ocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4geyB2YWx1ZSB9O1xuICB9XG59O1xuZnVuY3Rpb24gbWFrZVVwZGF0ZShsaXZlTGlzdCwgZGVsdGFVcGRhdGVzKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbGl2ZUxpc3QsXG4gICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgIHVwZGF0ZXM6IGRlbHRhVXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gc2V0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVEZWx0YShpbmRleCkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiZGVsZXRlXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGluc2VydERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJpbnNlcnRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJtb3ZlXCIsXG4gICAgcHJldmlvdXNJbmRleCxcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihvcHMsIGRlbGV0ZWRJZCkge1xuICByZXR1cm4gb3BzLm1hcCgob3AsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBjb25zdCBmaXJzdE9wID0gb3A7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5maXJzdE9wLFxuICAgICAgICBpbnRlbnQ6IFwic2V0XCIsXG4gICAgICAgIGRlbGV0ZWRJZFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9saWIvZnJlZXplLnRzXG52YXIgZnJlZXplID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gKFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAoeCkgPT4geFxuKSA6IE9iamVjdC5mcmVlemU7XG5cbi8vIHNyYy9jcmR0cy9MaXZlTWFwLnRzXG52YXIgTGl2ZU1hcCA9IGNsYXNzIF9MaXZlTWFwIGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoZW50cmllczIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChlbnRyaWVzMikge1xuICAgICAgY29uc3QgbWFwcGVkRW50cmllcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllczIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKHZhbHVlKTtcbiAgICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICBtYXBwZWRFbnRyaWVzLnB1c2goW2tleSwgbm9kZV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcChtYXBwZWRFbnRyaWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgIHBhcmVudElkLFxuICAgICAgcGFyZW50S2V5XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBvcHMucHVzaCguLi52YWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgcG9vbCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBfaXRlbV0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgX0xpdmVNYXAoKTtcbiAgICBtYXAuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChpZCk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobWFwLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBtYXAuX21hcC5zZXQoY3JkdC5wYXJlbnRLZXksIGNoaWxkKTtcbiAgICAgIG1hcC5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgW19rZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXksIG9wSWQgfSA9IG9wO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleTtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbC5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIGNvbnN0IGxhc3RVcGRhdGVPcElkID0gdGhpcy51bmFja25vd2xlZGdlZFNldC5nZXQoa2V5KTtcbiAgICAgIGlmIChsYXN0VXBkYXRlT3BJZCA9PT0gb3BJZCkge1xuICAgICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdFVwZGF0ZU9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIHJldmVyc2UgPSBwcmV2aW91c1ZhbHVlLl90b09wcyh0aGlzSWQsIGtleSk7XG4gICAgICBwcmV2aW91c1ZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBjaGlsZCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX21hcC52YWx1ZXMoKSkge1xuICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAodmFsdWUgPT09IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoaWxkLl9kZXRhY2goKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlID0ge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgdXBkYXRlczogeyBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgIH07XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IHN0b3JhZ2VVcGRhdGUsIHJldmVyc2UgfTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVNYXAgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAyIC8qIE1BUCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGUgTGl2ZU1hcC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBvciB1bmRlZmluZWQgaWYgdGhlIGtleSBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgTGl2ZU1hcC5cbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIGEgdmFsdWUuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBhIHN0cmluZy5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGxzb25Ub0xpdmVOb2RlKHZhbHVlKTtcbiAgICBpdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgaXRlbS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBvcHMgPSBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQuc2V0KGtleSwgbm4ob3BzWzBdLm9wSWQpKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvbGRWYWx1ZSA/IG9sZFZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5KSA6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgTGl2ZU1hcC5cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgb3Igbm90LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gdGVzdCBmb3IgcHJlc2VuY2UuXG4gICAqL1xuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgYnkga2V5LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgZXhpc3RlZCBhbmQgaGFzIGJlZW4gcmVtb3ZlZCwgb3IgZmFsc2UgaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGlmIChpdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIGl0ZW0uX2lkKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpc0lkLCB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGl0ZW0uX2lkLFxuICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgaXRlbS5fdG9PcHModGhpc0lkLCBrZXkpLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIFtrZXksIHZhbHVlXSBwYWlycyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgZW50cmllcygpIHtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGhpcy5fbWFwLmVudHJpZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyYXRvclZhbHVlLnZhbHVlO1xuICAgICAgICBjb25zdCBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlWzFdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogW2tleSwgdmFsdWVdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FtZSBmdW5jdGlvbiBvYmplY3QgYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGVudHJpZXMgbWV0aG9kLlxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAua2V5cygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSB2YWx1ZXMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIHZhbHVlcygpIHtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGhpcy5fbWFwLnZhbHVlcygpO1xuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3JWYWx1ZSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlcmF0b3JWYWx1ZS5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKGl0ZXJhdG9yVmFsdWUudmFsdWUpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiB0aGUgTWFwIG9iamVjdCwgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgbWFwLlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcykge1xuICAgICAgY2FsbGJhY2soZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICBpZDogdGhpcy5faWQgPz8gbmFub2lkKCksXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiBBcnJheS5mcm9tKHRoaXMuX21hcC5lbnRyaWVzKCkpLm1hcChcbiAgICAgICAgKFtrZXkyLCB2YWxdKSA9PiB2YWwudG9UcmVlTm9kZShrZXkyKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZS50b0ltbXV0YWJsZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVNYXAoXG4gICAgICBBcnJheS5mcm9tKHRoaXMuX21hcCkubWFwKChba2V5LCBub2RlXSkgPT4gW2tleSwgbm9kZS5jbG9uZSgpXSlcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU9iamVjdC50c1xudmFyIExpdmVPYmplY3QgPSBjbGFzcyBfTGl2ZU9iamVjdCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9idWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKSB7XG4gICAgY29uc3QgcGFyZW50VG9DaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHJvb3QgPSBudWxsO1xuICAgIGZvciAoY29uc3QgW2lkLCBjcmR0XSBvZiBpdGVtcykge1xuICAgICAgaWYgKGlzUm9vdENyZHQoY3JkdCkpIHtcbiAgICAgICAgcm9vdCA9IFtpZCwgY3JkdF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0dXBsZSA9IFtpZCwgY3JkdF07XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoY3JkdC5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh0dXBsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50VG9DaGlsZHJlbi5zZXQoY3JkdC5wYXJlbnRJZCwgW3R1cGxlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgY2FuJ3QgYmUgbnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbUl0ZW1zKGl0ZW1zLCBwb29sKSB7XG4gICAgY29uc3QgW3Jvb3QsIHBhcmVudFRvQ2hpbGRyZW5dID0gX0xpdmVPYmplY3QuX2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4oaXRlbXMpO1xuICAgIHJldHVybiBfTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoXG4gICAgICByb290LFxuICAgICAgcGFyZW50VG9DaGlsZHJlbixcbiAgICAgIHBvb2xcbiAgICApO1xuICB9XG4gIGNvbnN0cnVjdG9yKG9iaiA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBvID0gY29tcGFjdE9iamVjdChvYmopO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG8pKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ba2V5XTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG8pKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wSWQgPSBwb29sPy5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBvcCA9IHtcbiAgICAgIHR5cGU6IDQgLyogQ1JFQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIG9wSWQsXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleSxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wLmRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbGl2ZU9iaiA9IG5ldyBfTGl2ZU9iamVjdChpdGVtLmRhdGEpO1xuICAgIGxpdmVPYmouX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplQ2hpbGRyZW4obGl2ZU9iaiwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplQ2hpbGRyZW4obGl2ZU9iaiwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQobm4obGl2ZU9iai5faWQpKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpdmVPYmo7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZVRvTHNvbihbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGlmIChpc0xpdmVTdHJ1Y3R1cmUoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKGxpdmVPYmosIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICAgIGxpdmVPYmouX21hcC5zZXQoY3JkdC5wYXJlbnRLZXksIGNoaWxkKTtcbiAgICAgIGxpdmVPYmouaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZU9iajtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBvcElkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9Mc29uKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbC5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3BJZCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKSB7XG4gICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wSWQpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3BJZCkge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUocHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgIHJldmVyc2UgPSBwcmV2aW91c1ZhbHVlLl90b09wcyh0aGlzSWQsIGtleSk7XG4gICAgICBwcmV2aW91c1ZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFt7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzSWQsIGtleSB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZDogdGhpc0lkLFxuICAgICAgICAgIGRhdGE6IHsgW2tleV06IHByZXZpb3VzVmFsdWUgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmIChpc0xpdmVTdHJ1Y3R1cmUoY2hpbGQpKSB7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXZlcnNlLFxuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhpZCwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgICBpZiAodmFsdWUgPT09IGNoaWxkKSB7XG4gICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlID0ge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgIFtwYXJlbnRLZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IHN0b3JhZ2VVcGRhdGUsIHJldmVyc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgaWYgKG9wLnR5cGUgPT09IDMgLyogVVBEQVRFX09CSkVDVCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKTtcbiAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseURlbGV0ZU9iamVjdEtleShvcCwgaXNMb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKCFpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgdGhpcy5wYXJlbnQubm9kZS5faWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogT0JKRUNUICovLFxuICAgICAgICBwYXJlbnRJZDogdGhpcy5wYXJlbnQubm9kZS5faWQsXG4gICAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5LFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpIHtcbiAgICBsZXQgaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlID0ge1xuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgaWQsXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyhpZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlVXBkYXRlLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkLCBrZXkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcC5kYXRhW2tleV07XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wLm9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgICAgdGhpcy5fbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZS5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2UudW5zaGlmdChyZXZlcnNlVXBkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTW9kaWZpZWQgPyB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfSA6IHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBrZXkgPSBvcC5rZXk7XG4gICAgaWYgKHRoaXMuX21hcC5oYXMoa2V5KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoIWlzTG9jYWwgJiYgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgbGV0IHJldmVyc2UgPSBbXTtcbiAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgIHJldmVyc2UgPSBvbGRWYWx1ZS5fdG9PcHMoaWQsIG9wLmtleSk7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXZlcnNlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGRhdGE6IHsgW2tleV06IG9sZFZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogeyBbb3Aua2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIExpdmVPYmplY3QgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuICB0b09iamVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX21hcCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhIHByb3BlcnR5IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFkZFxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICB0aGlzLnVwZGF0ZSh7IFtrZXldOiB2YWx1ZSB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIHRoZSBMaXZlT2JqZWN0LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldFxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBrZXkgZnJvbSB0aGUgTGl2ZU9iamVjdFxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qga2V5QXNTdHJpbmcgPSBrZXk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleUFzU3RyaW5nKTtcbiAgICBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmV2ZXJzZTtcbiAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIHJldmVyc2UgPSBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleUFzU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBkYXRhOiB7IFtrZXlBc1N0cmluZ106IG9sZFZhbHVlIH0sXG4gICAgICAgICAgaWQ6IHRoaXMuX2lkXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5QXNTdHJpbmcpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9KTtcbiAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLyxcbiAgICAgICAgICBrZXk6IGtleUFzU3RyaW5nLFxuICAgICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICByZXZlcnNlLFxuICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlIHdpdGggYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0gcGF0Y2ggVGhlIG9iamVjdCB1c2VkIHRvIG92ZXJyaWRlcyBwcm9wZXJ0aWVzXG4gICAqL1xuICB1cGRhdGUocGF0Y2gpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDAgfHwgdGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgIGNvbnN0IG9wSWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpO1xuICAgIGNvbnN0IHVwZGF0ZWRQcm9wcyA9IHt9O1xuICAgIGNvbnN0IHJldmVyc2VVcGRhdGVPcCA9IHtcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhdGNoW2tleV07XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKHsgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLywgaWQ6IHRoaXMuX2lkLCBrZXkgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXZlcnNlVXBkYXRlT3AuZGF0YVtrZXldID0gb2xkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMaXZlTm9kZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbmV3VmFsdWUuX2F0dGFjaCh0aGlzLl9wb29sLmdlbmVyYXRlSWQoKSwgdGhpcy5fcG9vbCk7XG4gICAgICAgIGNvbnN0IG5ld0F0dGFjaENoaWxkT3BzID0gbmV3VmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBjcmVhdGVDcmR0T3AgPSBuZXdBdHRhY2hDaGlsZE9wcy5maW5kKFxuICAgICAgICAgIChvcCkgPT4gb3AucGFyZW50SWQgPT09IHRoaXMuX2lkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjcmVhdGVDcmR0T3ApIHtcbiAgICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKGNyZWF0ZUNyZHRPcC5vcElkKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BzLnB1c2goLi4ubmV3QXR0YWNoQ2hpbGRPcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlZFByb3BzW2tleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBvcElkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBuZXdWYWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGVPcC5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2VPcHMudW5zaGlmdChyZXZlcnNlVXBkYXRlT3ApO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModXBkYXRlZFByb3BzKS5sZW5ndGggIT09IDApIHtcbiAgICAgIG9wcy51bnNoaWZ0KHtcbiAgICAgICAgb3BJZCxcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgIGRhdGE6IHVwZGF0ZWRQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvVHJlZU5vZGUoa2V5KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIGNvbnN0IG5vZGVJZCA9IHRoaXMuX2lkID8/IG5hbm9pZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIGlkOiBub2RlSWQsXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiBBcnJheS5mcm9tKHRoaXMuX21hcC5lbnRyaWVzKCkpLm1hcChcbiAgICAgICAgKFtrZXkyLCB2YWx1ZV0pID0+IGlzTGl2ZU5vZGUodmFsdWUpID8gdmFsdWUudG9UcmVlTm9kZShrZXkyKSA6IHsgdHlwZTogXCJKc29uXCIsIGlkOiBgJHtub2RlSWR9OiR7a2V5Mn1gLCBrZXk6IGtleTIsIHBheWxvYWQ6IHZhbHVlIH1cbiAgICAgIClcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gaXNMaXZlU3RydWN0dXJlKHZhbCkgPyB2YWwudG9JbW11dGFibGUoKSA6IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHJlc3VsdCA6IE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlT2JqZWN0KFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX21hcCkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgaXNMaXZlU3RydWN0dXJlKHZhbHVlKSA/IHZhbHVlLmNsb25lKCkgOiBkZWVwQ2xvbmUodmFsdWUpXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL2xpdmVibG9ja3MtaGVscGVycy50c1xuZnVuY3Rpb24gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApIHtcbiAgcmV0dXJuIGxzb25Ub0xpdmVOb2RlKGNyZWF0aW9uT3BUb0xzb24ob3ApKTtcbn1cbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xzb24ob3ApIHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSA4IC8qIENSRUFURV9SRUdJU1RFUiAqLzpcbiAgICAgIHJldHVybiBvcC5kYXRhO1xuICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgcmV0dXJuIG5ldyBMaXZlT2JqZWN0KG9wLmRhdGEpO1xuICAgIGNhc2UgNyAvKiBDUkVBVEVfTUFQICovOlxuICAgICAgcmV0dXJuIG5ldyBMaXZlTWFwKCk7XG4gICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgcmV0dXJuIG5ldyBMaXZlTGlzdChbXSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihvcCwgXCJVbmtub3duIGNyZWF0aW9uIE9wXCIpO1xuICB9XG59XG5mdW5jdGlvbiBpc1NhbWVOb2RlT3JDaGlsZE9mKG5vZGUsIHBhcmVudCkge1xuICBpZiAobm9kZSA9PT0gcGFyZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICByZXR1cm4gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLnBhcmVudC5ub2RlLCBwYXJlbnQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIExpdmVSZWdpc3Rlci5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgQ1JEVCB0eXBlXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgIGNhc2UgMCAvKiBPQkpFQ1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAxIC8qIExJU1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTGlzdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMiAvKiBNQVAgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTWFwLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAzIC8qIFJFR0lTVEVSICovOiB7XG4gICAgICByZXR1cm4gY3JkdC5kYXRhO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkge1xuICByZXR1cm4gaXNMaXZlTGlzdCh2YWx1ZSkgfHwgaXNMaXZlTWFwKHZhbHVlKSB8fCBpc0xpdmVPYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gaXNMaXZlU3RydWN0dXJlKHZhbHVlKSB8fCBpc0xpdmVSZWdpc3Rlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0xpdmVMaXN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0O1xufVxuZnVuY3Rpb24gaXNMaXZlTWFwKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVNYXA7XG59XG5mdW5jdGlvbiBpc0xpdmVPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZU9iamVjdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZVJlZ2lzdGVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcjtcbn1cbmZ1bmN0aW9uIGNsb25lTHNvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGxpdmVOb2RlVG9Mc29uKG9iaikge1xuICBpZiAob2JqIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyKSB7XG4gICAgcmV0dXJuIG9iai5kYXRhO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVMaXN0IHx8IG9iaiBpbnN0YW5jZW9mIExpdmVNYXAgfHwgb2JqIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzc2VydE5ldmVyKG9iaiwgXCJVbmtub3duIEFic3RyYWN0Q3JkdFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gbHNvblRvTGl2ZU5vZGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU9iamVjdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIExpdmVNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IExpdmVSZWdpc3Rlcih2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyZWVzRGlmZk9wZXJhdGlvbnMoY3VycmVudEl0ZW1zLCBuZXdJdGVtcykge1xuICBjb25zdCBvcHMgPSBbXTtcbiAgY3VycmVudEl0ZW1zLmZvckVhY2goKF8sIGlkKSA9PiB7XG4gICAgaWYgKCFuZXdJdGVtcy5nZXQoaWQpKSB7XG4gICAgICBvcHMucHVzaCh7XG4gICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgIGlkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBuZXdJdGVtcy5mb3JFYWNoKChjcmR0LCBpZCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRDcmR0ID0gY3VycmVudEl0ZW1zLmdldChpZCk7XG4gICAgaWYgKGN1cnJlbnRDcmR0KSB7XG4gICAgICBpZiAoY3JkdC50eXBlID09PSAwIC8qIE9CSkVDVCAqLykge1xuICAgICAgICBpZiAoY3VycmVudENyZHQudHlwZSAhPT0gMCAvKiBPQkpFQ1QgKi8gfHwgSlNPTi5zdHJpbmdpZnkoY3JkdC5kYXRhKSAhPT0gSlNPTi5zdHJpbmdpZnkoY3VycmVudENyZHQuZGF0YSkpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3JkdC5wYXJlbnRLZXkgIT09IGN1cnJlbnRDcmR0LnBhcmVudEtleSkge1xuICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXJlbnRLZXk6IG5uKGNyZHQucGFyZW50S2V5LCBcIlBhcmVudCBrZXkgbXVzdCBub3QgYmUgbWlzc2luZ1wiKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAzIC8qIFJFR0lTVEVSICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDggLyogQ1JFQVRFX1JFR0lTVEVSICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXksXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExJU1QgKi86XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMiAvKiBDUkVBVEVfTElTVCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMCAvKiBPQkpFQ1QgKi86XG4gICAgICAgICAgaWYgKGNyZHQucGFyZW50SWQgPT09IHZvaWQgMCB8fCBjcmR0LnBhcmVudEtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSW50ZXJuYWwgZXJyb3IuIENhbm5vdCBzZXJpYWxpemUgc3RvcmFnZSByb290IGludG8gYW4gb3BlcmF0aW9uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDQgLyogQ1JFQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBNQVAgKi86XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNyAvKiBDUkVBVEVfTUFQICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBmaXJzdC51cGRhdGVzO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKHNlY29uZC51cGRhdGVzKSkge1xuICAgIHVwZGF0ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTWFwU3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBmaXJzdC51cGRhdGVzO1xuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzOiB1cGRhdGVzLmNvbmNhdChzZWNvbmQudXBkYXRlcylcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlU3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBpZiAoZmlyc3QgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBzZWNvbmQ7XG4gIH1cbiAgaWYgKGZpcnN0LnR5cGUgPT09IFwiTGl2ZU9iamVjdFwiICYmIHNlY29uZC50eXBlID09PSBcIkxpdmVPYmplY3RcIikge1xuICAgIHJldHVybiBtZXJnZU9iamVjdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKGZpcnN0LnR5cGUgPT09IFwiTGl2ZU1hcFwiICYmIHNlY29uZC50eXBlID09PSBcIkxpdmVNYXBcIikge1xuICAgIHJldHVybiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKGZpcnN0LnR5cGUgPT09IFwiTGl2ZUxpc3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTGlzdFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlTGlzdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpO1xuICB9IGVsc2Uge1xuICB9XG4gIHJldHVybiBzZWNvbmQ7XG59XG5mdW5jdGlvbiBpc1BsYWluKHZhbHVlKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIpIHtcbiAgaWYgKCFpc1BsYWluKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGggfHwgXCJyb290XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIG5lc3RlZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoIWlzUGxhaW4obmVzdGVkVmFsdWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBuZXN0ZWRQYXRoLFxuICAgICAgICB2YWx1ZTogbmVzdGVkVmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKFxuICAgICAgICBuZXN0ZWRWYWx1ZSxcbiAgICAgICAgbmVzdGVkUGF0aFxuICAgICAgKTtcbiAgICAgIGlmIChub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL2xpYi9kZWJ1Zy50c1xuZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2UobXNnLCB0cmFjZVJvb3QpIHtcbiAgY29uc3QgZXJyb3JMaWtlID0geyBuYW1lOiBtc2cgfTtcbiAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvckxpa2UsIHRyYWNlUm9vdCk7XG4gIHJldHVybiBlcnJvckxpa2Uuc3RhY2s7XG59XG5cbi8vIHNyYy9saWIvSnNvbi50c1xuZnVuY3Rpb24gaXNKc29uU2NhbGFyKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGRhdGEgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gaXNKc29uQXJyYXkoZGF0YSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkYXRhKTtcbn1cbmZ1bmN0aW9uIGlzSnNvbk9iamVjdChkYXRhKSB7XG4gIHJldHVybiAhaXNKc29uU2NhbGFyKGRhdGEpICYmICFpc0pzb25BcnJheShkYXRhKTtcbn1cblxuLy8gc3JjL2xpYi9vYmplY3RUb1F1ZXJ5LnRzXG52YXIgaWRlbnRpZmllclJlZ2V4ID0gL15bYS16QS1aX11bYS16QS1aMC05X10qJC87XG5mdW5jdGlvbiBvYmplY3RUb1F1ZXJ5KG9iaikge1xuICBsZXQgZmlsdGVyTGlzdCA9IFtdO1xuICBjb25zdCBlbnRyaWVzMiA9IE9iamVjdC5lbnRyaWVzKG9iaik7XG4gIGNvbnN0IGtleVZhbHVlUGFpcnMgPSBbXTtcbiAgY29uc3Qga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IFtdO1xuICBjb25zdCBpbmRleGVkS2V5cyA9IFtdO1xuICBlbnRyaWVzMi5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoIWlkZW50aWZpZXJSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBtdXN0IG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzLCBfXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaW1wbGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGtleVZhbHVlUGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVdpdGhPcGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgIGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICEoXCJzdGFydHNXaXRoXCIgaW4gdmFsdWUpKSB7XG4gICAgICBpbmRleGVkS2V5cy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfVxuICB9KTtcbiAgZmlsdGVyTGlzdCA9IFtcbiAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMoa2V5VmFsdWVQYWlycyksXG4gICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpXG4gIF07XG4gIGluZGV4ZWRLZXlzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG5lc3RlZEVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gICAgY29uc3QgbktleVZhbHVlUGFpcnMgPSBbXTtcbiAgICBjb25zdCBuS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IFtdO1xuICAgIG5lc3RlZEVudHJpZXMuZm9yRWFjaCgoW25lc3RlZEtleSwgbmVzdGVkVmFsdWVdKSA9PiB7XG4gICAgICBpZiAoaXNTdHJpbmdFbXB0eShuZXN0ZWRLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXNTaW1wbGVWYWx1ZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgbktleVZhbHVlUGFpcnMucHVzaChbZm9ybWF0RmlsdGVyS2V5KGtleSwgbmVzdGVkS2V5KSwgbmVzdGVkVmFsdWVdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVdpdGhPcGVyYXRvcihuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgbktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IucHVzaChbXG4gICAgICAgICAgZm9ybWF0RmlsdGVyS2V5KGtleSwgbmVzdGVkS2V5KSxcbiAgICAgICAgICBuZXN0ZWRWYWx1ZVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmaWx0ZXJMaXN0ID0gW1xuICAgICAgLi4uZmlsdGVyTGlzdCxcbiAgICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhuS2V5VmFsdWVQYWlycyksXG4gICAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IobktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpXG4gICAgXTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJMaXN0Lm1hcChcbiAgICAoeyBrZXksIG9wZXJhdG9yLCB2YWx1ZSB9KSA9PiBmb3JtYXRGaWx0ZXIoa2V5LCBvcGVyYXRvciwgZm9ybWF0RmlsdGVyVmFsdWUodmFsdWUpKVxuICApLmpvaW4oXCIgQU5EIFwiKTtcbn1cbnZhciBnZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMgPSAoa2V5VmFsdWVQYWlycykgPT4ge1xuICBjb25zdCBmaWx0ZXJzID0gW107XG4gIGtleVZhbHVlUGFpcnMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgZmlsdGVycy5wdXNoKHtcbiAgICAgIGtleSxcbiAgICAgIG9wZXJhdG9yOiBcIjpcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVycztcbn07XG52YXIgZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gKGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpID0+IHtcbiAgY29uc3QgZmlsdGVycyA9IFtdO1xuICBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc3RhcnRzV2l0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICBvcGVyYXRvcjogXCJeXCIsXG4gICAgICAgIHZhbHVlOiB2YWx1ZS5zdGFydHNXaXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmlsdGVycztcbn07XG52YXIgaXNTaW1wbGVWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBpc1ZhbHVlV2l0aE9wZXJhdG9yID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgXCJzdGFydHNXaXRoXCIgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGZvcm1hdEZpbHRlciA9IChrZXksIG9wZXJhdG9yLCB2YWx1ZSkgPT4ge1xuICByZXR1cm4gYCR7a2V5fSR7b3BlcmF0b3J9JHt2YWx1ZX1gO1xufTtcbnZhciBmb3JtYXRGaWx0ZXJLZXkgPSAoa2V5LCBuZXN0ZWRLZXkpID0+IHtcbiAgaWYgKG5lc3RlZEtleSkge1xuICAgIHJldHVybiBgJHtrZXl9WyR7SlNPTi5zdHJpbmdpZnkobmVzdGVkS2V5KX1dYDtcbiAgfVxuICByZXR1cm4ga2V5O1xufTtcbnZhciBmb3JtYXRGaWx0ZXJWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGlzU3RyaW5nRW1wdHkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG59O1xudmFyIGlzU3RyaW5nRW1wdHkgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuICF2YWx1ZSB8fCB2YWx1ZS50b1N0cmluZygpLnRyaW0oKSA9PT0gXCJcIjtcbn07XG5cbi8vIHNyYy9wcm90b2NvbC9DbGllbnRNc2cudHNcbnZhciBDbGllbnRNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoQ2xpZW50TXNnQ29kZTIpID0+IHtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJCUk9BRENBU1RfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RfRVZFTlRcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9TVE9SQUdFXCJdID0gMjAwXSA9IFwiRkVUQ0hfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9ZRE9DXCJdID0gMzAwXSA9IFwiRkVUQ0hfWURPQ1wiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAxXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgcmV0dXJuIENsaWVudE1zZ0NvZGUyO1xufSkoQ2xpZW50TXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy9yZWZzL0ltbXV0YWJsZVJlZi50c1xuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBwYXRjaCkge1xuICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICBjb25zdCBuZXdWYWx1ZSA9IHsgLi4udGFyZ2V0IH07XG4gIE9iamVjdC5rZXlzKHBhdGNoKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBjb25zdCB2YWwgPSBwYXRjaFtrZXldO1xuICAgIGlmIChuZXdWYWx1ZVtrZXldICE9PSB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWxldGUgbmV3VmFsdWVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZCA/IG5ld1ZhbHVlIDogdGFyZ2V0O1xufVxudmFyIEltbXV0YWJsZVJlZiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZXYgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgfVxuICBnZXQgZGlkSW52YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXYub2JzZXJ2YWJsZTtcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2V2Lm5vdGlmeSgpO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUgPz8gKHRoaXMuX2NhY2hlID0gdGhpcy5fdG9JbW11dGFibGUoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWZzL090aGVyc1JlZi50c1xuZnVuY3Rpb24gbWFrZVVzZXIoY29ubiwgcHJlc2VuY2UpIHtcbiAgY29uc3QgeyBjb25uZWN0aW9uSWQsIGlkLCBpbmZvIH0gPSBjb25uO1xuICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShjb25uLnNjb3Blcyk7XG4gIHJldHVybiBmcmVlemUoXG4gICAgY29tcGFjdE9iamVjdCh7XG4gICAgICBjb25uZWN0aW9uSWQsXG4gICAgICBpZCxcbiAgICAgIGluZm8sXG4gICAgICBjYW5Xcml0ZSxcbiAgICAgIGNhbkNvbW1lbnQ6IGNhbkNvbW1lbnQoY29ubi5zY29wZXMpLFxuICAgICAgaXNSZWFkT25seTogIWNhbldyaXRlLFxuICAgICAgLy8gRGVwcmVjYXRlZCwga2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eVxuICAgICAgcHJlc2VuY2VcbiAgICB9KVxuICApO1xufVxudmFyIE90aGVyc1JlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgLy9cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25uZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl91c2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgY29ubmVjdGlvbklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbnMua2V5cygpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHVzZXJzID0gY29tcGFjdChcbiAgICAgIEFycmF5LmZyb20odGhpcy5fcHJlc2VuY2VzLmtleXMoKSkubWFwKFxuICAgICAgICAoY29ubmVjdGlvbklkKSA9PiB0aGlzLmdldFVzZXIoTnVtYmVyKGNvbm5lY3Rpb25JZCkpXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gdXNlcnM7XG4gIH1cbiAgY2xlYXJPdGhlcnMoKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3ByZXNlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMuX2Nvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5fcHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb25uICE9PSB2b2lkIDAgJiYgcHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNhY2hlZFVzZXIgPSB0aGlzLl91c2Vycy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY2FjaGVkVXNlcikge1xuICAgICAgcmV0dXJuIGNhY2hlZFVzZXI7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkVXNlciA9IHRoaXMuX2dldFVzZXIoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY29tcHV0ZWRVc2VyKSB7XG4gICAgICB0aGlzLl91c2Vycy5zZXQoY29ubmVjdGlvbklkLCBjb21wdXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkVXNlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBpZiAodGhpcy5fdXNlcnMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX3VzZXJzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogUmVjb3JkcyBhIGtub3duIGNvbm5lY3Rpb24uIFRoaXMgcmVjb3JkcyB0aGUgY29ubmVjdGlvbiBJRCBhbmQgdGhlXG4gICAqIGFzc29jaWF0ZWQgbWV0YWRhdGEuXG4gICAqL1xuICBzZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCwgbWV0YVVzZXJJZCwgbWV0YVVzZXJJbmZvLCBzY29wZXMpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucy5zZXQoXG4gICAgICBjb25uZWN0aW9uSWQsXG4gICAgICBmcmVlemUoe1xuICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgIGlkOiBtZXRhVXNlcklkLFxuICAgICAgICBpbmZvOiBtZXRhVXNlckluZm8sXG4gICAgICAgIHNjb3Blc1xuICAgICAgfSlcbiAgICApO1xuICAgIGlmICh0aGlzLl9wcmVzZW5jZXMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEga25vd24gY29ubmVjdGlvbklkLiBSZW1vdmVzIGJvdGggdGhlIGNvbm5lY3Rpb24ncyBtZXRhZGF0YSBhbmRcbiAgICogdGhlIHByZXNlbmNlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uSWQpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgfVxuICAvKipcbiAgICogU3RvcmVzIGEgbmV3IHVzZXIgZnJvbSBhIGZ1bGwgcHJlc2VuY2UgdXBkYXRlLiBJZiB0aGUgdXNlciBhbHJlYWR5IGV4aXN0cyxcbiAgICogaXRzIGtub3duIHByZXNlbmNlIGRhdGEgaXMgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBzZXRPdGhlcihjb25uZWN0aW9uSWQsIHByZXNlbmNlKSB7XG4gICAgdGhpcy5fcHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShjb21wYWN0T2JqZWN0KHByZXNlbmNlKSkpO1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9ucy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoZXMgdGhlIHByZXNlbmNlIGRhdGEgZm9yIGFuIGV4aXN0aW5nIFwib3RoZXJcIi4gSWYgd2UgZG9uJ3Qga25vdyB0aGVcbiAgICogaW5pdGlhbCBwcmVzZW5jZSBkYXRhIGZvciB0aGlzIHVzZXIgeWV0LCBkaXNjYXJkIHRoaXMgcGF0Y2ggYW5kIGF3YWl0IHRoZVxuICAgKiBmdWxsIC5zZXRPdGhlcigpIGNhbGwgZmlyc3QuXG4gICAqL1xuICBwYXRjaE90aGVyKGNvbm5lY3Rpb25JZCwgcGF0Y2gpIHtcbiAgICBjb25zdCBvbGRQcmVzZW5jZSA9IHRoaXMuX3ByZXNlbmNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAob2xkUHJlc2VuY2UgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdQcmVzZW5jZSA9IG1lcmdlKG9sZFByZXNlbmNlLCBwYXRjaCk7XG4gICAgaWYgKG9sZFByZXNlbmNlICE9PSBuZXdQcmVzZW5jZSkge1xuICAgICAgdGhpcy5fcHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShuZXdQcmVzZW5jZSkpO1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWZzL1BhdGNoYWJsZVJlZi50c1xudmFyIFBhdGNoYWJsZVJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZGF0YSA9IGZyZWV6ZShjb21wYWN0T2JqZWN0KGRhdGEpKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgY3VycmVudCBvYmplY3QuXG4gICAqL1xuICBwYXRjaChwYXRjaCkge1xuICAgIGNvbnN0IG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IG5ld0RhdGEgPSBtZXJnZShvbGREYXRhLCBwYXRjaCk7XG4gICAgaWYgKG9sZERhdGEgIT09IG5ld0RhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBmcmVlemUobmV3RGF0YSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWZzL1ZhbHVlUmVmLnRzXG52YXIgVmFsdWVSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdmFsdWUgPSBmcmVlemUoaW5pdGlhbFZhbHVlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBmcmVlemUobmV3VmFsdWUpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG59O1xudmFyIERlcml2ZWRSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHRyYW5zZm9ybUZuID0gYXJncy5wb3AoKTtcbiAgICBjb25zdCBvdGhlclJlZnMgPSBhcmdzO1xuICAgIHRoaXMuX3JlZnMgPSBvdGhlclJlZnM7XG4gICAgdGhpcy5fcmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIHJlZi5kaWRJbnZhbGlkYXRlLnN1YnNjcmliZSgoKSA9PiB0aGlzLmludmFsaWRhdGUoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtRm47XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShcbiAgICAgIC4uLnRoaXMuX3JlZnMubWFwKChyZWYpID0+IHJlZi5jdXJyZW50KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9yb29tLnRzXG52YXIgTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUgPSAxMDI0ICogMTAyNCAtIDEwMjQ7XG5mdW5jdGlvbiBtYWtlSWRGYWN0b3J5KGNvbm5lY3Rpb25JZCkge1xuICBsZXQgY291bnQgPSAwO1xuICByZXR1cm4gKCkgPT4gYCR7Y29ubmVjdGlvbklkfToke2NvdW50Kyt9YDtcbn1cbmZ1bmN0aW9uIHVzZXJUb1RyZWVOb2RlKGtleSwgdXNlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVXNlclwiLFxuICAgIGlkOiBgJHt1c2VyLmNvbm5lY3Rpb25JZH1gLFxuICAgIGtleSxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBjb25uZWN0aW9uSWQ6IHVzZXIuY29ubmVjdGlvbklkLFxuICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICBpbmZvOiB1c2VyLmluZm8sXG4gICAgICBwcmVzZW5jZTogdXNlci5wcmVzZW5jZSxcbiAgICAgIGlzUmVhZE9ubHk6ICF1c2VyLmNhbldyaXRlXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKSB7XG4gIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICBjb25zdCBpbkJhY2tncm91bmRTaW5jZSA9IHsgY3VycmVudDogbnVsbCB9O1xuICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiKSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA/PyBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZG9jPy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICBjb25zdCB1bnN1YiA9ICgpID0+IHtcbiAgICBkb2M/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIH07XG4gIHJldHVybiBbaW5CYWNrZ3JvdW5kU2luY2UsIHVuc3ViXTtcbn1cbnZhciBDb21tZW50c0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRzQXBpKHJvb21JZCwgZ2V0QXV0aFZhbHVlLCBmZXRjaENsaWVudEFwaSkge1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaENvbW1lbnRzQXBpKGVuZHBvaW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBnZXRBdXRoVmFsdWUoKTtcbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkocm9vbUlkLCBlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoSnNvbihlbmRwb2ludCwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKGVuZHBvaW50LCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICBsZXQgZXJyb3IzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgQ29tbWVudHNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IENvbW1lbnRzQXBpRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBib2R5O1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgYm9keSA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMpIHtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKG9wdGlvbnM/LnF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IG9iamVjdFRvUXVlcnkob3B0aW9ucy5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDb21tZW50c0FwaShcbiAgICAgIFwiL3RocmVhZHNcIixcbiAgICAgIHtcbiAgICAgICAgc2luY2U6IG9wdGlvbnM/LnNpbmNlPy50b0lTT1N0cmluZygpLFxuICAgICAgICBxdWVyeVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IGpzb24uZGF0YS5tYXAoKHRocmVhZCkgPT4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgKG5vdGlmaWNhdGlvbikgPT4gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKG5vdGlmaWNhdGlvbilcbiAgICAgICAgKSxcbiAgICAgICAgZGVsZXRlZFRocmVhZHM6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKFxuICAgICAgICAgIChpbmZvKSA9PiBjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKGluZm8pXG4gICAgICAgICksXG4gICAgICAgIGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnM6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgKGluZm8pID0+IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mbyhpbmZvKVxuICAgICAgICApLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiBbXSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBbXSxcbiAgICAgICAgZGVsZXRlZFRocmVhZHM6IFtdLFxuICAgICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBbXSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHJlcXVlc3RlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aHJlYWRzLlwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkKHsgdGhyZWFkSWQgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDb21tZW50c0FwaShcbiAgICAgIGAvdGhyZWFkLXdpdGgtbm90aWZpY2F0aW9uLyR7dGhyZWFkSWR9YFxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiBjb252ZXJ0VG9UaHJlYWREYXRhKGpzb24udGhyZWFkKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb246IGpzb24uaW5ib3hOb3RpZmljYXRpb24gPyBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoanNvbi5pbmJveE5vdGlmaWNhdGlvbikgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRocmVhZCAke3RocmVhZElkfS5gKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGhyZWFkKHtcbiAgICBtZXRhZGF0YSxcbiAgICBib2R5LFxuICAgIGNvbW1lbnRJZCxcbiAgICB0aHJlYWRJZFxuICB9KSB7XG4gICAgY29uc3QgdGhyZWFkID0gYXdhaXQgZmV0Y2hKc29uKFwiL3RocmVhZHNcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGlkOiB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgYm9keVxuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YVxuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRocmVhZCh7IHRocmVhZElkIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX1gLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0VGhyZWFkTWV0YWRhdGEoe1xuICAgIG1ldGFkYXRhLFxuICAgIHRocmVhZElkXG4gIH0pIHtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vbWV0YWRhdGFgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNSZXNvbHZlZCh7IHRocmVhZElkIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9tYXJrLWFzLXJlc29sdmVkYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzVW5yZXNvbHZlZCh7IHRocmVhZElkIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9tYXJrLWFzLXVucmVzb2x2ZWRgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgYm9keVxuICB9KSB7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0Q29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGJvZHlcbiAgfSkge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgYm9keVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbW1lbnQyKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWRcbiAgfSkge1xuICAgIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhZGRSZWFjdGlvbjIoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgY29uc3QgcmVhY3Rpb24gPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfS9yZWFjdGlvbnNgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbW9qaSB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24ocmVhY3Rpb24pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uMih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfS9yZWFjdGlvbnMvJHtlbmNvZGVVUklDb21wb25lbnQoZW1vamkpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRUaHJlYWRzLFxuICAgIGdldFRocmVhZCxcbiAgICBjcmVhdGVUaHJlYWQsXG4gICAgZGVsZXRlVGhyZWFkLFxuICAgIGVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICBtYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgICBtYXJrVGhyZWFkQXNVbnJlc29sdmVkLFxuICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgZWRpdENvbW1lbnQsXG4gICAgZGVsZXRlQ29tbWVudDogZGVsZXRlQ29tbWVudDIsXG4gICAgYWRkUmVhY3Rpb246IGFkZFJlYWN0aW9uMixcbiAgICByZW1vdmVSZWFjdGlvbjogcmVtb3ZlUmVhY3Rpb24yXG4gIH07XG59XG52YXIgTUFSS19JTkJPWF9OT1RJRklDQVRJT05TX0FTX1JFQURfQkFUQ0hfREVMQVkyID0gNTA7XG5mdW5jdGlvbiBjcmVhdGVSb29tKG9wdGlvbnMsIGNvbmZpZykge1xuICBjb25zdCBpbml0aWFsUHJlc2VuY2UgPSBvcHRpb25zLmluaXRpYWxQcmVzZW5jZTtcbiAgY29uc3QgaW5pdGlhbFN0b3JhZ2UgPSBvcHRpb25zLmluaXRpYWxTdG9yYWdlO1xuICBjb25zdCBbaW5CYWNrZ3JvdW5kU2luY2UsIHVuaW5zdGFsbEJnVGFiU3B5XSA9IGluc3RhbGxCYWNrZ3JvdW5kVGFiU3B5KCk7XG4gIGNvbnN0IGRlbGVnYXRlcyA9IHtcbiAgICAuLi5jb25maWcuZGVsZWdhdGVzLFxuICAgIC8vIEEgY29ubmVjdGlvbiBpcyBhbGxvd2VkIHRvIGdvIGludG8gXCJ6b21iaWUgc3RhdGVcIiBvbmx5IGlmIGFsbCBvZiB0aGVcbiAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcHBseTpcbiAgICAvL1xuICAgIC8vIC0gVGhlIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgY2xpZW50IG9wdGlvbiBpcyBjb25maWd1cmVkXG4gICAgLy8gLSBUaGUgYnJvd3NlciB3aW5kb3cgaGFzIGJlZW4gaW4gdGhlIGJhY2tncm91bmQgZm9yIGF0IGxlYXN0XG4gICAgLy8gICBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIG1pbGxpc2Vjb25kc1xuICAgIC8vIC0gVGhlcmUgYXJlIG5vIHBlbmRpbmcgY2hhbmdlc1xuICAgIC8vXG4gICAgY2FuWm9tYmllKCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAhPT0gdm9pZCAwICYmIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgIT09IG51bGwgJiYgRGF0ZS5ub3coKSA+IGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgKyBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgJiYgZ2V0U3RvcmFnZVN0YXR1cygpICE9PSBcInN5bmNocm9uaXppbmdcIjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1hbmFnZWRTb2NrZXQgPSBuZXcgTWFuYWdlZFNvY2tldChcbiAgICBkZWxlZ2F0ZXMsXG4gICAgY29uZmlnLmVuYWJsZURlYnVnTG9nZ2luZ1xuICApO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGJ1ZmZlcjoge1xuICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICBsYXN0Rmx1c2hlZEF0OiAwLFxuICAgICAgcHJlc2VuY2VVcGRhdGVzOiAoXG4gICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBpbml0aWFsIHByZXNlbmNlIG1lc3NhZ2UgYXMgYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZVxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICAgICAgZGF0YTogaW5pdGlhbFByZXNlbmNlXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBtZXNzYWdlczogW10sXG4gICAgICBzdG9yYWdlT3BlcmF0aW9uczogW11cbiAgICB9LFxuICAgIHN0YXRpY1Nlc3Npb25JbmZvOiBuZXcgVmFsdWVSZWYobnVsbCksXG4gICAgZHluYW1pY1Nlc3Npb25JbmZvOiBuZXcgVmFsdWVSZWYobnVsbCksXG4gICAgbXlQcmVzZW5jZTogbmV3IFBhdGNoYWJsZVJlZihpbml0aWFsUHJlc2VuY2UpLFxuICAgIG90aGVyczogbmV3IE90aGVyc1JlZigpLFxuICAgIGluaXRpYWxTdG9yYWdlLFxuICAgIGlkRmFjdG9yeTogbnVsbCxcbiAgICAvLyBTdG9yYWdlXG4gICAgY2xvY2s6IDAsXG4gICAgb3BDbG9jazogMCxcbiAgICBub2RlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICByb290OiB2b2lkIDAsXG4gICAgdW5kb1N0YWNrOiBbXSxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHBhdXNlZEhpc3Rvcnk6IG51bGwsXG4gICAgYWN0aXZlQmF0Y2g6IG51bGwsXG4gICAgdW5hY2tub3dsZWRnZWRPcHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgLy8gRGVidWdcbiAgICBvcFN0YWNrVHJhY2VzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIDogdm9pZCAwXG4gIH07XG4gIGNvbnN0IGRvTm90QmF0Y2hVcGRhdGVzID0gKGNiKSA9PiBjYigpO1xuICBjb25zdCBiYXRjaFVwZGF0ZXMgPSBjb25maWcudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPz8gZG9Ob3RCYXRjaFVwZGF0ZXM7XG4gIGxldCBsYXN0VG9rZW5LZXk7XG4gIGZ1bmN0aW9uIG9uU3RhdHVzRGlkQ2hhbmdlKG5ld1N0YXR1cykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlO1xuICAgIGlmIChhdXRoVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRva2VuS2V5ID0gZ2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKTtcbiAgICAgIGlmICh0b2tlbktleSAhPT0gbGFzdFRva2VuS2V5KSB7XG4gICAgICAgIGxhc3RUb2tlbktleSA9IHRva2VuS2V5O1xuICAgICAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQ7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQsXG4gICAgICAgICAgICB1c2VySW5mbzogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmluZm8gOiB0b2tlbi51aVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdm9pZCAwLFxuICAgICAgICAgICAgdXNlckluZm86IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IF9jb25uZWN0aW9uTG9zc1RpbWVySWQ7XG4gIGxldCBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudChuZXdTdGF0dXMpIHtcbiAgICBpZiAobmV3U3RhdHVzID09PSBcInJlY29ubmVjdGluZ1wiKSB7XG4gICAgICBfY29ubmVjdGlvbkxvc3NUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbnRleHQub3RoZXJzLmNsZWFyT3RoZXJzKCk7XG4gICAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGNvbmZpZy5sb3N0Q29ubmVjdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCk7XG4gICAgICBpZiAoX2hhc0xvc3RDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJyZXN0b3JlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25EaWRDb25uZWN0KCkge1xuICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgZGF0YTogKFxuICAgICAgICAvLyBCZWNhdXNlIGNvbnRleHQubWUuY3VycmVudCBpcyBhIHJlYWRvbmx5IG9iamVjdCwgd2UnbGwgaGF2ZSB0b1xuICAgICAgICAvLyBtYWtlIGEgY29weSBoZXJlLiBPdGhlcndpc2UsIHR5cGUgZXJyb3JzIGhhcHBlbiBsYXRlciB3aGVuXG4gICAgICAgIC8vIFwicGF0Y2hpbmdcIiBteSBwcmVzZW5jZS5cbiAgICAgICAgeyAuLi5jb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTGl2ZWJsb2Nrc0Vycm9yLnN1YnNjcmliZSgoZXJyKSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3IyKFxuICAgICAgICAgIGBDb25uZWN0aW9uIHRvIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkLiBSZWFzb246ICR7ZXJyLm1lc3NhZ2V9IChjb2RlOiAke2Vyci5jb2RlfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZXZlbnRIdWIuZXJyb3Iubm90aWZ5KGVycik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBwb29sID0ge1xuICAgIHJvb21JZDogY29uZmlnLnJvb21JZCxcbiAgICBnZXROb2RlOiAoaWQpID0+IGNvbnRleHQubm9kZXMuZ2V0KGlkKSxcbiAgICBhZGROb2RlOiAoaWQsIG5vZGUpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5jbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0Lm9wQ2xvY2srK31gLFxuICAgIGRpc3BhdGNoKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCB0aGlzLmRpc3BhdGNoKTtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5zZXQob3Aub3BJZCwgc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQmF0Y2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC5vcHMucHVzaChvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoLi4ucmV2ZXJzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKHJldmVyc2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICAgICAgbm90aWZ5KHsgc3RvcmFnZVVwZGF0ZXMgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlOiAoKSA9PiB7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5zY29wZXM7XG4gICAgICBpZiAoc2NvcGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKTtcbiAgICAgIGlmICghY2FuV3JpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHdyaXRlIHRvIHN0b3JhZ2Ugd2l0aCBhIHJlYWQgb25seSB1c2VyLCBwbGVhc2UgZW5zdXJlIHRoZSB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uc1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBldmVudEh1YiA9IHtcbiAgICBzdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE5ldy9yZWNvbW1lbmRlZCBBUElcbiAgICBsb3N0Q29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY3VzdG9tRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHNlbGY6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG15UHJlc2VuY2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG90aGVyczogbWFrZUV2ZW50U291cmNlKCksXG4gICAgZXJyb3I6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VCYXRjaDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgaGlzdG9yeTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZURpZExvYWQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VTdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHlkb2M6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGNvbW1lbnRzOiBtYWtlRXZlbnRTb3VyY2UoKVxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaENsaWVudEFwaShyb29tSWQsIGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMyLCBwYXJhbXMpIHtcbiAgICBjb25zdCB1cmwgPSB1cmxqb2luKFxuICAgICAgY29uZmlnLmJhc2VVcmwsXG4gICAgICBgL3YyL2Mvcm9vbXMvJHtlbmNvZGVVUklDb21wb25lbnQocm9vbUlkKX0ke2VuZHBvaW50fWAsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICAgIGNvbnN0IGZldGNoZXIgPSBjb25maWcucG9seWZpbGxzPy5mZXRjaCB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZldGNoO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaGVyKHVybCwge1xuICAgICAgLi4ub3B0aW9uczIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnMyPy5oZWFkZXJzLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Z2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKX1gXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtRmV0Y2goYXV0aFZhbHVlLCByb29tSWQpIHtcbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkocm9vbUlkLCBcIi9zdG9yYWdlXCIsIGF1dGhWYWx1ZSwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGh0dHBQb3N0VG9Sb29tKGVuZHBvaW50LCBib2R5KSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShjb25maWcucm9vbUlkLCBlbmRwb2ludCwgbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUZXh0TWVudGlvbih1c2VySWQsIG1lbnRpb25JZCkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhdXRob3JpemVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoXG4gICAgICBjb25maWcucm9vbUlkLFxuICAgICAgXCIvdGV4dC1tZW50aW9uc1wiLFxuICAgICAgbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIG1lbnRpb25JZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGV4dE1lbnRpb24obWVudGlvbklkKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShcbiAgICAgIGNvbmZpZy5yb29tSWQsXG4gICAgICBgL3RleHQtbWVudGlvbnMvJHttZW50aW9uSWR9YCxcbiAgICAgIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlcG9ydFRleHRFZGl0b3IodHlwZSwgcm9vdEtleSkge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGRlbGVnYXRlcy5hdXRoZW50aWNhdGUoKTtcbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoY29uZmlnLnJvb21JZCwgXCIvdGV4dC1tZXRhZGF0YVwiLCBhdXRoVmFsdWUsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB0eXBlLFxuICAgICAgICByb290S2V5XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNlbmRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkobWVzc2FnZXMpO1xuICAgIGNvbnN0IG5vbmNlID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uY3VycmVudD8ubm9uY2U7XG4gICAgaWYgKGNvbmZpZy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCAmJiBub25jZSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZXJpYWxpemVkUGF5bG9hZCkubGVuZ3RoO1xuICAgICAgaWYgKHNpemUgPiBNQVhfU09DS0VUX01FU1NBR0VfU0laRSkge1xuICAgICAgICB2b2lkIGh0dHBQb3N0VG9Sb29tKFwiL3NlbmQtbWVzc2FnZVwiLCB7IG5vbmNlLCBtZXNzYWdlcyB9KS50aGVuKFxuICAgICAgICAgIChyZXNwKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3Aub2sgJiYgcmVzcC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgICBtYW5hZ2VkU29ja2V0LnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1lc3NhZ2Ugd2FzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cyBhbmQgc2VudCBvdmVyIEhUVFAgaW5zdGVhZFwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFuYWdlZFNvY2tldC5zZW5kKHNlcmlhbGl6ZWRQYXlsb2FkKTtcbiAgfVxuICBjb25zdCBzZWxmID0gbmV3IERlcml2ZWRSZWYoXG4gICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mbyxcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mbyxcbiAgICBjb250ZXh0Lm15UHJlc2VuY2UsXG4gICAgKHN0YXRpY1Nlc3Npb24sIGR5bmFtaWNTZXNzaW9uLCBteVByZXNlbmNlKSA9PiB7XG4gICAgICBpZiAoc3RhdGljU2Vzc2lvbiA9PT0gbnVsbCB8fCBkeW5hbWljU2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKGR5bmFtaWNTZXNzaW9uLnNjb3Blcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29ubmVjdGlvbklkOiBkeW5hbWljU2Vzc2lvbi5hY3RvcixcbiAgICAgICAgICBpZDogc3RhdGljU2Vzc2lvbi51c2VySWQsXG4gICAgICAgICAgaW5mbzogc3RhdGljU2Vzc2lvbi51c2VySW5mbyxcbiAgICAgICAgICBwcmVzZW5jZTogbXlQcmVzZW5jZSxcbiAgICAgICAgICBjYW5Xcml0ZSxcbiAgICAgICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGR5bmFtaWNTZXNzaW9uLnNjb3BlcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGxldCBfbGFzdFNlbGY7XG4gIGZ1bmN0aW9uIG5vdGlmeVNlbGZDaGFuZ2VkKGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnN0IGN1cnJTZWxmID0gc2VsZi5jdXJyZW50O1xuICAgIGlmIChjdXJyU2VsZiAhPT0gbnVsbCAmJiBjdXJyU2VsZiAhPT0gX2xhc3RTZWxmKSB7XG4gICAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICBldmVudEh1Yi5zZWxmLm5vdGlmeShjdXJyU2VsZik7XG4gICAgICB9KTtcbiAgICAgIF9sYXN0U2VsZiA9IGN1cnJTZWxmO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWxmQXNUcmVlTm9kZSA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIHNlbGYsXG4gICAgKG1lKSA9PiBtZSAhPT0gbnVsbCA/IHVzZXJUb1RyZWVOb2RlKFwiTWVcIiwgbWUpIDogbnVsbFxuICApO1xuICBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAobWVzc2FnZS5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBjYW5ub3QgbG9hZCBzdG9yYWdlIHdpdGhvdXQgaXRlbXNcIik7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LnJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgdXBkYXRlUm9vdChtZXNzYWdlLml0ZW1zLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnJvb3QgPSBMaXZlT2JqZWN0Ll9mcm9tSXRlbXMobWVzc2FnZS5pdGVtcywgcG9vbCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbldyaXRlID0gc2VsZi5jdXJyZW50Py5jYW5Xcml0ZSA/PyB0cnVlO1xuICAgIGNvbnN0IHN0YWNrU2l6ZUJlZm9yZSA9IGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0LmluaXRpYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoY29udGV4dC5yb290LmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNhbldyaXRlKSB7XG4gICAgICAgICAgY29udGV4dC5yb290LnNldChrZXksIGNsb25lTHNvbihjb250ZXh0LmluaXRpYWxTdG9yYWdlW2tleV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEF0dGVtcHRlZCB0byBwb3B1bGF0ZSBtaXNzaW5nIHN0b3JhZ2Uga2V5ICcke2tleX0nLCBidXQgY3VycmVudCB1c2VyIGhhcyBubyB3cml0ZSBhY2Nlc3NgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSBzdGFja1NpemVCZWZvcmU7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUm9vdChpdGVtcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbaWQsIG5vZGVdIG9mIGNvbnRleHQubm9kZXMpIHtcbiAgICAgIGN1cnJlbnRJdGVtcy5zZXQoaWQsIG5vZGUuX3NlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ldyBNYXAoaXRlbXMpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhvcHMsIGZhbHNlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gIH1cbiAgZnVuY3Rpb24gX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC51bmRvU3RhY2subGVuZ3RoID49IDUwKSB7XG4gICAgICBjb250ZXh0LnVuZG9TdGFjay5zaGlmdCgpO1xuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5wdXNoKGhpc3RvcnlPcHMpO1xuICAgIG9uSGlzdG9yeUNoYW5nZShiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnBhdXNlZEhpc3RvcnkgIT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeS51bnNoaWZ0KC4uLmhpc3RvcnlPcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeSh1cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXM7XG4gICAgY29uc3Qgb3RoZXJzVXBkYXRlcyA9IHVwZGF0ZXMub3RoZXJzO1xuICAgIGJhdGNoZWRVcGRhdGVzV3JhcHBlcigoKSA9PiB7XG4gICAgICBpZiAob3RoZXJzVXBkYXRlcyAhPT0gdm9pZCAwICYmIG90aGVyc1VwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5jdXJyZW50O1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIG90aGVyc1VwZGF0ZXMpIHtcbiAgICAgICAgICBldmVudEh1Yi5vdGhlcnMubm90aWZ5KHsgLi4uZXZlbnQsIG90aGVycyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMucHJlc2VuY2UgPz8gZmFsc2UpIHtcbiAgICAgICAgbm90aWZ5U2VsZkNoYW5nZWQoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICBldmVudEh1Yi5teVByZXNlbmNlLm5vdGlmeShjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcmFnZVVwZGF0ZXMgIT09IHZvaWQgMCAmJiBzdG9yYWdlVXBkYXRlcy5zaXplID4gMCkge1xuICAgICAgICBjb25zdCB1cGRhdGVzMiA9IEFycmF5LmZyb20oc3RvcmFnZVVwZGF0ZXMudmFsdWVzKCkpO1xuICAgICAgICBldmVudEh1Yi5zdG9yYWdlQmF0Y2gubm90aWZ5KHVwZGF0ZXMyKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDb25uZWN0aW9uSWQoKSB7XG4gICAgY29uc3QgaW5mbyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmFjdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludGVybmFsLiBUcmllZCB0byBnZXQgY29ubmVjdGlvbiBpZCBidXQgY29ubmVjdGlvbiB3YXMgbmV2ZXIgb3BlblwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wcyhyYXdPcHMsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICByZXZlcnNlOiBbXSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJlc2VuY2U6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb3BzID0gcmF3T3BzLm1hcCgob3ApID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIgJiYgIW9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3AsIG9wSWQ6IHBvb2wuZ2VuZXJhdGVPcElkKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb25zdCByZXZlcnNlID0ge1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgcmV2ZXJzZS5kYXRhW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChvcC5kYXRhKTtcbiAgICAgICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHsgdHlwZTogXCJwYXJ0aWFsXCIsIGRhdGE6IG9wLmRhdGEgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3AuZGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucmV2ZXJzZS51bnNoaWZ0KHJldmVyc2UpO1xuICAgICAgICBvdXRwdXQucHJlc2VuY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgICAgICBzb3VyY2UgPSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvcElkID0gbm4ob3Aub3BJZCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5kZWxldGUob3BJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICBzb3VyY2UgPSBkZWxldGVkID8gMiAvKiBBQ0sgKi8gOiAxIC8qIFJFTU9URSAqLztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBseU9wUmVzdWx0ID0gYXBwbHlPcChvcCwgc291cmNlKTtcbiAgICAgICAgaWYgKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQpIHtcbiAgICAgICAgICBjb25zdCBub2RlSWQgPSBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkO1xuICAgICAgICAgIGlmICghKG5vZGVJZCAmJiBjcmVhdGVkTm9kZUlkcy5oYXMobm9kZUlkKSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgIG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpLFxuICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5nZXQobm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCkpLFxuICAgICAgICAgICAgICAgIGFwcGx5T3BSZXN1bHQubW9kaWZpZWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG91dHB1dC5yZXZlcnNlLnVuc2hpZnQoLi4uYXBwbHlPcFJlc3VsdC5yZXZlcnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IDIgLyogQ1JFQVRFX0xJU1QgKi8gfHwgb3AudHlwZSA9PT0gNyAvKiBDUkVBVEVfTUFQICovIHx8IG9wLnR5cGUgPT09IDQgLyogQ1JFQVRFX09CSkVDVCAqLykge1xuICAgICAgICAgICAgY3JlYXRlZE5vZGVJZHMuYWRkKG5uKG9wLmlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvcHMsXG4gICAgICByZXZlcnNlOiBvdXRwdXQucmV2ZXJzZSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IG91dHB1dC5zdG9yYWdlVXBkYXRlcyxcbiAgICAgICAgcHJlc2VuY2U6IG91dHB1dC5wcmVzZW5jZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcChvcCwgc291cmNlKSB7XG4gICAgaWYgKGlzQWNrT3Aob3ApKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi86XG4gICAgICBjYXNlIDMgLyogVVBEQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuX2FwcGx5KG9wLCBzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgMSAvKiBTRVRfUEFSRU5UX0tFWSAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLnBhcmVudElkKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnROb2RlLl9hdHRhY2hDaGlsZChvcCwgc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUHJlc2VuY2UocGF0Y2gsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qgb2xkVmFsdWVzID0ge307XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgICB0eXBlOiBcInBhcnRpYWxcIixcbiAgICAgICAgZGF0YToge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBvdmVycmlkZVZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3ZlcnJpZGVWYWx1ZTtcbiAgICAgIG9sZFZhbHVlc1trZXldID0gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnRba2V5XTtcbiAgICB9XG4gICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKHBhdGNoKTtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiBvbGRWYWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnVwZGF0ZXMucHJlc2VuY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhcbiAgICAgICAgICAgIFt7IHR5cGU6IFwicHJlc2VuY2VcIiwgZGF0YTogb2xkVmFsdWVzIH1dLFxuICAgICAgICAgICAgZG9Ob3RCYXRjaFVwZGF0ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeSh7IHByZXNlbmNlOiB0cnVlIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudGFyZ2V0QWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgb2xkVXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgY29uc3QgbmV3VXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBpZiAob2xkVXNlciA9PT0gdm9pZCAwICYmIG5ld1VzZXIgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVudGVyXCIsIHVzZXI6IG5ld1VzZXIgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5vdGhlcnMucGF0Y2hPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpLCBtZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgdXBkYXRlczogbWVzc2FnZS5kYXRhLFxuICAgICAgICB1c2VyXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24obWVzc2FnZS5hY3Rvcik7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxlYXZlXCIsIHVzZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gb25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICBhY3RvcjogbWVzc2FnZS5hY3RvcixcbiAgICAgIG5vbmNlOiBtZXNzYWdlLm5vbmNlLFxuICAgICAgc2NvcGVzOiBtZXNzYWdlLnNjb3Blc1xuICAgIH0pO1xuICAgIGNvbnRleHQuaWRGYWN0b3J5ID0gbWFrZUlkRmFjdG9yeShtZXNzYWdlLmFjdG9yKTtcbiAgICBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIGZvciAoY29uc3QgY29ubmVjdGlvbklkIG9mIGNvbnRleHQub3RoZXJzLmNvbm5lY3Rpb25JZHMoKSkge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNbY29ubmVjdGlvbklkXTtcbiAgICAgIGlmICh1c2VyID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dC5vdGhlcnMucmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXNzYWdlLnVzZXJzKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1trZXldO1xuICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gTnVtYmVyKGtleSk7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRDb25uZWN0aW9uKFxuICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgIHVzZXIuaWQsXG4gICAgICAgIHVzZXIuaW5mbyxcbiAgICAgICAgdXNlci5zY29wZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwicmVzZXRcIiB9O1xuICB9XG4gIGZ1bmN0aW9uIGNhblVuZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gY2FuUmVkbygpIHtcbiAgICByZXR1cm4gY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBvbkhpc3RvcnlDaGFuZ2UoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGV2ZW50SHViLmhpc3Rvcnkubm90aWZ5KHsgY2FuVW5kbzogY2FuVW5kbygpLCBjYW5SZWRvOiBjYW5SZWRvKCkgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgIG1lc3NhZ2UuYWN0b3IsXG4gICAgICBtZXNzYWdlLmlkLFxuICAgICAgbWVzc2FnZS5pbmZvLFxuICAgICAgbWVzc2FnZS5zY29wZXNcbiAgICApO1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgIGRhdGE6IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgdGFyZ2V0QWN0b3I6IG1lc3NhZ2UuYWN0b3JcbiAgICB9KTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIHJldHVybiB1c2VyID8geyB0eXBlOiBcImVudGVyXCIsIHVzZXIgfSA6IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICghaXNKc29uT2JqZWN0KGRhdGEpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlcyh0ZXh0KSB7XG4gICAgY29uc3QgZGF0YSA9IHRyeVBhcnNlSnNvbih0ZXh0KTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGlzSnNvbkFycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gY29tcGFjdChkYXRhLm1hcCgoaXRlbSkgPT4gcGFyc2VTZXJ2ZXJNZXNzYWdlKGl0ZW0pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21wYWN0KFtwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSldKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlBbmRTZW5kT3BzKG9mZmxpbmVPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChvZmZsaW5lT3BzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBjb25zdCBvcHMgPSBBcnJheS5mcm9tKG9mZmxpbmVPcHMudmFsdWVzKCkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgdHJ1ZSk7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICBvcHM6IHJlc3VsdC5vcHNcbiAgICB9KTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTZXJ2ZXJNZXNzYWdlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gcGFyc2VTZXJ2ZXJNZXNzYWdlcyhldmVudC5kYXRhKTtcbiAgICBpZiAobWVzc2FnZXMgPT09IG51bGwgfHwgbWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZXMgPSB7XG4gICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIG90aGVyczogW11cbiAgICB9O1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIDEwMSAvKiBVU0VSX0pPSU5FRCAqLzoge1xuICAgICAgICAgICAgY29uc3QgdXNlckpvaW5lZFVwZGF0ZSA9IG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodXNlckpvaW5lZFVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKHVzZXJKb2luZWRVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzUHJlc2VuY2VVcGRhdGUgPSBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChvdGhlcnNQcmVzZW5jZVVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG90aGVyc1ByZXNlbmNlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMyAvKiBCUk9BRENBU1RFRF9FVkVOVCAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuY3VycmVudDtcbiAgICAgICAgICAgIGV2ZW50SHViLmN1c3RvbUV2ZW50Lm5vdGlmeSh7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogbWVzc2FnZS5hY3RvcixcbiAgICAgICAgICAgICAgdXNlcjogbWVzc2FnZS5hY3RvciA8IDAgPyBudWxsIDogb3RoZXJzLmZpbmQoKHUpID0+IHUuY29ubmVjdGlvbklkID09PSBtZXNzYWdlLmFjdG9yKSA/PyBudWxsLFxuICAgICAgICAgICAgICBldmVudDogbWVzc2FnZS5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDIgLyogVVNFUl9MRUZUICovOiB7XG4gICAgICAgICAgICBjb25zdCBldmVudDIgPSBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChldmVudDIpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChldmVudDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMzAwIC8qIFVQREFURV9ZRE9DICovOiB7XG4gICAgICAgICAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwNCAvKiBST09NX1NUQVRFICovOiB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLzoge1xuICAgICAgICAgICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAxIC8qIFVQREFURV9TVE9SQUdFICovOiB7XG4gICAgICAgICAgICBjb25zdCBhcHBseVJlc3VsdCA9IGFwcGx5T3BzKG1lc3NhZ2Uub3BzLCBmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhcHBseVJlc3VsdC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksIHZhbHVlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjk5IC8qIFJFSkVDVF9TVE9SQUdFX09QICovOiB7XG4gICAgICAgICAgICBlcnJvcldpdGhUaXRsZShcbiAgICAgICAgICAgICAgXCJTdG9yYWdlIG11dGF0aW9uIHJlamVjdGlvbiBlcnJvclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlLnJlYXNvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBvcElkIG9mIG1lc3NhZ2Uub3BJZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZSA9IGNvbnRleHQub3BTdGFja1RyYWNlcz8uZ2V0KG9wSWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgICAgdHJhY2VzLmFkZCh0cmFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB3YXJuV2l0aFRpdGxlKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGNhbGxzIGNhdXNlZCB0aGUgcmVqZWN0ZWQgc3RvcmFnZSBtdXRhdGlvbnM6XCIsXG4gICAgICAgICAgICAgICAgICBgXG5cbiR7QXJyYXkuZnJvbSh0cmFjZXMpLmpvaW4oXCJcXG5cXG5cIil9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBTdG9yYWdlIG11dGF0aW9ucyByZWplY3RlZCBieSBzZXJ2ZXI6ICR7bWVzc2FnZS5yZWFzb259YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNDAwIC8qIFRIUkVBRF9DUkVBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA3IC8qIFRIUkVBRF9ERUxFVEVEICovOlxuICAgICAgICAgIGNhc2UgNDAxIC8qIFRIUkVBRF9NRVRBREFUQV9VUERBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA4IC8qIFRIUkVBRF9VUERBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA1IC8qIENPTU1FTlRfUkVBQ1RJT05fQURERUQgKi86XG4gICAgICAgICAgY2FzZSA0MDYgLyogQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEICovOlxuICAgICAgICAgIGNhc2UgNDAyIC8qIENPTU1FTlRfQ1JFQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMyAvKiBDT01NRU5UX0VESVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNCAvKiBDT01NRU5UX0RFTEVURUQgKi86IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmNvbW1lbnRzLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm90aWZ5KHVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmbHVzaE5vd09yU29vbigpIHtcbiAgICBjb25zdCBzdG9yYWdlT3BzID0gY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnM7XG4gICAgaWYgKHN0b3JhZ2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBzdG9yYWdlT3BzKSB7XG4gICAgICAgIGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuc2V0KG5uKG9wLm9wSWQpLCBvcCk7XG4gICAgICB9XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucyA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRNaWxsaXMgPSBub3cgLSBjb250ZXh0LmJ1ZmZlci5sYXN0Rmx1c2hlZEF0O1xuICAgIGlmIChlbGFwc2VkTWlsbGlzID49IGNvbmZpZy50aHJvdHRsZURlbGF5KSB7XG4gICAgICBjb25zdCBtZXNzYWdlc1RvRmx1c2ggPSBzZXJpYWxpemVCdWZmZXIoKTtcbiAgICAgIGlmIChtZXNzYWdlc1RvRmx1c2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlc1RvRmx1c2gpO1xuICAgICAgY29udGV4dC5idWZmZXIgPSB7XG4gICAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgICBsYXN0Rmx1c2hlZEF0OiBub3csXG4gICAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdLFxuICAgICAgICBwcmVzZW5jZVVwZGF0ZXM6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQpO1xuICAgICAgY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEID0gc2V0VGltZW91dChcbiAgICAgICAgZmx1c2hOb3dPclNvb24sXG4gICAgICAgIGNvbmZpZy50aHJvdHRsZURlbGF5IC0gZWxhcHNlZE1pbGxpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKCkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChcbiAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLnR5cGUgPT09IFwiZnVsbFwiID8ge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgLy8gUG9wdWxhdGluZyB0aGUgYHRhcmdldEFjdG9yYCBmaWVsZCB0dXJucyB0aGlzIG1lc3NhZ2UgaW50b1xuICAgICAgICAgIC8vIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGUgbWVzc2FnZSAobm90IGEgcGF0Y2gpLCB3aGljaCB3aWxsIGdldFxuICAgICAgICAgIC8vIGludGVycHJldGVkIGJ5IG90aGVyIGNsaWVudHMgYXMgc3VjaC5cbiAgICAgICAgICB0YXJnZXRBY3RvcjogLTEsXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgY29udGV4dC5idWZmZXIubWVzc2FnZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLyxcbiAgICAgICAgb3BzOiBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVZRG9jKHVwZGF0ZSwgZ3VpZCkge1xuICAgIGNvbnN0IGNsaWVudE1zZyA9IHtcbiAgICAgIHR5cGU6IDMwMSAvKiBVUERBVEVfWURPQyAqLyxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIGd1aWRcbiAgICB9O1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goY2xpZW50TXNnKTtcbiAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShjbGllbnRNc2cpO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyID0ge1xuICAgIHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIgJiYgIW9wdGlvbnMyLnNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAzIC8qIEJST0FEQ0FTVF9FVkVOVCAqLyxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaE9wcyhvcHMpIHtcbiAgICBjb25zdCB7IHN0b3JhZ2VPcGVyYXRpb25zIH0gPSBjb250ZXh0LmJ1ZmZlcjtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgbGV0IF9nZXRTdG9yYWdlJCA9IG51bGw7XG4gIGxldCBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wcyA9IG5ldyBNYXAoY29udGV4dC51bmFja25vd2xlZGdlZE9wcyk7XG4gICAgY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIGFwcGx5QW5kU2VuZE9wcyh1bmFja25vd2xlZGdlZE9wcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2U/LigpO1xuICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5ub3RpZnkoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdHJlYW1TdG9yYWdlKCkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RyZWFtRmV0Y2gobWFuYWdlZFNvY2tldC5hdXRoVmFsdWUsIGNvbmZpZy5yb29tSWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UoeyB0eXBlOiAyMDAgLyogSU5JVElBTF9TVE9SQUdFX1NUQVRFICovLCBpdGVtcyB9KTtcbiAgfVxuICBmdW5jdGlvbiByZWZyZXNoU3RvcmFnZShvcHRpb25zMikge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gY29udGV4dC5idWZmZXIubWVzc2FnZXM7XG4gICAgaWYgKGNvbmZpZy51bnN0YWJsZV9zdHJlYW1EYXRhKSB7XG4gICAgICB2b2lkIHN0cmVhbVN0b3JhZ2UoKTtcbiAgICB9IGVsc2UgaWYgKCFtZXNzYWdlcy5zb21lKChtc2cpID0+IG1zZy50eXBlID09PSAyMDAgLyogRkVUQ0hfU1RPUkFHRSAqLykpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goeyB0eXBlOiAyMDAgLyogRkVUQ0hfU1RPUkFHRSAqLyB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMyLmZsdXNoKSB7XG4gICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdGFydExvYWRpbmdTdG9yYWdlKCkge1xuICAgIGlmIChfZ2V0U3RvcmFnZSQgPT09IG51bGwpIHtcbiAgICAgIHJlZnJlc2hTdG9yYWdlKHsgZmx1c2g6IHRydWUgfSk7XG4gICAgICBfZ2V0U3RvcmFnZSQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH1cbiAgICByZXR1cm4gX2dldFN0b3JhZ2UkO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0b3JhZ2VTbmFwc2hvdCgpIHtcbiAgICBjb25zdCByb290ID0gY29udGV4dC5yb290O1xuICAgIGlmIChyb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH0gZWxzZSB7XG4gICAgICB2b2lkIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRTdG9yYWdlKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHJvb3Q6IGNvbnRleHQucm9vdFxuICAgICAgfSk7XG4gICAgfVxuICAgIGF3YWl0IHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDogbm4oY29udGV4dC5yb290KVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmV0Y2hZRG9jKHZlY3RvciwgZ3VpZCkge1xuICAgIGlmICghY29udGV4dC5idWZmZXIubWVzc2FnZXMuZmluZCgobSkgPT4ge1xuICAgICAgcmV0dXJuIG0udHlwZSA9PT0gMzAwIC8qIEZFVENIX1lET0MgKi8gJiYgbS52ZWN0b3IgPT09IHZlY3RvciAmJiBtLmd1aWQgPT09IGd1aWQ7XG4gICAgfSkpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAzMDAgLyogRkVUQ0hfWURPQyAqLyxcbiAgICAgICAgdmVjdG9yLFxuICAgICAgICBndWlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiB1bmRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC51bmRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIGNvbnRleHQucmVkb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgICAgb25IaXN0b3J5Q2hhbmdlKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVkbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVkbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucmVkb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICBjb250ZXh0LnVuZG9TdGFjay5wdXNoKHJlc3VsdC5yZXZlcnNlKTtcbiAgICAgIG9uSGlzdG9yeUNoYW5nZShkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcCBvZiByZXN1bHQub3BzKSB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgfVxuICBmdW5jdGlvbiBiYXRjaChjYWxsYmFjaykge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgbGV0IHJldHVyblZhbHVlID0gdm9pZCAwO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoID0ge1xuICAgICAgICBvcHM6IFtdLFxuICAgICAgICB1cGRhdGVzOiB7XG4gICAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICAgICAgcHJlc2VuY2U6IGZhbHNlLFxuICAgICAgICAgIG90aGVyczogW11cbiAgICAgICAgfSxcbiAgICAgICAgcmV2ZXJzZU9wczogW11cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zdCBjdXJyZW50QmF0Y2ggPSBjb250ZXh0LmFjdGl2ZUJhdGNoO1xuICAgICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoID0gbnVsbDtcbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhjdXJyZW50QmF0Y2gucmV2ZXJzZU9wcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50QmF0Y2gub3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50QmF0Y2gub3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkaXNwYXRjaE9wcyhjdXJyZW50QmF0Y2gub3BzKTtcbiAgICAgICAgfVxuICAgICAgICBub3RpZnkoY3VycmVudEJhdGNoLnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2VIaXN0b3J5KCkge1xuICAgIGlmIChjb250ZXh0LnBhdXNlZEhpc3RvcnkgPT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IFtdO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXN1bWVIaXN0b3J5KCkge1xuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnBhdXNlZEhpc3Rvcnk7XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBpZiAoaGlzdG9yeU9wcyAhPT0gbnVsbCAmJiBoaXN0b3J5T3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVN0YXR1cygpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBfZ2V0U3RvcmFnZSQgPT09IG51bGwgPyBcIm5vdC1sb2FkZWRcIiA6IFwibG9hZGluZ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zaXplID09PSAwID8gXCJzeW5jaHJvbml6ZWRcIiA6IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfVxuICBsZXQgX2xhc3RTdG9yYWdlU3RhdHVzID0gZ2V0U3RvcmFnZVN0YXR1cygpO1xuICBmdW5jdGlvbiBub3RpZnlTdG9yYWdlU3RhdHVzKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gICAgaWYgKF9sYXN0U3RvcmFnZVN0YXR1cyAhPT0gc3RvcmFnZVN0YXR1cykge1xuICAgICAgX2xhc3RTdG9yYWdlU3RhdHVzID0gc3RvcmFnZVN0YXR1cztcbiAgICAgIGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMubm90aWZ5KHN0b3JhZ2VTdGF0dXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1ByZXNlbmNlUmVhZHkoKSB7XG4gICAgcmV0dXJuIHNlbGYuY3VycmVudCAhPT0gbnVsbDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWxQcmVzZW5jZVJlYWR5KCkge1xuICAgIHdoaWxlICghaXNQcmVzZW5jZVJlYWR5KCkpIHtcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCk7XG4gICAgICBjb25zdCB1bnN1YjEgPSBldmVudHMuc2VsZi5zdWJzY3JpYmVPbmNlKHJlc29sdmUpO1xuICAgICAgY29uc3QgdW5zdWIyID0gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmVPbmNlKHJlc29sdmUpO1xuICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIHVuc3ViMSgpO1xuICAgICAgdW5zdWIyKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzU3RvcmFnZVJlYWR5KCkge1xuICAgIHJldHVybiBnZXRTdG9yYWdlU25hcHNob3QoKSAhPT0gbnVsbDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWxTdG9yYWdlUmVhZHkoKSB7XG4gICAgd2hpbGUgKCFpc1N0b3JhZ2VSZWFkeSgpKSB7XG4gICAgICBhd2FpdCBnZXRTdG9yYWdlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG90aGVyc19mb3JEZXZUb29scyA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIGNvbnRleHQub3RoZXJzLFxuICAgIChvdGhlcnMpID0+IG90aGVycy5tYXAoKG90aGVyLCBpbmRleCkgPT4gdXNlclRvVHJlZU5vZGUoYE90aGVyICR7aW5kZXh9YCwgb3RoZXIpKVxuICApO1xuICBjb25zdCBldmVudHMgPSB7XG4gICAgc3RhdHVzOiBldmVudEh1Yi5zdGF0dXMub2JzZXJ2YWJsZSxcbiAgICBsb3N0Q29ubmVjdGlvbjogZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ub2JzZXJ2YWJsZSxcbiAgICBjdXN0b21FdmVudDogZXZlbnRIdWIuY3VzdG9tRXZlbnQub2JzZXJ2YWJsZSxcbiAgICBvdGhlcnM6IGV2ZW50SHViLm90aGVycy5vYnNlcnZhYmxlLFxuICAgIHNlbGY6IGV2ZW50SHViLnNlbGYub2JzZXJ2YWJsZSxcbiAgICBteVByZXNlbmNlOiBldmVudEh1Yi5teVByZXNlbmNlLm9ic2VydmFibGUsXG4gICAgZXJyb3I6IGV2ZW50SHViLmVycm9yLm9ic2VydmFibGUsXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgc3RvcmFnZTogZXZlbnRIdWIuc3RvcmFnZUJhdGNoLm9ic2VydmFibGUsXG4gICAgc3RvcmFnZUJhdGNoOiBldmVudEh1Yi5zdG9yYWdlQmF0Y2gub2JzZXJ2YWJsZSxcbiAgICBoaXN0b3J5OiBldmVudEh1Yi5oaXN0b3J5Lm9ic2VydmFibGUsXG4gICAgc3RvcmFnZURpZExvYWQ6IGV2ZW50SHViLnN0b3JhZ2VEaWRMb2FkLm9ic2VydmFibGUsXG4gICAgc3RvcmFnZVN0YXR1czogZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5vYnNlcnZhYmxlLFxuICAgIHlkb2M6IGV2ZW50SHViLnlkb2Mub2JzZXJ2YWJsZSxcbiAgICBjb21tZW50czogZXZlbnRIdWIuY29tbWVudHMub2JzZXJ2YWJsZVxuICB9O1xuICBjb25zdCBjb21tZW50c0FwaSA9IGNyZWF0ZUNvbW1lbnRzQXBpKFxuICAgIGNvbmZpZy5yb29tSWQsXG4gICAgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSxcbiAgICBmZXRjaENsaWVudEFwaVxuICApO1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaE5vdGlmaWNhdGlvbnNKc29uKGVuZHBvaW50LCBvcHRpb25zMikge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGRlbGVnYXRlcy5hdXRoZW50aWNhdGUoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ2xpZW50QXBpKFxuICAgICAgY29uZmlnLnJvb21JZCxcbiAgICAgIGVuZHBvaW50LFxuICAgICAgYXV0aFZhbHVlLFxuICAgICAgb3B0aW9uczJcbiAgICApO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICBsZXQgZXJyb3IzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgZXJyb3JCb2R5Lm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvckJvZHlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCkge1xuICAgIHJldHVybiBmZXRjaE5vdGlmaWNhdGlvbnNKc29uKFxuICAgICAgXCIvbm90aWZpY2F0aW9uLXNldHRpbmdzXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHJldHVybiBmZXRjaE5vdGlmaWNhdGlvbnNKc29uKFxuICAgICAgXCIvbm90aWZpY2F0aW9uLXNldHRpbmdzXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZHMpIHtcbiAgICBhd2FpdCBmZXRjaE5vdGlmaWNhdGlvbnNKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5ib3hOb3RpZmljYXRpb25JZHMgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZCA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICBhd2FpdCBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICB9LFxuICAgIHsgZGVsYXk6IE1BUktfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0JBVENIX0RFTEFZMiB9XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQuZ2V0KGluYm94Tm90aWZpY2F0aW9uSWQpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAge1xuICAgICAgW2tJbnRlcm5hbF06IHtcbiAgICAgICAgZ2V0IHByZXNlbmNlQnVmZmVyKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzPy5kYXRhID8/IG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IHVuZG9TdGFjaygpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQudW5kb1N0YWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCBub2RlQ291bnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQubm9kZXMuc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIC8vIHNlbmQgbWV0YWRhdGEgd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIHJlcG9ydFRleHRFZGl0b3IsXG4gICAgICAgIC8vIGNyZWF0ZSBhIHRleHQgbWVudGlvbiB3aGVuIHVzaW5nIGEgdGV4dCBlZGl0b3JcbiAgICAgICAgY3JlYXRlVGV4dE1lbnRpb24sXG4gICAgICAgIC8vIGRlbGV0ZSBhIHRleHQgbWVudGlvbiB3aGVuIHVzaW5nIGEgdGV4dCBlZGl0b3JcbiAgICAgICAgZGVsZXRlVGV4dE1lbnRpb24sXG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHRoZSBMaXZlYmxvY2tzIGJyb3dzZXIgZXh0ZW5zaW9uXG4gICAgICAgIGdldFNlbGZfZm9yRGV2VG9vbHM6ICgpID0+IHNlbGZBc1RyZWVOb2RlLmN1cnJlbnQsXG4gICAgICAgIGdldE90aGVyc19mb3JEZXZUb29sczogKCkgPT4gb3RoZXJzX2ZvckRldlRvb2xzLmN1cnJlbnQsXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBzaW11bGF0ZToge1xuICAgICAgICAgIC8vIFRoZXNlIGV4aXN0IG9ubHkgZm9yIG91ciBFMkUgdGVzdGluZyBhcHBcbiAgICAgICAgICBleHBsaWNpdENsb3NlOiAoZXZlbnQpID0+IG1hbmFnZWRTb2NrZXQuX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSksXG4gICAgICAgICAgcmF3U2VuZDogKGRhdGEpID0+IG1hbmFnZWRTb2NrZXQuc2VuZChkYXRhKVxuICAgICAgICB9LFxuICAgICAgICBjb21tZW50czoge1xuICAgICAgICAgIC4uLmNvbW1lbnRzQXBpXG4gICAgICAgIH0sXG4gICAgICAgIG5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICBnZXRSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICAgICAgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaWQ6IGNvbmZpZy5yb29tSWQsXG4gICAgICBzdWJzY3JpYmU6IG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4oZXZlbnRzKSxcbiAgICAgIGNvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuY29ubmVjdCgpLFxuICAgICAgcmVjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LnJlY29ubmVjdCgpLFxuICAgICAgZGlzY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5kaXNjb25uZWN0KCksXG4gICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgIHVuaW5zdGFsbEJnVGFiU3B5KCk7XG4gICAgICAgIG1hbmFnZWRTb2NrZXQuZGVzdHJveSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFByZXNlbmNlXG4gICAgICB1cGRhdGVQcmVzZW5jZSxcbiAgICAgIHVwZGF0ZVlEb2MsXG4gICAgICBicm9hZGNhc3RFdmVudCxcbiAgICAgIC8vIFN0b3JhZ2VcbiAgICAgIGJhdGNoLFxuICAgICAgaGlzdG9yeToge1xuICAgICAgICB1bmRvLFxuICAgICAgICByZWRvLFxuICAgICAgICBjYW5VbmRvLFxuICAgICAgICBjYW5SZWRvLFxuICAgICAgICBjbGVhcixcbiAgICAgICAgcGF1c2U6IHBhdXNlSGlzdG9yeSxcbiAgICAgICAgcmVzdW1lOiByZXN1bWVIaXN0b3J5XG4gICAgICB9LFxuICAgICAgZmV0Y2hZRG9jLFxuICAgICAgZ2V0U3RvcmFnZSxcbiAgICAgIGdldFN0b3JhZ2VTbmFwc2hvdCxcbiAgICAgIGdldFN0b3JhZ2VTdGF0dXMsXG4gICAgICBpc1ByZXNlbmNlUmVhZHksXG4gICAgICBpc1N0b3JhZ2VSZWFkeSxcbiAgICAgIHdhaXRVbnRpbFByZXNlbmNlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsUHJlc2VuY2VSZWFkeSksXG4gICAgICB3YWl0VW50aWxTdG9yYWdlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsU3RvcmFnZVJlYWR5KSxcbiAgICAgIGV2ZW50cyxcbiAgICAgIC8vIENvcmVcbiAgICAgIGdldFN0YXR1czogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSxcbiAgICAgIGdldFNlbGY6ICgpID0+IHNlbGYuY3VycmVudCxcbiAgICAgIC8vIFByZXNlbmNlXG4gICAgICBnZXRQcmVzZW5jZTogKCkgPT4gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQsXG4gICAgICBnZXRPdGhlcnM6ICgpID0+IGNvbnRleHQub3RoZXJzLmN1cnJlbnRcbiAgICB9LFxuICAgIC8vIEV4cGxpY3RseSBtYWtlIHRoZSBpbnRlcm5hbCBmaWVsZCBub24tZW51bWVyYWJsZSwgdG8gYXZvaWQgYWdncmVzc2l2ZVxuICAgIC8vIGZyZWV6aW5nIHdoZW4gdXNlZCB3aXRoIEltbWVyXG4gICAga0ludGVybmFsLFxuICAgIHsgZW51bWVyYWJsZTogZmFsc2UgfVxuICApO1xufVxuZnVuY3Rpb24gbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihldmVudHMpIHtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBjb25zdCByZWxhdGVkVXBkYXRlcyA9IHVwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAodXBkYXRlKSA9PiBpc1NhbWVOb2RlT3JDaGlsZE9mKHVwZGF0ZS5ub2RlLCBub2RlKVxuICAgICAgKTtcbiAgICAgIGlmIChyZWxhdGVkVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlbGF0ZWRVcGRhdGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoKHVwZGF0ZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5ub2RlLl9pZCA9PT0gbm9kZS5faWQpIHtcbiAgICAgICAgICBjYWxsYmFjayh1cGRhdGUubm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZmlyc3QsIHNlY29uZCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgaXNSb29tRXZlbnROYW1lKGZpcnN0KSkge1xuICAgICAgaWYgKHR5cGVvZiBzZWNvbmQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwibXktcHJlc2VuY2VcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm15UHJlc2VuY2Uuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcIm90aGVyc1wiOiB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG90aGVycywgLi4uaW50ZXJuYWxFdmVudCB9ID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gY2Iob3RoZXJzLCBpbnRlcm5hbEV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmVycm9yLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJzdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwibG9zdC1jb25uZWN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJoaXN0b3J5XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJzdG9yYWdlLXN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZVN0YXR1cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKFxuICAgICAgICAgICAgZmlyc3QsXG4gICAgICAgICAgICBgXCIke1N0cmluZyhmaXJzdCl9XCIgaXMgbm90IGEgdmFsaWQgZXZlbnQgbmFtZWBcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDAgfHwgdHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBmaXJzdDtcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3BlY2lmeSBhIGxpc3RlbmVyIGNhbGxiYWNrXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNMaXZlTm9kZShmaXJzdCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmaXJzdDtcbiAgICAgIGlmIChvcHRpb25zPy5pc0RlZXApIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgbm9kZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7U3RyaW5nKGZpcnN0KX0gaXMgbm90IGEgdmFsdWUgdGhhdCBjYW4gYmUgc3Vic2NyaWJlZCB0by5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3Vic2NyaWJlO1xufVxuZnVuY3Rpb24gaXNSb29tRXZlbnROYW1lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJteS1wcmVzZW5jZVwiIHx8IHZhbHVlID09PSBcIm90aGVyc1wiIHx8IHZhbHVlID09PSBcImV2ZW50XCIgfHwgdmFsdWUgPT09IFwiZXJyb3JcIiB8fCB2YWx1ZSA9PT0gXCJoaXN0b3J5XCIgfHwgdmFsdWUgPT09IFwic3RhdHVzXCIgfHwgdmFsdWUgPT09IFwic3RvcmFnZS1zdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJsb3N0LWNvbm5lY3Rpb25cIiB8fCB2YWx1ZSA9PT0gXCJjb25uZWN0aW9uXCI7XG59XG5mdW5jdGlvbiBtYWtlQXV0aERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGF1dGhNYW5hZ2VyKSB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLCByb29tSWQgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYmFzZVVybCwgV2ViU29ja2V0UG9seWZpbGwpIHtcbiAgcmV0dXJuIChhdXRoVmFsdWUpID0+IHtcbiAgICBjb25zdCB3cyA9IFdlYlNvY2tldFBvbHlmaWxsID8/ICh0eXBlb2YgV2ViU29ja2V0ID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDogV2ViU29ja2V0KTtcbiAgICBpZiAod3MgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCB5b3UgbmVlZCB0byBwcm92aWRlIGEgV2ViU29ja2V0IHBvbHlmaWxsLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgIHVybC5wcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiID8gXCJ3c1wiIDogXCJ3c3NcIjtcbiAgICB1cmwucGF0aG5hbWUgPSBcIi92N1wiO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicm9vbUlkXCIsIHJvb21JZCk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInRva1wiLCBhdXRoVmFsdWUudG9rZW4ucmF3KTtcbiAgICB9IGVsc2UgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInB1YmtleVwiLCBhdXRoVmFsdWUucHVibGljQXBpS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKGF1dGhWYWx1ZSwgXCJVbmhhbmRsZWQgY2FzZVwiKTtcbiAgICB9XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIFBLR19WRVJTSU9OIHx8IFwiZGV2XCIpO1xuICAgIHJldHVybiBuZXcgd3ModXJsLnRvU3RyaW5nKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvc3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFN0b3JlKCkge1xuICBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgICB0aHJlYWRzOiB7fSxcbiAgICBxdWVyaWVzOiB7fSxcbiAgICBvcHRpbWlzdGljVXBkYXRlczogW10sXG4gICAgaW5ib3hOb3RpZmljYXRpb25zOiB7fSxcbiAgICBub3RpZmljYXRpb25TZXR0aW5nczoge31cbiAgfSk7XG4gIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVzRXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdG9yZSxcbiAgICBkZWxldGVUaHJlYWQodGhyZWFkSWQpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICB0aHJlYWRzOiBkZWxldGVLZXlJbW11dGFibGUoc3RhdGUudGhyZWFkcywgdGhyZWFkSWQpLFxuICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zKS5maWx0ZXIoXG4gICAgICAgICAgICAgIChbX2lkLCBub3RpZmljYXRpb25dKSA9PiBub3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBub3RpZmljYXRpb24udGhyZWFkSWQgPT09IHRocmVhZElkXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGVUaHJlYWRBbmROb3RpZmljYXRpb24odGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbikge1xuICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkLmlkXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICB0aHJlYWRzOiBleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwIHx8IGNvbXBhcmVUaHJlYWRzKHRocmVhZCwgZXhpc3RpbmdUaHJlYWQpID09PSAxID8geyAuLi5zdGF0ZS50aHJlYWRzLCBbdGhyZWFkLmlkXTogdGhyZWFkIH0gOiBzdGF0ZS50aHJlYWRzLFxuICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogaW5ib3hOb3RpZmljYXRpb24gPT09IHZvaWQgMCA/IHN0YXRlLmluYm94Tm90aWZpY2F0aW9ucyA6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgIFtpbmJveE5vdGlmaWNhdGlvbi5pZF06IGluYm94Tm90aWZpY2F0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyh0aHJlYWRzLCBpbmJveE5vdGlmaWNhdGlvbnMsIGRlbGV0ZWRUaHJlYWRzLCBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLCBxdWVyeUtleSkge1xuICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHRocmVhZHM6IGFwcGx5VGhyZWFkVXBkYXRlcyhzdGF0ZS50aHJlYWRzLCB7XG4gICAgICAgICAgbmV3VGhyZWFkczogdGhyZWFkcyxcbiAgICAgICAgICBkZWxldGVkVGhyZWFkc1xuICAgICAgICB9KSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBhcHBseU5vdGlmaWNhdGlvbnNVcGRhdGVzKFxuICAgICAgICAgIHN0YXRlLmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuZXdJbmJveE5vdGlmaWNhdGlvbnM6IGluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgIGRlbGV0ZWROb3RpZmljYXRpb25zOiBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBxdWVyaWVzOiBxdWVyeUtleSAhPT0gdm9pZCAwID8ge1xuICAgICAgICAgIC4uLnN0YXRlLnF1ZXJpZXMsXG4gICAgICAgICAgW3F1ZXJ5S2V5XTogeyBpc0xvYWRpbmc6IGZhbHNlLCBkYXRhOiB2b2lkIDAgfVxuICAgICAgICB9IDogc3RhdGUucXVlcmllc1xuICAgICAgfSkpO1xuICAgIH0sXG4gICAgdXBkYXRlUm9vbUluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzZXR0aW5ncywgcXVlcnlLZXkpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBub3RpZmljYXRpb25TZXR0aW5nczoge1xuICAgICAgICAgIC4uLnN0YXRlLm5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgICAgIFtyb29tSWRdOiBzZXR0aW5nc1xuICAgICAgICB9LFxuICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgLi4uc3RhdGUucXVlcmllcyxcbiAgICAgICAgICBbcXVlcnlLZXldOiB7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IHZvaWQgMCB9XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHB1c2hPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGUpIHtcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVzRXZlbnRTb3VyY2Uubm90aWZ5KG9wdGltaXN0aWNVcGRhdGUpO1xuICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBbLi4uc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMsIG9wdGltaXN0aWNVcGRhdGVdXG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBzZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5LCBxdWVyeVN0YXRlKSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgcXVlcmllczoge1xuICAgICAgICAgIC4uLnN0YXRlLnF1ZXJpZXMsXG4gICAgICAgICAgW3F1ZXJ5S2V5XTogcXVlcnlTdGF0ZVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBvcHRpbWlzdGljVXBkYXRlc0V2ZW50U291cmNlXG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVLZXlJbW11dGFibGUocmVjb3JkLCBrZXkpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNvcmQsIGtleSkpIHtcbiAgICBjb25zdCB7IFtrZXldOiBfdG9EZWxldGUsIC4uLnJlc3QgfSA9IHJlY29yZDtcbiAgICByZXR1cm4gcmVzdDtcbiAgfVxuICByZXR1cm4gcmVjb3JkO1xufVxuZnVuY3Rpb24gY29tcGFyZVRocmVhZHModGhyZWFkMSwgdGhyZWFkMikge1xuICBpZiAodGhyZWFkMS51cGRhdGVkQXQgJiYgdGhyZWFkMi51cGRhdGVkQXQpIHtcbiAgICByZXR1cm4gdGhyZWFkMS51cGRhdGVkQXQgPiB0aHJlYWQyLnVwZGF0ZWRBdCA/IDEgOiB0aHJlYWQxLnVwZGF0ZWRBdCA8IHRocmVhZDIudXBkYXRlZEF0ID8gLTEgOiAwO1xuICB9IGVsc2UgaWYgKHRocmVhZDEudXBkYXRlZEF0IHx8IHRocmVhZDIudXBkYXRlZEF0KSB7XG4gICAgcmV0dXJuIHRocmVhZDEudXBkYXRlZEF0ID8gMSA6IC0xO1xuICB9XG4gIGlmICh0aHJlYWQxLmNyZWF0ZWRBdCA+IHRocmVhZDIuY3JlYXRlZEF0KSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAodGhyZWFkMS5jcmVhdGVkQXQgPCB0aHJlYWQyLmNyZWF0ZWRBdCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMoc3RhdGUpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHRocmVhZHM6IHtcbiAgICAgIC4uLnN0YXRlLnRocmVhZHNcbiAgICB9LFxuICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zXG4gICAgfSxcbiAgICBub3RpZmljYXRpb25TZXR0aW5nczoge1xuICAgICAgLi4uc3RhdGUubm90aWZpY2F0aW9uU2V0dGluZ3NcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZSBvZiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcykge1xuICAgIHN3aXRjaCAob3B0aW1pc3RpY1VwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiY3JlYXRlLXRocmVhZFwiOiB7XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkLmlkXSA9IG9wdGltaXN0aWNVcGRhdGUudGhyZWFkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LXRocmVhZC1tZXRhZGF0YVwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVhZC51cGRhdGVkQXQgIT09IHZvaWQgMCAmJiB0aHJlYWQudXBkYXRlZEF0ID4gb3B0aW1pc3RpY1VwZGF0ZS51cGRhdGVkQXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0ge1xuICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9wdGltaXN0aWNVcGRhdGUudXBkYXRlZEF0LFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi50aHJlYWQubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5vcHRpbWlzdGljVXBkYXRlLm1ldGFkYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLXRocmVhZC1hcy1yZXNvbHZlZFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IHtcbiAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgcmVzb2x2ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay10aHJlYWQtYXMtdW5yZXNvbHZlZFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IHtcbiAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgcmVzb2x2ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImNyZWF0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IHVwc2VydENvbW1lbnQoXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMocmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucykuZmluZChcbiAgICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBub3RpZmljYXRpb24udGhyZWFkSWQgPT09IHRocmVhZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNbaW5ib3hOb3RpZmljYXRpb24uaWRdID0ge1xuICAgICAgICAgIC4uLmluYm94Tm90aWZpY2F0aW9uLFxuICAgICAgICAgIG5vdGlmaWVkQXQ6IG9wdGltaXN0aWNVcGRhdGUuY29tbWVudC5jcmVhdGVkQXQsXG4gICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVkaXQtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB1cHNlcnRDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IGRlbGV0ZUNvbW1lbnQoXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZGVsZXRlZEF0XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS10aHJlYWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF0gPSB7XG4gICAgICAgICAgLi4ucmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF0sXG4gICAgICAgICAgZGVsZXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9wdGltaXN0aWNVcGRhdGUuZGVsZXRlZEF0LFxuICAgICAgICAgIGNvbW1lbnRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhZGQtcmVhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IGFkZFJlYWN0aW9uKFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnJlYWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInJlbW92ZS1yZWFjdGlvblwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0gcmVtb3ZlUmVhY3Rpb24oXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZW1vamksXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS51c2VySWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5yZW1vdmVkQXRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiOiB7XG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXSA9IHtcbiAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnNbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXSxcbiAgICAgICAgICByZWFkQXQ6IG9wdGltaXN0aWNVcGRhdGUucmVhZEF0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstYWxsLWluYm94LW5vdGlmaWNhdGlvbnMtYXMtcmVhZFwiOiB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgaW4gcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucykge1xuICAgICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNbaWRdID0ge1xuICAgICAgICAgICAgLi4ucmVzdWx0LmluYm94Tm90aWZpY2F0aW9uc1tpZF0sXG4gICAgICAgICAgICByZWFkQXQ6IG9wdGltaXN0aWNVcGRhdGUucmVhZEF0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtaW5ib3gtbm90aWZpY2F0aW9uXCI6IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIFtvcHRpbWlzdGljVXBkYXRlLmluYm94Tm90aWZpY2F0aW9uSWRdOiBfLFxuICAgICAgICAgIC4uLmluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICB9ID0gcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucztcbiAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucyA9IGluYm94Tm90aWZpY2F0aW9ucztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWFsbC1pbmJveC1ub3RpZmljYXRpb25zXCI6IHtcbiAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucyA9IHt9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ1cGRhdGUtbm90aWZpY2F0aW9uLXNldHRpbmdzXCI6IHtcbiAgICAgICAgcmVzdWx0Lm5vdGlmaWNhdGlvblNldHRpbmdzW29wdGltaXN0aWNVcGRhdGUucm9vbUlkXSA9IHtcbiAgICAgICAgICAuLi5yZXN1bHQubm90aWZpY2F0aW9uU2V0dGluZ3Nbb3B0aW1pc3RpY1VwZGF0ZS5yb29tSWRdLFxuICAgICAgICAgIC4uLm9wdGltaXN0aWNVcGRhdGUuc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFwcGx5VGhyZWFkVXBkYXRlcyhleGlzdGluZ1RocmVhZHMsIHVwZGF0ZXMpIHtcbiAgY29uc3QgdXBkYXRlZFRocmVhZHMgPSB7IC4uLmV4aXN0aW5nVGhyZWFkcyB9O1xuICB1cGRhdGVzLm5ld1RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSB1cGRhdGVkVGhyZWFkc1t0aHJlYWQuaWRdO1xuICAgIGlmIChleGlzdGluZ1RocmVhZCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZVRocmVhZHMoZXhpc3RpbmdUaHJlYWQsIHRocmVhZCk7XG4gICAgICBpZiAocmVzdWx0ID09PSAxKSByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZWRUaHJlYWRzW3RocmVhZC5pZF0gPSB0aHJlYWQ7XG4gIH0pO1xuICB1cGRhdGVzLmRlbGV0ZWRUaHJlYWRzLmZvckVhY2goKHsgaWQsIGRlbGV0ZWRBdCB9KSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSB1cGRhdGVkVGhyZWFkc1tpZF07XG4gICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHJldHVybjtcbiAgICBleGlzdGluZ1RocmVhZC5kZWxldGVkQXQgPSBkZWxldGVkQXQ7XG4gICAgZXhpc3RpbmdUaHJlYWQudXBkYXRlZEF0ID0gZGVsZXRlZEF0O1xuICAgIGV4aXN0aW5nVGhyZWFkLmNvbW1lbnRzID0gW107XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZFRocmVhZHM7XG59XG5mdW5jdGlvbiBhcHBseU5vdGlmaWNhdGlvbnNVcGRhdGVzKGV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zLCB1cGRhdGVzKSB7XG4gIGNvbnN0IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMgPSB7IC4uLmV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zIH07XG4gIHVwZGF0ZXMubmV3SW5ib3hOb3RpZmljYXRpb25zLmZvckVhY2goKG5vdGlmaWNhdGlvbikgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nTm90aWZpY2F0aW9uID0gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdO1xuICAgIGlmIChleGlzdGluZ05vdGlmaWNhdGlvbikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZUluYm94Tm90aWZpY2F0aW9ucyhcbiAgICAgICAgZXhpc3RpbmdOb3RpZmljYXRpb24sXG4gICAgICAgIG5vdGlmaWNhdGlvblxuICAgICAgKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IDEpIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdID0gbm90aWZpY2F0aW9uO1xuICB9KTtcbiAgdXBkYXRlcy5kZWxldGVkTm90aWZpY2F0aW9ucy5mb3JFYWNoKFxuICAgICh7IGlkIH0pID0+IGRlbGV0ZSB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zW2lkXVxuICApO1xuICByZXR1cm4gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmJveE5vdGlmaWNhdGlvbnMoaW5ib3hOb3RpZmljYXRpb25BLCBpbmJveE5vdGlmaWNhdGlvbkIpIHtcbiAgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5ub3RpZmllZEF0ID4gaW5ib3hOb3RpZmljYXRpb25CLm5vdGlmaWVkQXQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChpbmJveE5vdGlmaWNhdGlvbkEubm90aWZpZWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5ub3RpZmllZEF0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ICYmIGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQpIHtcbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA+IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAxIDogaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAtMSA6IDA7XG4gIH0gZWxzZSBpZiAoaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCB8fCBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0KSB7XG4gICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiB1cHNlcnRDb21tZW50KHRocmVhZCwgY29tbWVudCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoY29tbWVudC50aHJlYWRJZCAhPT0gdGhyZWFkLmlkKSB7XG4gICAgd2FybihcbiAgICAgIGBDb21tZW50ICR7Y29tbWVudC5pZH0gZG9lcyBub3QgYmVsb25nIHRvIHRocmVhZCAke3RocmVhZC5pZH1gXG4gICAgKTtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChleGlzdGluZ0NvbW1lbnQyKSA9PiBleGlzdGluZ0NvbW1lbnQyLmlkID09PSBjb21tZW50LmlkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgodGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDAsIGNvbW1lbnQuY3JlYXRlZEF0LmdldFRpbWUoKSlcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZWRUaHJlYWQgPSB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICB1cGRhdGVkQXQsXG4gICAgICBjb21tZW50czogWy4uLnRocmVhZC5jb21tZW50cywgY29tbWVudF1cbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGVkVGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZWRpdGVkQXQgPT09IHZvaWQgMCB8fCBjb21tZW50LmVkaXRlZEF0ID09PSB2b2lkIDAgfHwgZXhpc3RpbmdDb21tZW50LmVkaXRlZEF0IDw9IGNvbW1lbnQuZWRpdGVkQXQpIHtcbiAgICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgICAgKGV4aXN0aW5nQ29tbWVudDIpID0+IGV4aXN0aW5nQ29tbWVudDIuaWQgPT09IGNvbW1lbnQuaWQgPyBjb21tZW50IDogZXhpc3RpbmdDb21tZW50MlxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlZFRocmVhZCA9IHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoXG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgIHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwLFxuICAgICAgICAgIGNvbW1lbnQuZWRpdGVkQXQ/LmdldFRpbWUoKSB8fCBjb21tZW50LmNyZWF0ZWRBdC5nZXRUaW1lKClcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGVkVGhyZWFkO1xuICB9XG4gIHJldHVybiB0aHJlYWQ7XG59XG5mdW5jdGlvbiBkZWxldGVDb21tZW50KHRocmVhZCwgY29tbWVudElkLCBkZWxldGVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICBib2R5OiB2b2lkIDBcbiAgICB9IDogY29tbWVudFxuICApO1xuICBpZiAoIXVwZGF0ZWRDb21tZW50cy5zb21lKChjb21tZW50KSA9PiBjb21tZW50LmRlbGV0ZWRBdCA9PT0gdm9pZCAwKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdCxcbiAgICAgIGNvbW1lbnRzOiBbXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBkZWxldGVkQXQsXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gYWRkUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIHJlYWN0aW9uKSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgcmVhY3Rpb25zOiB1cHNlcnRSZWFjdGlvbihjb21tZW50LnJlYWN0aW9ucywgcmVhY3Rpb24pXG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHJlYWN0aW9uLmNyZWF0ZWRBdC5nZXRUaW1lKCksIHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwKVxuICAgICksXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIGVtb2ppLCB1c2VySWQsIHJlbW92ZWRBdCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIHJlYWN0aW9uczogY29tbWVudC5yZWFjdGlvbnMubWFwKFxuICAgICAgICAocmVhY3Rpb24pID0+IHJlYWN0aW9uLmVtb2ppID09PSBlbW9qaSA/IHtcbiAgICAgICAgICAuLi5yZWFjdGlvbixcbiAgICAgICAgICB1c2VyczogcmVhY3Rpb24udXNlcnMuZmlsdGVyKCh1c2VyKSA9PiB1c2VyLmlkICE9PSB1c2VySWQpXG4gICAgICAgIH0gOiByZWFjdGlvblxuICAgICAgKS5maWx0ZXIoKHJlYWN0aW9uKSA9PiByZWFjdGlvbi51c2Vycy5sZW5ndGggPiAwKVxuICAgICAgLy8gUmVtb3ZlIHJlYWN0aW9ucyB3aXRoIG5vIHVzZXJzIGxlZnRcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVtb3ZlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDApXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiB1cHNlcnRSZWFjdGlvbihyZWFjdGlvbnMsIHJlYWN0aW9uKSB7XG4gIGNvbnN0IGV4aXN0aW5nUmVhY3Rpb24gPSByZWFjdGlvbnMuZmluZChcbiAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaVxuICApO1xuICBpZiAoZXhpc3RpbmdSZWFjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnJlYWN0aW9ucyxcbiAgICAgIHtcbiAgICAgICAgZW1vamk6IHJlYWN0aW9uLmVtb2ppLFxuICAgICAgICBjcmVhdGVkQXQ6IHJlYWN0aW9uLmNyZWF0ZWRBdCxcbiAgICAgICAgdXNlcnM6IFt7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGlmIChleGlzdGluZ1JlYWN0aW9uLnVzZXJzLnNvbWUoKHVzZXIpID0+IHVzZXIuaWQgPT09IHJlYWN0aW9uLnVzZXJJZCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHJlYWN0aW9ucy5tYXAoXG4gICAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaSA/IHtcbiAgICAgICAgLi4uZXhpc3RpbmdSZWFjdGlvbjIsXG4gICAgICAgIHVzZXJzOiBbLi4uZXhpc3RpbmdSZWFjdGlvbjIudXNlcnMsIHsgaWQ6IHJlYWN0aW9uLnVzZXJJZCB9XVxuICAgICAgfSA6IGV4aXN0aW5nUmVhY3Rpb24yXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVhY3Rpb25zO1xufVxuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTUlOX1RIUk9UVExFID0gMTY7XG52YXIgTUFYX1RIUk9UVExFID0gMWUzO1xudmFyIERFRkFVTFRfVEhST1RUTEUgPSAxMDA7XG52YXIgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUID0gMTVlMztcbnZhciBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAyMDA7XG52YXIgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMWUzO1xudmFyIE1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDNlNDtcbnZhciBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gNWUzO1xudmFyIFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgPSA1MDtcbnZhciBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgPSA1MDtcbmZ1bmN0aW9uIGdldEJhc2VVcmwoYmFzZVVybCkge1xuICBpZiAodHlwZW9mIGJhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgYmFzZVVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBiYXNlVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERUZBVUxUX0JBU0VfVVJMO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpIHtcbiAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS50b2tlbi5yYXc7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChvcHRpb25zKSB7XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuICBjb25zdCB0aHJvdHRsZURlbGF5ID0gZ2V0VGhyb3R0bGUoY2xpZW50T3B0aW9ucy50aHJvdHRsZSA/PyBERUZBVUxUX1RIUk9UVExFKTtcbiAgY29uc3QgbG9zdENvbm5lY3Rpb25UaW1lb3V0ID0gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMubG9zdENvbm5lY3Rpb25UaW1lb3V0ID8/IERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVRcbiAgKTtcbiAgY29uc3QgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgPSBnZXRCYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XG4gICk7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsKGNsaWVudE9wdGlvbnMuYmFzZVVybCk7XG4gIGNvbnN0IGF1dGhNYW5hZ2VyID0gY3JlYXRlQXV0aE1hbmFnZXIob3B0aW9ucyk7XG4gIGNvbnN0IHJvb21zQnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHRlYXJkb3duUm9vbShyb29tKSB7XG4gICAgdW5saW5rRGV2VG9vbHMocm9vbS5pZCk7XG4gICAgcm9vbXNCeUlkLmRlbGV0ZShyb29tLmlkKTtcbiAgICByb29tLmRlc3Ryb3koKTtcbiAgfVxuICBmdW5jdGlvbiBsZWFzZVJvb20oZGV0YWlscykge1xuICAgIGNvbnN0IGxlYXZlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZiA9IGxlYXZlO1xuICAgICAgaWYgKCFkZXRhaWxzLnVuc3Vicy5kZWxldGUoc2VsZikpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIlRoaXMgbGVhdmUgZnVuY3Rpb24gd2FzIGFscmVhZHkgY2FsbGVkLiBDYWxsaW5nIGl0IG1vcmUgdGhhbiBvbmNlIGhhcyBubyBlZmZlY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkZXRhaWxzLnVuc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGVhcmRvd25Sb29tKGRldGFpbHMucm9vbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGRldGFpbHMudW5zdWJzLmFkZChsZWF2ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IGRldGFpbHMucm9vbSxcbiAgICAgIGxlYXZlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBlbnRlclJvb20ocm9vbUlkLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSByb29tc0J5SWQuZ2V0KHJvb21JZCk7XG4gICAgaWYgKGV4aXN0aW5nICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsZWFzZVJvb20oZXhpc3RpbmcpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zMiA9IGFyZ3NbMF0gPz8ge307XG4gICAgY29uc3QgaW5pdGlhbFByZXNlbmNlID0gKHR5cGVvZiBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZShyb29tSWQpIDogb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlKSA/PyB7fTtcbiAgICBjb25zdCBpbml0aWFsU3RvcmFnZSA9ICh0eXBlb2Ygb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlKHJvb21JZCkgOiBvcHRpb25zMi5pbml0aWFsU3RvcmFnZSkgPz8ge307XG4gICAgY29uc3QgbmV3Um9vbSA9IGNyZWF0ZVJvb20oXG4gICAgICB7IGluaXRpYWxQcmVzZW5jZSwgaW5pdGlhbFN0b3JhZ2UgfSxcbiAgICAgIHtcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICB0aHJvdHRsZURlbGF5LFxuICAgICAgICBsb3N0Q29ubmVjdGlvblRpbWVvdXQsXG4gICAgICAgIGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0LFxuICAgICAgICBwb2x5ZmlsbHM6IGNsaWVudE9wdGlvbnMucG9seWZpbGxzLFxuICAgICAgICBkZWxlZ2F0ZXM6IGNsaWVudE9wdGlvbnMubW9ja2VkRGVsZWdhdGVzID8/IHtcbiAgICAgICAgICBjcmVhdGVTb2NrZXQ6IG1ha2VDcmVhdGVTb2NrZXREZWxlZ2F0ZUZvclJvb20oXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBiYXNlVXJsLFxuICAgICAgICAgICAgY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LldlYlNvY2tldFxuICAgICAgICAgICksXG4gICAgICAgICAgYXV0aGVudGljYXRlOiBtYWtlQXV0aERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGF1dGhNYW5hZ2VyKVxuICAgICAgICB9LFxuICAgICAgICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IGNsaWVudE9wdGlvbnMuZW5hYmxlRGVidWdMb2dnaW5nLFxuICAgICAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogb3B0aW9uczI/LnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuICAgICAgICBiYXNlVXJsLFxuICAgICAgICB1bnN0YWJsZV9mYWxsYmFja1RvSFRUUDogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQLFxuICAgICAgICB1bnN0YWJsZV9zdHJlYW1EYXRhOiAhIWNsaWVudE9wdGlvbnMudW5zdGFibGVfc3RyZWFtRGF0YVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgbmV3Um9vbURldGFpbHMgPSB7XG4gICAgICByb29tOiBuZXdSb29tLFxuICAgICAgdW5zdWJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICByb29tc0J5SWQuc2V0KHJvb21JZCwgbmV3Um9vbURldGFpbHMpO1xuICAgIHNldHVwRGV2VG9vbHMoKCkgPT4gQXJyYXkuZnJvbShyb29tc0J5SWQua2V5cygpKSk7XG4gICAgbGlua0RldlRvb2xzKHJvb21JZCwgbmV3Um9vbSk7XG4gICAgY29uc3Qgc2hvdWxkQ29ubmVjdCA9IG9wdGlvbnMyLmF1dG9Db25uZWN0ID8/IHRydWU7XG4gICAgaWYgKHNob3VsZENvbm5lY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgYXRvYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmF0b2IgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiWW91IG5lZWQgdG8gcG9seWZpbGwgYXRvYiB0byB1c2UgdGhlIGNsaWVudCBpbiB5b3VyIGVudmlyb25tZW50LiBQbGVhc2UgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgYXQgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2F0b2ItcG9seWZpbGxcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsLmF0b2IgPSBjbGllbnRPcHRpb25zLnBvbHlmaWxscy5hdG9iO1xuICAgICAgfVxuICAgICAgbmV3Um9vbS5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBsZWFzZVJvb20obmV3Um9vbURldGFpbHMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvb20ocm9vbUlkKSB7XG4gICAgY29uc3Qgcm9vbSA9IHJvb21zQnlJZC5nZXQocm9vbUlkKT8ucm9vbTtcbiAgICByZXR1cm4gcm9vbSA/IHJvb20gOiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICBhdXRoTWFuYWdlci5yZXNldCgpO1xuICAgIGZvciAoY29uc3QgeyByb29tIH0gb2Ygcm9vbXNCeUlkLnZhbHVlcygpKSB7XG4gICAgICBpZiAoIWlzSWRsZShyb29tLmdldFN0YXR1cygpKSkge1xuICAgICAgICByb29tLnJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBjdXJyZW50VXNlcklkU3RvcmUgPSBjcmVhdGVTdG9yZShudWxsKTtcbiAgY29uc3Qge1xuICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb25cbiAgfSA9IGNyZWF0ZU5vdGlmaWNhdGlvbnNBcGkoe1xuICAgIGJhc2VVcmwsXG4gICAgZmV0Y2hlcjogY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmV0Y2gsXG4gICAgYXV0aE1hbmFnZXIsXG4gICAgY3VycmVudFVzZXJJZFN0b3JlXG4gIH0pO1xuICBjb25zdCBjYWNoZVN0b3JlID0gY3JlYXRlQ2xpZW50U3RvcmUoKTtcbiAgY29uc3QgcmVzb2x2ZVVzZXJzID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlVXNlcnM7XG4gIGNvbnN0IHdhcm5JZk5vUmVzb2x2ZVVzZXJzID0gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKFxuICAgICgpID0+ICFyZXNvbHZlVXNlcnMsXG4gICAgXCJTZXQgdGhlIHJlc29sdmVVc2VycyBvcHRpb24gaW4gY3JlYXRlQ2xpZW50IHRvIHNwZWNpZnkgdXNlciBpbmZvLlwiXG4gICk7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKFxuICAgIGFzeW5jIChiYXRjaGVkVXNlcklkcykgPT4ge1xuICAgICAgY29uc3QgdXNlcklkcyA9IGJhdGNoZWRVc2VySWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzPy4oeyB1c2VySWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlVXNlcnMoKTtcbiAgICAgIHJldHVybiB1c2VycyA/PyB1c2VySWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHJlc29sdmVSb29tc0luZm8gPSBjbGllbnRPcHRpb25zLnJlc29sdmVSb29tc0luZm87XG4gIGNvbnN0IHdhcm5JZk5vUmVzb2x2ZVJvb21zSW5mbyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVJvb21zSW5mbyxcbiAgICBcIlNldCB0aGUgcmVzb2x2ZVJvb21zSW5mbyBvcHRpb24gaW4gY3JlYXRlQ2xpZW50IHRvIHNwZWNpZnkgcm9vbSBpbmZvLlwiXG4gICk7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShcbiAgICBhc3luYyAoYmF0Y2hlZFJvb21JZHMpID0+IHtcbiAgICAgIGNvbnN0IHJvb21JZHMgPSBiYXRjaGVkUm9vbUlkcy5mbGF0KCk7XG4gICAgICBjb25zdCByb29tc0luZm8gPSBhd2FpdCByZXNvbHZlUm9vbXNJbmZvPy4oeyByb29tSWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlUm9vbXNJbmZvKCk7XG4gICAgICByZXR1cm4gcm9vbXNJbmZvID8/IHJvb21JZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgfVxuICApO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIGVudGVyUm9vbSxcbiAgICAgIGdldFJvb20sXG4gICAgICBsb2dvdXQsXG4gICAgICAvLyBJbnRlcm5hbFxuICAgICAgW2tJbnRlcm5hbF06IHtcbiAgICAgICAgbm90aWZpY2F0aW9uczoge1xuICAgICAgICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICAgICAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgICAgICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICAgICAgICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudFVzZXJJZFN0b3JlLFxuICAgICAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiBjbGllbnRPcHRpb25zLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMsXG4gICAgICAgIGNhY2hlU3RvcmUsXG4gICAgICAgIHVzZXJzU3RvcmUsXG4gICAgICAgIHJvb21zSW5mb1N0b3JlLFxuICAgICAgICBnZXRSb29tSWRzKCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBrSW50ZXJuYWwsXG4gICAge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG59XG52YXIgTm90aWZpY2F0aW9uc0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNoZWNrQm91bmRzKG9wdGlvbiwgdmFsdWUsIG1pbiwgbWF4LCByZWNvbW1lbmRlZE1pbikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDwgbWluIHx8IG1heCAhPT0gdm9pZCAwICYmIHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF4ICE9PSB2b2lkIDAgPyBgJHtvcHRpb259IHNob3VsZCBiZSBiZXR3ZWVuICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufSBhbmQgJHttYXh9LmAgOiBgJHtvcHRpb259IHNob3VsZCBiZSBhdCBsZWFzdCAke3JlY29tbWVuZGVkTWluID8/IG1pbn0uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XCIsXG4gICAgdmFsdWUsXG4gICAgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBnZXRUaHJvdHRsZSh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXCJ0aHJvdHRsZVwiLCB2YWx1ZSwgTUlOX1RIUk9UVExFLCBNQVhfVEhST1RUTEUpO1xufVxuZnVuY3Rpb24gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImxvc3RDb25uZWN0aW9uVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoY29uZGl0aW9uLCAuLi5hcmdzKSB7XG4gIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIWhhc1dhcm5lZCAmJiAodHlwZW9mIGNvbmRpdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gY29uZGl0aW9uKCkgOiBjb25kaXRpb24pKSB7XG4gICAgICAgIHdhcm4oLi4uYXJncyk7XG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2NvbW1lbnRzL2NvbW1lbnQtYm9keS50c1xuZnVuY3Rpb24gaXNDb21tZW50Qm9keVBhcmFncmFwaChlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJtZW50aW9uXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5VGV4dChlbGVtZW50KSB7XG4gIHJldHVybiAhKFwidHlwZVwiIGluIGVsZW1lbnQpICYmIFwidGV4dFwiIGluIGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQudGV4dCA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlNZW50aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlMaW5rKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcImxpbmtcIjtcbn1cbnZhciBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzID0ge1xuICBwYXJhZ3JhcGg6IGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgsXG4gIHRleHQ6IGlzQ29tbWVudEJvZHlUZXh0LFxuICBsaW5rOiBpc0NvbW1lbnRCb2R5TGluayxcbiAgbWVudGlvbjogaXNDb21tZW50Qm9keU1lbnRpb25cbn07XG52YXIgY29tbWVudEJvZHlFbGVtZW50c1R5cGVzID0ge1xuICBwYXJhZ3JhcGg6IFwiYmxvY2tcIixcbiAgdGV4dDogXCJpbmxpbmVcIixcbiAgbGluazogXCJpbmxpbmVcIixcbiAgbWVudGlvbjogXCJpbmxpbmVcIlxufTtcbmZ1bmN0aW9uIHRyYXZlcnNlQ29tbWVudEJvZHkoYm9keSwgZWxlbWVudE9yVmlzaXRvciwgcG9zc2libHlWaXNpdG9yKSB7XG4gIGlmICghYm9keSB8fCAhYm9keT8uY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogdm9pZCAwO1xuICBjb25zdCB0eXBlID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlc1tlbGVtZW50XSA6IFwiYWxsXCI7XG4gIGNvbnN0IGd1YXJkID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHNbZWxlbWVudF0gOiAoKSA9PiB0cnVlO1xuICBjb25zdCB2aXNpdG9yID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnRPclZpc2l0b3IgOiBwb3NzaWJseVZpc2l0b3I7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgYm9keS5jb250ZW50KSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICBpZiAoZ3VhcmQoYmxvY2spKSB7XG4gICAgICAgIHZpc2l0b3I/LihibG9jayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgIGZvciAoY29uc3QgaW5saW5lIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChndWFyZChpbmxpbmUpKSB7XG4gICAgICAgICAgdmlzaXRvcj8uKGlubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KSB7XG4gIGNvbnN0IG1lbnRpb25lZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHRyYXZlcnNlQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBcIm1lbnRpb25cIixcbiAgICAobWVudGlvbikgPT4gbWVudGlvbmVkSWRzLmFkZChtZW50aW9uLmlkKVxuICApO1xuICByZXR1cm4gQXJyYXkuZnJvbShtZW50aW9uZWRJZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShib2R5LCByZXNvbHZlVXNlcnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICghcmVzb2x2ZVVzZXJzKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG4gIH1cbiAgY29uc3QgdXNlcklkcyA9IGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KTtcbiAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnMoe1xuICAgIHVzZXJJZHNcbiAgfSk7XG4gIGZvciAoY29uc3QgW2luZGV4LCB1c2VySWRdIG9mIHVzZXJJZHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgdXNlciA9IHVzZXJzPy5baW5kZXhdO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXNvbHZlZFVzZXJzLnNldCh1c2VySWQsIHVzZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRVc2Vycztcbn1cbnZhciBodG1sRXNjYXBhYmxlcyA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjMzk7XCJcbn07XG52YXIgaHRtbEVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKGh0bWxFc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBodG1sU2FmZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtTdHJpbmcodmFsdWUpXSwgW10pO1xufVxuZnVuY3Rpb24gam9pbkh0bWwoc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEh0bWxTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5IdG1sKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgaHRtbEVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBodG1sRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgSHRtbFNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlSHRtbChubih0aGlzLl92YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBodG1sKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzID0ge1xuICBfOiBcIlxcXFxfXCIsXG4gIFwiKlwiOiBcIlxcXFwqXCIsXG4gIFwiI1wiOiBcIlxcXFwjXCIsXG4gIFwiYFwiOiBcIlxcXFxgXCIsXG4gIFwiflwiOiBcIlxcXFx+XCIsXG4gIFwiIVwiOiBcIlxcXFwhXCIsXG4gIFwifFwiOiBcIlxcXFx8XCIsXG4gIFwiKFwiOiBcIlxcXFwoXCIsXG4gIFwiKVwiOiBcIlxcXFwpXCIsXG4gIFwie1wiOiBcIlxcXFx7XCIsXG4gIFwifVwiOiBcIlxcXFx9XCIsXG4gIFwiW1wiOiBcIlxcXFxbXCIsXG4gIFwiXVwiOiBcIlxcXFxdXCJcbn07XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhtYXJrZG93bkVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGpvaW5NYXJrZG93bihzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlTWFya2Rvd24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFya2Rvd25TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5NYXJrZG93bih2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IG1hcmtkb3duRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgTWFya2Rvd25TYWZlU3RyaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICB0aGlzLl9zdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZU1hcmtkb3duKG5uKHRoaXMuX3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1hcmtkb3duKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCB1cmwuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfSBlbHNlIGlmICh1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICByZXR1cm4gXCJodHRwczovL1wiICsgdXJsO1xuICB9XG4gIHJldHVybjtcbn1cbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4gY2hpbGRyZW4sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC50ZXh0LFxuICBsaW5rOiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCA/PyBlbGVtZW50LnVybCxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gaHRtbGA8cD4ke2h0bWxTYWZlKGNoaWxkcmVuKX08L3A+YCA6IGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHN0cm9uZz4ke2NoaWxkcmVufTwvc3Ryb25nPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxlbT4ke2NoaWxkcmVufTwvZW0+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzPiR7Y2hpbGRyZW59PC9zPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8Y29kZT4ke2NoaWxkcmVufTwvY29kZT5gO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxhIGhyZWY9XCIke2hyZWZ9XCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPiR7ZWxlbWVudC50ZXh0ID8/IGVsZW1lbnQudXJsfTwvYT5gO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8c3BhbiBkYXRhLW1lbnRpb24+QCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfTwvc3Bhbj5gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYCoqJHtjaGlsZHJlbn0qKmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBfJHtjaGlsZHJlbn1fYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmB+fiR7Y2hpbGRyZW59fn5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYFxcYCR7Y2hpbGRyZW59XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gWyR7ZWxlbWVudC50ZXh0ID8/IGVsZW1lbnQudXJsfV0oJHtocmVmfSlgO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzdHJpbmdpZnlDb21tZW50Qm9keShib2R5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCA/PyBcInBsYWluXCI7XG4gIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnM/LnNlcGFyYXRvciA/PyAoZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBcIlxcblxcblwiIDogXCJcXG5cIik7XG4gIGNvbnN0IGVsZW1lbnRzID0ge1xuICAgIC4uLmZvcm1hdCA9PT0gXCJodG1sXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA6IGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzIDogc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzLFxuICAgIC4uLm9wdGlvbnM/LmVsZW1lbnRzXG4gIH07XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgb3B0aW9ucz8ucmVzb2x2ZVVzZXJzXG4gICk7XG4gIGNvbnN0IGJsb2NrcyA9IGJvZHkuY29udGVudC5mbGF0TWFwKChibG9jaywgYmxvY2tJbmRleCkgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2sudHlwZSkge1xuICAgICAgY2FzZSBcInBhcmFncmFwaFwiOiB7XG4gICAgICAgIGNvbnN0IGlubGluZXMgPSBibG9jay5jaGlsZHJlbi5mbGF0TWFwKChpbmxpbmUsIGlubGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlNZW50aW9uKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmxpbmUuaWQgPyBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLm1lbnRpb24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgdXNlcjogcmVzb2x2ZWRVc2Vycy5nZXQoaW5saW5lLmlkKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubGluayhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICBocmVmOiB0b0Fic29sdXRlVXJsKGlubGluZS51cmwpID8/IGlubGluZS51cmxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5VGV4dChpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzLnRleHQoeyBlbGVtZW50OiBpbmxpbmUgfSwgaW5saW5lSW5kZXgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBlbGVtZW50cy5wYXJhZ3JhcGgoXG4gICAgICAgICAgICB7IGVsZW1lbnQ6IGJsb2NrLCBjaGlsZHJlbjogaW5saW5lcy5qb2luKFwiXCIpIH0sXG4gICAgICAgICAgICBibG9ja0luZGV4XG4gICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBibG9ja3Muam9pbihzZXBhcmF0b3IpO1xufVxuXG4vLyBzcmMvY3JkdHMvdXRpbHMudHNcbmZ1bmN0aW9uIHRvUGxhaW5Mc29uKGxzb24pIHtcbiAgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobHNvbi50b09iamVjdCgpKS5mbGF0TWFwKFxuICAgICAgICAgIChba2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgPyBbW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXV0gOiBbXVxuICAgICAgICApXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIFsuLi5sc29uXS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXSlcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgZGF0YTogWy4uLmxzb25dLm1hcCgoaXRlbSkgPT4gdG9QbGFpbkxzb24oaXRlbSkpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbHNvbjtcbiAgfVxufVxuXG4vLyBzcmMvaW1tdXRhYmxlLnRzXG5mdW5jdGlvbiBsc29uT2JqZWN0VG9Kc29uKG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgY29uc3QgdmFsID0gb2JqW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxpdmVPYmplY3RUb0pzb24obGl2ZU9iamVjdCkge1xuICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbihsaXZlT2JqZWN0LnRvT2JqZWN0KCkpO1xufVxuZnVuY3Rpb24gbGl2ZU1hcFRvSnNvbihtYXApIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsc29uTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubWFwKGxzb25Ub0pzb24pO1xufVxuZnVuY3Rpb24gbGl2ZUxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlLnRvQXJyYXkoKSk7XG59XG5mdW5jdGlvbiBsc29uVG9Kc29uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gbGl2ZU9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiBsaXZlTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIGxpdmVNYXBUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBkZWVwTGl2ZWlmeSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0KHZhbHVlLm1hcChkZWVwTGl2ZWlmeSkpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgY29uc3QgaW5pdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICBjb25zdCB2YWwgPSB2YWx1ZVtrZXldO1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW5pdFtrZXldID0gZGVlcExpdmVpZnkodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaXZlT2JqZWN0KGluaXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlTGlzdChsaXZlTGlzdCwgcHJldiwgbmV4dCkge1xuICBsZXQgaSA9IDA7XG4gIGxldCBwcmV2RW5kID0gcHJldi5sZW5ndGggLSAxO1xuICBsZXQgbmV4dEVuZCA9IG5leHQubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZOb2RlID0gcHJldlswXTtcbiAgbGV0IG5leHROb2RlID0gbmV4dFswXTtcbiAgb3V0ZXI6IHtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICArK2k7XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgfVxuICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgcHJldkVuZC0tO1xuICAgICAgbmV4dEVuZC0tO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIH1cbiAgfVxuICBpZiAoaSA+IHByZXZFbmQpIHtcbiAgICBpZiAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaSA+IG5leHRFbmQpIHtcbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoaSA8PSBwcmV2RW5kICYmIGkgPD0gbmV4dEVuZCkge1xuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgICAgY29uc3QgbGl2ZUxpc3ROb2RlID0gbGl2ZUxpc3QuZ2V0KGkpO1xuICAgICAgaWYgKGlzTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUpICYmIGlzUGxhaW5PYmplY3QocHJldk5vZGUpICYmIGlzUGxhaW5PYmplY3QobmV4dE5vZGUpKSB7XG4gICAgICAgIHBhdGNoTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUsIHByZXZOb2RlLCBuZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXZlTGlzdC5zZXQoaSwgZGVlcExpdmVpZnkobmV4dE5vZGUpKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdEtleShsaXZlT2JqZWN0LCBrZXksIHByZXYsIG5leHQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5leHQpO1xuICAgIGlmIChub25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgZXJyb3IyKFxuICAgICAgICBgTmV3IHN0YXRlIHBhdGg6ICcke25vblNlcmlhbGl6YWJsZVZhbHVlLnBhdGh9JyB2YWx1ZTogJyR7U3RyaW5nKFxuICAgICAgICAgIG5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlXG4gICAgICAgICl9JyBpcyBub3Qgc2VyaWFsaXphYmxlLlxuT25seSBzZXJpYWxpemFibGUgdmFsdWUgY2FuIGJlIHN5bmNlZCB3aXRoIExpdmVibG9ja3MuYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBsaXZlT2JqZWN0LmdldChrZXkpO1xuICBpZiAobmV4dCA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH0gZWxzZSBpZiAocHJldiA9PT0gbmV4dCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpc0xpdmVMaXN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHByZXYpICYmIEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICBwYXRjaExpdmVMaXN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIGlmIChpc0xpdmVPYmplY3QodmFsdWUpICYmIGlzUGxhaW5PYmplY3QocHJldikgJiYgaXNQbGFpbk9iamVjdChuZXh0KSkge1xuICAgIHBhdGNoTGl2ZU9iamVjdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdChyb290LCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgIHBhdGNoTGl2ZU9iamVjdEtleShyb290LCBrZXksIHByZXZba2V5XSwgbmV4dFtrZXldKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgaWYgKG5leHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICByb290LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXModXBkYXRlcykubGVuZ3RoID4gMCkge1xuICAgIHJvb3QudXBkYXRlKHVwZGF0ZXMpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRzUGF0aChub2RlKSB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICBpZiAoaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50Lm5vZGUuX2luZGV4T2ZQb3NpdGlvbihub2RlLnBhcmVudC5rZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50LmtleSk7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudC5ub2RlO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0KHN0YXRlLCB1cGRhdGVzKSB7XG4gIHJldHVybiB1cGRhdGVzLnJlZHVjZShcbiAgICAoc3RhdGUyLCB1cGRhdGUpID0+IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUyLCB1cGRhdGUpLFxuICAgIHN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aCA9IGdldFBhcmVudHNQYXRoKHVwZGF0ZS5ub2RlKTtcbiAgcmV0dXJuIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aEl0ZW0gPSBwYXRoLnBvcCgpO1xuICBpZiAocGF0aEl0ZW0gPT09IHZvaWQgMCkge1xuICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJMaXZlT2JqZWN0XCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVPYmplY3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTGlzdFwiOiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZUxpc3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gYXJyYXlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1N0YXRlID0gc3RhdGUubWFwKCh4KSA9PiB4KTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0VXBkYXRlIG9mIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5tYXAoXG4gICAgICAgICAgICAgIChpdGVtLCBpbmRleCkgPT4gaW5kZXggPT09IGxpc3RVcGRhdGUuaW5kZXggPyBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkgOiBpdGVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImluc2VydFwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5pbmRleCA9PT0gbmV3U3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlLnB1c2gobHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4KVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5zcGxpY2UobGlzdFVwZGF0ZS5pbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwibW92ZVwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ID4gbGlzdFVwZGF0ZS5pbmRleCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLmluZGV4ICsgMVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZU1hcFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTWFwIGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnN0YXRlXTtcbiAgICBuZXdBcnJheVtwYXRoSXRlbV0gPSBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKFxuICAgICAgc3RhdGVbcGF0aEl0ZW1dLFxuICAgICAgcGF0aCxcbiAgICAgIHVwZGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9IGVsc2UgaWYgKGlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICBjb25zdCBub2RlID0gc3RhdGVbcGF0aEl0ZW1dO1xuICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGVBc09iaiA9IHN0YXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGVBc09iaixcbiAgICAgICAgW3BhdGhJdGVtXTogbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShub2RlLCBwYXRoLCB1cGRhdGUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9kZXByZWNhdGlvbi50c1xudmFyIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuaGFzKGtleSkpIHtcbiAgICAgIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5hZGQoa2V5KTtcbiAgICAgIGVycm9yV2l0aFRpdGxlKFwiRGVwcmVjYXRpb24gd2FybmluZ1wiLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZUlmKGNvbmRpdGlvbiwgbWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgdXNhZ2VFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB1c2FnZUVycm9yLm5hbWUgPSBcIlVzYWdlIGVycm9yXCI7XG4gICAgZXJyb3JXaXRoVGl0bGUoXCJVc2FnZSBlcnJvclwiLCBtZXNzYWdlKTtcbiAgICB0aHJvdyB1c2FnZUVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcklmKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvbGliL1BvbGxlci50c1xuZnVuY3Rpb24gbWFrZVBvbGxlcihjYWxsYmFjaykge1xuICBsZXQgY29udGV4dCA9IHtcbiAgICBzdGF0ZTogXCJzdG9wcGVkXCIsXG4gICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICBpbnRlcnZhbDogbnVsbCxcbiAgICBsYXN0U2NoZWR1bGVkQXQ6IG51bGwsXG4gICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgfTtcbiAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHNjaGVkdWxlKGNvbnRleHQuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICB2b2lkIGNhbGxiYWNrKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2NoZWR1bGUoaW50ZXJ2YWwpIHtcbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicnVubmluZ1wiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuc3RhdGUgIT09IFwic3RvcHBlZFwiID8gY29udGV4dC5pbnRlcnZhbCA6IGludGVydmFsLFxuICAgICAgbGFzdFNjaGVkdWxlZEF0OiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IHNldFRpbWVvdXQocG9sbCwgaW50ZXJ2YWwpLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNjaGVkdWxlUmVtYWluaW5nKHJlbWFpbmluZykge1xuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSBcInBhdXNlZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJydW5uaW5nXCIsXG4gICAgICBpbnRlcnZhbDogY29udGV4dC5pbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogY29udGV4dC5sYXN0U2NoZWR1bGVkQXQsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIHJlbWFpbmluZyksXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoaW50ZXJ2YWwpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGUoaW50ZXJ2YWwpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3RhcnQoaW50ZXJ2YWwpIHtcbiAgICBzdG9wKCk7XG4gICAgc3RhcnQoaW50ZXJ2YWwpO1xuICB9XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSBcInJ1bm5pbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC50aW1lb3V0SGFuZGxlKTtcbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicGF1c2VkXCIsXG4gICAgICBpbnRlcnZhbDogY29udGV4dC5pbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogY29udGV4dC5sYXN0U2NoZWR1bGVkQXQsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBudWxsLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwgLSAocGVyZm9ybWFuY2Uubm93KCkgLSBjb250ZXh0Lmxhc3RTY2hlZHVsZWRBdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJwYXVzZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlbWFpbmluZyhjb250ZXh0LnJlbWFpbmluZ0ludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlmIChjb250ZXh0LnN0YXRlID09PSBcInN0b3BwZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC50aW1lb3V0SGFuZGxlKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC50aW1lb3V0SGFuZGxlKTtcbiAgICB9XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInN0b3BwZWRcIixcbiAgICAgIGludGVydmFsOiBudWxsLFxuICAgICAgbGFzdFNjaGVkdWxlZEF0OiBudWxsLFxuICAgICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIHJlc3RhcnQsXG4gICAgcGF1c2UsXG4gICAgcmVzdW1lLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9zaGFsbG93LnRzXG5mdW5jdGlvbiBzaGFsbG93QXJyYXkoeHMsIHlzKSB7XG4gIGlmICh4cy5sZW5ndGggIT09IHlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QuaXMoeHNbaV0sIHlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dPYmoob2JqQSwgb2JqQikge1xuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmpBKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqQikgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqQikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXlzQS5ldmVyeShcbiAgICAoa2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5KSAmJiBPYmplY3QuaXMob2JqQVtrZXldLCBvYmpCW2tleV0pXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93KGEsIGIpIHtcbiAgaWYgKE9iamVjdC5pcyhhLCBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgY29uc3QgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICBpZiAoaXNBcnJheUEgfHwgaXNBcnJheUIpIHtcbiAgICBpZiAoIWlzQXJyYXlBIHx8ICFpc0FycmF5Qikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhbGxvd0FycmF5KGEsIGIpO1xuICB9XG4gIHJldHVybiBzaGFsbG93T2JqKGEsIGIpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBDbGllbnRNc2dDb2RlLFxuICBDb21tZW50c0FwaUVycm9yLFxuICBDcmR0VHlwZSxcbiAgTGl2ZUxpc3QsXG4gIExpdmVNYXAsXG4gIExpdmVPYmplY3QsXG4gIE5vdGlmaWNhdGlvbnNBcGlFcnJvcixcbiAgT3BDb2RlLFxuICBTZXJ2ZXJNc2dDb2RlLFxuICBXZWJzb2NrZXRDbG9zZUNvZGVzLFxuICBhY2tPcCxcbiAgYWRkUmVhY3Rpb24sXG4gIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMsXG4gIGFzUG9zLFxuICBhc3NlcnQsXG4gIGFzc2VydE5ldmVyLFxuICBiNjRkZWNvZGUsXG4gIGNsb25lTHNvbixcbiAgZmFuY3lfY29uc29sZV9leHBvcnRzIGFzIGNvbnNvbGUsXG4gIGNvbnZlcnRUb0NvbW1lbnREYXRhLFxuICBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uLFxuICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEsXG4gIGNvbnZlcnRUb1RocmVhZERhdGEsXG4gIGNyZWF0ZUNsaWVudCxcbiAgZGVsZXRlQ29tbWVudCxcbiAgZGVwcmVjYXRlLFxuICBkZXByZWNhdGVJZixcbiAgZGV0ZWN0RHVwZXMsXG4gIGVycm9ySWYsXG4gIGZyZWV6ZSxcbiAgZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5LFxuICBpc0NoaWxkQ3JkdCxcbiAgaXNKc29uQXJyYXksXG4gIGlzSnNvbk9iamVjdCxcbiAgaXNKc29uU2NhbGFyLFxuICBpc0xpdmVOb2RlLFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1Jvb3RDcmR0LFxuICBrSW50ZXJuYWwsXG4gIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdCxcbiAgbHNvblRvSnNvbixcbiAgbWFrZUV2ZW50U291cmNlLFxuICBtYWtlUG9sbGVyLFxuICBtYWtlUG9zaXRpb24sXG4gIG1lbW9pemVPblN1Y2Nlc3MsXG4gIG5uLFxuICBvYmplY3RUb1F1ZXJ5LFxuICBwYXRjaExpdmVPYmplY3RLZXksXG4gIHJhaXNlLFxuICByZW1vdmVSZWFjdGlvbixcbiAgc2hhbGxvdyxcbiAgc3RyaW5naWZ5LFxuICBzdHJpbmdpZnlDb21tZW50Qm9keSxcbiAgdGhyb3dVc2FnZUVycm9yLFxuICB0b1BsYWluTHNvbixcbiAgdHJ5UGFyc2VKc29uLFxuICB1cHNlcnRDb21tZW50LFxuICB3YWl0LFxuICB3aXRoVGltZW91dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   addReaction: () => (/* binding */ addReaction),\n/* harmony export */   applyOptimisticUpdates: () => (/* binding */ applyOptimisticUpdates),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   deleteComment: () => (/* binding */ deleteComment),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   removeReaction: () => (/* binding */ removeReaction),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   upsertComment: () => (/* binding */ upsertComment),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.3.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function clear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    clear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options.size ?? DEFAULT_SIZE;\n    this.delay = options.delay;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.input) === stringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(callback, options) {\n  const batch = new Batch(callback, options);\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    cache.set(cacheKey, state);\n    eventSource2.notify();\n  }\n  async function get(input) {\n    const cacheKey = getCacheKey(input);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(input);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(input) {\n    const cacheKey = getCacheKey(input);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2.observable,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const newState = callback(state);\n    if (state === newState) {\n      return;\n    }\n    state = newState;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    callback(state);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    subscribe\n  };\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url.toString();\n}\n\n// src/notifications.ts\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url = urljoin(baseUrl, `/v2/c${endpoint}`, params);\n    const response = await fetcher(url.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const json = await fetchJson(\"/inbox-notifications\", void 0, {\n      limit: options?.limit,\n      since: options?.since?.toISOString()\n    });\n    return {\n      threads: json.threads.map((thread) => convertToThreadData(thread)),\n      inboxNotifications: json.inboxNotifications.map(\n        (notification) => convertToInboxNotificationData(notification)\n      ),\n      deletedThreads: json.deletedThreads.map(\n        (info) => convertToThreadDeleteInfo(info)\n      ),\n      deletedInboxNotifications: json.deletedInboxNotifications.map(\n        (info) => convertToInboxNotificationDeleteInfo(info)\n      ),\n      meta: {\n        requestedAt: new Date(json.meta.requestedAt)\n      }\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(\"/inbox-notifications/count\");\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await fetchJson(\"/inbox-notifications\", {\n      method: \"DELETE\"\n    });\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await fetchJson(\n      `/inbox-notifications/${encodeURIComponent(inboxNotificationId)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n  const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n  const len = alphabet.length;\n  return Array.from(\n    { length },\n    () => alphabet.charAt(Math.floor(Math.random() * len))\n  ).join(\"\");\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isValueWithOperator(value)) {\n      keyValuePairsWithOperator.push([key, value]);\n    } else if (typeof value === \"object\" && !(\"startsWith\" in value)) {\n      indexedKeys.push([key, value]);\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isValueWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(\n    ({ key, operator, value }) => formatFilter(key, operator, formatFilterValue(value))\n  ).join(\" AND \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  return false;\n};\nvar isValueWithOperator = (value) => {\n  if (typeof value === \"object\" && value !== null && \"startsWith\" in value) {\n    return true;\n  }\n  return false;\n};\nvar formatFilter = (key, operator, value) => {\n  return `${key}${operator}${value}`;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${JSON.stringify(nestedKey)}]`;\n  }\n  return key;\n};\nvar formatFilterValue = (value) => {\n  if (typeof value === \"string\") {\n    if (isStringEmpty(value)) {\n      throw new Error(\"Value cannot be empty\");\n    }\n    return JSON.stringify(value);\n  }\n  return value.toString();\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createCommentsApi(roomId, getAuthValue, fetchClientApi) {\n  async function fetchCommentsApi(endpoint, params, options) {\n    const authValue = await getAuthValue();\n    return fetchClientApi(roomId, endpoint, authValue, options, params);\n  }\n  async function fetchJson(endpoint, options, params) {\n    const response = await fetchCommentsApi(endpoint, params, options);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreads(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const response = await fetchCommentsApi(\n      \"/threads\",\n      {\n        since: options?.since?.toISOString(),\n        query\n      },\n      {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map((thread) => convertToThreadData(thread)),\n        inboxNotifications: json.inboxNotifications.map(\n          (notification) => convertToInboxNotificationData(notification)\n        ),\n        deletedThreads: json.deletedThreads.map(\n          (info) => convertToThreadDeleteInfo(info)\n        ),\n        deletedInboxNotifications: json.deletedInboxNotifications.map(\n          (info) => convertToInboxNotificationDeleteInfo(info)\n        ),\n        meta: {\n          requestedAt: new Date(json.meta.requestedAt)\n        }\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        meta: {\n          requestedAt: /* @__PURE__ */ new Date()\n        }\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread({ threadId }) {\n    const response = await fetchCommentsApi(\n      `/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return;\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId,\n    threadId\n  }) {\n    const thread = await fetchJson(\"/threads\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        id: threadId,\n        comment: {\n          id: commentId,\n          body\n        },\n        metadata\n      })\n    });\n    return convertToThreadData(thread);\n  }\n  async function deleteThread({ threadId }) {\n    await fetchJson(`/threads/${encodeURIComponent(threadId)}`, {\n      method: \"DELETE\"\n    });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function markThreadAsResolved({ threadId }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/mark-as-resolved`,\n      {\n        method: \"POST\"\n      }\n    );\n  }\n  async function markThreadAsUnresolved({ threadId }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/mark-as-unresolved`,\n      {\n        method: \"POST\"\n      }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment2({\n    threadId,\n    commentId\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function addReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions/${encodeURIComponent(emoji)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getThreads,\n    getThread,\n    createThread,\n    deleteThread,\n    editThreadMetadata,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    createComment,\n    editComment,\n    deleteComment: deleteComment2,\n    addReaction: addReaction2,\n    removeReaction: removeReaction2\n  };\n}\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 = 50;\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getAuthBearerHeaderFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(roomId, endpoint, authValue, options2, params) {\n    const url = urljoin(\n      config.baseUrl,\n      `/v2/c/rooms/${encodeURIComponent(roomId)}${endpoint}`,\n      params\n    );\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(roomId, \"/storage\", authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(config.roomId, endpoint, managedSocket.authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    });\n  }\n  async function createTextMention(userId, mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      config.roomId,\n      \"/text-mentions\",\n      managedSocket.authValue,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          userId,\n          mentionId\n        })\n      }\n    );\n  }\n  async function deleteTextMention(mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      config.roomId,\n      `/text-mentions/${mentionId}`,\n      managedSocket.authValue,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function reportTextEditor(type, rootKey) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(config.roomId, \"/text-metadata\", authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        type,\n        rootKey\n      })\n    });\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = self.current?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storageBatch.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (true) {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 407 /* THREAD_DELETED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 408 /* THREAD_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  function isPresenceReady() {\n    return self.current !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  const commentsApi = createCommentsApi(\n    config.roomId,\n    delegates.authenticate,\n    fetchClientApi\n  );\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(\n      config.roomId,\n      endpoint,\n      authValue,\n      options2\n    );\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getRoomNotificationSettings() {\n    return fetchNotificationsJson(\n      \"/notification-settings\"\n    );\n  }\n  function updateRoomNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      \"/notification-settings\",\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        comments: {\n          ...commentsApi\n        },\n        notifications: {\n          getRoomNotificationSettings,\n          updateRoomNotificationSettings,\n          markInboxNotificationAsRead\n        }\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n\n// src/store.ts\nfunction createClientStore() {\n  const store = createStore({\n    threads: {},\n    queries: {},\n    optimisticUpdates: [],\n    inboxNotifications: {},\n    notificationSettings: {}\n  });\n  const optimisticUpdatesEventSource = makeEventSource();\n  return {\n    ...store,\n    deleteThread(threadId) {\n      store.set((state) => {\n        return {\n          ...state,\n          threads: deleteKeyImmutable(state.threads, threadId),\n          inboxNotifications: Object.fromEntries(\n            Object.entries(state.inboxNotifications).filter(\n              ([_id, notification]) => notification.kind === \"thread\" && notification.threadId === threadId\n            )\n          )\n        };\n      });\n    },\n    updateThreadAndNotification(thread, inboxNotification) {\n      store.set((state) => {\n        const existingThread = state.threads[thread.id];\n        return {\n          ...state,\n          threads: existingThread === void 0 || compareThreads(thread, existingThread) === 1 ? { ...state.threads, [thread.id]: thread } : state.threads,\n          inboxNotifications: inboxNotification === void 0 ? state.inboxNotifications : {\n            ...state.inboxNotifications,\n            [inboxNotification.id]: inboxNotification\n          }\n        };\n      });\n    },\n    updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads, deletedInboxNotifications, queryKey) {\n      store.set((state) => ({\n        ...state,\n        threads: applyThreadUpdates(state.threads, {\n          newThreads: threads,\n          deletedThreads\n        }),\n        inboxNotifications: applyNotificationsUpdates(\n          state.inboxNotifications,\n          {\n            newInboxNotifications: inboxNotifications,\n            deletedNotifications: deletedInboxNotifications\n          }\n        ),\n        queries: queryKey !== void 0 ? {\n          ...state.queries,\n          [queryKey]: { isLoading: false, data: void 0 }\n        } : state.queries\n      }));\n    },\n    updateRoomInboxNotificationSettings(roomId, settings, queryKey) {\n      store.set((state) => ({\n        ...state,\n        notificationSettings: {\n          ...state.notificationSettings,\n          [roomId]: settings\n        },\n        queries: {\n          ...state.queries,\n          [queryKey]: { isLoading: false, data: void 0 }\n        }\n      }));\n    },\n    pushOptimisticUpdate(optimisticUpdate) {\n      optimisticUpdatesEventSource.notify(optimisticUpdate);\n      store.set((state) => ({\n        ...state,\n        optimisticUpdates: [...state.optimisticUpdates, optimisticUpdate]\n      }));\n    },\n    setQueryState(queryKey, queryState) {\n      store.set((state) => ({\n        ...state,\n        queries: {\n          ...state.queries,\n          [queryKey]: queryState\n        }\n      }));\n    },\n    optimisticUpdatesEventSource\n  };\n}\nfunction deleteKeyImmutable(record, key) {\n  if (Object.prototype.hasOwnProperty.call(record, key)) {\n    const { [key]: _toDelete, ...rest } = record;\n    return rest;\n  }\n  return record;\n}\nfunction compareThreads(thread1, thread2) {\n  if (thread1.updatedAt && thread2.updatedAt) {\n    return thread1.updatedAt > thread2.updatedAt ? 1 : thread1.updatedAt < thread2.updatedAt ? -1 : 0;\n  } else if (thread1.updatedAt || thread2.updatedAt) {\n    return thread1.updatedAt ? 1 : -1;\n  }\n  if (thread1.createdAt > thread2.createdAt) {\n    return 1;\n  } else if (thread1.createdAt < thread2.createdAt) {\n    return -1;\n  }\n  return 0;\n}\nfunction applyOptimisticUpdates(state) {\n  const result = {\n    threads: {\n      ...state.threads\n    },\n    inboxNotifications: {\n      ...state.inboxNotifications\n    },\n    notificationSettings: {\n      ...state.notificationSettings\n    }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        result.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        };\n        break;\n      }\n      case \"mark-thread-as-resolved\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          resolved: true\n        };\n        break;\n      }\n      case \"mark-thread-as-unresolved\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          resolved: false\n        };\n        break;\n      }\n      case \"create-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        const inboxNotification = Object.values(result.inboxNotifications).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        result.inboxNotifications[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = deleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[optimisticUpdate.threadId] = {\n          ...result.threads[optimisticUpdate.threadId],\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        };\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = addReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = removeReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        result.inboxNotifications[optimisticUpdate.inboxNotificationId] = {\n          ...state.inboxNotifications[optimisticUpdate.inboxNotificationId],\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in result.inboxNotifications) {\n          result.inboxNotifications[id] = {\n            ...result.inboxNotifications[id],\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        const {\n          [optimisticUpdate.inboxNotificationId]: _,\n          ...inboxNotifications\n        } = result.inboxNotifications;\n        result.inboxNotifications = inboxNotifications;\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        result.inboxNotifications = {};\n        break;\n      }\n      case \"update-notification-settings\": {\n        result.notificationSettings[optimisticUpdate.roomId] = {\n          ...result.notificationSettings[optimisticUpdate.roomId],\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return result;\n}\nfunction applyThreadUpdates(existingThreads, updates) {\n  const updatedThreads = { ...existingThreads };\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n    if (existingThread) {\n      const result = compareThreads(existingThread, thread);\n      if (result === 1) return;\n    }\n    updatedThreads[thread.id] = thread;\n  });\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === void 0) return;\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n  return updatedThreads;\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1) return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction upsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction deleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      body: void 0\n    } : comment\n  );\n  if (!updatedComments.some((comment) => comment.deletedAt === void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n      comments: []\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction addReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction removeReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification\n  } = createNotificationsApi({\n    baseUrl,\n    fetcher: clientOptions.polyfills?.fetch || /* istanbul ignore next */\n    fetch,\n    authManager,\n    currentUserIdStore\n  });\n  const cacheStore = createClientStore();\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const usersStore = createBatchStore(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const roomsInfoStore = createBatchStore(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  return Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Internal\n      [kInternal]: {\n        notifications: {\n          getInboxNotifications,\n          getUnreadInboxNotificationsCount,\n          markAllInboxNotificationsAsRead,\n          markInboxNotificationAsRead,\n          deleteAllInboxNotifications,\n          deleteInboxNotification\n        },\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        cacheStore,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    return \"https://\" + url;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ?? element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n  let context = {\n    state: \"stopped\",\n    timeoutHandle: null,\n    interval: null,\n    lastScheduledAt: null,\n    remainingInterval: null\n  };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule(context.interval);\n    }\n    void callback();\n  }\n  function schedule(interval) {\n    context = {\n      state: \"running\",\n      interval: context.state !== \"stopped\" ? context.interval : interval,\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval),\n      remainingInterval: null\n    };\n  }\n  function scheduleRemaining(remaining) {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    context = {\n      state: \"running\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: setTimeout(poll, remaining),\n      remainingInterval: null\n    };\n  }\n  function start(interval) {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule(interval);\n  }\n  function restart(interval) {\n    stop();\n    start(interval);\n  }\n  function pause() {\n    if (context.state !== \"running\") {\n      return;\n    }\n    clearTimeout(context.timeoutHandle);\n    context = {\n      state: \"paused\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: null,\n      remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n    };\n  }\n  function resume() {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    scheduleRemaining(context.remainingInterval);\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = {\n      state: \"stopped\",\n      interval: null,\n      lastScheduledAt: null,\n      timeoutHandle: null,\n      remainingInterval: null\n    };\n  }\n  return {\n    start,\n    restart,\n    pause,\n    resume,\n    stop\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQixHQUFHLFVBQVU7QUFDeEU7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxxR0FBcUcsa0JBQWtCO0FBQ3ZIO0FBQ0E7QUFDQSxXQUFXLFNBQVMsRUFBRSxVQUFVO0FBQ2hDLFdBQVcsU0FBUyxFQUFFLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHdCQUF3QjtBQUMzRztBQUNBO0FBQ0EsYUFBYSxVQUFVLFFBQVEsWUFBWTtBQUMzQyxhQUFhLFNBQVMsUUFBUSxXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0MscUJBQXFCLFdBQVcsZ0JBQWdCLHVCQUF1QixnQkFBZ0I7QUFDdkg7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssUUFBUSxTQUFTLFVBQVUsY0FBYztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQSwwQ0FBMEMsK0JBQStCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1EQUFtRCw0RkFBNEY7QUFDL0k7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJLGNBQWM7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0JBQXNCLHFFQUFxRSxHQUFHLFlBQVksbUJBQW1CLFNBQVM7QUFDdEk7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCxNQUFNO0FBQ04saURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdFQUFnRSxTQUFTLEtBQUs7QUFDOUU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYyxtQ0FBbUMsU0FBUyxhQUFhO0FBQ3ZIO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQkFBZ0IseUJBQXlCLElBQUksYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVMsR0FBRyxlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQXdEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDRHQUE0RyxhQUFhLFlBQVksZUFBZTtBQUNwSjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQSxvQ0FBb0MsZ0NBQWdDO0FBQ3BFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2Qiw2QkFBNkI7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTSxtQ0FBbUMsbUJBQW1CO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLG1DQUFtQyx1QkFBdUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNLG1DQUFtQyx1QkFBdUI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBcUMsR0FBRyxDQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsYUFBYSxNQUFxQztBQUNsRDtBQUNBLEVBQUUsQ0FBUTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELCtCQUErQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxxQkFBcUIsT0FBTyxHQUFHLEtBQUs7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sc0JBQXNCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJLEdBQUcsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FB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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QixzQkFBc0I7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsc0NBQXNDO0FBQ25IO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyx3Q0FBd0M7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixVQUFVO0FBQ1YsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYyw0Q0FBNEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQixZQUFZO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBNkRFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcz9mMWZjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4zLjBcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL2R1cGUtZGV0ZWN0aW9uLnRzXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge307XG52YXIgY3Jvc3NMaW5rZWREb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvY3Jvc3MtbGlua2VkXCI7XG52YXIgZHVwZXNEb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvZHVwZXNcIjtcbnZhciBTUEFDRSA9IFwiIFwiO1xuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVjdER1cGVzKHBrZ05hbWUsIHBrZ1ZlcnNpb24sIHBrZ0Zvcm1hdCkge1xuICBjb25zdCBwa2dJZCA9IFN5bWJvbC5mb3IocGtnTmFtZSk7XG4gIGNvbnN0IHBrZ0J1aWxkSW5mbyA9IHBrZ0Zvcm1hdCA/IGAke3BrZ1ZlcnNpb24gfHwgXCJkZXZcIn0gKCR7cGtnRm9ybWF0fSlgIDogcGtnVmVyc2lvbiB8fCBcImRldlwiO1xuICBpZiAoIWdbcGtnSWRdKSB7XG4gICAgZ1twa2dJZF0gPSBwa2dCdWlsZEluZm87XG4gIH0gZWxzZSBpZiAoZ1twa2dJZF0gPT09IHBrZ0J1aWxkSW5mbykge1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IFtcbiAgICAgIGBNdWx0aXBsZSBjb3BpZXMgb2YgTGl2ZWJsb2NrcyBhcmUgYmVpbmcgbG9hZGVkIGluIHlvdXIgcHJvamVjdC4gVGhpcyB3aWxsIGNhdXNlIGlzc3VlcyEgU2VlICR7ZHVwZXNEb2NzICsgU1BBQ0V9YCxcbiAgICAgIFwiXCIsXG4gICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgIGAtICR7cGtnTmFtZX0gJHtnW3BrZ0lkXX0gKGFscmVhZHkgbG9hZGVkKWAsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7cGtnQnVpbGRJbmZvfSAodHJ5aW5nIHRvIGxvYWQgdGhpcyBub3cpYFxuICAgIF0uam9pbihcIlxcblwiKTtcbiAgICBlcnJvcihtc2cpO1xuICB9XG4gIGlmIChwa2dWZXJzaW9uICYmIFBLR19WRVJTSU9OICYmIHBrZ1ZlcnNpb24gIT09IFBLR19WRVJTSU9OKSB7XG4gICAgZXJyb3IoXG4gICAgICBbXG4gICAgICAgIGBDcm9zcy1saW5rZWQgdmVyc2lvbnMgb2YgTGl2ZWJsb2NrcyBmb3VuZCwgd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2Nyb3NzTGlua2VkRG9jcyArIFNQQUNFfWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQ29uZmxpY3RzOlwiLFxuICAgICAgICBgLSAke1BLR19OQU1FfSBpcyBhdCAke1BLR19WRVJTSU9OfWAsXG4gICAgICAgIGAtICR7cGtnTmFtZX0gaXMgYXQgJHtwa2dWZXJzaW9ufWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQWx3YXlzIHVwZ3JhZGUgYWxsIExpdmVibG9ja3MgcGFja2FnZXMgdG8gdGhlIHNhbWUgdmVyc2lvbiBudW1iZXIuXCJcbiAgICAgIF0uam9pbihcIlxcblwiKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSwgZXJybXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgZXJybXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICBlcnIubmFtZSA9IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKHZhbHVlLCBlcnJtc2cgPSBcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG5vbi1udWxsYWJsZVwiKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwLCBlcnJtc2cpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9saWIvY29udHJvbGxlZFByb21pc2UudHNcbmZ1bmN0aW9uIGNvbnRyb2xsZWRQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIFtwcm9taXNlLCByZXNvbHZlLCByZWplY3RdO1xufVxuZnVuY3Rpb24gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCkge1xuICBjb25zdCBbcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0XSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vLyBzcmMvbGliL0V2ZW50U291cmNlLnRzXG5mdW5jdGlvbiBtYWtlRXZlbnRTb3VyY2UoKSB7XG4gIGNvbnN0IF9vbmV0aW1lT2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBfYnVmZmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgX2J1ZmZlciA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKF9idWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBfYnVmZmVyKSB7XG4gICAgICBub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgICBfYnVmZmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBfb2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVPbmNlKGNhbGxiYWNrKSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29uZXRpbWVPYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWwocHJlZGljYXRlKSB7XG4gICAgbGV0IHVuc3ViO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB1bnN1YiA9IHN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSA9PT0gdm9pZCAwIHx8IHByZWRpY2F0ZShldmVudCkpIHtcbiAgICAgICAgICByZXMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHVuc3ViPy4oKSk7XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5T3JCdWZmZXIoZXZlbnQpIHtcbiAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgX2J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBfb2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgX29ic2VydmVycy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGNvdW50KCkge1xuICAgIHJldHVybiBfb25ldGltZU9ic2VydmVycy5zaXplICsgX29ic2VydmVycy5zaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUHJpdmF0ZS9pbnRlcm5hbCBjb250cm9sIG92ZXIgZXZlbnQgZW1pc3Npb25cbiAgICBub3RpZnk6IG5vdGlmeU9yQnVmZmVyLFxuICAgIHN1YnNjcmliZSxcbiAgICBzdWJzY3JpYmVPbmNlLFxuICAgIGNsZWFyLFxuICAgIGNvdW50LFxuICAgIHdhaXRVbnRpbCxcbiAgICBwYXVzZSxcbiAgICB1bnBhdXNlLFxuICAgIC8vIFB1YmxpY2x5IGV4cG9zYWJsZSBzdWJzY3JpcHRpb24gQVBJXG4gICAgb2JzZXJ2YWJsZToge1xuICAgICAgc3Vic2NyaWJlLFxuICAgICAgc3Vic2NyaWJlT25jZSxcbiAgICAgIHdhaXRVbnRpbFxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9mYW5jeS1jb25zb2xlLnRzXG52YXIgZmFuY3lfY29uc29sZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChmYW5jeV9jb25zb2xlX2V4cG9ydHMsIHtcbiAgZXJyb3I6ICgpID0+IGVycm9yMixcbiAgZXJyb3JXaXRoVGl0bGU6ICgpID0+IGVycm9yV2l0aFRpdGxlLFxuICB3YXJuOiAoKSA9PiB3YXJuLFxuICB3YXJuV2l0aFRpdGxlOiAoKSA9PiB3YXJuV2l0aFRpdGxlXG59KTtcbnZhciBiYWRnZSA9IFwiYmFja2dyb3VuZDojMGUwZDEyO2JvcmRlci1yYWRpdXM6OTk5OXB4O2NvbG9yOiNmZmY7cGFkZGluZzozcHggN3B4O2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NjAwO1wiO1xudmFyIGJvbGQgPSBcImZvbnQtd2VpZ2h0OjYwMFwiO1xuZnVuY3Rpb24gd3JhcChtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IGNvbnNvbGVbbWV0aG9kXShcIiVjTGl2ZWJsb2Nrc1wiLCBiYWRnZSwgbWVzc2FnZSwgLi4uYXJncylcbiAgKTtcbn1cbnZhciB3YXJuID0gd3JhcChcIndhcm5cIik7XG52YXIgZXJyb3IyID0gd3JhcChcImVycm9yXCIpO1xuZnVuY3Rpb24gd3JhcFdpdGhUaXRsZShtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKHRpdGxlLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXG4gICAgICBgJWNMaXZlYmxvY2tzJWMgJHt0aXRsZX1gLFxuICAgICAgYmFkZ2UsXG4gICAgICBib2xkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIC4uLmFyZ3NcbiAgICApXG4gICk7XG59XG52YXIgd2FybldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJ3YXJuXCIpO1xudmFyIGVycm9yV2l0aFRpdGxlID0gd3JhcFdpdGhUaXRsZShcImVycm9yXCIpO1xuXG4vLyBzcmMvbGliL2ZzbS50c1xuZnVuY3Rpb24gZGlzdGFuY2Uoc3RhdGUxLCBzdGF0ZTIpIHtcbiAgaWYgKHN0YXRlMSA9PT0gc3RhdGUyKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBjb25zdCBjaHVua3MxID0gc3RhdGUxLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgY2h1bmtzMiA9IHN0YXRlMi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IG1pbkxlbiA9IE1hdGgubWluKGNodW5rczEubGVuZ3RoLCBjaHVua3MyLmxlbmd0aCk7XG4gIGxldCBzaGFyZWQgPSAwO1xuICBmb3IgKDsgc2hhcmVkIDwgbWluTGVuOyBzaGFyZWQrKykge1xuICAgIGlmIChjaHVua3MxW3NoYXJlZF0gIT09IGNodW5rczJbc2hhcmVkXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVwID0gY2h1bmtzMS5sZW5ndGggLSBzaGFyZWQ7XG4gIGNvbnN0IGRvd24gPSBjaHVua3MyLmxlbmd0aCAtIHNoYXJlZDtcbiAgcmV0dXJuIFt1cCwgZG93bl07XG59XG5mdW5jdGlvbiBwYXR0ZXJucyh0YXJnZXRTdGF0ZSwgbGV2ZWxzKSB7XG4gIGNvbnN0IHBhcnRzID0gdGFyZ2V0U3RhdGUuc3BsaXQoXCIuXCIpO1xuICBpZiAobGV2ZWxzIDwgMSB8fCBsZXZlbHMgPiBwYXJ0cy5sZW5ndGggKyAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgbGV2ZWxzXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAobGV2ZWxzID4gcGFydHMubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goXCIqXCIpO1xuICB9XG4gIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSBsZXZlbHMgKyAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbGljZSA9IHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5qb2luKFwiLlwiKSArIFwiLipcIik7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKHRhcmdldFN0YXRlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBTYWZlQ29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmN1cnIgPSBpbml0aWFsQ29udGV4dDtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhbGxvd3MgcGF0Y2hpbmcgb2YgdGhlIGNvbnRleHQsIGJ5XG4gICAqIGNhbGxpbmcgYGNvbnRleHQucGF0Y2goKWAuIFBhdGNoaW5nIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIGR1cmF0aW9uXG4gICAqIG9mIHRoaXMgd2luZG93LlxuICAgKi9cbiAgYWxsb3dQYXRjaGluZyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBhbGxvd2VkID0gdHJ1ZTtcbiAgICBjb25zdCBwYXRjaGFibGVDb250ZXh0ID0ge1xuICAgICAgLi4udGhpcy5jdXJyLFxuICAgICAgcGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICBzZWxmLmN1cnIgPSBPYmplY3QuYXNzaWduKHt9LCBzZWxmLmN1cnIsIHBhdGNoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMocGF0Y2gpKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJwYXRjaFwiKSB7XG4gICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm8gbG9uZ2VyIHBhdGNoIHN0YWxlIGNvbnRleHRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNhbGxiYWNrKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgIGFsbG93ZWQgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cbn07XG52YXIgbmV4dElkID0gMTtcbnZhciBGU00gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlLCB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoZSBmaXJzdCBjYWxsIG1hZGUgdG9cbiAgICogLmFkZFN0YXRlKCkuXG4gICAqL1xuICBnZXQgaW5pdGlhbFN0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RhdGVzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGF0ZXMgZGVmaW5lZCB5ZXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgPT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdGFydGVkIHlldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RvcHBlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIG1hY2hpbmUgYnkgZW50ZXJpbmcgdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtYWNoaW5lIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMSAvKiBTVEFSVEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gdGhpcy5pbml0aWFsU3RhdGU7XG4gICAgdGhpcy5lbnRlcihudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHN0YXRlIG1hY2hpbmUuIFN0b3BwaW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHdpbGwgY2FsbCBleGl0XG4gICAqIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgYnV0IG5vdCBlbnRlciBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAxIC8qIFNUQVJURUQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdG9wIGEgc3RhdGUgbWFjaGluZSB0aGF0IGhhc24ndCBzdGFydGVkIHlldFwiKTtcbiAgICB9XG4gICAgdGhpcy5leGl0KG51bGwpO1xuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMiAvKiBTVE9QUEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuaWQgPSBuZXh0SWQrKztcbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDAgLyogTk9UX1NUQVJURURfWUVUICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5lbnRlckZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jbGVhbnVwU3RhY2sgPSBbXTtcbiAgICB0aGlzLmtub3duRXZlbnRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBuZXcgU2FmZUNvbnRleHQoaW5pdGlhbENvbnRleHQpO1xuICAgIHRoaXMuZXZlbnRIdWIgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbFRyYW5zaXRpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRFbnRlclN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKVxuICAgIH07XG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsVHJhbnNpdGlvbjogdGhpcy5ldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5vYnNlcnZhYmxlLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogdGhpcy5ldmVudEh1Yi5kaWRFbnRlclN0YXRlLm9ic2VydmFibGVcbiAgICB9O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbiBleHBsaWNpdCBmaW5pdGUgc3RhdGUgaW4gdGhlIHN0YXRlIG1hY2hpbmUuXG4gICAqL1xuICBhZGRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyKG5hbWVPclBhdHRlcm4sIGVudGVyRm4pIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVudGVyRm5zLmhhcyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPIFdlIF9jdXJyZW50bHlfIGRvbid0IHN1cHBvcnQgbXVsdGlwbGUgLm9uRW50ZXJzKCkgZm9yIHRoZSBzYW1lXG4gICAgICAgIC8vIHN0YXRlLCBidXQgdGhpcyBpcyBub3QgYSBmdW5kYW1lbnRhbCBsaW1pdGF0aW9uLiBKdXN0IG5vdFxuICAgICAgICAvLyBpbXBsZW1lbnRlZCB5ZXQuIElmIHdlIHdhbnRlZCB0bywgd2UgY291bGQgbWFrZSB0aGlzIGFuIGFycmF5LlxuICAgICAgICBgZW50ZXIvZXhpdCBmdW5jdGlvbiBmb3IgJHtuYW1lT3JQYXR0ZXJufSBhbHJlYWR5IGV4aXN0c2BcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW50ZXJGbnMuc2V0KG5hbWVPclBhdHRlcm4sIGVudGVyRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uRW50ZXJBc3luYyhuYW1lT3JQYXR0ZXJuLCBwcm9taXNlRm4sIG9uT0ssIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKG5hbWVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdm9pZCBwcm9taXNlRm4odGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50LCBzaWduYWwpLnRoZW4oXG4gICAgICAgIC8vIE9uIE9LXG4gICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX09LXCIsIGRhdGEgfSwgb25PSyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBPbiBFcnJvclxuICAgICAgICAocmVhc29uKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX0VSUk9SXCIsIHJlYXNvbiB9LCBvbkVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGlmIChuYW1lT3JQYXR0ZXJuID09PSBcIipcIikge1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZU9yUGF0dGVybi5lbmRzV2l0aChcIi4qXCIpKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuYW1lT3JQYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy5zdGF0ZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YXRlcyBtYXRjaCAke0pTT04uc3RyaW5naWZ5KG5hbWVPclBhdHRlcm4pfWApO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFsbCBhbGxvd2VkIG91dGdvaW5nIHRyYW5zaXRpb25zIGZvciBhIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0cyBmb3IgZWFjaCBldmVudCBjYW4gYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gICAqIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by4gVGhlc2UgZnVuY3Rpb25zIGNhbiBsb29rIGF0IHRoZSBgZXZlbnRgIG9yXG4gICAqIGBjb250ZXh0YCBwYXJhbXMgdG8gY29uZGl0aW9uYWxseSBkZWNpZGUgd2hpY2ggbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uXG4gICAqIHRvLlxuICAgKlxuICAgKiBJZiB5b3Ugc2V0IGl0IHRvIGBudWxsYCwgdGhlbiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIGV4cGxpY2l0bHkgZm9yYmlkZGVuXG4gICAqIGFuZCB0aHJvdyBhbiBlcnJvci4gSWYgeW91IGRvbid0IGRlZmluZSBhIHRhcmdldCBmb3IgYSB0cmFuc2l0aW9uLCB0aGVuXG4gICAqIHN1Y2ggZXZlbnRzIHdpbGwgZ2V0IGlnbm9yZWQuXG4gICAqL1xuICBhZGRUcmFuc2l0aW9ucyhuYW1lT3JQYXR0ZXJuLCBtYXBwaW5nKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyY1N0YXRlIG9mIHRoaXMuZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5nZXQoc3JjU3RhdGUpO1xuICAgICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLnNldChzcmNTdGF0ZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHRhcmdldF9dIG9mIE9iamVjdC5lbnRyaWVzKG1hcHBpbmcpKSB7XG4gICAgICAgIGlmIChtYXAuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzZXQgdHJhbnNpdGlvbiBcIiR7dHlwZX1cIiBvbiBcIiR7c3JjU3RhdGV9XCIgKHZpYSBcIiR7bmFtZU9yUGF0dGVybn1cIiksIGJ1dCBhIHRyYW5zaXRpb24gYWxyZWFkeSBleGlzdHMgdGhlcmUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0XztcbiAgICAgICAgdGhpcy5rbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuIFRoZSBzdGF0ZSBuYW1lLCBvciBzdGF0ZSBncm91cCBwYXR0ZXJuIG5hbWUuXG4gICAqIEBwYXJhbSBhZnRlciAgICAgICAgICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRvIHRha2UgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgIGlzIHRha2VuLCB0aGUgdGltZXIgd2lsbCBnZXQgY2FuY2VsbGVkLlxuICAgKiBAcGFyYW0gdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCkgOiBhZnRlcjI7XG4gICAgICBjb25zdCB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJUSU1FUlwiIH0sIHRhcmdldCk7XG4gICAgICB9LCBtcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldCh0aGlzLmN1cnJlbnRTdGF0ZSk/LmdldChldmVudE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGl0cyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuXG4gICAqIENhbGwgdGhpcyBiZWZvcmUgY2hhbmdpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBsZXZlbHMgRGVmaW5lcyBob3cgbWFueSBcImxldmVsc1wiIG9mIG5lc3Rpbmcgd2lsbCBiZVxuICAgKiBleGl0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tIGBmb28uYmFyLnF1eGAgdG9cbiAgICogYGZvby5iYXIuYmF6YCwgdGhlbiB0aGUgbGV2ZWwgaXMgMS4gQnV0IGlmIHlvdSB0cmFuc2l0aW9uIGZyb21cbiAgICogYGZvby5iYXIucXV4YCB0byBgYmxhLmJsYWAsIHRoZW4gdGhlIGxldmVsIGlzIDMuXG4gICAqIElmIGBudWxsYCwgaXQgd2lsbCBleGl0IGFsbCBsZXZlbHMuXG4gICAqL1xuICBleGl0KGxldmVscykge1xuICAgIHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzID8/IHRoaXMuY2xlYW51cFN0YWNrLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgZW50ZXIobGV2ZWxzKSB7XG4gICAgY29uc3QgZW50ZXJQYXR0ZXJucyA9IHBhdHRlcm5zKFxuICAgICAgdGhpcy5jdXJyZW50U3RhdGUsXG4gICAgICBsZXZlbHMgPz8gdGhpcy5jdXJyZW50U3RhdGUuc3BsaXQoXCIuXCIpLmxlbmd0aCArIDFcbiAgICApO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVudGVyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgZW50ZXJGbiA9IHRoaXMuZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKGNsZWFudXBGbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMua25vd25FdmVudFR5cGVzLmhhcyhldmVudC50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV2ZW50ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQudHlwZSl9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMiAvKiBTVE9QUEVEICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZuID0gdGhpcy5nZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbihldmVudCwgdGFyZ2V0Rm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRTdGF0ZTtcbiAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICBjb25zdCBuZXh0VGFyZ2V0ID0gdGFyZ2V0Rm4oZXZlbnQsIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCk7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgZWZmZWN0cyA9IHZvaWQgMDtcbiAgICBpZiAobmV4dFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGVzLmhhcyhuZXh0U3RhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV4dCBzdGF0ZSBuYW1lOiAke0pTT04uc3RyaW5naWZ5KG5leHRTdGF0ZSl9YCk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ubm90aWZ5KHsgZnJvbTogb2xkU3RhdGUsIHRvOiBuZXh0U3RhdGUgfSk7XG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpc3RhbmNlKHRoaXMuY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIGlmICh1cCA+IDApIHtcbiAgICAgIHRoaXMuZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbmV4dFN0YXRlO1xuICAgIGlmIChlZmZlY3RzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGVmZmVjdHNUb1J1biA9IGVmZmVjdHM7XG4gICAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0c1RvUnVuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWZmZWN0KHBhdGNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hhYmxlQ29udGV4dC5wYXRjaChlZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb3duID4gMCkge1xuICAgICAgdGhpcy5lbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKTtcbn1cbmZ1bmN0aW9uIHRyeVBhcnNlSnNvbihyYXdNZXNzYWdlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmF3TWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGI2NGRlY29kZShiNjR2YWx1ZSkge1xuICB0cnkge1xuICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gYjY0dmFsdWUucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gICAgY29uc3QgZGVjb2RlZFZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgYXRvYihmb3JtYXR0ZWRWYWx1ZSkuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiJVwiICsgKFwiMDBcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgIH0pLmpvaW4oXCJcIilcbiAgICApO1xuICAgIHJldHVybiBkZWNvZGVkVmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBhdG9iKGI2NHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcGFjdChpdGVtcykge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKFxuICAgIChpdGVtKSA9PiBpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHZvaWQgMFxuICApO1xufVxuZnVuY3Rpb24gY29tcGFjdE9iamVjdChvYmopIHtcbiAgY29uc3QgbmV3T2JqID0geyAuLi5vYmogfTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBpZiAobmV3T2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIG5ld09ialtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdPYmo7XG59XG5mdW5jdGlvbiB3YWl0KG1pbGxpcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIG1pbGxpcykpO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aFRpbWVvdXQocHJvbWlzZSwgbWlsbGlzLCBlcnJtc2cpIHtcbiAgbGV0IHRpbWVySUQ7XG4gIGNvbnN0IHRpbWVyJCA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICB0aW1lcklEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKGVycm1zZykpO1xuICAgIH0sIG1pbGxpcyk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCB0aW1lciRdKS5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aW1lcklEKSk7XG59XG5mdW5jdGlvbiBtZW1vaXplT25TdWNjZXNzKGZhY3RvcnlGbikge1xuICBsZXQgY2FjaGVkID0gbnVsbDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoY2FjaGVkID09PSBudWxsKSB7XG4gICAgICBjYWNoZWQgPSBmYWN0b3J5Rm4oKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNhY2hlZCA9IG51bGw7XG4gICAgICAgIH0sIDVlMyk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkO1xuICB9O1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvU2VydmVyTXNnLnRzXG52YXIgU2VydmVyTXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcnZlck1zZ0NvZGUyKSA9PiB7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9KT0lORURcIl0gPSAxMDFdID0gXCJVU0VSX0pPSU5FRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfTEVGVFwiXSA9IDEwMl0gPSBcIlVTRVJfTEVGVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkJST0FEQ0FTVEVEX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNURURfRVZFTlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJST09NX1NUQVRFXCJdID0gMTA0XSA9IFwiUk9PTV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiXSA9IDIwMF0gPSBcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJSRUpFQ1RfU1RPUkFHRV9PUFwiXSA9IDI5OV0gPSBcIlJFSkVDVF9TVE9SQUdFX09QXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDBdID0gXCJVUERBVEVfWURPQ1wiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9DUkVBVEVEXCJdID0gNDAwXSA9IFwiVEhSRUFEX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfREVMRVRFRFwiXSA9IDQwN10gPSBcIlRIUkVBRF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIl0gPSA0MDFdID0gXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9VUERBVEVEXCJdID0gNDA4XSA9IFwiVEhSRUFEX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0NSRUFURURcIl0gPSA0MDJdID0gXCJDT01NRU5UX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0VESVRFRFwiXSA9IDQwM10gPSBcIkNPTU1FTlRfRURJVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9ERUxFVEVEXCJdID0gNDA0XSA9IFwiQ09NTUVOVF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiXSA9IDQwNV0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIl0gPSA0MDZdID0gXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIjtcbiAgcmV0dXJuIFNlcnZlck1zZ0NvZGUyO1xufSkoU2VydmVyTXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9JV2ViU29ja2V0LnRzXG52YXIgV2Vic29ja2V0Q2xvc2VDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFdlYnNvY2tldENsb3NlQ29kZXMyKSA9PiB7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfTk9STUFMXCJdID0gMWUzXSA9IFwiQ0xPU0VfTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfQUJOT1JNQUxcIl0gPSAxMDA2XSA9IFwiQ0xPU0VfQUJOT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiXSA9IDEwMTFdID0gXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRSWV9BR0FJTl9MQVRFUlwiXSA9IDEwMTNdID0gXCJUUllfQUdBSU5fTEFURVJcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCJdID0gNGUzXSA9IFwiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk5PVF9BTExPV0VEXCJdID0gNDAwMV0gPSBcIk5PVF9BTExPV0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiXSA9IDQwMDJdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCJdID0gNDAwM10gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCJdID0gNDAwNF0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCJdID0gNDAwNV0gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlJPT01fSURfVVBEQVRFRFwiXSA9IDQwMDZdID0gXCJST09NX0lEX1VQREFURURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJLSUNLRURcIl0gPSA0MTAwXSA9IFwiS0lDS0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVE9LRU5fRVhQSVJFRFwiXSA9IDQxMDldID0gXCJUT0tFTl9FWFBJUkVEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiXSA9IDQ5OTldID0gXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCI7XG4gIHJldHVybiBXZWJzb2NrZXRDbG9zZUNvZGVzMjtcbn0pKFdlYnNvY2tldENsb3NlQ29kZXMgfHwge30pO1xuZnVuY3Rpb24gc2hvdWxkRGlzY29ubmVjdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSA0OTk5IC8qIENMT1NFX1dJVEhPVVRfUkVUUlkgKi8gfHwgY29kZSA+PSA0ZTMgJiYgY29kZSA8IDQxMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA0MTAwICYmIGNvZGUgPCA0MjAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMTMgLyogVFJZX0FHQUlOX0xBVEVSICovIHx8IGNvZGUgPj0gNDIwMCAmJiBjb2RlIDwgNDMwMDtcbn1cblxuLy8gc3JjL2Nvbm5lY3Rpb24udHNcbmZ1bmN0aW9uIGlzSWRsZShzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gXCJpbml0aWFsXCIgfHwgc3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiO1xufVxuZnVuY3Rpb24gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdGUgPSBtYWNoaW5lLmN1cnJlbnRTdGF0ZTtcbiAgc3dpdGNoIChzdGF0ZSkge1xuICAgIGNhc2UgXCJAb2suY29ubmVjdGVkXCI6XG4gICAgY2FzZSBcIkBvay5hd2FpdGluZy1wb25nXCI6XG4gICAgICByZXR1cm4gXCJjb25uZWN0ZWRcIjtcbiAgICBjYXNlIFwiQGlkbGUuaW5pdGlhbFwiOlxuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIGNhc2UgXCJAYXV0aC5idXN5XCI6XG4gICAgY2FzZSBcIkBhdXRoLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYnVzeVwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBpZGxlLnpvbWJpZVwiOlxuICAgICAgcmV0dXJuIG1hY2hpbmUuY29udGV4dC5zdWNjZXNzQ291bnQgPiAwID8gXCJyZWNvbm5lY3RpbmdcIiA6IFwiY29ubmVjdGluZ1wiO1xuICAgIGNhc2UgXCJAaWRsZS5mYWlsZWRcIjpcbiAgICAgIHJldHVybiBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoc3RhdGUsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgfVxufVxudmFyIEJBQ0tPRkZfREVMQVlTID0gWzI1MCwgNTAwLCAxZTMsIDJlMywgNGUzLCA4ZTMsIDFlNF07XG52YXIgUkVTRVRfREVMQVkgPSBCQUNLT0ZGX0RFTEFZU1swXSAtIDE7XG52YXIgQkFDS09GRl9ERUxBWVNfU0xPVyA9IFsyZTMsIDNlNCwgNmU0LCAzZTVdO1xudmFyIEhFQVJUQkVBVF9JTlRFUlZBTCA9IDNlNDtcbnZhciBQT05HX1RJTUVPVVQgPSAyZTM7XG52YXIgQVVUSF9USU1FT1VUID0gMWU0O1xudmFyIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQgPSAxZTQ7XG52YXIgU3RvcFJldHJ5aW5nID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKHJlYXNvbik7XG4gIH1cbn07XG52YXIgTGl2ZWJsb2Nrc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn07XG5mdW5jdGlvbiBuZXh0QmFja29mZkRlbGF5KGN1cnJlbnREZWxheSwgZGVsYXlzKSB7XG4gIHJldHVybiBkZWxheXMuZmluZCgoZGVsYXkpID0+IGRlbGF5ID4gY3VycmVudERlbGF5KSA/PyBkZWxheXNbZGVsYXlzLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gaW5jcmVhc2VCYWNrb2ZmRGVsYXkoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHtcbiAgICBiYWNrb2ZmRGVsYXk6IG5leHRCYWNrb2ZmRGVsYXkoY29udGV4dC5iYWNrb2ZmRGVsYXksIEJBQ0tPRkZfREVMQVlTKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZU19TTE9XKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U3VjY2Vzc0NvdW50KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7IHN1Y2Nlc3NDb3VudDogMCB9KTtcbn1cbmZ1bmN0aW9uIGxvZyhsZXZlbCwgbWVzc2FnZSkge1xuICBjb25zdCBsb2dnZXIgPSBsZXZlbCA9PT0gMiAvKiBFUlJPUiAqLyA/IGVycm9yMiA6IGxldmVsID09PSAxIC8qIFdBUk4gKi8gPyB3YXJuIDogKFxuICAgIC8qIGJsYWNrIGhvbGUgKi9cbiAgICAoKSA9PiB7XG4gICAgfVxuICApO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxvZ2dlcihtZXNzYWdlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGUpIHtcbiAgY29uc3QgY29ubiA9IFwiQ29ubmVjdGlvbiB0byBMaXZlYmxvY2tzIHdlYnNvY2tldCBzZXJ2ZXJcIjtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB3YXJuKGAke2Nvbm59IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZC4gJHtTdHJpbmcoZSl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGlzQ2xvc2VFdmVudChlKSA/IGAke2Nvbm59IGNsb3NlZCBwcmVtYXR1cmVseSAoY29kZTogJHtlLmNvZGV9KS4gUmV0cnlpbmcgaW4gJHtjdHguYmFja29mZkRlbGF5fW1zLmAgOiBgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBsb2dDbG9zZUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGRldGFpbHMgPSBbYGNvZGU6ICR7ZXZlbnQuY29kZX1gXTtcbiAgaWYgKGV2ZW50LnJlYXNvbikge1xuICAgIGRldGFpbHMucHVzaChgcmVhc29uOiAke2V2ZW50LnJlYXNvbn1gKTtcbiAgfVxuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgQ29ubmVjdGlvbiB0byBMaXZlYmxvY2tzIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkICgke2RldGFpbHMuam9pbihcIiwgXCIpfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gXG4gICAgKTtcbiAgfTtcbn1cbnZhciBsb2dQZXJtYW5lbnRDbG9zZSA9IGxvZyhcbiAgMSAvKiBXQVJOICovLFxuICBcIkNvbm5lY3Rpb24gdG8gV2ViU29ja2V0IGNsb3NlZCBwZXJtYW5lbnRseS4gV29uJ3QgcmV0cnkuXCJcbik7XG5mdW5jdGlvbiBpc0Nsb3NlRXZlbnQoZXJyb3IzKSB7XG4gIHJldHVybiAhKGVycm9yMyBpbnN0YW5jZW9mIEVycm9yKSAmJiBlcnJvcjMudHlwZSA9PT0gXCJjbG9zZVwiO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2luZyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXJ0ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIGZ1bmN0aW9uIGxvZzIoLi4uYXJncykge1xuICAgIHdhcm4oXG4gICAgICBgJHsoKCgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gMWUzKS50b0ZpeGVkKDIpfSBbRlNNICMke21hY2hpbmUuaWR9XWAsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfVxuICBjb25zdCB1bnN1YnMgPSBbXG4gICAgbWFjaGluZS5ldmVudHMuZGlkUmVjZWl2ZUV2ZW50LnN1YnNjcmliZSgoZSkgPT4gbG9nMihgRXZlbnQgJHtlLnR5cGV9YCkpLFxuICAgIG1hY2hpbmUuZXZlbnRzLndpbGxUcmFuc2l0aW9uLnN1YnNjcmliZShcbiAgICAgICh7IGZyb20sIHRvIH0pID0+IGxvZzIoXCJUcmFuc2l0aW9uaW5nXCIsIGZyb20sIFwiXFx1MjE5MlwiLCB0bylcbiAgICApLFxuICAgIG1hY2hpbmUuZXZlbnRzLmRpZElnbm9yZUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChlKSA9PiBsb2cyKFwiSWdub3JlZCBldmVudFwiLCBlLnR5cGUsIGUsIFwiKGN1cnJlbnQgc3RhdGUgd29uJ3QgaGFuZGxlIGl0KVwiKVxuICAgIClcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy53aWxsRXhpdFN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRXhpdGluZyBzdGF0ZVwiLCBzKSksXG4gICAgLy8gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkVudGVyaW5nIHN0YXRlXCIsIHMpKSxcbiAgXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgICAgdW5zdWIoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSkge1xuICBjb25zdCBzdGF0dXNEaWRDaGFuZ2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkQ29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWREaXNjb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGxldCBsYXN0U3RhdHVzID0gbnVsbDtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3QgY3VyclN0YXR1cyA9IHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKTtcbiAgICBpZiAoY3VyclN0YXR1cyAhPT0gbGFzdFN0YXR1cykge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLm5vdGlmeShjdXJyU3RhdHVzKTtcbiAgICB9XG4gICAgaWYgKGxhc3RTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIgJiYgY3VyclN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgZGlkRGlzY29ubmVjdC5ub3RpZnkoKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIgJiYgY3VyclN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgZGlkQ29ubmVjdC5ub3RpZnkoKTtcbiAgICB9XG4gICAgbGFzdFN0YXR1cyA9IGN1cnJTdGF0dXM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN0YXR1c0RpZENoYW5nZTogc3RhdHVzRGlkQ2hhbmdlLm9ic2VydmFibGUsXG4gICAgZGlkQ29ubmVjdDogZGlkQ29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIGRpZERpc2Nvbm5lY3Q6IGRpZERpc2Nvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICB1bnN1YnNjcmliZVxuICB9O1xufVxudmFyIGFzc2lnbiA9IChwYXRjaCkgPT4gKGN0eCkgPT4gY3R4LnBhdGNoKHBhdGNoKTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoZGVsZWdhdGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9uTWVzc2FnZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgY29uc3Qgb25MaXZlYmxvY2tzRXJyb3IgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZmlyZUVycm9yRXZlbnQoZXJybXNnLCBlcnJjb2RlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBMaXZlYmxvY2tzRXJyb3IoZXJybXNnLCBlcnJjb2RlKTtcbiAgICAgIG9uTGl2ZWJsb2Nrc0Vycm9yLm5vdGlmeShlcnIpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW5pdGlhbENvbnRleHQgPSB7XG4gICAgc3VjY2Vzc0NvdW50OiAwLFxuICAgIGF1dGhWYWx1ZTogbnVsbCxcbiAgICBzb2NrZXQ6IG51bGwsXG4gICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICB9O1xuICBjb25zdCBtYWNoaW5lID0gbmV3IEZTTShpbml0aWFsQ29udGV4dCkuYWRkU3RhdGUoXCJAaWRsZS5pbml0aWFsXCIpLmFkZFN0YXRlKFwiQGlkbGUuZmFpbGVkXCIpLmFkZFN0YXRlKFwiQGlkbGUuem9tYmllXCIpLmFkZFN0YXRlKFwiQGF1dGguYnVzeVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5idXN5XCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiKS5hZGRTdGF0ZShcIkBvay5jb25uZWN0ZWRcIikuYWRkU3RhdGUoXCJAb2suYXdhaXRpbmctcG9uZ1wiKTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIipcIiwge1xuICAgIFJFQ09OTkVDVDoge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCByZXNldFN1Y2Nlc3NDb3VudF1cbiAgICB9LFxuICAgIERJU0NPTk5FQ1Q6IFwiQGlkbGUuaW5pdGlhbFwiXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAaWRsZS4qXCIsIHJlc2V0U3VjY2Vzc0NvdW50KS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLipcIiwge1xuICAgIENPTk5FQ1Q6IChfLCBjdHgpID0+IChcbiAgICAgIC8vIElmIHdlIHN0aWxsIGhhdmUgYSBrbm93biBhdXRoVmFsdWUsIHRyeSB0byByZWNvbm5lY3QgdG8gdGhlIHNvY2tldCBkaXJlY3RseSxcbiAgICAgIC8vIG90aGVyd2lzZSwgdHJ5IHRvIG9idGFpbiBhIG5ldyBhdXRoVmFsdWVcbiAgICAgIGN0eC5hdXRoVmFsdWUgIT09IG51bGwgPyBcIkBjb25uZWN0aW5nLmJ1c3lcIiA6IFwiQGF1dGguYnVzeVwiXG4gICAgKVxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBhdXRoLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGF1dGguYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGF1dGguYnVzeVwiLFxuICAgICgpID0+IHdpdGhUaW1lb3V0KFxuICAgICAgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpLFxuICAgICAgQVVUSF9USU1FT1VULFxuICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIGF1dGhcIlxuICAgICksXG4gICAgLy8gT24gc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgYXV0aFZhbHVlOiBva0V2ZW50LmRhdGFcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gQXV0aCBmYWlsZWRcbiAgICAoZmFpbGVkRXZlbnQpID0+IHtcbiAgICAgIGlmIChmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5LFxuICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgIDIgLyogRVJST1IgKi8sXG4gICAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2ZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIEVycm9yID8gZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UgOiBTdHJpbmcoZmFpbGVkRXZlbnQucmVhc29uKX1gXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgb25Tb2NrZXRFcnJvciA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfRVJST1JcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldE1lc3NhZ2UgPSAoZXZlbnQpID0+IGV2ZW50LmRhdGEgPT09IFwicG9uZ1wiID8gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJQT05HXCIgfSkgOiBvbk1lc3NhZ2Uubm90aWZ5KGV2ZW50KTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Tb2NrZXQoc29ja2V0KSB7XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy9cbiAgICAvLyBVc2UgdGhlIFwiY3JlYXRlU29ja2V0XCIgZGVsZWdhdGUgZnVuY3Rpb24gKHByb3ZpZGVkIHRvIHRoZVxuICAgIC8vIE1hbmFnZWRTb2NrZXQpIHRvIGNyZWF0ZSB0aGUgYWN0dWFsIFdlYlNvY2tldCBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgIC8vIFRoZW4sIHNldCB1cCBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMsIGFuZCB3YWl0IGZvciB0aGVcbiAgICAvLyBcIm9wZW5cIiBldmVudCB0byBvY2N1ci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIFwib3BlblwiIGV2ZW50IGhhcHBlbnMsIHdlJ3JlIHJlYWR5IHRvIHRyYW5zaXRpb24gdG8gdGhlXG4gICAgLy8gT0sgc3RhdGUuIFRoaXMgaXMgZG9uZSBieSByZXNvbHZpbmcgdGhlIFByb21pc2UuXG4gICAgLy9cbiAgICBhc3luYyAoY3R4LCBzaWduYWwpID0+IHtcbiAgICAgIGxldCBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gbnVsbDtcbiAgICAgIGxldCB1bmNvbmZpcm1lZFNvY2tldCA9IG51bGw7XG4gICAgICBjb25zdCBjb25uZWN0JCA9IG5ldyBQcm9taXNlKFxuICAgICAgICAocmVzb2x2ZSwgcmVqKSA9PiB7XG4gICAgICAgICAgaWYgKGN0eC5hdXRoVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggYXV0aFZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzb2NrZXQgPSBkZWxlZ2F0ZXMuY3JlYXRlU29ja2V0KGN0eC5hdXRoVmFsdWUpO1xuICAgICAgICAgIHVuY29uZmlybWVkU29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdChldmVudCkge1xuICAgICAgICAgICAgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgICByZWooZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBbYWN0b3IkLCBkaWRSZWNlaXZlQWN0b3JdID0gY29udHJvbGxlZFByb21pc2UoKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yQWN0b3JJZChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyTXNnID0gdHJ5UGFyc2VKc29uKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKHNlcnZlck1zZz8udHlwZSA9PT0gMTA0IC8qIFJPT01fU1RBVEUgKi8pIHtcbiAgICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2b2lkIGFjdG9yJC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShbc29ja2V0LCB1bnN1Yl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gd2l0aFRpbWVvdXQoXG4gICAgICAgIGNvbm5lY3QkLFxuICAgICAgICBTT0NLRVRfQ09OTkVDVF9USU1FT1VULFxuICAgICAgICBcIlRpbWVkIG91dCBkdXJpbmcgd2Vic29ja2V0IGNvbm5lY3Rpb25cIlxuICAgICAgKS50aGVuKFxuICAgICAgICAvL1xuICAgICAgICAvLyBQYXJ0IDM6XG4gICAgICAgIC8vIEJ5IG5vdywgb3VyIFwib3BlblwiIGV2ZW50IGhhcyBmaXJlZCwgYW5kIHRoZSBwcm9taXNlIGhhcyBiZWVuXG4gICAgICAgIC8vIHJlc29sdmVkLiBUd28gcG9zc2libGUgc2NlbmFyaW9zOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBUaGUgaGFwcHkgcGF0aC4gTW9zdCBsaWtlbHkuXG4gICAgICAgIC8vIDIuIFVoLW9oLiBBIHByZW1hdHVyZSBjbG9zZS9lcnJvciBldmVudCBoYXMgYmVlbiBvYnNlcnZlZC4gTGV0J3NcbiAgICAgICAgLy8gICAgcmVqZWN0IHRoZSBwcm9taXNlIGFmdGVyIGFsbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQW55IGNsb3NlL2Vycm9yIGV2ZW50IHRoYXQgd2lsbCBnZXQgc2NoZWR1bGVkIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gb253YXJkcywgd2lsbCBiZSBjYXVnaHQgaW4gdGhlIE9LIHN0YXRlLCBhbmQgZGVhbHQgd2l0aFxuICAgICAgICAvLyBhY2NvcmRpbmdseS5cbiAgICAgICAgLy9cbiAgICAgICAgKFtzb2NrZXQsIHVuc3ViXSkgPT4ge1xuICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydGVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FwdHVyZWRQcmVtYXR1cmVFdmVudCkge1xuICAgICAgICAgICAgdGhyb3cgY2FwdHVyZWRQcmVtYXR1cmVFdmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgfVxuICAgICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB0ZWFyZG93blNvY2tldCh1bmNvbmZpcm1lZFNvY2tldCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIE9ubHkgdHJhbnNpdGlvbiB0byBPSyBzdGF0ZSBhZnRlciBhIHN1Y2Nlc3NmdWxseSBvcGVuZWQgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAb2suY29ubmVjdGVkXCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIHNvY2tldDogb2tFdmVudC5kYXRhLFxuICAgICAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWRcbiAgICAoZmFpbHVyZSkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gZmFpbHVyZS5yZWFzb247XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNDbG9zZUV2ZW50KGVycikpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSxcbiAgICAgICAgICAgICAgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLnJlYXNvbiksXG4gICAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5yZWFzb24sIGVyci5jb2RlKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IHNlbmRIZWFydGJlYXQgPSB7XG4gICAgdGFyZ2V0OiBcIkBvay5hd2FpdGluZy1wb25nXCIsXG4gICAgZWZmZWN0OiAoY3R4KSA9PiB7XG4gICAgICBjdHguc29ja2V0Py5zZW5kKFwicGluZ1wiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1heWJlSGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IGNhblpvbWJpZSA9IGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiICYmIGRlbGVnYXRlcy5jYW5ab21iaWUoKTtcbiAgICByZXR1cm4gY2FuWm9tYmllID8gXCJAaWRsZS56b21iaWVcIiA6IHNlbmRIZWFydGJlYXQ7XG4gIH07XG4gIG1hY2hpbmUuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmNvbm5lY3RlZFwiLCBIRUFSVEJFQVRfSU5URVJWQUwsIG1heWJlSGVhcnRiZWF0KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5jb25uZWN0ZWRcIiwge1xuICAgIE5BVklHQVRPUl9PRkZMSU5FOiBtYXliZUhlYXJ0YmVhdCxcbiAgICAvLyBEb24ndCB0YWtlIHRoZSBicm93c2VyJ3Mgd29yZCBmb3IgaXQgd2hlbiBpdCBzYXlzIGl0J3Mgb2ZmbGluZS4gRG8gYSBwaW5nL3BvbmcgdG8gbWFrZSBzdXJlLlxuICAgIFdJTkRPV19HT1RfRk9DVVM6IHNlbmRIZWFydGJlYXRcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS56b21iaWVcIiwge1xuICAgIFdJTkRPV19HT1RfRk9DVVM6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiXG4gICAgLy8gV2hlbiBpbiB6b21iaWUgc3RhdGUsIHRoZSBjbGllbnQgd2lsbCB0cnkgdG8gd2FrZSB1cCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHdpbmRvdyByZWdhaW5zIGZvY3VzXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAb2suKlwiLCAoY3R4KSA9PiB7XG4gICAgY3R4LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiBjdHguc3VjY2Vzc0NvdW50ICsgMSB9KTtcbiAgICBjb25zdCB0aW1lcklEID0gc2V0VGltZW91dChcbiAgICAgIC8vIE9uIHRoZSBuZXh0IHRpY2ssIHN0YXJ0IGRlbGl2ZXJpbmcgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBhbHJlYWR5XG4gICAgICAvLyBiZWVuIHJlY2VpdmVkLCBhbmQgY29udGludWUgc3luY2hyb25vdXMgZGVsaXZlcnkgb2YgYWxsIGZ1dHVyZVxuICAgICAgLy8gaW5jb21pbmcgbWVzc2FnZXMuXG4gICAgICBvbk1lc3NhZ2UudW5wYXVzZSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiAoY3R4MikgPT4ge1xuICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4Mi5zb2NrZXQpO1xuICAgICAgY3R4Mi5wYXRjaCh7IHNvY2tldDogbnVsbCB9KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTtcbiAgICAgIG9uTWVzc2FnZS5wYXVzZSgpO1xuICAgIH07XG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgeyBQT05HOiBcIkBvay5jb25uZWN0ZWRcIiB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suYXdhaXRpbmctcG9uZ1wiLCBQT05HX1RJTUVPVVQsIHtcbiAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vIExvZyBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MgYW5kIGRyb3AgdGhlIGN1cnJlbnQgb3BlbiBzb2NrZXRcbiAgICBlZmZlY3Q6IGxvZyhcbiAgICAgIDEgLyogV0FSTiAqLyxcbiAgICAgIFwiUmVjZWl2ZWQgbm8gcG9uZyBmcm9tIHNlcnZlciwgYXNzdW1lIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcy5cIlxuICAgIClcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suKlwiLCB7XG4gICAgLy8gV2hlbiBhIHNvY2tldCByZWNlaXZlcyBhbiBlcnJvciwgdGhpcyBjYW4gY2F1c2UgdGhlIGNsb3Npbmcgb2YgdGhlXG4gICAgLy8gc29ja2V0LCBvciBub3QuIFNvIGFsd2F5cyBjaGVjayB0byBzZWUgaWYgdGhlIHNvY2tldCBpcyBzdGlsbCBPUEVOIG9yXG4gICAgLy8gbm90LiBXaGVuIHN0aWxsIE9QRU4sIGRvbid0IHRyYW5zaXRpb24uXG4gICAgRVhQTElDSVRfU09DS0VUX0VSUk9SOiAoXywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQuc29ja2V0Py5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBpbmNyZWFzZUJhY2tvZmZEZWxheVxuICAgICAgfTtcbiAgICB9LFxuICAgIEVYUExJQ0lUX1NPQ0tFVF9DTE9TRTogKGUpID0+IHtcbiAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2dQZXJtYW5lbnRDbG9zZSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGUuZXZlbnQucmVhc29uLCBlLmV2ZW50LmNvZGUpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIGlmIChlLmV2ZW50LmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gICAgY29uc3Qgcm9vdCA9IHdpbiA/PyBkb2M7XG4gICAgbWFjaGluZS5vbkVudGVyKFwiKlwiLCAoY3R4KSA9PiB7XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtPZmZsaW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PRkZMSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtCYWNrT25saW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PTkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiV0lORE9XX0dPVF9GT0NVU1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgcm9vdD8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJvb3Q/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4LnNvY2tldCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGNsZWFudXBzID0gW107XG4gIGNvbnN0IHsgc3RhdHVzRGlkQ2hhbmdlLCBkaWRDb25uZWN0LCBkaWREaXNjb25uZWN0LCB1bnN1YnNjcmliZSB9ID0gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpO1xuICBjbGVhbnVwcy5wdXNoKHVuc3Vic2NyaWJlKTtcbiAgaWYgKG9wdGlvbnMuZW5hYmxlRGVidWdMb2dnaW5nKSB7XG4gICAgY2xlYW51cHMucHVzaChlbmFibGVUcmFjaW5nKG1hY2hpbmUpKTtcbiAgfVxuICBtYWNoaW5lLnN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgbWFjaGluZSxcbiAgICBjbGVhbnVwcyxcbiAgICAvLyBPYnNlcnZhYmxlIGV2ZW50cyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGlzIG1hY2hpbmVcbiAgICBldmVudHM6IHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZSxcbiAgICAgIGRpZENvbm5lY3QsXG4gICAgICBkaWREaXNjb25uZWN0LFxuICAgICAgb25NZXNzYWdlOiBvbk1lc3NhZ2Uub2JzZXJ2YWJsZSxcbiAgICAgIG9uTGl2ZWJsb2Nrc0Vycm9yOiBvbkxpdmVibG9ja3NFcnJvci5vYnNlcnZhYmxlXG4gICAgfVxuICB9O1xufVxudmFyIE1hbmFnZWRTb2NrZXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlcywgZW5hYmxlRGVidWdMb2dnaW5nID0gZmFsc2UsIHdhaXRGb3JBY3RvcklkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgbWFjaGluZSwgZXZlbnRzLCBjbGVhbnVwcyB9ID0gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShcbiAgICAgIGRlbGVnYXRlcyxcbiAgICAgIHsgd2FpdEZvckFjdG9ySWQsIGVuYWJsZURlYnVnTG9nZ2luZyB9XG4gICAgKTtcbiAgICB0aGlzLm1hY2hpbmUgPSBtYWNoaW5lO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuY2xlYW51cHMgPSBjbGVhbnVwcztcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b05ld0Nvbm5lY3Rpb25TdGF0dXModGhpcy5tYWNoaW5lKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXV0aCBhdXRoVmFsdWUuXG4gICAqL1xuICBnZXQgYXV0aFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLm1hY2hpbmUuY29udGV4dC5hdXRoVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgdG8gdHJ5IHRvIGNvbm5lY3QgdG8gYSBXZWJTb2NrZXQuIFRoaXMgb25seSBoYXMgYW4gZWZmZWN0XG4gICAqIGlmIHRoZSBtYWNoaW5lIGlzIGlkbGUgYXQgdGhlIG1vbWVudCwgb3RoZXJ3aXNlIHRoaXMgaXMgYSBuby1vcC5cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogSWYgaWRsZSwgd2lsbCB0cnkgdG8gY29ubmVjdC4gT3RoZXJ3aXNlLCBpdCB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IHRvXG4gICAqIHRoZSBzb2NrZXQsIHBvdGVudGlhbGx5IG9idGFpbmluZyBhIG5ldyBhdXRoVmFsdWUgZmlyc3QsIGlmIG5lZWRlZC5cbiAgICovXG4gIHJlY29ubmVjdCgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiUkVDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgdG8gZGlzY29ubmVjdCBmcm9tIHRoZSBjdXJyZW50IFdlYlNvY2tldC4gSXMgZ29pbmcgdG8gYmVcbiAgICogYSBuby1vcCBpZiB0aGVyZSBpcyBubyBhY3RpdmUgY29ubmVjdGlvbi5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkRJU0NPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIHN0b3AgdGhlIG1hY2hpbmUgYW5kIHJ1biBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuIEFmdGVyXG4gICAqIGNhbGxpbmcgZGVzdHJveSgpLCB5b3UgY2FuIG5vIGxvbmdlciB1c2UgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzIGJlZm9yZVxuICAgKiBsZXR0aW5nIHRoZSBpbnN0YW5jZSBnZXQgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWFjaGluZS5zdG9wKCk7XG4gICAgbGV0IGNsZWFudXA7XG4gICAgd2hpbGUgKGNsZWFudXAgPSB0aGlzLmNsZWFudXBzLnBvcCgpKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTYWZlbHkgc2VuZCBhIG1lc3NhZ2UgdG8gdGhlIGN1cnJlbnQgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFdpbGwgZW1pdCBhIGxvZ1xuICAgKiBtZXNzYWdlIGlmIHRoaXMgaXMgc29tZWhvdyBpbXBvc3NpYmxlLlxuICAgKi9cbiAgc2VuZChkYXRhKSB7XG4gICAgY29uc3Qgc29ja2V0ID0gdGhpcy5tYWNoaW5lLmNvbnRleHQ/LnNvY2tldDtcbiAgICBpZiAoc29ja2V0ID09PSBudWxsKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IG5vdCBjb25uZWN0ZWQgeWV0XCIsIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IDEpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogV2ViU29ja2V0IG5vIGxvbmdlciBvcGVuXCIsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQuc2VuZChkYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5PVEU6IFVzZWQgYnkgdGhlIEUyRSBhcHAgb25seSwgdG8gc2ltdWxhdGUgZXhwbGljaXQgZXZlbnRzLlxuICAgKiBOb3QgaWRlYWwgdG8ga2VlcCBleHBvc2VkIDooXG4gICAqL1xuICBfcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZChldmVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9BdXRoVG9rZW4udHNcbmZ1bmN0aW9uIGNhbldyaXRlU3RvcmFnZShzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG59XG5mdW5jdGlvbiBjYW5Db21tZW50KHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gaXNWYWxpZEF1dGhUb2tlblBheWxvYWQoZGF0YSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChkYXRhKSAmJiAoZGF0YS5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pO1xufVxuZnVuY3Rpb24gcGFyc2VBdXRoVG9rZW4ocmF3VG9rZW5TdHJpbmcpIHtcbiAgY29uc3QgdG9rZW5QYXJ0cyA9IHJhd1Rva2VuU3RyaW5nLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHRva2VuUGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aGVudGljYXRpb24gZXJyb3I6IGludmFsaWQgSldUIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IHBheWxvYWQgPSB0cnlQYXJzZUpzb24oYjY0ZGVjb2RlKHRva2VuUGFydHNbMV0pKTtcbiAgaWYgKCEocGF5bG9hZCAmJiBpc1ZhbGlkQXV0aFRva2VuUGF5bG9hZChwYXlsb2FkKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBleHBlY3RlZCBhIHZhbGlkIHRva2VuIGJ1dCBkaWQgbm90IGdldCBvbmUuIEhpbnQ6IGlmIHlvdSBhcmUgdXNpbmcgYSBjYWxsYmFjaywgZW5zdXJlIHRoZSByb29tIGlzIHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSB0b2tlbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50Q2FsbGJhY2tcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByYXc6IHJhd1Rva2VuU3RyaW5nLFxuICAgIHBhcnNlZDogcGF5bG9hZFxuICB9O1xufVxuXG4vLyBzcmMvYXV0aC1tYW5hZ2VyLnRzXG5mdW5jdGlvbiBjcmVhdGVBdXRoTWFuYWdlcihhdXRoT3B0aW9ucykge1xuICBjb25zdCBhdXRoZW50aWNhdGlvbiA9IHByZXBhcmVBdXRoZW50aWNhdGlvbihhdXRoT3B0aW9ucyk7XG4gIGNvbnN0IHNlZW5Ub2tlbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgZXhwaXJ5VGltZXMgPSBbXTtcbiAgY29uc3QgcmVxdWVzdFByb21pc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgc2VlblRva2Vucy5jbGVhcigpO1xuICAgIHRva2Vucy5sZW5ndGggPSAwO1xuICAgIGV4cGlyeVRpbWVzLmxlbmd0aCA9IDA7XG4gICAgcmVxdWVzdFByb21pc2VzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSB7XG4gICAgaWYgKHJlcXVlc3RlZFNjb3BlID09PSBcImNvbW1lbnRzOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOnJlYWRcIiAvKiBDb21tZW50c1JlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTpyZWFkXCIgLyogUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3RlZFNjb3BlID09PSBcInJvb206cmVhZFwiKSB7XG4gICAgICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwicm9vbTpyZWFkXCIgLyogUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGdldENhY2hlZFRva2VuKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgY29uc3Qgbm93ID0gTWF0aC5jZWlsKERhdGUubm93KCkgLyAxZTMpO1xuICAgIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gZXhwaXJ5VGltZXNbaV07XG4gICAgICBpZiAoZXhwaXJlc0F0IDw9IG5vdykge1xuICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBleHBpcnlUaW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSBlbHNlIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8pIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0T3B0aW9ucy5yb29tSWQgJiYgT2JqZWN0LmVudHJpZXModG9rZW4ucGFyc2VkLnBlcm1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbcmVzb3VyY2UsIHNjb3Blc10gb2YgT2JqZWN0LmVudHJpZXModG9rZW4ucGFyc2VkLnBlcm1zKSkge1xuICAgICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2UuaW5jbHVkZXMoXCIqXCIpICYmIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdE9wdGlvbnMucmVxdWVzdGVkU2NvcGUsIHNjb3BlcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UuaW5jbHVkZXMoXCIqXCIpICYmIHJlcXVlc3RPcHRpb25zLnJvb21JZC5zdGFydHNXaXRoKHJlc291cmNlLnJlcGxhY2UoXCIqXCIsIFwiXCIpKSB8fCByZXF1ZXN0T3B0aW9ucy5yb29tSWQgPT09IHJlc291cmNlICYmIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdE9wdGlvbnMucmVxdWVzdGVkU2NvcGUsIHNjb3BlcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYWtlQXV0aFJlcXVlc3Qob3B0aW9ucykge1xuICAgIGNvbnN0IGZldGNoZXIgPSBhdXRoT3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoID8/ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDogd2luZG93LmZldGNoKTtcbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJwcml2YXRlXCIpIHtcbiAgICAgIGlmIChmZXRjaGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRvIHVzZSBMaXZlYmxvY2tzIGNsaWVudCBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQgd2l0aCBhIHVybCBhcyBhdXRoIGVuZHBvaW50LCB5b3UgbmVlZCB0byBwcm92aWRlIGEgZmV0Y2ggcG9seWZpbGwuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2hlciwgYXV0aGVudGljYXRpb24udXJsLCB7XG4gICAgICAgIHJvb206IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXV0aFRva2VuKHJlc3BvbnNlLnRva2VuKTtcbiAgICAgIGlmIChzZWVuVG9rZW5zLmhhcyhwYXJzZWQucmF3KSkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiVGhlIHNhbWUgTGl2ZWJsb2NrcyBhdXRoIHRva2VuIHdhcyBpc3N1ZWQgZnJvbSB0aGUgYmFja2VuZCBiZWZvcmUuIENhY2hpbmcgTGl2ZWJsb2NrcyB0b2tlbnMgaXMgbm90IHN1cHBvcnRlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRpb24uY2FsbGJhY2sob3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlLmVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtcInJlYXNvblwiIGluIHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZS5yZWFzb24gPT09IFwic3RyaW5nXCIgPyByZXNwb25zZS5yZWFzb24gOiBcIkZvcmJpZGRlblwifWA7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yID09PSBcImZvcmJpZGRlblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKHJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91ciBhdXRoZW50aWNhdGlvbiBjYWxsYmFjayBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgdG9rZW4sIGJ1dCBpdCBkaWQgbm90LiBIaW50OiB0aGUgcmV0dXJuIHZhbHVlIHNob3VsZCBsb29rIGxpa2U6IHsgdG9rZW46IFwiLi4uXCIgfSdcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVW5leHBlY3RlZCBhdXRoZW50aWNhdGlvbiB0eXBlLiBNdXN0IGJlIHByaXZhdGUgb3IgY3VzdG9tLlwiXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRBdXRoVmFsdWUocmVxdWVzdE9wdGlvbnMpIHtcbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJwdWJsaWNcIiwgcHVibGljQXBpS2V5OiBhdXRoZW50aWNhdGlvbi5wdWJsaWNBcGlLZXkgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkVG9rZW4gPSBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucyk7XG4gICAgaWYgKGNhY2hlZFRva2VuICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuOiBjYWNoZWRUb2tlbiB9O1xuICAgIH1cbiAgICBsZXQgY3VycmVudFByb21pc2U7XG4gICAgaWYgKHJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZXMuZ2V0KHJlcXVlc3RPcHRpb25zLnJvb21JZCk7XG4gICAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQocmVxdWVzdE9wdGlvbnMucm9vbUlkLCBjdXJyZW50UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChcImxpdmVibG9ja3MtdXNlci10b2tlblwiKTtcbiAgICAgIGlmIChjdXJyZW50UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlID0gbWFrZUF1dGhSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLnNldChcImxpdmVibG9ja3MtdXNlci10b2tlblwiLCBjdXJyZW50UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGN1cnJlbnRQcm9taXNlO1xuICAgICAgY29uc3QgQlVGRkVSID0gMzA7XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpICsgKHRva2VuLnBhcnNlZC5leHAgLSB0b2tlbi5wYXJzZWQuaWF0KSAtIEJVRkZFUjtcbiAgICAgIHNlZW5Ub2tlbnMuYWRkKHRva2VuLnJhdyk7XG4gICAgICBpZiAodG9rZW4ucGFyc2VkLmsgIT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBleHBpcnlUaW1lcy5wdXNoKGV4cGlyZXNBdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbiB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAocmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5kZWxldGUocmVxdWVzdE9wdGlvbnMucm9vbUlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5kZWxldGUoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVzZXQsXG4gICAgZ2V0QXV0aFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwdWJsaWNBcGlLZXksIGF1dGhFbmRwb2ludCB9ID0gYXV0aE9wdGlvbnM7XG4gIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCAmJiBwdWJsaWNBcGlLZXkgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCBzaW11bHRhbmVvdXNseSB1c2UgYHB1YmxpY0FwaUtleWAgYW5kIGBhdXRoRW5kcG9pbnRgIG9wdGlvbnMuIFBsZWFzZSBwaWNrIG9uZSBhbmQgbGVhdmUgdGhlIG90aGVyIG9wdGlvbiB1bnNwZWNpZmllZC4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2YgcHVibGljQXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwic2tfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBgcHVibGljQXBpS2V5YCBvcHRpb24uIFRoZSB2YWx1ZSB5b3UgcGFzc2VkIGlzIGEgc2VjcmV0IGtleSwgd2hpY2ggc2hvdWxkIG5vdCBiZSB1c2VkIGZyb20gdGhlIGNsaWVudC4gUGxlYXNlIG9ubHkgZXZlciBwYXNzIGEgcHVibGljIGtleSBoZXJlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRQdWJsaWNLZXlcIlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInBrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQga2V5LiBQbGVhc2UgdXNlIHRoZSBwdWJsaWMga2V5IGZvcm1hdDogcGtfPHB1YmxpYyBrZXk+LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRQdWJsaWNLZXlcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHVibGljXCIsXG4gICAgICBwdWJsaWNBcGlLZXlcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHJpdmF0ZVwiLFxuICAgICAgdXJsOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgICAgY2FsbGJhY2s6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBgYXV0aEVuZHBvaW50YCBvcHRpb24gbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRBdXRoRW5kcG9pbnRcIlxuICAgICk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIFwiSW52YWxpZCBMaXZlYmxvY2tzIGNsaWVudCBvcHRpb25zLiBQbGVhc2UgcHJvdmlkZSBlaXRoZXIgYSBgcHVibGljQXBpS2V5YCBvciBgYXV0aEVuZHBvaW50YCBvcHRpb24uIFRoZXkgY2Fubm90IGJvdGggYmUgZW1wdHkuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEF1dGhFbmRwb2ludChmZXRjaDIsIGVuZHBvaW50LCBib2R5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoMihlbmRwb2ludCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGAkeyhhd2FpdCByZXMudGV4dCgpKS50cmltKCkgfHwgXCJyZWFzb24gbm90IHByb3ZpZGVkIGluIGF1dGggcmVzcG9uc2VcIn0gKCR7cmVzLnN0YXR1c30gcmV0dXJuZWQgYnkgUE9TVCAke2VuZHBvaW50fSlgO1xuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEgfHwgcmVzLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKGBVbmF1dGhvcml6ZWQ6ICR7cmVhc29ufWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhdXRoZW50aWNhdGU6ICR7cmVhc29ufWApO1xuICAgIH1cbiAgfVxuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIHdoZW4gZG9pbmcgYSBQT1NUIHJlcXVlc3Qgb24gXCIke2VuZHBvaW50fVwiLiAke1N0cmluZyhcbiAgICAgICAgZXJcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpIHx8IHR5cGVvZiBkYXRhLnRva2VuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgSlNPTiByZXNwb25zZSBvZiB0aGUgZm9ybSBcXGB7IHRva2VuOiBcIi4uLlwiIH1cXGAgd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgZGF0YVxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7IHRva2VuIH0gPSBkYXRhO1xuICByZXR1cm4geyB0b2tlbiB9O1xufVxuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgREVGQVVMVF9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9hcGkubGl2ZWJsb2Nrcy5pb1wiO1xuXG4vLyBzcmMvaW50ZXJuYWwudHNcbnZhciBrSW50ZXJuYWwgPSBTeW1ib2woKTtcblxuLy8gc3JjL2RldnRvb2xzL2JyaWRnZS50c1xudmFyIF9icmlkZ2VBY3RpdmUgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdGl2YXRlQnJpZGdlKGFsbG93ZWQpIHtcbiAgX2JyaWRnZUFjdGl2ZSA9IGFsbG93ZWQ7XG59XG5mdW5jdGlvbiBzZW5kVG9QYW5lbChtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmdWxsTXNnID0ge1xuICAgIC4uLm1lc3NhZ2UsXG4gICAgc291cmNlOiBcImxpdmVibG9ja3MtZGV2dG9vbHMtY2xpZW50XCJcbiAgfTtcbiAgaWYgKCEob3B0aW9ucz8uZm9yY2UgfHwgX2JyaWRnZUFjdGl2ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LnBvc3RNZXNzYWdlKGZ1bGxNc2csIFwiKlwiKTtcbn1cbnZhciBldmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YT8uc291cmNlID09PSBcImxpdmVibG9ja3MtZGV2dG9vbHMtcGFuZWxcIikge1xuICAgICAgZXZlbnRTb3VyY2Uubm90aWZ5KGV2ZW50LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuICB9KTtcbn1cbnZhciBvbk1lc3NhZ2VGcm9tUGFuZWwgPSBldmVudFNvdXJjZS5vYnNlcnZhYmxlO1xuXG4vLyBzcmMvZGV2dG9vbHMvaW5kZXgudHNcbnZhciBWRVJTSU9OID0gUEtHX1ZFUlNJT04gfHwgXCJkZXZcIjtcbnZhciBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBEZXZUb29scyhnZXRBbGxSb29tcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9kZXZ0b29sc1NldHVwSGFzUnVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gdHJ1ZTtcbiAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdFwiOiB7XG4gICAgICAgIGFjdGl2YXRlQnJpZGdlKHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHJvb21JZCBvZiBnZXRBbGxSb29tcygpKSB7XG4gICAgICAgICAgc2VuZFRvUGFuZWwoe1xuICAgICAgICAgICAgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgY2xpZW50VmVyc2lvbjogVkVSU0lPTlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcIndha2UtdXAtZGV2dG9vbHNcIiB9LCB7IGZvcmNlOiB0cnVlIH0pO1xufVxudmFyIHVuc3Vic0J5Um9vbUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHN0b3BTeW5jU3RyZWFtKHJvb21JZCkge1xuICBjb25zdCB1bnN1YnMgPSB1bnN1YnNCeVJvb21JZC5nZXQocm9vbUlkKSA/PyBbXTtcbiAgdW5zdWJzQnlSb29tSWQuZGVsZXRlKHJvb21JZCk7XG4gIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgdW5zdWIoKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RhcnRTeW5jU3RyZWFtKHJvb20pIHtcbiAgc3RvcFN5bmNTdHJlYW0ocm9vbS5pZCk7XG4gIGZ1bGxTeW5jKHJvb20pO1xuICB1bnN1YnNCeVJvb21JZC5zZXQocm9vbS5pZCwgW1xuICAgIC8vIFdoZW4gdGhlIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZXNcbiAgICByb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSksXG4gICAgLy8gV2hlbiBzdG9yYWdlIGluaXRpYWxpemVzLCBzZW5kIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlRGlkTG9hZC5zdWJzY3JpYmVPbmNlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgc3RvcmFnZSB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgc3RvcmFnZSByb290XG4gICAgcm9vbS5ldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIFwibWVcIiBvciBcIm90aGVyc1wiIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyB2YWx1ZXMgYWNjb3JkaW5nbHlcbiAgICByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY01lKHJvb20pKSxcbiAgICByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSB5ZG9jIGlzIHVwZGF0ZWQsIGZvcndhcmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnlkb2Muc3Vic2NyaWJlKCh1cGRhdGUpID0+IHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkpLFxuICAgIC8vIEFueSB0aW1lIGEgY3VzdG9tIHJvb20gZXZlbnQgaXMgcmVjZWl2ZWQsIGZvcndhcmQgaXRcbiAgICByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZXZlbnREYXRhKSA9PiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKVxuICAgIClcbiAgXSk7XG59XG5mdW5jdGlvbiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjp5ZG9jXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHVwZGF0ZVxuICB9KTtcbn1cbnZhciBsb2FkZWRBdCA9IERhdGUubm93KCk7XG52YXIgZXZlbnRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5leHRFdmVudElkKCkge1xuICByZXR1cm4gYGV2ZW50LSR7bG9hZGVkQXR9LSR7ZXZlbnRDb3VudGVyKyt9YDtcbn1cbmZ1bmN0aW9uIGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpldmVudHM6OmN1c3RvbS1ldmVudFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogXCJDdXN0b21FdmVudFwiLFxuICAgICAgaWQ6IG5leHRFdmVudElkKCksXG4gICAgICBrZXk6IFwiRXZlbnRcIixcbiAgICAgIGNvbm5lY3Rpb25JZDogZXZlbnREYXRhLmNvbm5lY3Rpb25JZCxcbiAgICAgIHBheWxvYWQ6IGV2ZW50RGF0YS5ldmVudFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGlmIChyb290KSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIHN0b3JhZ2U6IHJvb3QudG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY01lKHJvb20pIHtcbiAgY29uc3QgbWUgPSByb29tW2tJbnRlcm5hbF0uZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBpZiAobWUpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgbWVcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkge1xuICBjb25zdCBvdGhlcnMgPSByb29tW2tJbnRlcm5hbF0uZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIGlmIChvdGhlcnMpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgb3RoZXJzXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ1bGxTeW5jKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGNvbnN0IG1lID0gcm9vbVtrSW50ZXJuYWxdLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbVtrSW50ZXJuYWxdLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICByb29tLmZldGNoWURvYyhcIlwiKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpmdWxsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKSxcbiAgICBzdG9yYWdlOiByb290Py50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkID8/IG51bGwsXG4gICAgbWUsXG4gICAgb3RoZXJzXG4gIH0pO1xufVxudmFyIHJvb21DaGFubmVsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCkge1xuICBjb25zdCBsaXN0ZW5lciA9IHJvb21DaGFubmVsTGlzdGVuZXJzLmdldChyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5kZWxldGUocm9vbUlkKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbGlua0RldlRvb2xzKHJvb21JZCwgcm9vbSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsIHJvb21JZCwgY2xpZW50VmVyc2lvbjogVkVSU0lPTiB9KTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuc2V0KFxuICAgIHJvb21JZCxcbiAgICAvLyBSZXR1cm5zIHRoZSB1bnN1YnNjcmliZSBjYWxsYmFjaywgdGhhdCB3ZSBzdG9yZSBpbiB0aGVcbiAgICAvLyByb29tQ2hhbm5lbExpc3RlbmVycyByZWdpc3RyeVxuICAgIG9uTWVzc2FnZUZyb21QYW5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xuICAgICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICAgIGNhc2UgXCJyb29tOjpzdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0YXJ0U3luY1N0cmVhbShyb29tKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJvb206OnVuc3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB1bmxpbmtEZXZUb29scyhyb29tSWQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6dW5hdmFpbGFibGVcIixcbiAgICByb29tSWRcbiAgfSk7XG59XG5cbi8vIHNyYy9saWIvc3RyaW5naWZ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiIHx8IG9iamVjdCA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKTtcbiAgfVxuICBjb25zdCBzb3J0ZWRPYmplY3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLnNvcnQoKS5yZWR1Y2UoXG4gICAgKHNvcnRlZE9iamVjdDIsIGtleSkgPT4ge1xuICAgICAgc29ydGVkT2JqZWN0MltrZXldID0gb2JqZWN0W2tleV07XG4gICAgICByZXR1cm4gc29ydGVkT2JqZWN0MjtcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3J0ZWRPYmplY3QsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvbGliL2JhdGNoLnRzXG52YXIgREVGQVVMVF9TSVpFID0gNTA7XG52YXIgQmF0Y2hDYWxsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICB9XG59O1xudmFyIEJhdGNoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZSA/PyBERUZBVUxUX1NJWkU7XG4gICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gIH1cbiAgY2xlYXJEZWxheVRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQgIT09IHZvaWQgMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc2NoZWR1bGUoKSB7XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSB0aGlzLnNpemUpIHtcbiAgICAgIHZvaWQgdGhpcy5mbHVzaCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY2xlYXJEZWxheVRpbWVvdXQoKTtcbiAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHZvaWQgdGhpcy5mbHVzaCgpLCB0aGlzLmRlbGF5KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmx1c2goKSB7XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbGxzID0gdGhpcy5xdWV1ZS5zcGxpY2UoMCk7XG4gICAgY29uc3QgaW5wdXRzID0gY2FsbHMubWFwKChjYWxsKSA9PiBjYWxsLmlucHV0KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuY2FsbGJhY2soaW5wdXRzKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHM/LltpbmRleF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgIGNhbGwucmVqZWN0KG5ldyBFcnJvcihcIkNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5LlwiKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbHMubGVuZ3RoICE9PSByZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGwucmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQ2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBudW1iZXIgb2YgcHJvdmlkZWQgaXRlbXMuIEV4cGVjdGVkICR7Y2FsbHMubGVuZ3RofSwgYnV0IGdvdCAke3Jlc3VsdHMubGVuZ3RofS5gXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGNhbGwucmVqZWN0KHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgdGhpcy5lcnJvciA9IHRydWU7XG4gICAgICBjYWxscy5mb3JFYWNoKChjYWxsKSA9PiB7XG4gICAgICAgIGNhbGwucmVqZWN0KGVycm9yMyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0KGlucHV0KSB7XG4gICAgY29uc3QgZXhpc3RpbmdDYWxsID0gdGhpcy5xdWV1ZS5maW5kKFxuICAgICAgKGNhbGwyKSA9PiBzdHJpbmdpZnkoY2FsbDIuaW5wdXQpID09PSBzdHJpbmdpZnkoaW5wdXQpXG4gICAgKTtcbiAgICBpZiAoZXhpc3RpbmdDYWxsKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdDYWxsLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGNhbGwgPSBuZXcgQmF0Y2hDYWxsKGlucHV0KTtcbiAgICB0aGlzLnF1ZXVlLnB1c2goY2FsbCk7XG4gICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgIHJldHVybiBjYWxsLnByb21pc2U7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyRGVsYXlUaW1lb3V0KCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVCYXRjaFN0b3JlKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGNvbnN0IGJhdGNoID0gbmV3IEJhdGNoKGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBldmVudFNvdXJjZTIgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoYXJncykge1xuICAgIHJldHVybiBzdHJpbmdpZnkoYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHN0YXRlKSB7XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzdGF0ZSk7XG4gICAgZXZlbnRTb3VyY2UyLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldChpbnB1dCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoaW5wdXQpO1xuICAgIGlmIChjYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBiYXRjaC5nZXQoaW5wdXQpO1xuICAgICAgc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHsgaXNMb2FkaW5nOiBmYWxzZSwgZGF0YTogcmVzdWx0IH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yM1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXRlKGlucHV0KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShpbnB1dCk7XG4gICAgcmV0dXJuIGNhY2hlLmdldChjYWNoZUtleSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5ldmVudFNvdXJjZTIub2JzZXJ2YWJsZSxcbiAgICBnZXQsXG4gICAgZ2V0U3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9jcmVhdGUtc3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZSkge1xuICBsZXQgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNhbGxiYWNrKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT09IG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgZm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVyKHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICBjYWxsYmFjayhzdGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgc3Vic2NyaWJlXG4gIH07XG59XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgdXBkYXRlZEF0ID0gZGF0YS51cGRhdGVkQXQgPyBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgY29tbWVudHMgPSBkYXRhLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdCxcbiAgICB1cGRhdGVkQXQsXG4gICAgY29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24oZGF0YSkge1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdClcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShkYXRhKSB7XG4gIGNvbnN0IG5vdGlmaWVkQXQgPSBuZXcgRGF0ZShkYXRhLm5vdGlmaWVkQXQpO1xuICBjb25zdCByZWFkQXQgPSBkYXRhLnJlYWRBdCA/IG5ldyBEYXRlKGRhdGEucmVhZEF0KSA6IG51bGw7XG4gIGlmIChcImFjdGl2aXRpZXNcIiBpbiBkYXRhKSB7XG4gICAgY29uc3QgYWN0aXZpdGllcyA9IGRhdGEuYWN0aXZpdGllcy5tYXAoKGFjdGl2aXR5KSA9PiAoe1xuICAgICAgLi4uYWN0aXZpdHksXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGFjdGl2aXR5LmNyZWF0ZWRBdClcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBub3RpZmllZEF0LFxuICAgICAgcmVhZEF0LFxuICAgICAgYWN0aXZpdGllc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIG5vdGlmaWVkQXQsXG4gICAgcmVhZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oZGF0YSkge1xuICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBkZWxldGVkQXRcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi91cmwudHNcbmZ1bmN0aW9uIHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXJsam9pbihiYXNlVXJsLCBwYXRoLCBwYXJhbXMpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKTtcbiAgaWYgKHBhcmFtcyAhPT0gdm9pZCAwKSB7XG4gICAgdXJsLnNlYXJjaCA9IChwYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBwYXJhbXMgOiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuLy8gc3JjL25vdGlmaWNhdGlvbnMudHNcbnZhciBNQVJLX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9CQVRDSF9ERUxBWSA9IDUwO1xuZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uc0FwaSh7XG4gIGJhc2VVcmwsXG4gIGF1dGhNYW5hZ2VyLFxuICBjdXJyZW50VXNlcklkU3RvcmUsXG4gIGZldGNoZXJcbn0pIHtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hKc29uKGVuZHBvaW50LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiXG4gICAgfSk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiICYmIGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8pIHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQudWlkO1xuICAgICAgY3VycmVudFVzZXJJZFN0b3JlLnNldCgoKSA9PiB1c2VySWQpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB1cmxqb2luKGJhc2VVcmwsIGAvdjIvYyR7ZW5kcG9pbnR9YCwgcGFyYW1zKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoZXIodXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpfWBcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGZldGNoSnNvbihcIi9pbmJveC1ub3RpZmljYXRpb25zXCIsIHZvaWQgMCwge1xuICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0LFxuICAgICAgc2luY2U6IG9wdGlvbnM/LnNpbmNlPy50b0lTT1N0cmluZygpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IGpzb24udGhyZWFkcy5tYXAoKHRocmVhZCkgPT4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpKSxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEobm90aWZpY2F0aW9uKVxuICAgICAgKSxcbiAgICAgIGRlbGV0ZWRUaHJlYWRzOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChcbiAgICAgICAgKGluZm8pID0+IGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8oaW5mbylcbiAgICAgICksXG4gICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAoaW5mbykgPT4gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGluZm8pXG4gICAgICApLFxuICAgICAgbWV0YToge1xuICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvY291bnRcIik7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5ib3hOb3RpZmljYXRpb25JZHM6IFwiYWxsXCIgfSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5ib3hOb3RpZmljYXRpb25JZHMgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZCA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICBhd2FpdCBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICB9LFxuICAgIHsgZGVsYXk6IE1BUktfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICAgIGF3YWl0IGZldGNoSnNvbihcIi9pbmJveC1ub3RpZmljYXRpb25zXCIsIHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL2luYm94LW5vdGlmaWNhdGlvbnMvJHtlbmNvZGVVUklDb21wb25lbnQoaW5ib3hOb3RpZmljYXRpb25JZCl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb25cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wb3NpdGlvbi50c1xudmFyIE1JTl9DT0RFID0gMzI7XG52YXIgTUFYX0NPREUgPSAxMjY7XG52YXIgTlVNX0RJR0lUUyA9IE1BWF9DT0RFIC0gTUlOX0NPREUgKyAxO1xudmFyIFpFUk8gPSBudGhEaWdpdCgwKTtcbnZhciBPTkUgPSBudGhEaWdpdCgxKTtcbnZhciBaRVJPX05JTkUgPSBaRVJPICsgbnRoRGlnaXQoLTEpO1xuZnVuY3Rpb24gbnRoRGlnaXQobikge1xuICBjb25zdCBjb2RlID0gTUlOX0NPREUgKyAobiA8IDAgPyBOVU1fRElHSVRTICsgbiA6IG4pO1xuICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuIHZhbHVlOiAke259YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBtYWtlUG9zaXRpb24oeCwgeSkge1xuICBpZiAoeCAhPT0gdm9pZCAwICYmIHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZXR3ZWVuKHgsIHkpO1xuICB9IGVsc2UgaWYgKHggIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhZnRlcih4KTtcbiAgfSBlbHNlIGlmICh5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmVmb3JlKHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPTkU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJlZm9yZShwb3MpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcG9zLmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDw9IE1JTl9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgaWYgKGNvZGUgPT09IE1JTl9DT0RFICsgMSkge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFpFUk9fTklORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9ORTtcbn1cbmZ1bmN0aW9uIGFmdGVyKHBvcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwb3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IE1BWF9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAxKTtcbiAgfVxuICByZXR1cm4gcG9zICsgT05FO1xufVxuZnVuY3Rpb24gYmV0d2VlbihsbywgaGkpIHtcbiAgaWYgKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4obG8sIGhpKTtcbiAgfSBlbHNlIGlmIChsbyA+IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGhpLCBsbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmFsdWUgYmV0d2VlbiB0d28gZXF1YWwgcG9zaXRpb25zXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfYmV0d2VlbihsbywgaGkpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbG9MZW4gPSBsby5sZW5ndGg7XG4gIGNvbnN0IGhpTGVuID0gaGkubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvQ29kZSA9IGluZGV4IDwgbG9MZW4gPyBsby5jaGFyQ29kZUF0KGluZGV4KSA6IE1JTl9DT0RFO1xuICAgIGNvbnN0IGhpQ29kZSA9IGluZGV4IDwgaGlMZW4gPyBoaS5jaGFyQ29kZUF0KGluZGV4KSA6IE1BWF9DT0RFO1xuICAgIGlmIChsb0NvZGUgPT09IGhpQ29kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaGlDb2RlIC0gbG9Db2RlID09PSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gaW5kZXggKyAxO1xuICAgICAgbGV0IHByZWZpeCA9IGxvLnN1YnN0cmluZygwLCBzaXplKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBwcmVmaXggKz0gWkVSTy5yZXBlYXQoc2l6ZSAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gbG8uc3Vic3RyaW5nKHNpemUpO1xuICAgICAgY29uc3QgbmluZXMgPSBcIlwiO1xuICAgICAgcmV0dXJuIHByZWZpeCArIF9iZXR3ZWVuKHN1ZmZpeCwgbmluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFrZU4obG8sIGluZGV4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlDb2RlICsgbG9Db2RlID4+IDEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFrZU4ocG9zLCBuKSB7XG4gIHJldHVybiBuIDwgcG9zLmxlbmd0aCA/IHBvcy5zdWJzdHJpbmcoMCwgbikgOiBwb3MgKyBaRVJPLnJlcGVhdChuIC0gcG9zLmxlbmd0aCk7XG59XG52YXIgTUlOX05PTl9aRVJPX0NPREUgPSBNSU5fQ09ERSArIDE7XG5mdW5jdGlvbiBpc1BvcyhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0SWR4ID0gc3RyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGxhc3QgPSBzdHIuY2hhckNvZGVBdChsYXN0SWR4KTtcbiAgaWYgKGxhc3QgPCBNSU5fTk9OX1pFUk9fQ09ERSB8fCBsYXN0ID4gTUFYX0NPREUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3Moc3RyKSB7XG4gIGNvbnN0IGNvZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGVzLnB1c2goY29kZSA8IE1JTl9DT0RFID8gTUlOX0NPREUgOiBjb2RlID4gTUFYX0NPREUgPyBNQVhfQ09ERSA6IGNvZGUpO1xuICB9XG4gIHdoaWxlIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID09PSBNSU5fQ09ERSkge1xuICAgIGNvZGVzLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBjb2Rlcy5sZW5ndGggPiAwID8gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2RlcykgOiAoXG4gICAgLy8gRWRnZSBjYXNlOiB0aGUgc3RyIHdhcyBhIDAtb25seSBzdHJpbmcsIHdoaWNoIGlzIGludmFsaWQuIERlZmF1bHQgYmFjayB0byAuMVxuICAgIE9ORVxuICApO1xufVxuZnVuY3Rpb24gYXNQb3Moc3RyKSB7XG4gIHJldHVybiBpc1BvcyhzdHIpID8gc3RyIDogY29udmVydFRvUG9zKHN0cik7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9PcC50c1xudmFyIE9wQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE9wQ29kZTIpID0+IHtcbiAgT3BDb2RlMltPcENvZGUyW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlNFVF9QQVJFTlRfS0VZXCJdID0gMV0gPSBcIlNFVF9QQVJFTlRfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9MSVNUXCJdID0gMl0gPSBcIkNSRUFURV9MSVNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlVQREFURV9PQkpFQ1RcIl0gPSAzXSA9IFwiVVBEQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfT0JKRUNUXCJdID0gNF0gPSBcIkNSRUFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX0NSRFRcIl0gPSA1XSA9IFwiREVMRVRFX0NSRFRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX09CSkVDVF9LRVlcIl0gPSA2XSA9IFwiREVMRVRFX09CSkVDVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX01BUFwiXSA9IDddID0gXCJDUkVBVEVfTUFQXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9SRUdJU1RFUlwiXSA9IDhdID0gXCJDUkVBVEVfUkVHSVNURVJcIjtcbiAgcmV0dXJuIE9wQ29kZTI7XG59KShPcENvZGUgfHwge30pO1xuZnVuY3Rpb24gYWNrT3Aob3BJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgaWQ6IFwiQUNLXCIsXG4gICAgLy8gKEgpQUNLXG4gICAgb3BJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNBY2tPcChvcCkge1xuICByZXR1cm4gb3AudHlwZSA9PT0gNSAvKiBERUxFVEVfQ1JEVCAqLyAmJiBvcC5pZCA9PT0gXCJBQ0tcIjtcbn1cblxuLy8gc3JjL2NyZHRzL0Fic3RyYWN0Q3JkdC50c1xuZnVuY3Rpb24gY3JkdEFzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gSGFzUGFyZW50KG5vZGUsIGtleSwgcG9zID0gYXNQb3Moa2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiSGFzUGFyZW50XCIsIG5vZGUsIGtleSwgcG9zIH0pO1xufVxudmFyIE5vUGFyZW50ID0gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiTm9QYXJlbnRcIiB9KTtcbmZ1bmN0aW9uIE9ycGhhbmVkKG9sZEtleSwgb2xkUG9zID0gYXNQb3Mob2xkS2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiT3JwaGFuZWRcIiwgb2xkS2V5LCBvbGRQb3MgfSk7XG59XG52YXIgQWJzdHJhY3RDcmR0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0UGFyZW50S2V5T3JUaHJvdygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50UG9zKCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zO1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkUG9zO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wb29sKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbDtcbiAgfVxuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbCA/IHRoaXMuX19wb29sLnJvb21JZCA6IG51bGw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX2lkKCkge1xuICAgIHJldHVybiB0aGlzLl9faWQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3BhcmVudEtleSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBfaXNMb2NhbCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGUuX2RldGFjaENoaWxkKGNyZHRBc0xpdmVOb2RlKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2V0UGFyZW50TGluayhuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Lm5vZGUgIT09IG5ld1BhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHBhcmVudDogbm9kZSBhbHJlYWR5IGhhcyBhIHBhcmVudFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBpZiAodGhpcy5fX2lkIHx8IHRoaXMuX19wb29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXR0YWNoIG5vZGU6IGFscmVhZHkgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIHBvb2wuYWRkTm9kZShpZCwgY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgIHRoaXMuX19pZCA9IGlkO1xuICAgIHRoaXMuX19wb29sID0gcG9vbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgaWYgKHRoaXMuX19wb29sICYmIHRoaXMuX19pZCkge1xuICAgICAgdGhpcy5fX3Bvb2wuZGVsZXRlTm9kZSh0aGlzLl9faWQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBPcnBoYW5lZCh0aGlzLnBhcmVudC5rZXksIHRoaXMucGFyZW50LnBvcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9fcG9vbCA9IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIENsZWFyIHRoZSBJbW11dGFibGUgY2FjaGUsIHNvIHRoYXQgdGhlIG5leHQgY2FsbCB0byBgLnRvSW1tdXRhYmxlKClgIHdpbGxcbiAgICogcmVjb21wdXRlIHRoZSBlcXVpdmFsZW50IEltbXV0YWJsZSB2YWx1ZSBhZ2Fpbi4gIENhbGwgdGhpcyBhZnRlciBldmVyeVxuICAgKiBtdXRhdGlvbiB0byB0aGUgTGl2ZSBub2RlLlxuICAgKi9cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlICE9PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBSZXR1cm4gYW4gc25hcHNob3Qgb2YgdGhpcyBMaXZlIHRyZWUgZm9yIHVzZSBpbiBEZXZUb29scy5cbiAgICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFRyZWVOb2RlID09PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgIT09IGtleSkge1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgPSBrZXk7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHRoaXMuX3RvVHJlZU5vZGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFRyZWVOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaW1tdXRhYmxlIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuICB0b0ltbXV0YWJsZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlZEltbXV0YWJsZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbW11dGFibGU7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJpYWxpemVkQ3JkdC50c1xudmFyIENyZHRUeXBlID0gLyogQF9fUFVSRV9fICovICgoQ3JkdFR5cGUyKSA9PiB7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJPQkpFQ1RcIl0gPSAwXSA9IFwiT0JKRUNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJMSVNUXCJdID0gMV0gPSBcIkxJU1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk1BUFwiXSA9IDJdID0gXCJNQVBcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIlJFR0lTVEVSXCJdID0gM10gPSBcIlJFR0lTVEVSXCI7XG4gIHJldHVybiBDcmR0VHlwZTI7XG59KShDcmR0VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1Jvb3RDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8gJiYgIWlzQ2hpbGRDcmR0KGNyZHQpO1xufVxuZnVuY3Rpb24gaXNDaGlsZENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC5wYXJlbnRJZCAhPT0gdm9pZCAwICYmIGNyZHQucGFyZW50S2V5ICE9PSB2b2lkIDA7XG59XG5cbi8vIHNyYy9saWIvbmFub2lkLnRzXG5mdW5jdGlvbiBuYW5vaWQobGVuZ3RoID0gNykge1xuICBjb25zdCBhbHBoYWJldCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODksLi87W11+IUAjJCUmKigpXys9LVwiO1xuICBjb25zdCBsZW4gPSBhbHBoYWJldC5sZW5ndGg7XG4gIHJldHVybiBBcnJheS5mcm9tKFxuICAgIHsgbGVuZ3RoIH0sXG4gICAgKCkgPT4gYWxwaGFiZXQuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbikpXG4gICkuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL2NyZHRzL0xpdmVSZWdpc3Rlci50c1xudmFyIExpdmVSZWdpc3RlciA9IGNsYXNzIF9MaXZlUmVnaXN0ZXIgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgX3BhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCByZWdpc3RlciA9IG5ldyBfTGl2ZVJlZ2lzdGVyKGl0ZW0uZGF0YSk7XG4gICAgcmVnaXN0ZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBzZXJpYWxpemUgcmVnaXN0ZXIgaWYgcGFyZW50SWQgb3IgcGFyZW50S2V5IGlzIHVuZGVmaW5lZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgcGFyZW50SWQsXG4gICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZVJlZ2lzdGVyIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMyAvKiBSRUdJU1RFUiAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKF9vcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKF9jcmR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkpzb25cIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2RhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5kYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVMaXN0LnRzXG5mdW5jdGlvbiBjb21wYXJlTm9kZVBvc2l0aW9uKGl0ZW1BLCBpdGVtQikge1xuICBjb25zdCBwb3NBID0gaXRlbUEuX3BhcmVudFBvcztcbiAgY29uc3QgcG9zQiA9IGl0ZW1CLl9wYXJlbnRQb3M7XG4gIHJldHVybiBwb3NBID09PSBwb3NCID8gMCA6IHBvc0EgPCBwb3NCID8gLTEgOiAxO1xufVxudmFyIExpdmVMaXN0ID0gY2xhc3MgX0xpdmVMaXN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHBvc2l0aW9uID0gdm9pZCAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBtYWtlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdQb3NpdGlvbik7XG4gICAgICB0aGlzLl9pdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBsaXN0ID0gbmV3IF9MaXZlTGlzdChbXSk7XG4gICAgbGlzdC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGlzdCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbGlzdC5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdGluZyBvcHMgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgaWYgdGhleSBoYXZlIGFuICdvcElkJ1xuICAgKiBzbyB3ZSBtdXRhdGUgX3VuYWNrbm93bGVkZ2VkU2V0cyB0byBhdm9pZCBwb3RlbnRpYWwgZmxpY2tlcmluZ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL3B1bGwvMTE3N1xuICAgKlxuICAgKiBUaGlzIGlzIHF1aXRlIHVuaW50dWl0aXZlIGFuZCBzaG91bGQgZGlzYXBwZWFyIGFzIHNvb24gYXNcbiAgICogd2UgaW50cm9kdWNlIGFuIGV4cGxpY2l0IExpdmVMaXN0LlNldCBvcGVyYXRpb25cbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleTIgPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgICBjb25zdCBjaGlsZE9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwYXJlbnRLZXkyLCBwb29sKSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY29uc3QgY2hpbGRPcElkID0gY2hpbGRPcHNbMF0ub3BJZDtcbiAgICAgIGlmIChjaGlsZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KHBhcmVudEtleTIsIGNoaWxkT3BJZCk7XG4gICAgICB9XG4gICAgICBvcHMucHVzaCguLi5jaGlsZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gaW50byB0aGUgc29ydGVkIGxpc3QsIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgKi9cbiAgX2luc2VydEFuZFNvcnQoaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc29ydEl0ZW1zKCkge1xuICAgIHRoaXMuX2l0ZW1zLnNvcnQoY29tcGFyZU5vZGVQb3NpdGlvbik7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5kZXhPZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkgPT09IHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRSZW1vdGUob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBkZWxldGVkSWQgPSBvcC5kZWxldGVkSWQ7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXTtcbiAgICAgIGlmIChpdGVtV2l0aFNhbWVQb3NpdGlvbi5faWQgPT09IGRlbGV0ZWRJZCkge1xuICAgICAgICBpdGVtV2l0aFNhbWVQb3NpdGlvbi5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChpdGVtV2l0aFNhbWVQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB1cGRhdGVzLnB1c2goaW5zZXJ0RGVsdGEodGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSksIGNoaWxkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbXSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgdXBkYXRlcylcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0QWNrKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgIH1cbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wSWQgPSB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZ2V0KG9wLnBhcmVudEtleSk7XG4gICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSBvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5sZW5ndGggPT09IDAgPyB7IG1vZGlmaWVkOiBmYWxzZSB9IDogeyBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksIHJldmVyc2U6IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZGVsZXRlKG9wLnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IG9wLnBhcmVudEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoXG4gICAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgZGVsdGEucHVzaChtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gdGhpcy5fcG9vbC5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCByZWNyZWF0ZWRJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKG9ycGhhbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbikgOiBzZXREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbiksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KFxuICAgICAgICAgIG9wLFxuICAgICAgICAgIG9wLnBhcmVudEtleVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pIDogc2V0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIGRlbHRhIG9mIHRoZSBkZWxldGlvbiBvciBudWxsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oZGVsZXRlZElkKSB7XG4gICAgaWYgKGRlbGV0ZWRJZCA9PT0gdm9pZCAwIHx8IHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtID0gdGhpcy5fcG9vbC5nZXROb2RlKGRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWRJdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZXRhY2hDaGlsZChkZWxldGVkSXRlbSk7XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lm1vZGlmaWVkLnVwZGF0ZXNbMF07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlSZW1vdGVJbnNlcnQob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oZXhpc3RpbmdJdGVtSW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICByZXZlcnNlOiBbXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlJbnNlcnRBY2sob3ApIHtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgaXRlbUluZGV4QXRQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0pIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbkluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSBvbGRQb3NpdGlvbkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEob2xkUG9zaXRpb25JbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSBubih0aGlzLl9wb29sKS5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgb3JwaGFuKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBsZXQgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0/Ll9wYXJlbnRQb3M7XG4gICAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zO1xuICAgICAgbmV3S2V5ID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XSA9IGNoaWxkO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvcC5pZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gW3NldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXksIGNoaWxkKV07XG4gICAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvcC5pbnRlbnQgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0UmVtb3RlKG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlSZW1vdGVJbnNlcnQob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhubih0aGlzLl9pZCksIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXhUb0RlbGV0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUpXSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCkge1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBjaGlsZC5fcGFyZW50S2V5O1xuICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQ6IG5uKGNoaWxkLl9pZCksXG4gICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c0tleVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRDaGlsZEtleShuZXdLZXksIGNoaWxkLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZUxpc3QgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzLlxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9uZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHJldHVybiB0aGlzLmluc2VydChlbGVtZW50LCB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgb25lIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB5b3Ugd2FudCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqL1xuICBpbnNlcnQoZWxlbWVudCwgaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnNlcnQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0gPyB0aGlzLl9pdGVtc1tpbmRleCAtIDFdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgYWZ0ZXIyID0gdGhpcy5faXRlbXNbaW5kZXhdID8gdGhpcy5faXRlbXNbaW5kZXhdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGVsZW1lbnQpO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShpbmRleCwgdmFsdWUpXSldXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSBvbmUgZWxlbWVudCBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHRhcmdldEluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgZWxlbWVudCBzaG91bGQgYmUgYWZ0ZXIgbW92aW5nLlxuICAgKi9cbiAgbW92ZShpbmRleCwgdGFyZ2V0SW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInRhcmdldEluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGxldCBiZWZvcmVQb3NpdGlvbiA9IG51bGw7XG4gICAgbGV0IGFmdGVyUG9zaXRpb24gPSBudWxsO1xuICAgIGlmIChpbmRleCA8IHRhcmdldEluZGV4KSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCArIDFdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSAwID8gdm9pZCAwIDogdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXggLSAxXS5fcGFyZW50UG9zO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmVQb3NpdGlvbiwgYWZ0ZXJQb3NpdGlvbik7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEoaW5kZXgsIHRhcmdldEluZGV4LCBpdGVtKV0pXVxuICAgICAgXSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGVsZXRlIGxpc3QgaXRlbSBhdCBpbmRleCBcIiR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IGNoaWxkUmVjb3JkSWQgPSBpdGVtLl9pZDtcbiAgICAgIGlmIChjaGlsZFJlY29yZElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIG5uKHRoaXMuX2lkKSxcbiAgICAgICAgICBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleCldKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IGNoaWxkUmVjb3JkSWQsXG4gICAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGl0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKSxcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICAgIGNvbnN0IHVwZGF0ZURlbHRhID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICAgIGNvbnN0IGNoaWxkSWQgPSBpdGVtLl9pZDtcbiAgICAgICAgaWYgKGNoaWxkSWQpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKFxuICAgICAgICAgICAgLi4uaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1cGRhdGVEZWx0YS5wdXNoKGRlbGV0ZURlbHRhKDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KG5uKHRoaXMuX2lkKSwgbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVEZWx0YSkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQoaW5kZXgsIGl0ZW0pIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgY29uc3QgcG9zaXRpb24gPSBleGlzdGluZ0l0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBjb25zdCBleGlzdGluZ0lkID0gZXhpc3RpbmdJdGVtLl9pZDtcbiAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XSA9IHZhbHVlO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW3NldERlbHRhKGluZGV4LCB2YWx1ZSldKSk7XG4gICAgICBjb25zdCBvcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgZXhpc3RpbmdJZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocG9zaXRpb24sIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHZvaWQgMCksXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgb2YgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnkpID0+IGxpdmVOb2RlVG9Mc29uKGVudHJ5KVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhbGwgZWxlbWVudHMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LCB0YWtpbmcgdHdvIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCkuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBldmVyeSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBvZiB0aGUgTGl2ZUxpc3QuIFJldHVybiBhIHZhbHVlIHRoYXQgY29lcmNlcyB0byB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIG9yIHRvIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0LlxuICAgKi9cbiAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maWx0ZXIocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUuXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uIE90aGVyd2lzZSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZmluZChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHBhc3NlcyB0aGUgdGVzdC4gT3RoZXJ3aXNlLCAtMS5cbiAgICovXG4gIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvbiB0aGUgZWxlbWVudCB0byBnZXQuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih0aGlzLl9pdGVtc1tpbmRleF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0OyAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBpbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LiBUaGUgTGl2ZUxzaXQgaXMgc2VhcmNoZWQgYmFja3dhcmRzLCBzdGFydGluZyBhdCBmcm9tSW5kZXguXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgYmFja3dhcmRzLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZXZlcnkgZWxlbWVudC5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBtYXAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubWFwKFxuICAgICAgKGVudHJ5LCBpKSA9PiBjYWxsYmFjayhcbiAgICAgICAgbGl2ZU5vZGVUb0xzb24oZW50cnkpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgICAgIGlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCBwYXNzZXMgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBzb21lKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5zb21lKHByZWRpY2F0ZSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdEl0ZXJhdG9yKHRoaXMuX2l0ZW1zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KSB7XG4gICAgY29uc3QgbmV3SXRlbSA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBuZXdJdGVtLl9hdHRhY2gob3AuaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBuZXdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChuZXdJdGVtKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIHJldHVybiB7IG5ld0l0ZW0sIG5ld0luZGV4IH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2hpZnRJdGVtUG9zaXRpb24oaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMuX2l0ZW1zW2luZGV4ICsgMV0/Ll9wYXJlbnRQb3MgOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XS5fc2V0UGFyZW50TGluayh0aGlzLCBzaGlmdGVkUG9zaXRpb24pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpdGVtLnRvVHJlZU5vZGUoaW5kZXgudG9TdHJpbmcoKSlcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2l0ZW1zLm1hcCgobm9kZSkgPT4gbm9kZS50b0ltbXV0YWJsZSgpKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVMaXN0KHRoaXMuX2l0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5jbG9uZSgpKSk7XG4gIH1cbn07XG52YXIgTGl2ZUxpc3RJdGVyYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICB0aGlzLl9pbm5lckl0ZXJhdG9yID0gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5leHQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1ha2VVcGRhdGUobGl2ZUxpc3QsIGRlbHRhVXBkYXRlcykge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGxpdmVMaXN0LFxuICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICB1cGRhdGVzOiBkZWx0YVVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlRGVsdGEoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImRlbGV0ZVwiXG4gIH07XG59XG5mdW5jdGlvbiBpbnNlcnREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24ob3BzLCBkZWxldGVkSWQpIHtcbiAgcmV0dXJuIG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlyc3RPcCA9IG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlyc3RPcCxcbiAgICAgICAgaW50ZW50OiBcInNldFwiLFxuICAgICAgICBkZWxldGVkSWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL2ZyZWV6ZS50c1xudmFyIGZyZWV6ZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IChcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKHgpID0+IHhcbikgOiBPYmplY3QuZnJlZXplO1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU1hcC50c1xudmFyIExpdmVNYXAgPSBjbGFzcyBfTGl2ZU1hcCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZW50cmllczIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbWFwcGVkRW50cmllcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAobWFwcGVkRW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgX2l0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IF9MaXZlTWFwKCk7XG4gICAgbWFwLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKG1hcCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbWFwLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBtYXAuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5LCBvcElkIH0gPSBvcDtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXk7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICBjb25zdCBsYXN0VXBkYXRlT3BJZCA9IHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZ2V0KGtleSk7XG4gICAgICBpZiAobGFzdFVwZGF0ZU9wSWQgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9IGVsc2UgaWYgKGxhc3RVcGRhdGVPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIHVwZGF0ZXM6IHsgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LnNldChrZXksIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb2xkVmFsdWUgPyBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkgOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlLlxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAoaXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiBpdGVtLl9pZCkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXNJZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBMaXZlT2JqZWN0ID0gY2xhc3MgX0xpdmVPYmplY3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcykge1xuICAgIGNvbnN0IHBhcmVudFRvQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCByb290ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpc1Jvb3RDcmR0KGNyZHQpKSB7XG4gICAgICAgIHJvb3QgPSBbaWQsIGNyZHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBbaWQsIGNyZHRdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGNyZHQucGFyZW50SWQpO1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2godHVwbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRvQ2hpbGRyZW4uc2V0KGNyZHQucGFyZW50SWQsIFt0dXBsZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IGNhbid0IGJlIG51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0Ll9idWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fbWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIGlmIChvcC50eXBlID09PSAzIC8qIFVQREFURV9PQkpFQ1QgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVVwZGF0ZShvcCwgaXNMb2NhbCk7XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmICghaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIHRoaXMucGFyZW50Lm5vZGUuX2lkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgcGFyZW50SWQ6IHRoaXMucGFyZW50Lm5vZGUuX2lkLFxuICAgICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKSB7XG4gICAgbGV0IGlzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCByZXZlcnNlID0gW107XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZSA9IHtcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHMoaWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZS5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZCwga2V5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3AuZGF0YVtrZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcC5vcElkKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGUuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBpc01vZGlmaWVkID8ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH0gOiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLl9tYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9tYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoW10pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IEpTT04uc3RyaW5naWZ5KGNyZHQuZGF0YSkgIT09IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvZGVidWcudHNcbmZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG1zZywgdHJhY2VSb290KSB7XG4gIGNvbnN0IGVycm9yTGlrZSA9IHsgbmFtZTogbXNnIH07XG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3JMaWtlLCB0cmFjZVJvb3QpO1xuICByZXR1cm4gZXJyb3JMaWtlLnN0YWNrO1xufVxuXG4vLyBzcmMvbGliL0pzb24udHNcbmZ1bmN0aW9uIGlzSnNvblNjYWxhcihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSnNvbkFycmF5KGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoZGF0YSkge1xuICByZXR1cm4gIWlzSnNvblNjYWxhcihkYXRhKSAmJiAhaXNKc29uQXJyYXkoZGF0YSk7XG59XG5cbi8vIHNyYy9saWIvb2JqZWN0VG9RdWVyeS50c1xudmFyIGlkZW50aWZpZXJSZWdleCA9IC9eW2EtekEtWl9dW2EtekEtWjAtOV9dKiQvO1xuZnVuY3Rpb24gb2JqZWN0VG9RdWVyeShvYmopIHtcbiAgbGV0IGZpbHRlckxpc3QgPSBbXTtcbiAgY29uc3QgZW50cmllczIgPSBPYmplY3QuZW50cmllcyhvYmopO1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzID0gW107XG4gIGNvbnN0IGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IgPSBbXTtcbiAgY29uc3QgaW5kZXhlZEtleXMgPSBbXTtcbiAgZW50cmllczIuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKCFpZGVudGlmaWVyUmVnZXgudGVzdChrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgbXVzdCBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgX1wiKTtcbiAgICB9XG4gICAgaWYgKGlzU2ltcGxlVmFsdWUodmFsdWUpKSB7XG4gICAgICBrZXlWYWx1ZVBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9IGVsc2UgaWYgKGlzVmFsdWVXaXRoT3BlcmF0b3IodmFsdWUpKSB7XG4gICAgICBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhKFwic3RhcnRzV2l0aFwiIGluIHZhbHVlKSkge1xuICAgICAgaW5kZXhlZEtleXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH1cbiAgfSk7XG4gIGZpbHRlckxpc3QgPSBbXG4gICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzKGtleVZhbHVlUGFpcnMpLFxuICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcihrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKVxuICBdO1xuICBpbmRleGVkS2V5cy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBuZXN0ZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICAgIGNvbnN0IG5LZXlWYWx1ZVBhaXJzID0gW107XG4gICAgY29uc3QgbktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IgPSBbXTtcbiAgICBuZXN0ZWRFbnRyaWVzLmZvckVhY2goKFtuZXN0ZWRLZXksIG5lc3RlZFZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGlzU3RyaW5nRW1wdHkobmVzdGVkS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2ltcGxlVmFsdWUobmVzdGVkVmFsdWUpKSB7XG4gICAgICAgIG5LZXlWYWx1ZVBhaXJzLnB1c2goW2Zvcm1hdEZpbHRlcktleShrZXksIG5lc3RlZEtleSksIG5lc3RlZFZhbHVlXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsdWVXaXRoT3BlcmF0b3IobmVzdGVkVmFsdWUpKSB7XG4gICAgICAgIG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLnB1c2goW1xuICAgICAgICAgIGZvcm1hdEZpbHRlcktleShrZXksIG5lc3RlZEtleSksXG4gICAgICAgICAgbmVzdGVkVmFsdWVcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmlsdGVyTGlzdCA9IFtcbiAgICAgIC4uLmZpbHRlckxpc3QsXG4gICAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMobktleVZhbHVlUGFpcnMpLFxuICAgICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKVxuICAgIF07XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyTGlzdC5tYXAoXG4gICAgKHsga2V5LCBvcGVyYXRvciwgdmFsdWUgfSkgPT4gZm9ybWF0RmlsdGVyKGtleSwgb3BlcmF0b3IsIGZvcm1hdEZpbHRlclZhbHVlKHZhbHVlKSlcbiAgKS5qb2luKFwiIEFORCBcIik7XG59XG52YXIgZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzID0gKGtleVZhbHVlUGFpcnMpID0+IHtcbiAgY29uc3QgZmlsdGVycyA9IFtdO1xuICBrZXlWYWx1ZVBhaXJzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICBrZXksXG4gICAgICBvcGVyYXRvcjogXCI6XCIsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcnM7XG59O1xudmFyIGdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IChrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKSA9PiB7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoXCJzdGFydHNXaXRoXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgb3BlcmF0b3I6IFwiXlwiLFxuICAgICAgICB2YWx1ZTogdmFsdWUuc3RhcnRzV2l0aFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZpbHRlcnM7XG59O1xudmFyIGlzU2ltcGxlVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgaXNWYWx1ZVdpdGhPcGVyYXRvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIFwic3RhcnRzV2l0aFwiIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBmb3JtYXRGaWx0ZXIgPSAoa2V5LCBvcGVyYXRvciwgdmFsdWUpID0+IHtcbiAgcmV0dXJuIGAke2tleX0ke29wZXJhdG9yfSR7dmFsdWV9YDtcbn07XG52YXIgZm9ybWF0RmlsdGVyS2V5ID0gKGtleSwgbmVzdGVkS2V5KSA9PiB7XG4gIGlmIChuZXN0ZWRLZXkpIHtcbiAgICByZXR1cm4gYCR7a2V5fVske0pTT04uc3RyaW5naWZ5KG5lc3RlZEtleSl9XWA7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG52YXIgZm9ybWF0RmlsdGVyVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChpc1N0cmluZ0VtcHR5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufTtcbnZhciBpc1N0cmluZ0VtcHR5ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAhdmFsdWUgfHwgdmFsdWUudG9TdHJpbmcoKS50cmltKCkgPT09IFwiXCI7XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQ2xpZW50TXNnLnRzXG52YXIgQ2xpZW50TXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENsaWVudE1zZ0NvZGUyKSA9PiB7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiQlJPQURDQVNUX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNUX0VWRU5UXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfU1RPUkFHRVwiXSA9IDIwMF0gPSBcIkZFVENIX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfWURPQ1wiXSA9IDMwMF0gPSBcIkZFVENIX1lET0NcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMV0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIHJldHVybiBDbGllbnRNc2dDb2RlMjtcbn0pKENsaWVudE1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvcmVmcy9JbW11dGFibGVSZWYudHNcbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgcGF0Y2gpIHtcbiAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgbmV3VmFsdWUgPSB7IC4uLnRhcmdldCB9O1xuICBPYmplY3Qua2V5cyhwYXRjaCkuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgY29uc3QgdmFsID0gcGF0Y2hba2V5XTtcbiAgICBpZiAobmV3VmFsdWVba2V5XSAhPT0gdmFsKSB7XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIG5ld1ZhbHVlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZWQgPyBuZXdWYWx1ZSA6IHRhcmdldDtcbn1cbnZhciBJbW11dGFibGVSZWYgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2V2ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIH1cbiAgZ2V0IGRpZEludmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2Lm9ic2VydmFibGU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9ldi5ub3RpZnkoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlID8/ICh0aGlzLl9jYWNoZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9PdGhlcnNSZWYudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBPdGhlcnNSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3ByZXNlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGNvbm5lY3Rpb25JZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25zLmtleXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCB1c2VycyA9IGNvbXBhY3QoXG4gICAgICBBcnJheS5mcm9tKHRoaXMuX3ByZXNlbmNlcy5rZXlzKCkpLm1hcChcbiAgICAgICAgKGNvbm5lY3Rpb25JZCkgPT4gdGhpcy5nZXRVc2VyKE51bWJlcihjb25uZWN0aW9uSWQpKVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIHVzZXJzO1xuICB9XG4gIGNsZWFyT3RoZXJzKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNvbm4gPSB0aGlzLl9jb25uZWN0aW9ucy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHRoaXMuX3ByZXNlbmNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY29ubiAhPT0gdm9pZCAwICYmIHByZXNlbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYWtlVXNlcihjb25uLCBwcmVzZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZ2V0VXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBjb25zdCBjYWNoZWRVc2VyID0gdGhpcy5fdXNlcnMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLl9nZXRVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNvbXB1dGVkVXNlcikge1xuICAgICAgdGhpcy5fdXNlcnMuc2V0KGNvbm5lY3Rpb25JZCwgY29tcHV0ZWRVc2VyKTtcbiAgICAgIHJldHVybiBjb21wdXRlZFVzZXI7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl91c2Vycy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY29yZHMgYSBrbm93biBjb25uZWN0aW9uLiBUaGlzIHJlY29yZHMgdGhlIGNvbm5lY3Rpb24gSUQgYW5kIHRoZVxuICAgKiBhc3NvY2lhdGVkIG1ldGFkYXRhLlxuICAgKi9cbiAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIG1ldGFVc2VySWQsIG1ldGFVc2VySW5mbywgc2NvcGVzKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuc2V0KFxuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgZnJlZXplKHtcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgaW5mbzogbWV0YVVzZXJJbmZvLFxuICAgICAgICBzY29wZXNcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAodGhpcy5fcHJlc2VuY2VzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIGtub3duIGNvbm5lY3Rpb25JZC4gUmVtb3ZlcyBib3RoIHRoZSBjb25uZWN0aW9uJ3MgbWV0YWRhdGEgYW5kXG4gICAqIHRoZSBwcmVzZW5jZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlcyBhIG5ldyB1c2VyIGZyb20gYSBmdWxsIHByZXNlbmNlIHVwZGF0ZS4gSWYgdGhlIHVzZXIgYWxyZWFkeSBleGlzdHMsXG4gICAqIGl0cyBrbm93biBwcmVzZW5jZSBkYXRhIGlzIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgc2V0T3RoZXIoY29ubmVjdGlvbklkLCBwcmVzZW5jZSkge1xuICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUoY29tcGFjdE9iamVjdChwcmVzZW5jZSkpKTtcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbnMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBwcmVzZW5jZSBkYXRhIGZvciBhbiBleGlzdGluZyBcIm90aGVyXCIuIElmIHdlIGRvbid0IGtub3cgdGhlXG4gICAqIGluaXRpYWwgcHJlc2VuY2UgZGF0YSBmb3IgdGhpcyB1c2VyIHlldCwgZGlzY2FyZCB0aGlzIHBhdGNoIGFuZCBhd2FpdCB0aGVcbiAgICogZnVsbCAuc2V0T3RoZXIoKSBjYWxsIGZpcnN0LlxuICAgKi9cbiAgcGF0Y2hPdGhlcihjb25uZWN0aW9uSWQsIHBhdGNoKSB7XG4gICAgY29uc3Qgb2xkUHJlc2VuY2UgPSB0aGlzLl9wcmVzZW5jZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgIGlmIChvbGRQcmVzZW5jZSAhPT0gbmV3UHJlc2VuY2UpIHtcbiAgICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUobmV3UHJlc2VuY2UpKTtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9QYXRjaGFibGVSZWYudHNcbnZhciBQYXRjaGFibGVSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBmcmVlemUoY29tcGFjdE9iamVjdChkYXRhKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoZXMgdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgKi9cbiAgcGF0Y2gocGF0Y2gpIHtcbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBuZXdEYXRhID0gbWVyZ2Uob2xkRGF0YSwgcGF0Y2gpO1xuICAgIGlmIChvbGREYXRhICE9PSBuZXdEYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZnJlZXplKG5ld0RhdGEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9WYWx1ZVJlZi50c1xudmFyIFZhbHVlUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKGluaXRpYWxWYWx1ZSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKG5ld1ZhbHVlKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxufTtcbnZhciBEZXJpdmVkUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IGFyZ3MucG9wKCk7XG4gICAgY29uc3Qgb3RoZXJSZWZzID0gYXJncztcbiAgICB0aGlzLl9yZWZzID0gb3RoZXJSZWZzO1xuICAgIHRoaXMuX3JlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICByZWYuZGlkSW52YWxpZGF0ZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5pbnZhbGlkYXRlKCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybUZuO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0oXG4gICAgICAuLi50aGlzLl9yZWZzLm1hcCgocmVmKSA9PiByZWYuY3VycmVudClcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvcm9vbS50c1xudmFyIE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFID0gMTAyNCAqIDEwMjQgLSAxMDI0O1xuZnVuY3Rpb24gbWFrZUlkRmFjdG9yeShjb25uZWN0aW9uSWQpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgcmV0dXJuICgpID0+IGAke2Nvbm5lY3Rpb25JZH06JHtjb3VudCsrfWA7XG59XG5mdW5jdGlvbiB1c2VyVG9UcmVlTm9kZShrZXksIHVzZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlVzZXJcIixcbiAgICBpZDogYCR7dXNlci5jb25uZWN0aW9uSWR9YCxcbiAgICBrZXksXG4gICAgcGF5bG9hZDoge1xuICAgICAgY29ubmVjdGlvbklkOiB1c2VyLmNvbm5lY3Rpb25JZCxcbiAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgaW5mbzogdXNlci5pbmZvLFxuICAgICAgcHJlc2VuY2U6IHVzZXIucHJlc2VuY2UsXG4gICAgICBpc1JlYWRPbmx5OiAhdXNlci5jYW5Xcml0ZVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluc3RhbGxCYWNrZ3JvdW5kVGFiU3B5KCkge1xuICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgY29uc3QgaW5CYWNrZ3JvdW5kU2luY2UgPSB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgIGlmIChkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA9IGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPz8gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRvYz8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgZG9jPy5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB9O1xuICByZXR1cm4gW2luQmFja2dyb3VuZFNpbmNlLCB1bnN1Yl07XG59XG52YXIgQ29tbWVudHNBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50c0FwaShyb29tSWQsIGdldEF1dGhWYWx1ZSwgZmV0Y2hDbGllbnRBcGkpIHtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb21tZW50c0FwaShlbmRwb2ludCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gYXdhaXQgZ2V0QXV0aFZhbHVlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKHJvb21JZCwgZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmZXRjaEpzb24oZW5kcG9pbnQsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDb21tZW50c0FwaShlbmRwb2ludCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IENvbW1lbnRzQXBpRXJyb3IoXG4gICAgICAgICAgICBlcnJvckJvZHkubWVzc2FnZSxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yQm9keVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBDb21tZW50c0FwaUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkcyhvcHRpb25zKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zPy5xdWVyeSkge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KG9wdGlvbnMucXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHNBcGkoXG4gICAgICBcIi90aHJlYWRzXCIsXG4gICAgICB7XG4gICAgICAgIHNpbmNlOiBvcHRpb25zPy5zaW5jZT8udG9JU09TdHJpbmcoKSxcbiAgICAgICAgcXVlcnlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiBqc29uLmRhdGEubWFwKCh0aHJlYWQpID0+IGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKSksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIChub3RpZmljYXRpb24pID0+IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShub3RpZmljYXRpb24pXG4gICAgICAgICksXG4gICAgICAgIGRlbGV0ZWRUaHJlYWRzOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChcbiAgICAgICAgICAoaW5mbykgPT4gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhpbmZvKVxuICAgICAgICApLFxuICAgICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIChpbmZvKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oaW5mbylcbiAgICAgICAgKSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkczogW10sXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogW10sXG4gICAgICAgIGRlbGV0ZWRUaHJlYWRzOiBbXSxcbiAgICAgICAgZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uczogW10sXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICByZXF1ZXN0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkcy5cIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZCh7IHRocmVhZElkIH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHNBcGkoXG4gICAgICBgL3RocmVhZC13aXRoLW5vdGlmaWNhdGlvbi8ke3RocmVhZElkfWBcbiAgICApO1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZDogY29udmVydFRvVGhyZWFkRGF0YShqc29uLnRocmVhZCksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uOiBqc29uLmluYm94Tm90aWZpY2F0aW9uID8gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKGpzb24uaW5ib3hOb3RpZmljYXRpb24pIDogdm9pZCAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aHJlYWQgJHt0aHJlYWRJZH0uYCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRocmVhZCh7XG4gICAgbWV0YWRhdGEsXG4gICAgYm9keSxcbiAgICBjb21tZW50SWQsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIGNvbnN0IHRocmVhZCA9IGF3YWl0IGZldGNoSnNvbihcIi90aHJlYWRzXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVUaHJlYWQoeyB0aHJlYWRJZCB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9YCwge1xuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdFRocmVhZE1ldGFkYXRhKHtcbiAgICBtZXRhZGF0YSxcbiAgICB0aHJlYWRJZFxuICB9KSB7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L21ldGFkYXRhYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzUmVzb2x2ZWQoeyB0aHJlYWRJZCB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vbWFyay1hcy1yZXNvbHZlZGAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQoeyB0aHJlYWRJZCB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vbWFyay1hcy11bnJlc29sdmVkYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGJvZHlcbiAgfSkge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50c2AsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdENvbW1lbnQoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBib2R5XG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVDb21tZW50Mih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkXG4gIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gYWRkUmVhY3Rpb24yKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX0vcmVhY3Rpb25zYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1vamkgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKHJlYWN0aW9uKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW1vdmVSZWFjdGlvbjIoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX0vcmVhY3Rpb25zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGVtb2ppKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0VGhyZWFkcyxcbiAgICBnZXRUaHJlYWQsXG4gICAgY3JlYXRlVGhyZWFkLFxuICAgIGRlbGV0ZVRocmVhZCxcbiAgICBlZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgbWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gICAgbWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICBjcmVhdGVDb21tZW50LFxuICAgIGVkaXRDb21tZW50LFxuICAgIGRlbGV0ZUNvbW1lbnQ6IGRlbGV0ZUNvbW1lbnQyLFxuICAgIGFkZFJlYWN0aW9uOiBhZGRSZWFjdGlvbjIsXG4gICAgcmVtb3ZlUmVhY3Rpb246IHJlbW92ZVJlYWN0aW9uMlxuICB9O1xufVxudmFyIE1BUktfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0JBVENIX0RFTEFZMiA9IDUwO1xuZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRpb25zLCBjb25maWcpIHtcbiAgY29uc3QgaW5pdGlhbFByZXNlbmNlID0gb3B0aW9ucy5pbml0aWFsUHJlc2VuY2U7XG4gIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gb3B0aW9ucy5pbml0aWFsU3RvcmFnZTtcbiAgY29uc3QgW2luQmFja2dyb3VuZFNpbmNlLCB1bmluc3RhbGxCZ1RhYlNweV0gPSBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpO1xuICBjb25zdCBkZWxlZ2F0ZXMgPSB7XG4gICAgLi4uY29uZmlnLmRlbGVnYXRlcyxcbiAgICAvLyBBIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byBnbyBpbnRvIFwiem9tYmllIHN0YXRlXCIgb25seSBpZiBhbGwgb2YgdGhlXG4gICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnMgYXBwbHk6XG4gICAgLy9cbiAgICAvLyAtIFRoZSBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIGNsaWVudCBvcHRpb24gaXMgY29uZmlndXJlZFxuICAgIC8vIC0gVGhlIGJyb3dzZXIgd2luZG93IGhhcyBiZWVuIGluIHRoZSBiYWNrZ3JvdW5kIGZvciBhdCBsZWFzdFxuICAgIC8vICAgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBtaWxsaXNlY29uZHNcbiAgICAvLyAtIFRoZXJlIGFyZSBubyBwZW5kaW5nIGNoYW5nZXNcbiAgICAvL1xuICAgIGNhblpvbWJpZSgpIHtcbiAgICAgIHJldHVybiBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgIT09IHZvaWQgMCAmJiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICE9PSBudWxsICYmIERhdGUubm93KCkgPiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICsgY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICYmIGdldFN0b3JhZ2VTdGF0dXMoKSAhPT0gXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYW5hZ2VkU29ja2V0ID0gbmV3IE1hbmFnZWRTb2NrZXQoXG4gICAgZGVsZWdhdGVzLFxuICAgIGNvbmZpZy5lbmFibGVEZWJ1Z0xvZ2dpbmdcbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBidWZmZXI6IHtcbiAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgbGFzdEZsdXNoZWRBdDogMCxcbiAgICAgIHByZXNlbmNlVXBkYXRlczogKFxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgaW5pdGlhbCBwcmVzZW5jZSBtZXNzYWdlIGFzIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGVcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgICAgIGRhdGE6IGluaXRpYWxQcmVzZW5jZVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdXG4gICAgfSxcbiAgICBzdGF0aWNTZXNzaW9uSW5mbzogbmV3IFZhbHVlUmVmKG51bGwpLFxuICAgIGR5bmFtaWNTZXNzaW9uSW5mbzogbmV3IFZhbHVlUmVmKG51bGwpLFxuICAgIG15UHJlc2VuY2U6IG5ldyBQYXRjaGFibGVSZWYoaW5pdGlhbFByZXNlbmNlKSxcbiAgICBvdGhlcnM6IG5ldyBPdGhlcnNSZWYoKSxcbiAgICBpbml0aWFsU3RvcmFnZSxcbiAgICBpZEZhY3Rvcnk6IG51bGwsXG4gICAgLy8gU3RvcmFnZVxuICAgIGNsb2NrOiAwLFxuICAgIG9wQ2xvY2s6IDAsXG4gICAgbm9kZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgcm9vdDogdm9pZCAwLFxuICAgIHVuZG9TdGFjazogW10sXG4gICAgcmVkb1N0YWNrOiBbXSxcbiAgICBwYXVzZWRIaXN0b3J5OiBudWxsLFxuICAgIGFjdGl2ZUJhdGNoOiBudWxsLFxuICAgIHVuYWNrbm93bGVkZ2VkT3BzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIC8vIERlYnVnXG4gICAgb3BTdGFja1RyYWNlczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSA6IHZvaWQgMFxuICB9O1xuICBjb25zdCBkb05vdEJhdGNoVXBkYXRlcyA9IChjYikgPT4gY2IoKTtcbiAgY29uc3QgYmF0Y2hVcGRhdGVzID0gY29uZmlnLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID8/IGRvTm90QmF0Y2hVcGRhdGVzO1xuICBsZXQgbGFzdFRva2VuS2V5O1xuICBmdW5jdGlvbiBvblN0YXR1c0RpZENoYW5nZShuZXdTdGF0dXMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZTtcbiAgICBpZiAoYXV0aFZhbHVlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0b2tlbktleSA9IGdldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSk7XG4gICAgICBpZiAodG9rZW5LZXkgIT09IGxhc3RUb2tlbktleSkge1xuICAgICAgICBsYXN0VG9rZW5LZXkgPSB0b2tlbktleTtcbiAgICAgICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBhdXRoVmFsdWUudG9rZW4ucGFyc2VkO1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmlkIDogdG9rZW4udWlkLFxuICAgICAgICAgICAgdXNlckluZm86IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pbmZvIDogdG9rZW4udWlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICAgICAgICB1c2VySWQ6IHZvaWQgMCxcbiAgICAgICAgICAgIHVzZXJJbmZvOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgZXZlbnRIdWIuc3RhdHVzLm5vdGlmeShuZXdTdGF0dXMpO1xuICAgICAgbm90aWZ5U2VsZkNoYW5nZWQoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICB9XG4gIGxldCBfY29ubmVjdGlvbkxvc3NUaW1lcklkO1xuICBsZXQgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQobmV3U3RhdHVzKSB7XG4gICAgaWYgKG5ld1N0YXR1cyA9PT0gXCJyZWNvbm5lY3RpbmdcIikge1xuICAgICAgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcImxvc3RcIik7XG4gICAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBjb250ZXh0Lm90aGVycy5jbGVhck90aGVycygpO1xuICAgICAgICAgIG5vdGlmeSh7IG90aGVyczogW3sgdHlwZTogXCJyZXNldFwiIH1dIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBjb25maWcubG9zdENvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KF9jb25uZWN0aW9uTG9zc1RpbWVySWQpO1xuICAgICAgaWYgKF9oYXNMb3N0Q29ubmVjdGlvbikge1xuICAgICAgICBpZiAobmV3U3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcImZhaWxlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwicmVzdG9yZWRcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRGlkQ29ubmVjdCgpIHtcbiAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgIGRhdGE6IChcbiAgICAgICAgLy8gQmVjYXVzZSBjb250ZXh0Lm1lLmN1cnJlbnQgaXMgYSByZWFkb25seSBvYmplY3QsIHdlJ2xsIGhhdmUgdG9cbiAgICAgICAgLy8gbWFrZSBhIGNvcHkgaGVyZS4gT3RoZXJ3aXNlLCB0eXBlIGVycm9ycyBoYXBwZW4gbGF0ZXIgd2hlblxuICAgICAgICAvLyBcInBhdGNoaW5nXCIgbXkgcHJlc2VuY2UuXG4gICAgICAgIHsgLi4uY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQgfVxuICAgICAgKVxuICAgIH07XG4gICAgaWYgKF9nZXRTdG9yYWdlJCAhPT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gb25EaWREaXNjb25uZWN0KCkge1xuICAgIGNsZWFyVGltZW91dChjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQpO1xuICB9XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTWVzc2FnZS5zdWJzY3JpYmUoaGFuZGxlU2VydmVyTWVzc2FnZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUob25TdGF0dXNEaWRDaGFuZ2UpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5zdGF0dXNEaWRDaGFuZ2Uuc3Vic2NyaWJlKGhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5kaWRDb25uZWN0LnN1YnNjcmliZShvbkRpZENvbm5lY3QpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5kaWREaXNjb25uZWN0LnN1YnNjcmliZShvbkRpZERpc2Nvbm5lY3QpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5vbkxpdmVibG9ja3NFcnJvci5zdWJzY3JpYmUoKGVycikgPT4ge1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGVycm9yMihcbiAgICAgICAgICBgQ29ubmVjdGlvbiB0byB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZC4gUmVhc29uOiAke2Vyci5tZXNzYWdlfSAoY29kZTogJHtlcnIuY29kZX0pLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50SHViLmVycm9yLm5vdGlmeShlcnIpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgcG9vbCA9IHtcbiAgICByb29tSWQ6IGNvbmZpZy5yb29tSWQsXG4gICAgZ2V0Tm9kZTogKGlkKSA9PiBjb250ZXh0Lm5vZGVzLmdldChpZCksXG4gICAgYWRkTm9kZTogKGlkLCBub2RlKSA9PiB2b2lkIGNvbnRleHQubm9kZXMuc2V0KGlkLCBub2RlKSxcbiAgICBkZWxldGVOb2RlOiAoaWQpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5kZWxldGUoaWQpLFxuICAgIGdlbmVyYXRlSWQ6ICgpID0+IGAke2dldENvbm5lY3Rpb25JZCgpfToke2NvbnRleHQuY2xvY2srK31gLFxuICAgIGdlbmVyYXRlT3BJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5vcENsb2NrKyt9YCxcbiAgICBkaXNwYXRjaChvcHMsIHJldmVyc2UsIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICBjb25zdCBhY3RpdmVCYXRjaCA9IGNvbnRleHQuYWN0aXZlQmF0Y2g7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrVHJhY2UgPSBjYXB0dXJlU3RhY2tUcmFjZShcIlN0b3JhZ2UgbXV0YXRpb25cIiwgdGhpcy5kaXNwYXRjaCk7XG4gICAgICAgIGlmIChzdGFja1RyYWNlKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICAgIGlmIChvcC5vcElkKSB7XG4gICAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuc2V0KG9wLm9wSWQsIHN0YWNrVHJhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZUJhdGNoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgICAgYWN0aXZlQmF0Y2gub3BzLnB1c2gob3ApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICAgICAgYWN0aXZlQmF0Y2gudXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlQmF0Y2gucmV2ZXJzZU9wcy51bnNoaWZ0KC4uLnJldmVyc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhyZXZlcnNlLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICBkaXNwYXRjaE9wcyhvcHMpO1xuICAgICAgICAgIG5vdGlmeSh7IHN0b3JhZ2VVcGRhdGVzIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3NlcnRTdG9yYWdlSXNXcml0YWJsZTogKCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVzID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uY3VycmVudD8uc2NvcGVzO1xuICAgICAgaWYgKHNjb3BlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKHNjb3Blcyk7XG4gICAgICBpZiAoIWNhbldyaXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCB3cml0ZSB0byBzdG9yYWdlIHdpdGggYSByZWFkIG9ubHkgdXNlciwgcGxlYXNlIGVuc3VyZSB0aGUgdXNlciBoYXMgd3JpdGUgcGVybWlzc2lvbnNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgZXZlbnRIdWIgPSB7XG4gICAgc3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAvLyBOZXcvcmVjb21tZW5kZWQgQVBJXG4gICAgbG9zdENvbm5lY3Rpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGN1c3RvbUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzZWxmOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBteVByZXNlbmNlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBvdGhlcnM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGVycm9yOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlQmF0Y2g6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGhpc3Rvcnk6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlU3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICB5ZG9jOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBjb21tZW50czogbWFrZUV2ZW50U291cmNlKClcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDbGllbnRBcGkocm9vbUlkLCBlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zMiwgcGFyYW1zKSB7XG4gICAgY29uc3QgdXJsID0gdXJsam9pbihcbiAgICAgIGNvbmZpZy5iYXNlVXJsLFxuICAgICAgYC92Mi9jL3Jvb21zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJvb21JZCl9JHtlbmRwb2ludH1gLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgICBjb25zdCBmZXRjaGVyID0gY29uZmlnLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmZXRjaDtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hlcih1cmwsIHtcbiAgICAgIC4uLm9wdGlvbnMyLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5vcHRpb25zMj8uaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSl9YFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbUZldGNoKGF1dGhWYWx1ZSwgcm9vbUlkKSB7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKHJvb21JZCwgXCIvc3RvcmFnZVwiLCBhdXRoVmFsdWUsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBodHRwUG9zdFRvUm9vbShlbmRwb2ludCwgYm9keSkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhdXRob3JpemVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoY29uZmlnLnJvb21JZCwgZW5kcG9pbnQsIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dE1lbnRpb24odXNlcklkLCBtZW50aW9uSWQpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYXV0aG9yaXplZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKFxuICAgICAgY29uZmlnLnJvb21JZCxcbiAgICAgIFwiL3RleHQtbWVudGlvbnNcIixcbiAgICAgIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBtZW50aW9uSWRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRleHRNZW50aW9uKG1lbnRpb25JZCkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhdXRob3JpemVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoXG4gICAgICBjb25maWcucm9vbUlkLFxuICAgICAgYC90ZXh0LW1lbnRpb25zLyR7bWVudGlvbklkfWAsXG4gICAgICBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXBvcnRUZXh0RWRpdG9yKHR5cGUsIHJvb3RLZXkpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKGNvbmZpZy5yb29tSWQsIFwiL3RleHQtbWV0YWRhdGFcIiwgYXV0aFZhbHVlLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdEtleVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZW5kTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VzKTtcbiAgICBjb25zdCBub25jZSA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ/Lm5vbmNlO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAgJiYgbm9uY2UpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VyaWFsaXplZFBheWxvYWQpLmxlbmd0aDtcbiAgICAgIGlmIChzaXplID4gTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUpIHtcbiAgICAgICAgdm9pZCBodHRwUG9zdFRvUm9vbShcIi9zZW5kLW1lc3NhZ2VcIiwgeyBub25jZSwgbWVzc2FnZXMgfSkudGhlbihcbiAgICAgICAgICAocmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNwLm9rICYmIHJlc3Auc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXNzYWdlIHdhcyB0b28gbGFyZ2UgZm9yIHdlYnNvY2tldHMgYW5kIHNlbnQgb3ZlciBIVFRQIGluc3RlYWRcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG1hbmFnZWRTb2NrZXQuc2VuZChzZXJpYWxpemVkUGF5bG9hZCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8sXG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8sXG4gICAgY29udGV4dC5teVByZXNlbmNlLFxuICAgIChzdGF0aWNTZXNzaW9uLCBkeW5hbWljU2Vzc2lvbiwgbXlQcmVzZW5jZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY1Nlc3Npb24gPT09IG51bGwgfHwgZHluYW1pY1Nlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShkeW5hbWljU2Vzc2lvbi5zY29wZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbm5lY3Rpb25JZDogZHluYW1pY1Nlc3Npb24uYWN0b3IsXG4gICAgICAgICAgaWQ6IHN0YXRpY1Nlc3Npb24udXNlcklkLFxuICAgICAgICAgIGluZm86IHN0YXRpY1Nlc3Npb24udXNlckluZm8sXG4gICAgICAgICAgcHJlc2VuY2U6IG15UHJlc2VuY2UsXG4gICAgICAgICAgY2FuV3JpdGUsXG4gICAgICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChkeW5hbWljU2Vzc2lvbi5zY29wZXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICApO1xuICBsZXQgX2xhc3RTZWxmO1xuICBmdW5jdGlvbiBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb25zdCBjdXJyU2VsZiA9IHNlbGYuY3VycmVudDtcbiAgICBpZiAoY3VyclNlbGYgIT09IG51bGwgJiYgY3VyclNlbGYgIT09IF9sYXN0U2VsZikge1xuICAgICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgZXZlbnRIdWIuc2VsZi5ub3RpZnkoY3VyclNlbGYpO1xuICAgICAgfSk7XG4gICAgICBfbGFzdFNlbGYgPSBjdXJyU2VsZjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VsZkFzVHJlZU5vZGUgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBzZWxmLFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyB1c2VyVG9UcmVlTm9kZShcIk1lXCIsIG1lKSA6IG51bGxcbiAgKTtcbiAgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSwgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKG1lc3NhZ2UuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IGxvYWQgc3RvcmFnZSB3aXRob3V0IGl0ZW1zXCIpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHVwZGF0ZVJvb3QobWVzc2FnZS5pdGVtcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5yb290ID0gTGl2ZU9iamVjdC5fZnJvbUl0ZW1zKG1lc3NhZ2UuaXRlbXMsIHBvb2wpO1xuICAgIH1cbiAgICBjb25zdCBjYW5Xcml0ZSA9IHNlbGYuY3VycmVudD8uY2FuV3JpdGUgPz8gdHJ1ZTtcbiAgICBjb25zdCBzdGFja1NpemVCZWZvcmUgPSBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dC5pbml0aWFsU3RvcmFnZSkge1xuICAgICAgaWYgKGNvbnRleHQucm9vdC5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChjYW5Xcml0ZSkge1xuICAgICAgICAgIGNvbnRleHQucm9vdC5zZXQoa2V5LCBjbG9uZUxzb24oY29udGV4dC5pbml0aWFsU3RvcmFnZVtrZXldKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcG9wdWxhdGUgbWlzc2luZyBzdG9yYWdlIGtleSAnJHtrZXl9JywgYnV0IGN1cnJlbnQgdXNlciBoYXMgbm8gd3JpdGUgYWNjZXNzYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gc3RhY2tTaXplQmVmb3JlO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvb3QoaXRlbXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBjb250ZXh0Lm5vZGVzKSB7XG4gICAgICBjdXJyZW50SXRlbXMuc2V0KGlkLCBub2RlLl9zZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IGdldFRyZWVzRGlmZk9wZXJhdGlvbnMoY3VycmVudEl0ZW1zLCBuZXcgTWFwKGl0ZW1zKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCBmYWxzZSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICB9XG4gIGZ1bmN0aW9uIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA+PSA1MCkge1xuICAgICAgY29udGV4dC51bmRvU3RhY2suc2hpZnQoKTtcbiAgICB9XG4gICAgY29udGV4dC51bmRvU3RhY2sucHVzaChoaXN0b3J5T3BzKTtcbiAgICBvbkhpc3RvcnlDaGFuZ2UoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRUb1VuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkudW5zaGlmdCguLi5oaXN0b3J5T3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3RpZnkodXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzO1xuICAgIGNvbnN0IG90aGVyc1VwZGF0ZXMgPSB1cGRhdGVzLm90aGVycztcbiAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgaWYgKG90aGVyc1VwZGF0ZXMgIT09IHZvaWQgMCAmJiBvdGhlcnNVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuY3VycmVudDtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBvdGhlcnNVcGRhdGVzKSB7XG4gICAgICAgICAgZXZlbnRIdWIub3RoZXJzLm5vdGlmeSh7IC4uLmV2ZW50LCBvdGhlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGVzLnByZXNlbmNlID8/IGZhbHNlKSB7XG4gICAgICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgZXZlbnRIdWIubXlQcmVzZW5jZS5ub3RpZnkoY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3JhZ2VVcGRhdGVzICE9PSB2b2lkIDAgJiYgc3RvcmFnZVVwZGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgdXBkYXRlczIgPSBBcnJheS5mcm9tKHN0b3JhZ2VVcGRhdGVzLnZhbHVlcygpKTtcbiAgICAgICAgZXZlbnRIdWIuc3RvcmFnZUJhdGNoLm5vdGlmeSh1cGRhdGVzMik7XG4gICAgICB9XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbklkKCkge1xuICAgIGNvbnN0IGluZm8gPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5hY3RvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnRlcm5hbC4gVHJpZWQgdG8gZ2V0IGNvbm5lY3Rpb24gaWQgYnV0IGNvbm5lY3Rpb24gd2FzIG5ldmVyIG9wZW5cIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcHMocmF3T3BzLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgcmV2ZXJzZTogW10sXG4gICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIHByZXNlbmNlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlZE5vZGVJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG9wcyA9IHJhd09wcy5tYXAoKG9wKSA9PiB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiICYmICFvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm9wLCBvcElkOiBwb29sLmdlbmVyYXRlT3BJZCgpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3A7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgIGlmIChvcC50eXBlID09PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZSA9IHtcbiAgICAgICAgICB0eXBlOiBcInByZXNlbmNlXCIsXG4gICAgICAgICAgZGF0YToge31cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgICAgIHJldmVyc2UuZGF0YVtrZXldID0gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gob3AuZGF0YSk7XG4gICAgICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7IHR5cGU6IFwicGFydGlhbFwiLCBkYXRhOiBvcC5kYXRhIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFba2V5XSA9IG9wLmRhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnJldmVyc2UudW5zaGlmdChyZXZlcnNlKTtcbiAgICAgICAgb3V0cHV0LnByZXNlbmNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzb3VyY2U7XG4gICAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgICAgc291cmNlID0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb3BJZCA9IG5uKG9wLm9wSWQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWxldGVkID0gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5kZWxldGUob3BJZCk7XG4gICAgICAgICAgc291cmNlID0gZGVsZXRlZCA/IDIgLyogQUNLICovIDogMSAvKiBSRU1PVEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwbHlPcFJlc3VsdCA9IGFwcGx5T3Aob3AsIHNvdXJjZSk7XG4gICAgICAgIGlmIChhcHBseU9wUmVzdWx0Lm1vZGlmaWVkKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUlkID0gYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZDtcbiAgICAgICAgICBpZiAoIShub2RlSWQgJiYgY3JlYXRlZE5vZGVJZHMuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICBubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSxcbiAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyhcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuZ2V0KG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpKSxcbiAgICAgICAgICAgICAgICBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucmV2ZXJzZS51bnNoaWZ0KC4uLmFwcGx5T3BSZXN1bHQucmV2ZXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcC50eXBlID09PSAyIC8qIENSRUFURV9MSVNUICovIHx8IG9wLnR5cGUgPT09IDcgLyogQ1JFQVRFX01BUCAqLyB8fCBvcC50eXBlID09PSA0IC8qIENSRUFURV9PQkpFQ1QgKi8pIHtcbiAgICAgICAgICAgIGNyZWF0ZWROb2RlSWRzLmFkZChubihvcC5pZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3BzLFxuICAgICAgcmV2ZXJzZTogb3V0cHV0LnJldmVyc2UsXG4gICAgICB1cGRhdGVzOiB7XG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzOiBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMsXG4gICAgICAgIHByZXNlbmNlOiBvdXRwdXQucHJlc2VuY2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5T3Aob3AsIHNvdXJjZSkge1xuICAgIGlmIChpc0Fja09wKG9wKSkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovOlxuICAgICAgY2FzZSAzIC8qIFVQREFURV9PQkpFQ1QgKi86XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLmlkKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLl9hcHBseShvcCwgc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLyk7XG4gICAgICB9XG4gICAgICBjYXNlIDEgLyogU0VUX1BBUkVOVF9LRVkgKi86IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLmlkKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnQubm9kZS5fc2V0Q2hpbGRLZXkoXG4gICAgICAgICAgICBhc1BvcyhvcC5wYXJlbnRLZXkpLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHNvdXJjZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIGNhc2UgNyAvKiBDUkVBVEVfTUFQICovOlxuICAgICAgY2FzZSA4IC8qIENSRUFURV9SRUdJU1RFUiAqLzoge1xuICAgICAgICBpZiAob3AucGFyZW50SWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChwYXJlbnROb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50Tm9kZS5fYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVByZXNlbmNlKHBhdGNoLCBvcHRpb25zMikge1xuICAgIGNvbnN0IG9sZFZhbHVlcyA9IHt9O1xuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgICAgdHlwZTogXCJwYXJ0aWFsXCIsXG4gICAgICAgIGRhdGE6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVWYWx1ZSA9IHBhdGNoW2tleV07XG4gICAgICBpZiAob3ZlcnJpZGVWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFba2V5XSA9IG92ZXJyaWRlVmFsdWU7XG4gICAgICBvbGRWYWx1ZXNba2V5XSA9IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50W2tleV07XG4gICAgfVxuICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChwYXRjaCk7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gucmV2ZXJzZU9wcy51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiBcInByZXNlbmNlXCIsXG4gICAgICAgICAgZGF0YTogb2xkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC51cGRhdGVzLnByZXNlbmNlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgICAgYWRkVG9VbmRvU3RhY2soXG4gICAgICAgICAgICBbeyB0eXBlOiBcInByZXNlbmNlXCIsIGRhdGE6IG9sZFZhbHVlcyB9XSxcbiAgICAgICAgICAgIGRvTm90QmF0Y2hVcGRhdGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBub3RpZnkoeyBwcmVzZW5jZTogdHJ1ZSB9LCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLnRhcmdldEFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IG9sZFVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0T3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKTtcbiAgICAgIGNvbnN0IG5ld1VzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgaWYgKG9sZFVzZXIgPT09IHZvaWQgMCAmJiBuZXdVc2VyICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbnRlclwiLCB1c2VyOiBuZXdVc2VyIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnBhdGNoT3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKSwgbWVzc2FnZTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgIHVwZGF0ZXM6IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgdXNlclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJsZWF2ZVwiLCB1c2VyIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgYWN0b3I6IG1lc3NhZ2UuYWN0b3IsXG4gICAgICBub25jZTogbWVzc2FnZS5ub25jZSxcbiAgICAgIHNjb3BlczogbWVzc2FnZS5zY29wZXNcbiAgICB9KTtcbiAgICBjb250ZXh0LmlkRmFjdG9yeSA9IG1ha2VJZEZhY3RvcnkobWVzc2FnZS5hY3Rvcik7XG4gICAgbm90aWZ5U2VsZkNoYW5nZWQoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb25JZCBvZiBjb250ZXh0Lm90aGVycy5jb25uZWN0aW9uSWRzKCkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2Nvbm5lY3Rpb25JZF07XG4gICAgICBpZiAodXNlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVzc2FnZS51c2Vycykge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNba2V5XTtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IE51bWJlcihrZXkpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICB1c2VyLmlkLFxuICAgICAgICB1c2VyLmluZm8sXG4gICAgICAgIHVzZXIuc2NvcGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInJlc2V0XCIgfTtcbiAgfVxuICBmdW5jdGlvbiBjYW5VbmRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGNhblJlZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gb25IaXN0b3J5Q2hhbmdlKGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGJhdGNoZWRVcGRhdGVzV3JhcHBlcigoKSA9PiB7XG4gICAgICBldmVudEh1Yi5oaXN0b3J5Lm5vdGlmeSh7IGNhblVuZG86IGNhblVuZG8oKSwgY2FuUmVkbzogY2FuUmVkbygpIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICBtZXNzYWdlLmFjdG9yLFxuICAgICAgbWVzc2FnZS5pZCxcbiAgICAgIG1lc3NhZ2UuaW5mbyxcbiAgICAgIG1lc3NhZ2Uuc2NvcGVzXG4gICAgKTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICBkYXRhOiBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCxcbiAgICAgIHRhcmdldEFjdG9yOiBtZXNzYWdlLmFjdG9yXG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICByZXR1cm4gdXNlciA/IHsgdHlwZTogXCJlbnRlclwiLCB1c2VyIH0gOiB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAoIWlzSnNvbk9iamVjdChkYXRhKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZXModGV4dCkge1xuICAgIGNvbnN0IGRhdGEgPSB0cnlQYXJzZUpzb24odGV4dCk7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChpc0pzb25BcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoZGF0YS5tYXAoKGl0ZW0pID0+IHBhcnNlU2VydmVyTWVzc2FnZShpdGVtKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFjdChbcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFwcGx5QW5kU2VuZE9wcyhvZmZsaW5lT3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAob2ZmbGluZU9wcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgY29uc3Qgb3BzID0gQXJyYXkuZnJvbShvZmZsaW5lT3BzLnZhbHVlcygpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhvcHMsIHRydWUpO1xuICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgb3BzOiByZXN1bHQub3BzXG4gICAgfSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlcyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU2VydmVyTWVzc2FnZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHBhcnNlU2VydmVyTWVzc2FnZXMoZXZlbnQuZGF0YSk7XG4gICAgaWYgKG1lc3NhZ2VzID09PSBudWxsIHx8IG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBvdGhlcnM6IFtdXG4gICAgfTtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAxMDEgLyogVVNFUl9KT0lORUQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJKb2luZWRVcGRhdGUgPSBvblVzZXJKb2luZWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHVzZXJKb2luZWRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaCh1c2VySm9pbmVkVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyc1ByZXNlbmNlVXBkYXRlID0gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAob3RoZXJzUHJlc2VuY2VVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChvdGhlcnNQcmVzZW5jZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDMgLyogQlJPQURDQVNURURfRVZFTlQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVycyA9IGNvbnRleHQub3RoZXJzLmN1cnJlbnQ7XG4gICAgICAgICAgICBldmVudEh1Yi5jdXN0b21FdmVudC5ub3RpZnkoe1xuICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IG1lc3NhZ2UuYWN0b3IsXG4gICAgICAgICAgICAgIHVzZXI6IG1lc3NhZ2UuYWN0b3IgPCAwID8gbnVsbCA6IG90aGVycy5maW5kKCh1KSA9PiB1LmNvbm5lY3Rpb25JZCA9PT0gbWVzc2FnZS5hY3RvcikgPz8gbnVsbCxcbiAgICAgICAgICAgICAgZXZlbnQ6IG1lc3NhZ2UuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAyIC8qIFVTRVJfTEVGVCAqLzoge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQyID0gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQyKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2goZXZlbnQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDMwMCAvKiBVUERBVEVfWURPQyAqLzoge1xuICAgICAgICAgICAgZXZlbnRIdWIueWRvYy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDQgLyogUk9PTV9TVEFURSAqLzoge1xuICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChvblJvb21TdGF0ZU1lc3NhZ2UobWVzc2FnZSwgZG9Ob3RCYXRjaFVwZGF0ZXMpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi86IHtcbiAgICAgICAgICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLzoge1xuICAgICAgICAgICAgY29uc3QgYXBwbHlSZXN1bHQgPSBhcHBseU9wcyhtZXNzYWdlLm9wcywgZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXBwbHlSZXN1bHQudXBkYXRlcy5zdG9yYWdlVXBkYXRlcykge1xuICAgICAgICAgICAgICB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyh1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLCB2YWx1ZSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI5OSAvKiBSRUpFQ1RfU1RPUkFHRV9PUCAqLzoge1xuICAgICAgICAgICAgZXJyb3JXaXRoVGl0bGUoXG4gICAgICAgICAgICAgIFwiU3RvcmFnZSBtdXRhdGlvbiByZWplY3Rpb24gZXJyb3JcIixcbiAgICAgICAgICAgICAgbWVzc2FnZS5yZWFzb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3Qgb3BJZCBvZiBtZXNzYWdlLm9wSWRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2UgPSBjb250ZXh0Lm9wU3RhY2tUcmFjZXM/LmdldChvcElkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgIHRyYWNlcy5hZGQodHJhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHJhY2VzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgd2FybldpdGhUaXRsZShcbiAgICAgICAgICAgICAgICAgIFwiVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBjYWxscyBjYXVzZWQgdGhlIHJlamVjdGVkIHN0b3JhZ2UgbXV0YXRpb25zOlwiLFxuICAgICAgICAgICAgICAgICAgYFxuXG4ke0FycmF5LmZyb20odHJhY2VzKS5qb2luKFwiXFxuXFxuXCIpfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgU3RvcmFnZSBtdXRhdGlvbnMgcmVqZWN0ZWQgYnkgc2VydmVyOiAke21lc3NhZ2UucmVhc29ufWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQwMCAvKiBUSFJFQURfQ1JFQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNyAvKiBUSFJFQURfREVMRVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMSAvKiBUSFJFQURfTUVUQURBVEFfVVBEQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwOCAvKiBUSFJFQURfVVBEQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNSAvKiBDT01NRU5UX1JFQUNUSU9OX0FEREVEICovOlxuICAgICAgICAgIGNhc2UgNDA2IC8qIENPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMiAvKiBDT01NRU5UX0NSRUFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDMgLyogQ09NTUVOVF9FRElURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDQgLyogQ09NTUVOVF9ERUxFVEVEICovOiB7XG4gICAgICAgICAgICBldmVudEh1Yi5jb21tZW50cy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vdGlmeSh1cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hOb3dPclNvb24oKSB7XG4gICAgY29uc3Qgc3RvcmFnZU9wcyA9IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zO1xuICAgIGlmIChzdG9yYWdlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygc3RvcmFnZU9wcykge1xuICAgICAgICBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNldChubihvcC5vcElkKSwgb3ApO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH1cbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMgPSBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkTWlsbGlzID0gbm93IC0gY29udGV4dC5idWZmZXIubGFzdEZsdXNoZWRBdDtcbiAgICBpZiAoZWxhcHNlZE1pbGxpcyA+PSBjb25maWcudGhyb3R0bGVEZWxheSkge1xuICAgICAgY29uc3QgbWVzc2FnZXNUb0ZsdXNoID0gc2VyaWFsaXplQnVmZmVyKCk7XG4gICAgICBpZiAobWVzc2FnZXNUb0ZsdXNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXNUb0ZsdXNoKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyID0ge1xuICAgICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgICAgbGFzdEZsdXNoZWRBdDogbm93LFxuICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXSxcbiAgICAgICAgcHJlc2VuY2VVcGRhdGVzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAgIGZsdXNoTm93T3JTb29uLFxuICAgICAgICBjb25maWcudGhyb3R0bGVEZWxheSAtIGVsYXBzZWRNaWxsaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlcigpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy50eXBlID09PSBcImZ1bGxcIiA/IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIC8vIFBvcHVsYXRpbmcgdGhlIGB0YXJnZXRBY3RvcmAgZmllbGQgdHVybnMgdGhpcyBtZXNzYWdlIGludG9cbiAgICAgICAgICAvLyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlIG1lc3NhZ2UgKG5vdCBhIHBhdGNoKSwgd2hpY2ggd2lsbCBnZXRcbiAgICAgICAgICAvLyBpbnRlcnByZXRlZCBieSBvdGhlciBjbGllbnRzIGFzIHN1Y2guXG4gICAgICAgICAgdGFyZ2V0QWN0b3I6IC0xLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICAgIG9wczogY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXM7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlWURvYyh1cGRhdGUsIGd1aWQpIHtcbiAgICBjb25zdCBjbGllbnRNc2cgPSB7XG4gICAgICB0eXBlOiAzMDEgLyogVVBEQVRFX1lET0MgKi8sXG4gICAgICB1cGRhdGUsXG4gICAgICBndWlkXG4gICAgfTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKGNsaWVudE1zZyk7XG4gICAgZXZlbnRIdWIueWRvYy5ub3RpZnkoY2xpZW50TXNnKTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zMiA9IHtcbiAgICBzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeTogZmFsc2VcbiAgfSkge1xuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiICYmICFvcHRpb25zMi5zaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMyAvKiBCUk9BRENBU1RfRVZFTlQgKi8sXG4gICAgICBldmVudFxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2hPcHMob3BzKSB7XG4gICAgY29uc3QgeyBzdG9yYWdlT3BlcmF0aW9ucyB9ID0gY29udGV4dC5idWZmZXI7XG4gICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGxldCBfZ2V0U3RvcmFnZSQgPSBudWxsO1xuICBsZXQgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NJbml0aWFsU3RvcmFnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdW5hY2tub3dsZWRnZWRPcHMgPSBuZXcgTWFwKGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMpO1xuICAgIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICBhcHBseUFuZFNlbmRPcHModW5hY2tub3dsZWRnZWRPcHMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlPy4oKTtcbiAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgZXZlbnRIdWIuc3RvcmFnZURpZExvYWQubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtU3RvcmFnZSgpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0cmVhbUZldGNoKG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLCBjb25maWcucm9vbUlkKTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKHsgdHlwZTogMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLywgaXRlbXMgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaFN0b3JhZ2Uob3B0aW9uczIpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfc3RyZWFtRGF0YSkge1xuICAgICAgdm9pZCBzdHJlYW1TdG9yYWdlKCk7XG4gICAgfSBlbHNlIGlmICghbWVzc2FnZXMuc29tZSgobXNnKSA9PiBtc2cudHlwZSA9PT0gMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8pKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHsgdHlwZTogMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8gfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zMi5mbHVzaCkge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRMb2FkaW5nU3RvcmFnZSgpIHtcbiAgICBpZiAoX2dldFN0b3JhZ2UkID09PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiB0cnVlIH0pO1xuICAgICAgX2dldFN0b3JhZ2UkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlJDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU25hcHNob3QoKSB7XG4gICAgY29uc3Qgcm9vdCA9IGNvbnRleHQucm9vdDtcbiAgICBpZiAocm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZSgpIHtcbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICByb290OiBjb250ZXh0LnJvb3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IG5uKGNvbnRleHQucm9vdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZldGNoWURvYyh2ZWN0b3IsIGd1aWQpIHtcbiAgICBpZiAoIWNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLmZpbmQoKG0pID0+IHtcbiAgICAgIHJldHVybiBtLnR5cGUgPT09IDMwMCAvKiBGRVRDSF9ZRE9DICovICYmIG0udmVjdG9yID09PSB2ZWN0b3IgJiYgbS5ndWlkID09PSBndWlkO1xuICAgIH0pKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMzAwIC8qIEZFVENIX1lET0MgKi8sXG4gICAgICAgIHZlY3RvcixcbiAgICAgICAgZ3VpZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gdW5kbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5kbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQudW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICBjb250ZXh0LnJlZG9TdGFjay5wdXNoKHJlc3VsdC5yZXZlcnNlKTtcbiAgICAgIG9uSGlzdG9yeUNoYW5nZShkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcCBvZiByZXN1bHQub3BzKSB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnJlZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC51bmRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSAwO1xuICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGxldCByZXR1cm5WYWx1ZSA9IHZvaWQgMDtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IHtcbiAgICAgICAgb3BzOiBbXSxcbiAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICAgIHByZXNlbmNlOiBmYWxzZSxcbiAgICAgICAgICBvdGhlcnM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2VPcHM6IFtdXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IG51bGw7XG4gICAgICAgIGlmIChjdXJyZW50QmF0Y2gucmV2ZXJzZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYWRkVG9VbmRvU3RhY2soY3VycmVudEJhdGNoLnJldmVyc2VPcHMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGlzcGF0Y2hPcHMoY3VycmVudEJhdGNoLm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5KGN1cnJlbnRCYXRjaC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHBhdXNlSGlzdG9yeSgpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBbXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lSGlzdG9yeSgpIHtcbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5wYXVzZWRIaXN0b3J5O1xuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgaWYgKGhpc3RvcnlPcHMgIT09IG51bGwgJiYgaGlzdG9yeU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoVXBkYXRlcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gX2dldFN0b3JhZ2UkID09PSBudWxsID8gXCJub3QtbG9hZGVkXCIgOiBcImxvYWRpbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuc2l6ZSA9PT0gMCA/IFwic3luY2hyb25pemVkXCIgOiBcInN5bmNocm9uaXppbmdcIjtcbiAgICB9XG4gIH1cbiAgbGV0IF9sYXN0U3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmFnZVN0YXR1cygpIHtcbiAgICBjb25zdCBzdG9yYWdlU3RhdHVzID0gZ2V0U3RvcmFnZVN0YXR1cygpO1xuICAgIGlmIChfbGFzdFN0b3JhZ2VTdGF0dXMgIT09IHN0b3JhZ2VTdGF0dXMpIHtcbiAgICAgIF9sYXN0U3RvcmFnZVN0YXR1cyA9IHN0b3JhZ2VTdGF0dXM7XG4gICAgICBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm5vdGlmeShzdG9yYWdlU3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmVzZW5jZVJlYWR5KCkge1xuICAgIHJldHVybiBzZWxmLmN1cnJlbnQgIT09IG51bGw7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsUHJlc2VuY2VSZWFkeSgpIHtcbiAgICB3aGlsZSAoIWlzUHJlc2VuY2VSZWFkeSgpKSB7XG4gICAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IFByb21pc2Vfd2l0aFJlc29sdmVycygpO1xuICAgICAgY29uc3QgdW5zdWIxID0gZXZlbnRzLnNlbGYuc3Vic2NyaWJlT25jZShyZXNvbHZlKTtcbiAgICAgIGNvbnN0IHVuc3ViMiA9IGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlT25jZShyZXNvbHZlKTtcbiAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB1bnN1YjEoKTtcbiAgICAgIHVuc3ViMigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1N0b3JhZ2VSZWFkeSgpIHtcbiAgICByZXR1cm4gZ2V0U3RvcmFnZVNuYXBzaG90KCkgIT09IG51bGw7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsU3RvcmFnZVJlYWR5KCkge1xuICAgIHdoaWxlICghaXNTdG9yYWdlUmVhZHkoKSkge1xuICAgICAgYXdhaXQgZ2V0U3RvcmFnZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBvdGhlcnNfZm9yRGV2VG9vbHMgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBjb250ZXh0Lm90aGVycyxcbiAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKChvdGhlciwgaW5kZXgpID0+IHVzZXJUb1RyZWVOb2RlKGBPdGhlciAke2luZGV4fWAsIG90aGVyKSlcbiAgKTtcbiAgY29uc3QgZXZlbnRzID0ge1xuICAgIHN0YXR1czogZXZlbnRIdWIuc3RhdHVzLm9ic2VydmFibGUsXG4gICAgbG9zdENvbm5lY3Rpb246IGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm9ic2VydmFibGUsXG4gICAgY3VzdG9tRXZlbnQ6IGV2ZW50SHViLmN1c3RvbUV2ZW50Lm9ic2VydmFibGUsXG4gICAgb3RoZXJzOiBldmVudEh1Yi5vdGhlcnMub2JzZXJ2YWJsZSxcbiAgICBzZWxmOiBldmVudEh1Yi5zZWxmLm9ic2VydmFibGUsXG4gICAgbXlQcmVzZW5jZTogZXZlbnRIdWIubXlQcmVzZW5jZS5vYnNlcnZhYmxlLFxuICAgIGVycm9yOiBldmVudEh1Yi5lcnJvci5vYnNlcnZhYmxlLFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0b3JhZ2U6IGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VCYXRjaDogZXZlbnRIdWIuc3RvcmFnZUJhdGNoLm9ic2VydmFibGUsXG4gICAgaGlzdG9yeTogZXZlbnRIdWIuaGlzdG9yeS5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VTdGF0dXM6IGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMub2JzZXJ2YWJsZSxcbiAgICB5ZG9jOiBldmVudEh1Yi55ZG9jLm9ic2VydmFibGUsXG4gICAgY29tbWVudHM6IGV2ZW50SHViLmNvbW1lbnRzLm9ic2VydmFibGVcbiAgfTtcbiAgY29uc3QgY29tbWVudHNBcGkgPSBjcmVhdGVDb21tZW50c0FwaShcbiAgICBjb25maWcucm9vbUlkLFxuICAgIGRlbGVnYXRlcy5hdXRoZW50aWNhdGUsXG4gICAgZmV0Y2hDbGllbnRBcGlcbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihlbmRwb2ludCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENsaWVudEFwaShcbiAgICAgIGNvbmZpZy5yb29tSWQsXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIG9wdGlvbnMyXG4gICAgKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgICByZXR1cm4gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcbiAgICAgIFwiL25vdGlmaWNhdGlvbi1zZXR0aW5nc1wiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcbiAgICAgIFwiL25vdGlmaWNhdGlvbi1zZXR0aW5nc1wiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzZXR0aW5ncyksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcIi9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGluYm94Tm90aWZpY2F0aW9uSWRzIH0pXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBNQVJLX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9CQVRDSF9ERUxBWTIgfVxuICApO1xuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGJhdGNoZWRNYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLmdldChpbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIGdldCBwcmVzZW5jZUJ1ZmZlcigpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcz8uZGF0YSA/PyBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCB1bmRvU3RhY2soKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LnVuZG9TdGFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgbm9kZUNvdW50KCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lm5vZGVzLnNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAvLyBzZW5kIG1ldGFkYXRhIHdoZW4gdXNpbmcgYSB0ZXh0IGVkaXRvclxuICAgICAgICByZXBvcnRUZXh0RWRpdG9yLFxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGNyZWF0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBkZWxldGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGRlbGV0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBTdXBwb3J0IGZvciB0aGUgTGl2ZWJsb2NrcyBicm93c2VyIGV4dGVuc2lvblxuICAgICAgICBnZXRTZWxmX2ZvckRldlRvb2xzOiAoKSA9PiBzZWxmQXNUcmVlTm9kZS5jdXJyZW50LFxuICAgICAgICBnZXRPdGhlcnNfZm9yRGV2VG9vbHM6ICgpID0+IG90aGVyc19mb3JEZXZUb29scy5jdXJyZW50LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgc2ltdWxhdGU6IHtcbiAgICAgICAgICAvLyBUaGVzZSBleGlzdCBvbmx5IGZvciBvdXIgRTJFIHRlc3RpbmcgYXBwXG4gICAgICAgICAgZXhwbGljaXRDbG9zZTogKGV2ZW50KSA9PiBtYW5hZ2VkU29ja2V0Ll9wcml2YXRlU2VuZE1hY2hpbmVFdmVudCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pLFxuICAgICAgICAgIHJhd1NlbmQ6IChkYXRhKSA9PiBtYW5hZ2VkU29ja2V0LnNlbmQoZGF0YSlcbiAgICAgICAgfSxcbiAgICAgICAgY29tbWVudHM6IHtcbiAgICAgICAgICAuLi5jb21tZW50c0FwaVxuICAgICAgICB9LFxuICAgICAgICBub3RpZmljYXRpb25zOiB7XG4gICAgICAgICAgZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgICAgIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlkOiBjb25maWcucm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKGV2ZW50cyksXG4gICAgICBjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmNvbm5lY3QoKSxcbiAgICAgIHJlY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKSxcbiAgICAgIGRpc2Nvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuZGlzY29ubmVjdCgpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICB1bmluc3RhbGxCZ1RhYlNweSgpO1xuICAgICAgICBtYW5hZ2VkU29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgdXBkYXRlUHJlc2VuY2UsXG4gICAgICB1cGRhdGVZRG9jLFxuICAgICAgYnJvYWRjYXN0RXZlbnQsXG4gICAgICAvLyBTdG9yYWdlXG4gICAgICBiYXRjaCxcbiAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgdW5kbyxcbiAgICAgICAgcmVkbyxcbiAgICAgICAgY2FuVW5kbyxcbiAgICAgICAgY2FuUmVkbyxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIHBhdXNlOiBwYXVzZUhpc3RvcnksXG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGlzdG9yeVxuICAgICAgfSxcbiAgICAgIGZldGNoWURvYyxcbiAgICAgIGdldFN0b3JhZ2UsXG4gICAgICBnZXRTdG9yYWdlU25hcHNob3QsXG4gICAgICBnZXRTdG9yYWdlU3RhdHVzLFxuICAgICAgaXNQcmVzZW5jZVJlYWR5LFxuICAgICAgaXNTdG9yYWdlUmVhZHksXG4gICAgICB3YWl0VW50aWxQcmVzZW5jZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFByZXNlbmNlUmVhZHkpLFxuICAgICAgd2FpdFVudGlsU3RvcmFnZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSksXG4gICAgICBldmVudHMsXG4gICAgICAvLyBDb3JlXG4gICAgICBnZXRTdGF0dXM6ICgpID0+IG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCksXG4gICAgICBnZXRTZWxmOiAoKSA9PiBzZWxmLmN1cnJlbnQsXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgZ2V0UHJlc2VuY2U6ICgpID0+IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgZ2V0T3RoZXJzOiAoKSA9PiBjb250ZXh0Lm90aGVycy5jdXJyZW50XG4gICAgfSxcbiAgICAvLyBFeHBsaWN0bHkgbWFrZSB0aGUgaW50ZXJuYWwgZmllbGQgbm9uLWVudW1lcmFibGUsIHRvIGF2b2lkIGFnZ3Jlc3NpdmVcbiAgICAvLyBmcmVlemluZyB3aGVuIHVzZWQgd2l0aCBJbW1lclxuICAgIGtJbnRlcm5hbCxcbiAgICB7IGVudW1lcmFibGU6IGZhbHNlIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4oZXZlbnRzKSB7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZFVwZGF0ZXMgPSB1cGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gaXNTYW1lTm9kZU9yQ2hpbGRPZih1cGRhdGUubm9kZSwgbm9kZSlcbiAgICAgICk7XG4gICAgICBpZiAocmVsYXRlZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFjayhyZWxhdGVkVXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgIGlmICh1cGRhdGUubm9kZS5faWQgPT09IG5vZGUuX2lkKSB7XG4gICAgICAgICAgY2FsbGJhY2sodXBkYXRlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZpcnN0LCBzZWNvbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIGlzUm9vbUV2ZW50TmFtZShmaXJzdCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm15LXByZXNlbmNlXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJvdGhlcnNcIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvdGhlcnMsIC4uLmludGVybmFsRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNiKG90aGVycywgaW50ZXJuYWxFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5lcnJvci5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImxvc3QtY29ubmVjdGlvblwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGlzdG9yeVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuaGlzdG9yeS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RvcmFnZS1zdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBhc3NlcnROZXZlcihcbiAgICAgICAgICAgIGZpcnN0LFxuICAgICAgICAgICAgYFwiJHtTdHJpbmcoZmlyc3QpfVwiIGlzIG5vdCBhIHZhbGlkIGV2ZW50IG5hbWVgXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlY29uZCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gZmlyc3Q7XG4gICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZShzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgYSBsaXN0ZW5lciBjYWxsYmFja1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTGl2ZU5vZGUoZmlyc3QpKSB7XG4gICAgICBjb25zdCBub2RlID0gZmlyc3Q7XG4gICAgICBpZiAob3B0aW9ucz8uaXNEZWVwKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIG5vZGVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke1N0cmluZyhmaXJzdCl9IGlzIG5vdCBhIHZhbHVlIHRoYXQgY2FuIGJlIHN1YnNjcmliZWQgdG8uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN1YnNjcmliZTtcbn1cbmZ1bmN0aW9uIGlzUm9vbUV2ZW50TmFtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibXktcHJlc2VuY2VcIiB8fCB2YWx1ZSA9PT0gXCJvdGhlcnNcIiB8fCB2YWx1ZSA9PT0gXCJldmVudFwiIHx8IHZhbHVlID09PSBcImVycm9yXCIgfHwgdmFsdWUgPT09IFwiaGlzdG9yeVwiIHx8IHZhbHVlID09PSBcInN0YXR1c1wiIHx8IHZhbHVlID09PSBcInN0b3JhZ2Utc3RhdHVzXCIgfHwgdmFsdWUgPT09IFwibG9zdC1jb25uZWN0aW9uXCIgfHwgdmFsdWUgPT09IFwiY29ubmVjdGlvblwiO1xufVxuZnVuY3Rpb24gbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcikge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIiwgcm9vbUlkIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICB1cmwucHJvdG9jb2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsLnBhdGhuYW1lID0gXCIvdjdcIjtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInJvb21JZFwiLCByb29tSWQpO1xuICAgIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJwdWJrZXlcIiwgYXV0aFZhbHVlLnB1YmxpY0FwaUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihhdXRoVmFsdWUsIFwiVW5oYW5kbGVkIGNhc2VcIik7XG4gICAgfVxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidmVyc2lvblwiLCBQS0dfVkVSU0lPTiB8fCBcImRldlwiKTtcbiAgICByZXR1cm4gbmV3IHdzKHVybC50b1N0cmluZygpKTtcbiAgfTtcbn1cblxuLy8gc3JjL3N0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgdGhyZWFkczoge30sXG4gICAgcXVlcmllczoge30sXG4gICAgb3B0aW1pc3RpY1VwZGF0ZXM6IFtdLFxuICAgIGluYm94Tm90aWZpY2F0aW9uczoge30sXG4gICAgbm90aWZpY2F0aW9uU2V0dGluZ3M6IHt9XG4gIH0pO1xuICBjb25zdCBvcHRpbWlzdGljVXBkYXRlc0V2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIHJldHVybiB7XG4gICAgLi4uc3RvcmUsXG4gICAgZGVsZXRlVGhyZWFkKHRocmVhZElkKSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgdGhyZWFkczogZGVsZXRlS2V5SW1tdXRhYmxlKHN0YXRlLnRocmVhZHMsIHRocmVhZElkKSxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHN0YXRlLmluYm94Tm90aWZpY2F0aW9ucykuZmlsdGVyKFxuICAgICAgICAgICAgICAoW19pZCwgbm90aWZpY2F0aW9uXSkgPT4gbm90aWZpY2F0aW9uLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgbm90aWZpY2F0aW9uLnRocmVhZElkID09PSB0aHJlYWRJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlVGhyZWFkQW5kTm90aWZpY2F0aW9uKHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb24pIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZC5pZF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgdGhyZWFkczogZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCB8fCBjb21wYXJlVGhyZWFkcyh0aHJlYWQsIGV4aXN0aW5nVGhyZWFkKSA9PT0gMSA/IHsgLi4uc3RhdGUudGhyZWFkcywgW3RocmVhZC5pZF06IHRocmVhZCB9IDogc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDAgPyBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMgOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICBbaW5ib3hOb3RpZmljYXRpb24uaWRdOiBpbmJveE5vdGlmaWNhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnModGhyZWFkcywgaW5ib3hOb3RpZmljYXRpb25zLCBkZWxldGVkVGhyZWFkcywgZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucywgcXVlcnlLZXkpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB0aHJlYWRzOiBhcHBseVRocmVhZFVwZGF0ZXMoc3RhdGUudGhyZWFkcywge1xuICAgICAgICAgIG5ld1RocmVhZHM6IHRocmVhZHMsXG4gICAgICAgICAgZGVsZXRlZFRocmVhZHNcbiAgICAgICAgfSksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogYXBwbHlOb3RpZmljYXRpb25zVXBkYXRlcyhcbiAgICAgICAgICBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmV3SW5ib3hOb3RpZmljYXRpb25zOiBpbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICBkZWxldGVkTm90aWZpY2F0aW9uczogZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcXVlcmllczogcXVlcnlLZXkgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgICAuLi5zdGF0ZS5xdWVyaWVzLFxuICAgICAgICAgIFtxdWVyeUtleV06IHsgaXNMb2FkaW5nOiBmYWxzZSwgZGF0YTogdm9pZCAwIH1cbiAgICAgICAgfSA6IHN0YXRlLnF1ZXJpZXNcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHVwZGF0ZVJvb21JbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc2V0dGluZ3MsIHF1ZXJ5S2V5KSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgbm90aWZpY2F0aW9uU2V0dGluZ3M6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ub3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgICAgICBbcm9vbUlkXTogc2V0dGluZ3NcbiAgICAgICAgfSxcbiAgICAgICAgcXVlcmllczoge1xuICAgICAgICAgIC4uLnN0YXRlLnF1ZXJpZXMsXG4gICAgICAgICAgW3F1ZXJ5S2V5XTogeyBpc0xvYWRpbmc6IGZhbHNlLCBkYXRhOiB2b2lkIDAgfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBwdXNoT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlKSB7XG4gICAgICBvcHRpbWlzdGljVXBkYXRlc0V2ZW50U291cmNlLm5vdGlmeShvcHRpbWlzdGljVXBkYXRlKTtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogWy4uLnN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLCBvcHRpbWlzdGljVXBkYXRlXVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwgcXVlcnlTdGF0ZSkge1xuICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHF1ZXJpZXM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5xdWVyaWVzLFxuICAgICAgICAgIFtxdWVyeUtleV06IHF1ZXJ5U3RhdGVcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgb3B0aW1pc3RpY1VwZGF0ZXNFdmVudFNvdXJjZVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlS2V5SW1tdXRhYmxlKHJlY29yZCwga2V5KSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVjb3JkLCBrZXkpKSB7XG4gICAgY29uc3QgeyBba2V5XTogX3RvRGVsZXRlLCAuLi5yZXN0IH0gPSByZWNvcmQ7XG4gICAgcmV0dXJuIHJlc3Q7XG4gIH1cbiAgcmV0dXJuIHJlY29yZDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVUaHJlYWRzKHRocmVhZDEsIHRocmVhZDIpIHtcbiAgaWYgKHRocmVhZDEudXBkYXRlZEF0ICYmIHRocmVhZDIudXBkYXRlZEF0KSB7XG4gICAgcmV0dXJuIHRocmVhZDEudXBkYXRlZEF0ID4gdGhyZWFkMi51cGRhdGVkQXQgPyAxIDogdGhyZWFkMS51cGRhdGVkQXQgPCB0aHJlYWQyLnVwZGF0ZWRBdCA/IC0xIDogMDtcbiAgfSBlbHNlIGlmICh0aHJlYWQxLnVwZGF0ZWRBdCB8fCB0aHJlYWQyLnVwZGF0ZWRBdCkge1xuICAgIHJldHVybiB0aHJlYWQxLnVwZGF0ZWRBdCA/IDEgOiAtMTtcbiAgfVxuICBpZiAodGhyZWFkMS5jcmVhdGVkQXQgPiB0aHJlYWQyLmNyZWF0ZWRBdCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHRocmVhZDEuY3JlYXRlZEF0IDwgdGhyZWFkMi5jcmVhdGVkQXQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBhcHBseU9wdGltaXN0aWNVcGRhdGVzKHN0YXRlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB0aHJlYWRzOiB7XG4gICAgICAuLi5zdGF0ZS50aHJlYWRzXG4gICAgfSxcbiAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgIC4uLnN0YXRlLmluYm94Tm90aWZpY2F0aW9uc1xuICAgIH0sXG4gICAgbm90aWZpY2F0aW9uU2V0dGluZ3M6IHtcbiAgICAgIC4uLnN0YXRlLm5vdGlmaWNhdGlvblNldHRpbmdzXG4gICAgfVxuICB9O1xuICBmb3IgKGNvbnN0IG9wdGltaXN0aWNVcGRhdGUgb2Ygc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICBzd2l0Y2ggKG9wdGltaXN0aWNVcGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcImNyZWF0ZS10aHJlYWRcIjoge1xuICAgICAgICByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZC5pZF0gPSBvcHRpbWlzdGljVXBkYXRlLnRocmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZWRpdC10aHJlYWQtbWV0YWRhdGFcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlYWQudXBkYXRlZEF0ICE9PSB2b2lkIDAgJiYgdGhyZWFkLnVwZGF0ZWRBdCA+IG9wdGltaXN0aWNVcGRhdGUudXBkYXRlZEF0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IHtcbiAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgdXBkYXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLnVwZGF0ZWRBdCxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgLi4udGhyZWFkLm1ldGFkYXRhLFxuICAgICAgICAgICAgLi4ub3B0aW1pc3RpY1VwZGF0ZS5tZXRhZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay10aHJlYWQtYXMtcmVzb2x2ZWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIHJlc29sdmVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstdGhyZWFkLWFzLXVucmVzb2x2ZWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIHJlc29sdmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjcmVhdGUtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB1cHNlcnRDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpLmZpbmQoXG4gICAgICAgICAgKG5vdGlmaWNhdGlvbikgPT4gbm90aWZpY2F0aW9uLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgbm90aWZpY2F0aW9uLnRocmVhZElkID09PSB0aHJlYWQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW2luYm94Tm90aWZpY2F0aW9uLmlkXSA9IHtcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICBub3RpZmllZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0gdXBzZXJ0Q29tbWVudChcbiAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSBkZWxldGVDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtdGhyZWFkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdID0ge1xuICAgICAgICAgIC4uLnJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdLFxuICAgICAgICAgIGRlbGV0ZWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5kZWxldGVkQXQsXG4gICAgICAgICAgdXBkYXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdCxcbiAgICAgICAgICBjb21tZW50czogW11cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYWRkLXJlYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSBhZGRSZWFjdGlvbihcbiAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50SWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5yZWFjdGlvblxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJyZW1vdmUtcmVhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IHJlbW92ZVJlYWN0aW9uKFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmVtb2ppLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUudXNlcklkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUucmVtb3ZlZEF0XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9uLWFzLXJlYWRcIjoge1xuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF0gPSB7XG4gICAgICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF0sXG4gICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLnJlYWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLWFsbC1pbmJveC1ub3RpZmljYXRpb25zLWFzLXJlYWRcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW2lkXSA9IHtcbiAgICAgICAgICAgIC4uLnJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNbaWRdLFxuICAgICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLnJlYWRBdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWluYm94LW5vdGlmaWNhdGlvblwiOiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXTogXyxcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgfSA9IHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnM7XG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMgPSBpbmJveE5vdGlmaWNhdGlvbnM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1hbGwtaW5ib3gtbm90aWZpY2F0aW9uc1wiOiB7XG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMgPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXBkYXRlLW5vdGlmaWNhdGlvbi1zZXR0aW5nc1wiOiB7XG4gICAgICAgIHJlc3VsdC5ub3RpZmljYXRpb25TZXR0aW5nc1tvcHRpbWlzdGljVXBkYXRlLnJvb21JZF0gPSB7XG4gICAgICAgICAgLi4ucmVzdWx0Lm5vdGlmaWNhdGlvblNldHRpbmdzW29wdGltaXN0aWNVcGRhdGUucm9vbUlkXSxcbiAgICAgICAgICAuLi5vcHRpbWlzdGljVXBkYXRlLnNldHRpbmdzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhcHBseVRocmVhZFVwZGF0ZXMoZXhpc3RpbmdUaHJlYWRzLCB1cGRhdGVzKSB7XG4gIGNvbnN0IHVwZGF0ZWRUaHJlYWRzID0geyAuLi5leGlzdGluZ1RocmVhZHMgfTtcbiAgdXBkYXRlcy5uZXdUaHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gdXBkYXRlZFRocmVhZHNbdGhyZWFkLmlkXTtcbiAgICBpZiAoZXhpc3RpbmdUaHJlYWQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVUaHJlYWRzKGV4aXN0aW5nVGhyZWFkLCB0aHJlYWQpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gMSkgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVkVGhyZWFkc1t0aHJlYWQuaWRdID0gdGhyZWFkO1xuICB9KTtcbiAgdXBkYXRlcy5kZWxldGVkVGhyZWFkcy5mb3JFYWNoKCh7IGlkLCBkZWxldGVkQXQgfSkgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gdXBkYXRlZFRocmVhZHNbaWRdO1xuICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSByZXR1cm47XG4gICAgZXhpc3RpbmdUaHJlYWQuZGVsZXRlZEF0ID0gZGVsZXRlZEF0O1xuICAgIGV4aXN0aW5nVGhyZWFkLnVwZGF0ZWRBdCA9IGRlbGV0ZWRBdDtcbiAgICBleGlzdGluZ1RocmVhZC5jb21tZW50cyA9IFtdO1xuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZWRUaHJlYWRzO1xufVxuZnVuY3Rpb24gYXBwbHlOb3RpZmljYXRpb25zVXBkYXRlcyhleGlzdGluZ0luYm94Tm90aWZpY2F0aW9ucywgdXBkYXRlcykge1xuICBjb25zdCB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zID0geyAuLi5leGlzdGluZ0luYm94Tm90aWZpY2F0aW9ucyB9O1xuICB1cGRhdGVzLm5ld0luYm94Tm90aWZpY2F0aW9ucy5mb3JFYWNoKChub3RpZmljYXRpb24pID0+IHtcbiAgICBjb25zdCBleGlzdGluZ05vdGlmaWNhdGlvbiA9IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnNbbm90aWZpY2F0aW9uLmlkXTtcbiAgICBpZiAoZXhpc3RpbmdOb3RpZmljYXRpb24pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVJbmJveE5vdGlmaWNhdGlvbnMoXG4gICAgICAgIGV4aXN0aW5nTm90aWZpY2F0aW9uLFxuICAgICAgICBub3RpZmljYXRpb25cbiAgICAgICk7XG4gICAgICBpZiAocmVzdWx0ID09PSAxKSByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnNbbm90aWZpY2F0aW9uLmlkXSA9IG5vdGlmaWNhdGlvbjtcbiAgfSk7XG4gIHVwZGF0ZXMuZGVsZXRlZE5vdGlmaWNhdGlvbnMuZm9yRWFjaChcbiAgICAoeyBpZCB9KSA9PiBkZWxldGUgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tpZF1cbiAgKTtcbiAgcmV0dXJuIHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnM7XG59XG5mdW5jdGlvbiBjb21wYXJlSW5ib3hOb3RpZmljYXRpb25zKGluYm94Tm90aWZpY2F0aW9uQSwgaW5ib3hOb3RpZmljYXRpb25CKSB7XG4gIGlmIChpbmJveE5vdGlmaWNhdGlvbkEubm90aWZpZWRBdCA+IGluYm94Tm90aWZpY2F0aW9uQi5ub3RpZmllZEF0KSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoaW5ib3hOb3RpZmljYXRpb25BLm5vdGlmaWVkQXQgPCBpbmJveE5vdGlmaWNhdGlvbkIubm90aWZpZWRBdCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCAmJiBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0KSB7XG4gICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPiBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0ID8gMSA6IGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPCBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0ID8gLTEgOiAwO1xuICB9IGVsc2UgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgfHwgaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCkge1xuICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gdXBzZXJ0Q29tbWVudCh0aHJlYWQsIGNvbW1lbnQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGNvbW1lbnQudGhyZWFkSWQgIT09IHRocmVhZC5pZCkge1xuICAgIHdhcm4oXG4gICAgICBgQ29tbWVudCAke2NvbW1lbnQuaWR9IGRvZXMgbm90IGJlbG9uZyB0byB0aHJlYWQgJHt0aHJlYWQuaWR9YFxuICAgICk7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoZXhpc3RpbmdDb21tZW50MikgPT4gZXhpc3RpbmdDb21tZW50Mi5pZCA9PT0gY29tbWVudC5pZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwLCBjb21tZW50LmNyZWF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVkVGhyZWFkID0ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgdXBkYXRlZEF0LFxuICAgICAgY29tbWVudHM6IFsuLi50aHJlYWQuY29tbWVudHMsIGNvbW1lbnRdXG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmVkaXRlZEF0ID09PSB2b2lkIDAgfHwgY29tbWVudC5lZGl0ZWRBdCA9PT0gdm9pZCAwIHx8IGV4aXN0aW5nQ29tbWVudC5lZGl0ZWRBdCA8PSBjb21tZW50LmVkaXRlZEF0KSB7XG4gICAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAgIChleGlzdGluZ0NvbW1lbnQyKSA9PiBleGlzdGluZ0NvbW1lbnQyLmlkID09PSBjb21tZW50LmlkID8gY29tbWVudCA6IGV4aXN0aW5nQ29tbWVudDJcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZWRUaHJlYWQgPSB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICB0aHJlYWQudXBkYXRlZEF0Py5nZXRUaW1lKCkgfHwgMCxcbiAgICAgICAgICBjb21tZW50LmVkaXRlZEF0Py5nZXRUaW1lKCkgfHwgY29tbWVudC5jcmVhdGVkQXQuZ2V0VGltZSgpXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgfVxuICByZXR1cm4gdGhyZWFkO1xufVxuZnVuY3Rpb24gZGVsZXRlQ29tbWVudCh0aHJlYWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgZGVsZXRlZEF0LFxuICAgICAgYm9keTogdm9pZCAwXG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgaWYgKCF1cGRhdGVkQ29tbWVudHMuc29tZSgoY29tbWVudCkgPT4gY29tbWVudC5kZWxldGVkQXQgPT09IHZvaWQgMCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgZGVsZXRlZEF0LFxuICAgICAgdXBkYXRlZEF0OiBkZWxldGVkQXQsXG4gICAgICBjb21tZW50czogW11cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4udGhyZWFkLFxuICAgIHVwZGF0ZWRBdDogZGVsZXRlZEF0LFxuICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZFJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCByZWFjdGlvbikge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIHJlYWN0aW9uczogdXBzZXJ0UmVhY3Rpb24oY29tbWVudC5yZWFjdGlvbnMsIHJlYWN0aW9uKVxuICAgIH0gOiBjb21tZW50XG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4udGhyZWFkLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoXG4gICAgICBNYXRoLm1heChyZWFjdGlvbi5jcmVhdGVkQXQuZ2V0VGltZSgpLCB0aHJlYWQudXBkYXRlZEF0Py5nZXRUaW1lKCkgfHwgMClcbiAgICApLFxuICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCBlbW9qaSwgdXNlcklkLCByZW1vdmVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IGNvbW1lbnQucmVhY3Rpb25zLm1hcChcbiAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamkgPyB7XG4gICAgICAgICAgLi4ucmVhY3Rpb24sXG4gICAgICAgICAgdXNlcnM6IHJlYWN0aW9uLnVzZXJzLmZpbHRlcigodXNlcikgPT4gdXNlci5pZCAhPT0gdXNlcklkKVxuICAgICAgICB9IDogcmVhY3Rpb25cbiAgICAgICkuZmlsdGVyKChyZWFjdGlvbikgPT4gcmVhY3Rpb24udXNlcnMubGVuZ3RoID4gMClcbiAgICAgIC8vIFJlbW92ZSByZWFjdGlvbnMgd2l0aCBubyB1c2VycyBsZWZ0XG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHJlbW92ZWRBdC5nZXRUaW1lKCksIHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwKVxuICAgICksXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gdXBzZXJ0UmVhY3Rpb24ocmVhY3Rpb25zLCByZWFjdGlvbikge1xuICBjb25zdCBleGlzdGluZ1JlYWN0aW9uID0gcmVhY3Rpb25zLmZpbmQoXG4gICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamlcbiAgKTtcbiAgaWYgKGV4aXN0aW5nUmVhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5yZWFjdGlvbnMsXG4gICAgICB7XG4gICAgICAgIGVtb2ppOiByZWFjdGlvbi5lbW9qaSxcbiAgICAgICAgY3JlYXRlZEF0OiByZWFjdGlvbi5jcmVhdGVkQXQsXG4gICAgICAgIHVzZXJzOiBbeyBpZDogcmVhY3Rpb24udXNlcklkIH1dXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBpZiAoZXhpc3RpbmdSZWFjdGlvbi51c2Vycy5zb21lKCh1c2VyKSA9PiB1c2VyLmlkID09PSByZWFjdGlvbi51c2VySWQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiByZWFjdGlvbnMubWFwKFxuICAgICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamkgPyB7XG4gICAgICAgIC4uLmV4aXN0aW5nUmVhY3Rpb24yLFxuICAgICAgICB1c2VyczogWy4uLmV4aXN0aW5nUmVhY3Rpb24yLnVzZXJzLCB7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH0gOiBleGlzdGluZ1JlYWN0aW9uMlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlYWN0aW9ucztcbn1cblxuLy8gc3JjL2NsaWVudC50c1xudmFyIE1JTl9USFJPVFRMRSA9IDE2O1xudmFyIE1BWF9USFJPVFRMRSA9IDFlMztcbnZhciBERUZBVUxUX1RIUk9UVExFID0gMTAwO1xudmFyIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVCA9IDE1ZTM7XG52YXIgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMjAwO1xudmFyIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDFlMztcbnZhciBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAzZTQ7XG52YXIgREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDVlMztcbnZhciBSRVNPTFZFX1VTRVJTX0JBVENIX0RFTEFZID0gNTA7XG52YXIgUkVTT0xWRV9ST09NU19JTkZPX0JBVENIX0RFTEFZID0gNTA7XG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgaWYgKHR5cGVvZiBiYXNlVXJsID09PSBcInN0cmluZ1wiICYmIGJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4gYmFzZVVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CQVNFX1VSTDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKSB7XG4gIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgIHJldHVybiBhdXRoVmFsdWUucHVibGljQXBpS2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdXRoVmFsdWUudG9rZW4ucmF3O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnQob3B0aW9ucykge1xuICBjb25zdCBjbGllbnRPcHRpb25zID0gb3B0aW9ucztcbiAgY29uc3QgdGhyb3R0bGVEZWxheSA9IGdldFRocm90dGxlKGNsaWVudE9wdGlvbnMudGhyb3R0bGUgPz8gREVGQVVMVF9USFJPVFRMRSk7XG4gIGNvbnN0IGxvc3RDb25uZWN0aW9uVGltZW91dCA9IGdldExvc3RDb25uZWN0aW9uVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmxvc3RDb25uZWN0aW9uVGltZW91dCA/PyBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG4gIGNvbnN0IGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ID0gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFxuICApO1xuICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybChjbGllbnRPcHRpb25zLmJhc2VVcmwpO1xuICBjb25zdCBhdXRoTWFuYWdlciA9IGNyZWF0ZUF1dGhNYW5hZ2VyKG9wdGlvbnMpO1xuICBjb25zdCByb29tc0J5SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiB0ZWFyZG93blJvb20ocm9vbSkge1xuICAgIHVubGlua0RldlRvb2xzKHJvb20uaWQpO1xuICAgIHJvb21zQnlJZC5kZWxldGUocm9vbS5pZCk7XG4gICAgcm9vbS5kZXN0cm95KCk7XG4gIH1cbiAgZnVuY3Rpb24gbGVhc2VSb29tKGRldGFpbHMpIHtcbiAgICBjb25zdCBsZWF2ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGYgPSBsZWF2ZTtcbiAgICAgIGlmICghZGV0YWlscy51bnN1YnMuZGVsZXRlKHNlbGYpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGlzIGxlYXZlIGZ1bmN0aW9uIHdhcyBhbHJlYWR5IGNhbGxlZC4gQ2FsbGluZyBpdCBtb3JlIHRoYW4gb25jZSBoYXMgbm8gZWZmZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGV0YWlscy51bnN1YnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRlYXJkb3duUm9vbShkZXRhaWxzLnJvb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBkZXRhaWxzLnVuc3Vicy5hZGQobGVhdmUpO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiBkZXRhaWxzLnJvb20sXG4gICAgICBsZWF2ZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXJSb29tKHJvb21JZCwgLi4uYXJncykge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcm9vbXNCeUlkLmdldChyb29tSWQpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVhc2VSb29tKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uczIgPSBhcmdzWzBdID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9ICh0eXBlb2Ygb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSkgPz8ge307XG4gICAgY29uc3QgaW5pdGlhbFN0b3JhZ2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsU3RvcmFnZShyb29tSWQpIDogb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2UpID8/IHt9O1xuICAgIGNvbnN0IG5ld1Jvb20gPSBjcmVhdGVSb29tKFxuICAgICAgeyBpbml0aWFsUHJlc2VuY2UsIGluaXRpYWxTdG9yYWdlIH0sXG4gICAgICB7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgdGhyb3R0bGVEZWxheSxcbiAgICAgICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgcG9seWZpbGxzOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscyxcbiAgICAgICAgZGVsZWdhdGVzOiBjbGllbnRPcHRpb25zLm1vY2tlZERlbGVnYXRlcyA/PyB7XG4gICAgICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5XZWJTb2NrZXRcbiAgICAgICAgICApLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcilcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2dnaW5nOiBjbGllbnRPcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IG9wdGlvbnMyPy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgdW5zdGFibGVfZmFsbGJhY2tUb0hUVFA6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCxcbiAgICAgICAgdW5zdGFibGVfc3RyZWFtRGF0YTogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX3N0cmVhbURhdGFcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IG5ld1Jvb21EZXRhaWxzID0ge1xuICAgICAgcm9vbTogbmV3Um9vbSxcbiAgICAgIHVuc3ViczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgcm9vbXNCeUlkLnNldChyb29tSWQsIG5ld1Jvb21EZXRhaWxzKTtcbiAgICBzZXR1cERldlRvb2xzKCgpID0+IEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSkpO1xuICAgIGxpbmtEZXZUb29scyhyb29tSWQsIG5ld1Jvb20pO1xuICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSBvcHRpb25zMi5hdXRvQ29ubmVjdCA/PyB0cnVlO1xuICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGF0b2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5hdG9iID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIllvdSBuZWVkIHRvIHBvbHlmaWxsIGF0b2IgdG8gdXNlIHRoZSBjbGllbnQgaW4geW91ciBlbnZpcm9ubWVudC4gUGxlYXNlIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGF0IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLWNsaWVudC9hdG9iLXBvbHlmaWxsXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbC5hdG9iID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMuYXRvYjtcbiAgICAgIH1cbiAgICAgIG5ld1Jvb20uY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhc2VSb29tKG5ld1Jvb21EZXRhaWxzKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJvb20gPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnJvb207XG4gICAgcmV0dXJuIHJvb20gPyByb29tIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgYXV0aE1hbmFnZXIucmVzZXQoKTtcbiAgICBmb3IgKGNvbnN0IHsgcm9vbSB9IG9mIHJvb21zQnlJZC52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFpc0lkbGUocm9vbS5nZXRTdGF0dXMoKSkpIHtcbiAgICAgICAgcm9vbS5yZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY3VycmVudFVzZXJJZFN0b3JlID0gY3JlYXRlU3RvcmUobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zLFxuICAgIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uXG4gIH0gPSBjcmVhdGVOb3RpZmljYXRpb25zQXBpKHtcbiAgICBiYXNlVXJsLFxuICAgIGZldGNoZXI6IGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZldGNoLFxuICAgIGF1dGhNYW5hZ2VyLFxuICAgIGN1cnJlbnRVc2VySWRTdG9yZVxuICB9KTtcbiAgY29uc3QgY2FjaGVTdG9yZSA9IGNyZWF0ZUNsaWVudFN0b3JlKCk7XG4gIGNvbnN0IHJlc29sdmVVc2VycyA9IGNsaWVudE9wdGlvbnMucmVzb2x2ZVVzZXJzO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVVc2VycyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVVzZXJzLFxuICAgIFwiU2V0IHRoZSByZXNvbHZlVXNlcnMgb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHVzZXIgaW5mby5cIlxuICApO1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShcbiAgICBhc3luYyAoYmF0Y2hlZFVzZXJJZHMpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZHMgPSBiYXRjaGVkVXNlcklkcy5mbGF0KCk7XG4gICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycz8uKHsgdXNlcklkcyB9KTtcbiAgICAgIHdhcm5JZk5vUmVzb2x2ZVVzZXJzKCk7XG4gICAgICByZXR1cm4gdXNlcnMgPz8gdXNlcklkcy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICB9LFxuICAgIHsgZGVsYXk6IFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCByZXNvbHZlUm9vbXNJbmZvID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlUm9vbXNJbmZvO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8gPSBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoXG4gICAgKCkgPT4gIXJlc29sdmVSb29tc0luZm8sXG4gICAgXCJTZXQgdGhlIHJlc29sdmVSb29tc0luZm8gb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHJvb20gaW5mby5cIlxuICApO1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoXG4gICAgYXN5bmMgKGJhdGNoZWRSb29tSWRzKSA9PiB7XG4gICAgICBjb25zdCByb29tSWRzID0gYmF0Y2hlZFJvb21JZHMuZmxhdCgpO1xuICAgICAgY29uc3Qgcm9vbXNJbmZvID0gYXdhaXQgcmVzb2x2ZVJvb21zSW5mbz8uKHsgcm9vbUlkcyB9KTtcbiAgICAgIHdhcm5JZk5vUmVzb2x2ZVJvb21zSW5mbygpO1xuICAgICAgcmV0dXJuIHJvb21zSW5mbyA/PyByb29tSWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9ST09NU19JTkZPX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBlbnRlclJvb20sXG4gICAgICBnZXRSb29tLFxuICAgICAgbG9nb3V0LFxuICAgICAgLy8gSW50ZXJuYWxcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgICAgICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICAgICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgICAgICAgZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbnRVc2VySWRTdG9yZSxcbiAgICAgICAgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uczogY2xpZW50T3B0aW9ucy5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zLFxuICAgICAgICBjYWNoZVN0b3JlLFxuICAgICAgICB1c2Vyc1N0b3JlLFxuICAgICAgICByb29tc0luZm9TdG9yZSxcbiAgICAgICAgZ2V0Um9vbUlkcygpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyb29tc0J5SWQua2V5cygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAga0ludGVybmFsLFxuICAgIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfVxuICApO1xufVxudmFyIE5vdGlmaWNhdGlvbnNBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn07XG5mdW5jdGlvbiBjaGVja0JvdW5kcyhvcHRpb24sIHZhbHVlLCBtaW4sIG1heCwgcmVjb21tZW5kZWRNaW4pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIG1heCAhPT0gdm9pZCAwID8gYCR7b3B0aW9ufSBzaG91bGQgYmUgYmV0d2VlbiAke3JlY29tbWVuZGVkTWluID8/IG1pbn0gYW5kICR7bWF4fS5gIDogYCR7b3B0aW9ufSBzaG91bGQgYmUgYXQgbGVhc3QgJHtyZWNvbW1lbmRlZE1pbiA/PyBtaW59LmBcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gZ2V0VGhyb3R0bGUodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFwidGhyb3R0bGVcIiwgdmFsdWUsIE1JTl9USFJPVFRMRSwgTUFYX1RIUk9UVExFKTtcbn1cbmZ1bmN0aW9uIGdldExvc3RDb25uZWN0aW9uVGltZW91dCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJsb3N0Q29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKGNvbmRpdGlvbiwgLi4uYXJncykge1xuICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFoYXNXYXJuZWQgJiYgKHR5cGVvZiBjb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGNvbmRpdGlvbigpIDogY29uZGl0aW9uKSkge1xuICAgICAgICB3YXJuKC4uLmFyZ3MpO1xuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9jb21tZW50cy9jb21tZW50LWJvZHkudHNcbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keVRleHQoZWxlbWVudCkge1xuICByZXR1cm4gIShcInR5cGVcIiBpbiBlbGVtZW50KSAmJiBcInRleHRcIiBpbiBlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LnRleHQgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5TWVudGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJtZW50aW9uXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5TGluayhlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJsaW5rXCI7XG59XG52YXIgY29tbWVudEJvZHlFbGVtZW50c0d1YXJkcyA9IHtcbiAgcGFyYWdyYXBoOiBpc0NvbW1lbnRCb2R5UGFyYWdyYXBoLFxuICB0ZXh0OiBpc0NvbW1lbnRCb2R5VGV4dCxcbiAgbGluazogaXNDb21tZW50Qm9keUxpbmssXG4gIG1lbnRpb246IGlzQ29tbWVudEJvZHlNZW50aW9uXG59O1xudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlcyA9IHtcbiAgcGFyYWdyYXBoOiBcImJsb2NrXCIsXG4gIHRleHQ6IFwiaW5saW5lXCIsXG4gIGxpbms6IFwiaW5saW5lXCIsXG4gIG1lbnRpb246IFwiaW5saW5lXCJcbn07XG5mdW5jdGlvbiB0cmF2ZXJzZUNvbW1lbnRCb2R5KGJvZHksIGVsZW1lbnRPclZpc2l0b3IsIHBvc3NpYmx5VmlzaXRvcikge1xuICBpZiAoIWJvZHkgfHwgIWJvZHk/LmNvbnRlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50T3JWaXNpdG9yID09PSBcInN0cmluZ1wiID8gZWxlbWVudE9yVmlzaXRvciA6IHZvaWQgMDtcbiAgY29uc3QgdHlwZSA9IGVsZW1lbnQgPyBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXNbZWxlbWVudF0gOiBcImFsbFwiO1xuICBjb25zdCBndWFyZCA9IGVsZW1lbnQgPyBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzW2VsZW1lbnRdIDogKCkgPT4gdHJ1ZTtcbiAgY29uc3QgdmlzaXRvciA9IHR5cGVvZiBlbGVtZW50T3JWaXNpdG9yID09PSBcImZ1bmN0aW9uXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogcG9zc2libHlWaXNpdG9yO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJvZHkuY29udGVudCkge1xuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgaWYgKGd1YXJkKGJsb2NrKSkge1xuICAgICAgICB2aXNpdG9yPy4oYmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGlubGluZSBvZiBibG9jay5jaGlsZHJlbikge1xuICAgICAgICBpZiAoZ3VhcmQoaW5saW5lKSkge1xuICAgICAgICAgIHZpc2l0b3I/LihpbmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHkoYm9keSkge1xuICBjb25zdCBtZW50aW9uZWRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB0cmF2ZXJzZUNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgXCJtZW50aW9uXCIsXG4gICAgKG1lbnRpb24pID0+IG1lbnRpb25lZElkcy5hZGQobWVudGlvbi5pZClcbiAgKTtcbiAgcmV0dXJuIEFycmF5LmZyb20obWVudGlvbmVkSWRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkoYm9keSwgcmVzb2x2ZVVzZXJzKSB7XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAoIXJlc29sdmVVc2Vycykge1xuICAgIHJldHVybiByZXNvbHZlZFVzZXJzO1xuICB9XG4gIGNvbnN0IHVzZXJJZHMgPSBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHkoYm9keSk7XG4gIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzKHtcbiAgICB1c2VySWRzXG4gIH0pO1xuICBmb3IgKGNvbnN0IFtpbmRleCwgdXNlcklkXSBvZiB1c2VySWRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IHVzZXIgPSB1c2Vycz8uW2luZGV4XTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmVzb2x2ZWRVc2Vycy5zZXQodXNlcklkLCB1c2VyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG59XG52YXIgaHRtbEVzY2FwYWJsZXMgPSB7XG4gIFwiJlwiOiBcIiZhbXA7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICAnXCInOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImIzM5O1wiXG59O1xudmFyIGh0bWxFc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhodG1sRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gaHRtbFNhZmUodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbU3RyaW5nKHZhbHVlKV0sIFtdKTtcbn1cbmZ1bmN0aW9uIGpvaW5IdG1sKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtcIlwiXSwgW10pO1xuICB9XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlSHRtbCh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIdG1sU2FmZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBqb2luSHRtbCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIGh0bWxFc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gaHRtbEVzY2FwYWJsZXNbY2hhcmFjdGVyXVxuICApO1xufVxudmFyIEh0bWxTYWZlU3RyaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICB0aGlzLl9zdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZUh0bWwobm4odGhpcy5fdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gaHRtbChzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMpO1xufVxudmFyIG1hcmtkb3duRXNjYXBhYmxlcyA9IHtcbiAgXzogXCJcXFxcX1wiLFxuICBcIipcIjogXCJcXFxcKlwiLFxuICBcIiNcIjogXCJcXFxcI1wiLFxuICBcImBcIjogXCJcXFxcYFwiLFxuICBcIn5cIjogXCJcXFxcflwiLFxuICBcIiFcIjogXCJcXFxcIVwiLFxuICBcInxcIjogXCJcXFxcfFwiLFxuICBcIihcIjogXCJcXFxcKFwiLFxuICBcIilcIjogXCJcXFxcKVwiLFxuICBcIntcIjogXCJcXFxce1wiLFxuICBcIn1cIjogXCJcXFxcfVwiLFxuICBcIltcIjogXCJcXFxcW1wiLFxuICBcIl1cIjogXCJcXFxcXVwiXG59O1xudmFyIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMobWFya2Rvd25Fc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBqb2luTWFya2Rvd24oc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFtcIlwiXSwgW10pO1xuICB9XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZU1hcmtkb3duKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcmtkb3duU2FmZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBqb2luTWFya2Rvd24odmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBtYXJrZG93bkVzY2FwYWJsZXNbY2hhcmFjdGVyXVxuICApO1xufVxudmFyIE1hcmtkb3duU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgdGhpcy5fc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVNYXJrZG93bihubih0aGlzLl92YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBtYXJrZG93bihzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoc3RyaW5ncywgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIHRvQWJzb2x1dGVVcmwodXJsKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgdXJsLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH0gZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgcmV0dXJuIFwiaHR0cHM6Ly9cIiArIHVybDtcbiAgfVxuICByZXR1cm47XG59XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IGNoaWxkcmVuLFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCxcbiAgbGluazogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmwsXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBgQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbiA/IGh0bWxgPHA+JHtodG1sU2FmZShjaGlsZHJlbil9PC9wPmAgOiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzdHJvbmc+JHtjaGlsZHJlbn08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8ZW0+JHtjaGlsZHJlbn08L2VtPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8cz4ke2NoaWxkcmVufTwvcz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGNvZGU+JHtjaGlsZHJlbn08L2NvZGU+YDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8YSBocmVmPVwiJHtocmVmfVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj4ke2VsZW1lbnQudGV4dCA/PyBlbGVtZW50LnVybH08L2E+YDtcbiAgfSxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPHNwYW4gZGF0YS1tZW50aW9uPkAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH08L3NwYW4+YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmAqKiR7Y2hpbGRyZW59KipgO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXyR7Y2hpbGRyZW59X2A7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gfn4ke2NoaWxkcmVufX5+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBcXGAke2NoaWxkcmVufVxcYGA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIG1hcmtkb3duYFske2VsZW1lbnQudGV4dCA/PyBlbGVtZW50LnVybH1dKCR7aHJlZn0pYDtcbiAgfSxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIG1hcmtkb3duYEAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gc3RyaW5naWZ5Q29tbWVudEJvZHkoYm9keSwgb3B0aW9ucykge1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgPz8gXCJwbGFpblwiO1xuICBjb25zdCBzZXBhcmF0b3IgPSBvcHRpb25zPy5zZXBhcmF0b3IgPz8gKGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gXCJcXG5cXG5cIiA6IFwiXFxuXCIpO1xuICBjb25zdCBlbGVtZW50cyA9IHtcbiAgICAuLi5mb3JtYXQgPT09IFwiaHRtbFwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgOiBmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA6IHN0cmluZ2lmeUNvbW1lbnRCb2R5UGxhaW5FbGVtZW50cyxcbiAgICAuLi5vcHRpb25zPy5lbGVtZW50c1xuICB9O1xuICBjb25zdCByZXNvbHZlZFVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIG9wdGlvbnM/LnJlc29sdmVVc2Vyc1xuICApO1xuICBjb25zdCBibG9ja3MgPSBib2R5LmNvbnRlbnQuZmxhdE1hcCgoYmxvY2ssIGJsb2NrSW5kZXgpID0+IHtcbiAgICBzd2l0Y2ggKGJsb2NrLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJwYXJhZ3JhcGhcIjoge1xuICAgICAgICBjb25zdCBpbmxpbmVzID0gYmxvY2suY2hpbGRyZW4uZmxhdE1hcCgoaW5saW5lLCBpbmxpbmVJbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TWVudGlvbihpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5saW5lLmlkID8gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5tZW50aW9uKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIHVzZXI6IHJlc29sdmVkVXNlcnMuZ2V0KGlubGluZS5pZClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0gOiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlMaW5rKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLmxpbmsoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgaHJlZjogdG9BYnNvbHV0ZVVybChpbmxpbmUudXJsKSA/PyBpbmxpbmUudXJsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keVRleHQoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50cy50ZXh0KHsgZWxlbWVudDogaW5saW5lIH0sIGlubGluZUluZGV4KV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZWxlbWVudHMucGFyYWdyYXBoKFxuICAgICAgICAgICAgeyBlbGVtZW50OiBibG9jaywgY2hpbGRyZW46IGlubGluZXMuam9pbihcIlwiKSB9LFxuICAgICAgICAgICAgYmxvY2tJbmRleFxuICAgICAgICAgIClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYmxvY2tzLmpvaW4oc2VwYXJhdG9yKTtcbn1cblxuLy8gc3JjL2NyZHRzL3V0aWxzLnRzXG5mdW5jdGlvbiB0b1BsYWluTHNvbihsc29uKSB7XG4gIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGxzb24udG9PYmplY3QoKSkuZmxhdE1hcChcbiAgICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gW1trZXksIHRvUGxhaW5Mc29uKHZhbHVlKV1dIDogW11cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBbLi4ubHNvbl0ubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHRvUGxhaW5Mc29uKHZhbHVlKV0pXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGRhdGE6IFsuLi5sc29uXS5tYXAoKGl0ZW0pID0+IHRvUGxhaW5Mc29uKGl0ZW0pKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxzb247XG4gIH1cbn1cblxuLy8gc3JjL2ltbXV0YWJsZS50c1xuZnVuY3Rpb24gbHNvbk9iamVjdFRvSnNvbihvYmopIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHZhbCA9IG9ialtrZXldO1xuICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsaXZlT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QpIHtcbiAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24obGl2ZU9iamVjdC50b09iamVjdCgpKTtcbn1cbmZ1bmN0aW9uIGxpdmVNYXBUb0pzb24obWFwKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbHNvbkxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChsc29uVG9Kc29uKTtcbn1cbmZ1bmN0aW9uIGxpdmVMaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZS50b0FycmF5KCkpO1xufVxuZnVuY3Rpb24gbHNvblRvSnNvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIGxpdmVPYmplY3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gbGl2ZUxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiBsaXZlTWFwVG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiB2YWx1ZS5kYXRhO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZGVlcExpdmVpZnkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdCh2YWx1ZS5tYXAoZGVlcExpdmVpZnkpKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IGluaXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgdmFsID0gdmFsdWVba2V5XTtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGluaXRba2V5XSA9IGRlZXBMaXZlaWZ5KHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChpbml0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZUxpc3QobGl2ZUxpc3QsIHByZXYsIG5leHQpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgcHJldkVuZCA9IHByZXYubGVuZ3RoIC0gMTtcbiAgbGV0IG5leHRFbmQgPSBuZXh0Lmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2Tm9kZSA9IHByZXZbMF07XG4gIGxldCBuZXh0Tm9kZSA9IG5leHRbMF07XG4gIG91dGVyOiB7XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgKytpO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgIH1cbiAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgIHByZXZFbmQtLTtcbiAgICAgIG5leHRFbmQtLTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB9XG4gIH1cbiAgaWYgKGkgPiBwcmV2RW5kKSB7XG4gICAgaWYgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGkgPiBuZXh0RW5kKSB7XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGkgPD0gcHJldkVuZCAmJiBpIDw9IG5leHRFbmQpIHtcbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICAgIGNvbnN0IGxpdmVMaXN0Tm9kZSA9IGxpdmVMaXN0LmdldChpKTtcbiAgICAgIGlmIChpc0xpdmVPYmplY3QobGl2ZUxpc3ROb2RlKSAmJiBpc1BsYWluT2JqZWN0KHByZXZOb2RlKSAmJiBpc1BsYWluT2JqZWN0KG5leHROb2RlKSkge1xuICAgICAgICBwYXRjaExpdmVPYmplY3QobGl2ZUxpc3ROb2RlLCBwcmV2Tm9kZSwgbmV4dE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZUxpc3Quc2V0KGksIGRlZXBMaXZlaWZ5KG5leHROb2RlKSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3RLZXkobGl2ZU9iamVjdCwga2V5LCBwcmV2LCBuZXh0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBub25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXh0KTtcbiAgICBpZiAobm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgIGVycm9yMihcbiAgICAgICAgYE5ldyBzdGF0ZSBwYXRoOiAnJHtub25TZXJpYWxpemFibGVWYWx1ZS5wYXRofScgdmFsdWU6ICcke1N0cmluZyhcbiAgICAgICAgICBub25TZXJpYWxpemFibGVWYWx1ZS52YWx1ZVxuICAgICAgICApfScgaXMgbm90IHNlcmlhbGl6YWJsZS5cbk9ubHkgc2VyaWFsaXphYmxlIHZhbHVlIGNhbiBiZSBzeW5jZWQgd2l0aCBMaXZlYmxvY2tzLmBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHZhbHVlID0gbGl2ZU9iamVjdC5nZXQoa2V5KTtcbiAgaWYgKG5leHQgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3QuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9IGVsc2UgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaXNMaXZlTGlzdCh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShwcmV2KSAmJiBBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlTGlzdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSBpZiAoaXNMaXZlT2JqZWN0KHZhbHVlKSAmJiBpc1BsYWluT2JqZWN0KHByZXYpICYmIGlzUGxhaW5PYmplY3QobmV4dCkpIHtcbiAgICBwYXRjaExpdmVPYmplY3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2Uge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3Qocm9vdCwgcHJldiwgbmV4dCkge1xuICBjb25zdCB1cGRhdGVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICBwYXRjaExpdmVPYmplY3RLZXkocm9vdCwga2V5LCBwcmV2W2tleV0sIG5leHRba2V5XSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgIGlmIChuZXh0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgcm9vdC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICByb290LnVwZGF0ZSh1cGRhdGVzKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyZW50c1BhdGgobm9kZSkge1xuICBjb25zdCBwYXRoID0gW107XG4gIHdoaWxlIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgaWYgKGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5ub2RlLl9pbmRleE9mUG9zaXRpb24obm9kZS5wYXJlbnQua2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5rZXkpO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnQubm9kZTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdChzdGF0ZSwgdXBkYXRlcykge1xuICByZXR1cm4gdXBkYXRlcy5yZWR1Y2UoXG4gICAgKHN0YXRlMiwgdXBkYXRlKSA9PiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlMiwgdXBkYXRlKSxcbiAgICBzdGF0ZVxuICApO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZSwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGggPSBnZXRQYXJlbnRzUGF0aCh1cGRhdGUubm9kZSk7XG4gIHJldHVybiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGhJdGVtID0gcGF0aC5wb3AoKTtcbiAgaWYgKHBhdGhJdGVtID09PSB2b2lkIDApIHtcbiAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiTGl2ZU9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlT2JqZWN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZUxpc3RcIjoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVMaXN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIGFycmF5XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLm1hcCgoeCkgPT4geCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdFVwZGF0ZSBvZiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUubWFwKFxuICAgICAgICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGluZGV4ID09PSBsaXN0VXBkYXRlLmluZGV4ID8gbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pIDogaXRlbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUuaW5kZXggPT09IG5ld1N0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZS5wdXNoKGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleClcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUuc3BsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCA+IGxpc3RVcGRhdGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5pbmRleCArIDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVNYXBcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU1hcCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICBjb25zdCBuZXdBcnJheSA9IFsuLi5zdGF0ZV07XG4gICAgbmV3QXJyYXlbcGF0aEl0ZW1dID0gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShcbiAgICAgIHN0YXRlW3BhdGhJdGVtXSxcbiAgICAgIHBhdGgsXG4gICAgICB1cGRhdGVcbiAgICApO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSBlbHNlIGlmIChpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN0YXRlW3BhdGhJdGVtXTtcbiAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXRlQXNPYmogPSBzdGF0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlQXNPYmosXG4gICAgICAgIFtwYXRoSXRlbV06IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUobm9kZSwgcGF0aCwgdXBkYXRlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vIHNyYy9saWIvZGVwcmVjYXRpb24udHNcbnZhciBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmhhcyhrZXkpKSB7XG4gICAgICBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuYWRkKGtleSk7XG4gICAgICBlcnJvcldpdGhUaXRsZShcIkRlcHJlY2F0aW9uIHdhcm5pbmdcIiwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXByZWNhdGVJZihjb25kaXRpb24sIG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IHVzYWdlRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgdXNhZ2VFcnJvci5uYW1lID0gXCJVc2FnZSBlcnJvclwiO1xuICAgIGVycm9yV2l0aFRpdGxlKFwiVXNhZ2UgZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgdGhyb3cgdXNhZ2VFcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JJZihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9Qb2xsZXIudHNcbmZ1bmN0aW9uIG1ha2VQb2xsZXIoY2FsbGJhY2spIHtcbiAgbGV0IGNvbnRleHQgPSB7XG4gICAgc3RhdGU6IFwic3RvcHBlZFwiLFxuICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgaW50ZXJ2YWw6IG51bGwsXG4gICAgbGFzdFNjaGVkdWxlZEF0OiBudWxsLFxuICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gIH07XG4gIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICBzY2hlZHVsZShjb250ZXh0LmludGVydmFsKTtcbiAgICB9XG4gICAgdm9pZCBjYWxsYmFjaygpO1xuICB9XG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGludGVydmFsKSB7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInJ1bm5pbmdcIixcbiAgICAgIGludGVydmFsOiBjb250ZXh0LnN0YXRlICE9PSBcInN0b3BwZWRcIiA/IGNvbnRleHQuaW50ZXJ2YWwgOiBpbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKSxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzY2hlZHVsZVJlbWFpbmluZyhyZW1haW5pbmcpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJwYXVzZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicnVubmluZ1wiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogc2V0VGltZW91dChwb2xsLCByZW1haW5pbmcpLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KGludGVydmFsKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlKGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KGludGVydmFsKSB7XG4gICAgc3RvcCgpO1xuICAgIHN0YXJ0KGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInBhdXNlZFwiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBjb250ZXh0LmludGVydmFsIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gY29udGV4dC5sYXN0U2NoZWR1bGVkQXQpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09IFwicGF1c2VkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW1haW5pbmcoY29udGV4dC5yZW1haW5pbmdJbnRlcnZhbCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJzdG9wcGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQudGltZW91dEhhbmRsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgfVxuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJzdG9wcGVkXCIsXG4gICAgICBpbnRlcnZhbDogbnVsbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogbnVsbCxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICByZXN0YXJ0LFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqQSkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iakIpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgQ2xpZW50TXNnQ29kZSxcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgQ3JkdFR5cGUsXG4gIExpdmVMaXN0LFxuICBMaXZlTWFwLFxuICBMaXZlT2JqZWN0LFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIE9wQ29kZSxcbiAgU2VydmVyTXNnQ29kZSxcbiAgV2Vic29ja2V0Q2xvc2VDb2RlcyxcbiAgYWNrT3AsXG4gIGFkZFJlYWN0aW9uLFxuICBhcHBseU9wdGltaXN0aWNVcGRhdGVzLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYjY0ZGVjb2RlLFxuICBjbG9uZUxzb24sXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBjcmVhdGVDbGllbnQsXG4gIGRlbGV0ZUNvbW1lbnQsXG4gIGRlcHJlY2F0ZSxcbiAgZGVwcmVjYXRlSWYsXG4gIGRldGVjdER1cGVzLFxuICBlcnJvcklmLFxuICBmcmVlemUsXG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgaXNDaGlsZENyZHQsXG4gIGlzSnNvbkFycmF5LFxuICBpc0pzb25PYmplY3QsXG4gIGlzSnNvblNjYWxhcixcbiAgaXNMaXZlTm9kZSxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNSb290Q3JkdCxcbiAga0ludGVybmFsLFxuICBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3QsXG4gIGxzb25Ub0pzb24sXG4gIG1ha2VFdmVudFNvdXJjZSxcbiAgbWFrZVBvbGxlcixcbiAgbWFrZVBvc2l0aW9uLFxuICBtZW1vaXplT25TdWNjZXNzLFxuICBubixcbiAgb2JqZWN0VG9RdWVyeSxcbiAgcGF0Y2hMaXZlT2JqZWN0S2V5LFxuICByYWlzZSxcbiAgcmVtb3ZlUmVhY3Rpb24sXG4gIHNoYWxsb3csXG4gIHN0cmluZ2lmeSxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHksXG4gIHRocm93VXNhZ2VFcnJvcixcbiAgdG9QbGFpbkxzb24sXG4gIHRyeVBhcnNlSnNvbixcbiAgdXBzZXJ0Q29tbWVudCxcbiAgd2FpdCxcbiAgd2l0aFRpbWVvdXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@liveblocks/node/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/node/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Liveblocks: () => (/* binding */ Liveblocks),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   WebhookHandler: () => (/* binding */ WebhookHandler),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.getMentionedIdsFromCommentBody),\n/* harmony export */   stringifyCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.stringifyCommentBody)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liveblocks/core */ \"(action-browser)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stablelib/base64 */ \"(action-browser)/./node_modules/@stablelib/base64/lib/base64.js\");\n/* harmony import */ var fast_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-sha256 */ \"(action-browser)/./node_modules/fast-sha256/sha256.js\");\n// src/index.ts\n\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/node\";\nvar PKG_VERSION = \"2.3.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/client.ts\n\n\n// src/utils.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nasync function fetchPolyfill() {\n  return typeof globalThis.fetch !== \"undefined\" ? globalThis.fetch : (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/tr46\"), __webpack_require__.e(\"vendor-chunks/node-fetch\"), __webpack_require__.e(\"vendor-chunks/whatwg-url\"), __webpack_require__.e(\"vendor-chunks/webidl-conversions\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(action-browser)/./node_modules/node-fetch/lib/index.mjs\"))).default;\n}\nfunction isNonEmpty(value) {\n  return typeof value === \"string\" && value.length > 0;\n}\nfunction assertNonEmpty(value, field) {\n  if (!isNonEmpty(value)) {\n    throw new Error(\n      `Invalid value for field \"${field}\". Please provide a non-empty string. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize`\n    );\n  }\n}\nfunction assertSecretKey(value, field) {\n  if (!isNonEmpty(value) || !value.startsWith(\"sk_\")) {\n    throw new Error(\n      `Invalid value for field \"${field}\". Secret keys must start with \"sk_\". Please provide the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`\n    );\n  }\n}\nfunction normalizeStatusCode(statusCode) {\n  if (statusCode >= 200 && statusCode < 300) {\n    return 200;\n  } else if (statusCode >= 500) {\n    return 503;\n  } else {\n    return 403;\n  }\n}\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values[i - 1] ?? \"\") + str\n  );\n}\n\n// src/Session.ts\nvar ALL_PERMISSIONS = Object.freeze([\n  \"room:write\",\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:write\",\n  \"comments:read\"\n]);\nfunction isPermission(value) {\n  return ALL_PERMISSIONS.includes(value);\n}\nvar MAX_PERMS_PER_SET = 10;\nvar READ_ACCESS = Object.freeze([\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:read\"\n]);\nvar FULL_ACCESS = Object.freeze([\"room:write\", \"comments:write\"]);\nvar roomPatternRegex = /^([*]|[^*]{1,128}[*]?)$/;\nvar Session = class {\n  /** @internal */\n  constructor(postFn, userId, userInfo) {\n    this.FULL_ACCESS = FULL_ACCESS;\n    this.READ_ACCESS = READ_ACCESS;\n    /** @internal */\n    this._sealed = false;\n    /** @internal */\n    this._permissions = /* @__PURE__ */ new Map();\n    assertNonEmpty(userId, \"userId\");\n    this._postFn = postFn;\n    this._userId = userId;\n    this._userInfo = userInfo;\n  }\n  /** @internal */\n  getOrCreate(roomId) {\n    if (this._sealed) {\n      throw new Error(\"You can no longer change these permissions.\");\n    }\n    let perms = this._permissions.get(roomId);\n    if (perms) {\n      return perms;\n    } else {\n      if (this._permissions.size >= MAX_PERMS_PER_SET) {\n        throw new Error(\n          \"You cannot add permissions for more than 10 rooms in a single token\"\n        );\n      }\n      perms = /* @__PURE__ */ new Set();\n      this._permissions.set(roomId, perms);\n      return perms;\n    }\n  }\n  allow(roomIdOrPattern, newPerms) {\n    if (typeof roomIdOrPattern !== \"string\") {\n      throw new Error(\"Room name or pattern must be a string\");\n    }\n    if (!roomPatternRegex.test(roomIdOrPattern)) {\n      throw new Error(\"Invalid room name or pattern\");\n    }\n    if (newPerms.length === 0) {\n      throw new Error(\"Permission list cannot be empty\");\n    }\n    const existingPerms = this.getOrCreate(roomIdOrPattern);\n    for (const perm of newPerms) {\n      if (!isPermission(perm)) {\n        throw new Error(`Not a valid permission: ${perm}`);\n      }\n      existingPerms.add(perm);\n    }\n    return this;\n  }\n  /** @internal - For unit tests only */\n  hasPermissions() {\n    return this._permissions.size > 0;\n  }\n  /** @internal - For unit tests only */\n  seal() {\n    if (this._sealed) {\n      throw new Error(\n        \"You cannot reuse Session instances. Please create a new session every time.\"\n      );\n    }\n    this._sealed = true;\n  }\n  /** @internal - For unit tests only */\n  serializePermissions() {\n    return Object.fromEntries(\n      Array.from(this._permissions.entries()).map(([pat, perms]) => [\n        pat,\n        Array.from(perms)\n      ])\n    );\n  }\n  /**\n   * Call this to authorize the session to access Liveblocks. Note that this\n   * will return a Liveblocks \"access token\". Anyone that obtains such access\n   * token will have access to the allowed resources.\n   */\n  async authorize() {\n    this.seal();\n    if (!this.hasPermissions()) {\n      console.warn(\n        \"Access tokens without any permission will not be supported soon, you should use wildcards when the client requests a token for resources outside a room. See https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n    try {\n      const resp = await this._postFn(url`/v2/authorize-user`, {\n        // Required\n        userId: this._userId,\n        permissions: this.serializePermissions(),\n        // Optional metadata\n        userInfo: this._userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: 'Call to /v2/authorize-user failed. See \"error\" for more information.',\n        error: er\n      };\n    }\n  }\n};\n\n// src/client.ts\nvar Liveblocks = class {\n  /**\n   * Interact with the Liveblocks API from your Node.js backend.\n   */\n  constructor(options) {\n    const options_ = options;\n    const secret = options_.secret;\n    assertSecretKey(secret, \"secret\");\n    this._secret = secret;\n    this._baseUrl = new URL(getBaseUrl(options.baseUrl));\n  }\n  /** @internal */\n  async post(path, json) {\n    const url2 = urljoin(this._baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url2, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(json)\n    });\n    return res;\n  }\n  /** @internal */\n  async put(path, json) {\n    const url2 = urljoin(this._baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url2, {\n      method: \"PUT\",\n      headers,\n      body: JSON.stringify(json)\n    });\n  }\n  /** @internal */\n  async putBinary(path, body, params) {\n    const url2 = urljoin(this._baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`,\n      \"Content-Type\": \"application/octet-stream\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url2, { method: \"PUT\", headers, body });\n  }\n  /** @internal */\n  async delete(path) {\n    const url2 = urljoin(this._baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url2, { method: \"DELETE\", headers });\n    return res;\n  }\n  /** @internal */\n  async get(path, params) {\n    const url2 = urljoin(this._baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url2, { method: \"GET\", headers });\n    return res;\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Authentication\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Prepares a new session to authorize a user to access Liveblocks.\n   *\n   * IMPORTANT:\n   * Always make sure that you trust the user making the request to your\n   * backend before calling .prepareSession()!\n   *\n   * @param userId Tell Liveblocks the user ID of the user to authorize. Must\n   * uniquely identify the user account in your system. The uniqueness of this\n   * value will determine how many MAUs will be counted/billed.\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   *\n   */\n  prepareSession(userId, ...rest) {\n    const options = rest[0];\n    return new Session(this.post.bind(this), userId, options?.userInfo);\n  }\n  /**\n   * Call this to authenticate the user as an actor you want to allow to use\n   * Liveblocks.\n   *\n   * You should use this method only if you want to manage your permissions\n   * through the Liveblocks Permissions API. This method is more complicated to\n   * set up, but allows for finer-grained specification of permissions.\n   *\n   * Calling `.identifyUser()` only lets you securely identify a user (and what\n   * groups they belong to). What permissions this user will end up having is\n   * determined by whatever permissions you assign the user/group in your\n   * Liveblocks account, through the Permissions API:\n   * https://liveblocks.io/docs/rooms/permissions\n   *\n   * IMPORTANT:\n   * Always verify that you trust the user making the request before calling\n   * .identifyUser()!\n   *\n   * @param identity Tell Liveblocks the user ID of the user to authenticate.\n   * Must uniquely identify the user account in your system. The uniqueness of\n   * this value will determine how many MAUs will be counted/billed.\n   *\n   * If you also want to assign which groups this user belongs to, use the\n   * object form and specify the `groupIds` property. Those `groupIds` should\n   * match the groupIds you assigned permissions to via the Liveblocks\n   * Permissions API, see\n   * https://liveblocks.io/docs/rooms/permissions#permissions-levels-groups-accesses-example\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   */\n  // These fields define the security identity of the user. Whatever you pass in here will define which\n  async identifyUser(identity, ...rest) {\n    const options = rest[0];\n    const path = url`/v2/identify-user`;\n    const userId = typeof identity === \"string\" ? identity : identity.userId;\n    const groupIds = typeof identity === \"string\" ? void 0 : identity.groupIds;\n    assertNonEmpty(userId, \"userId\");\n    try {\n      const resp = await this.post(path, {\n        userId,\n        groupIds,\n        // Optional metadata\n        userInfo: options?.userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: `Call to ${urljoin(\n          this._baseUrl,\n          path\n        )} failed. See \"error\" for more information.`,\n        error: er\n      };\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Room\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a list of your rooms. The rooms are returned sorted by creation date, from newest to oldest. You can filter rooms by metadata, users accesses and groups accesses.\n   * @param params.limit (optional) A limit on the number of rooms to be returned. The limit can range between 1 and 100, and defaults to 20.\n   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.\n   * @param params.userId (optional) A filter on users accesses.\n   * @param params.metadata (optional) A filter on metadata. Multiple metadata keys can be used to filter rooms.\n   * @param params.groupIds (optional) A filter on groups accesses. Multiple groups can be used.\n   * @param params.query (optional) A query to filter rooms by. It is based on our query language. You can filter by metadata and room ID.\n   * @returns A list of rooms.\n   */\n  async getRooms(params = {}) {\n    const path = url`/v2/rooms`;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const queryParams = {\n      limit: params.limit,\n      startingAfter: params.startingAfter,\n      userId: params.userId,\n      groupIds: params.groupIds ? params.groupIds.join(\",\") : void 0,\n      // \"Flatten\" {metadata: {foo: \"bar\"}} to {\"metadata.foo\": \"bar\"}\n      ...Object.fromEntries(\n        Object.entries(params.metadata ?? {}).map(([key, val]) => [\n          `metadata.${key}`,\n          val\n        ])\n      ),\n      query\n    };\n    const res = await this.get(path, queryParams);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const rooms = data.data.map((room) => {\n      const lastConnectionAt = room.lastConnectionAt ? new Date(room.lastConnectionAt) : void 0;\n      const createdAt = new Date(room.createdAt);\n      return {\n        ...room,\n        createdAt,\n        lastConnectionAt\n      };\n    });\n    return {\n      ...data,\n      data: rooms\n    };\n  }\n  /**\n   * Creates a new room with the given id.\n   * @param roomId The id of the room to create.\n   * @param params.defaultAccesses The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @returns The created room.\n   */\n  async createRoom(roomId, params) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.post(url`/v2/rooms`, {\n      id: roomId,\n      defaultAccesses,\n      groupsAccesses,\n      usersAccesses,\n      metadata\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Returns a room with the given id.\n   * @param roomId The id of the room to return.\n   * @returns The room with the given id.\n   */\n  async getRoom(roomId) {\n    const res = await this.get(url`/v2/rooms/${roomId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      createdAt,\n      lastConnectionAt\n    };\n  }\n  /**\n   * Updates specific properties of a room. Its not necessary to provide the entire rooms information.\n   * Setting a property to `null` means to delete this property.\n   * @param roomId The id of the room to update.\n   * @param params.defaultAccesses (optional) The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @returns The updated room.\n   */\n  async updateRoom(roomId, params) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.post(url`/v2/rooms/${roomId}`, {\n      defaultAccesses,\n      groupsAccesses,\n      usersAccesses,\n      metadata\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Deletes a room with the given id. A deleted room is no longer accessible from the API or the dashboard and it cannot be restored.\n   * @param roomId The id of the room to delete.\n   */\n  async deleteRoom(roomId) {\n    const res = await this.delete(url`/v2/rooms/${roomId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns a list of users currently present in the requested room. For better performance, we recommand to call this endpoint every 10 seconds maximum. Duplicates can happen if a user is in the requested room with multiple browser tabs opened.\n   * @param roomId The id of the room to get the users from.\n   * @returns A list of users currently present in the requested room.\n   */\n  async getActiveUsers(roomId) {\n    const res = await this.get(url`/v2/rooms/${roomId}/active_users`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Boadcasts an event to a room without having to connect to it via the client from @liveblocks/client. The connectionId passed to event listeners is -1 when using this API.\n   * @param roomId The id of the room to broadcast the event to.\n   * @param message The message to broadcast. It can be any JSON serializable value.\n   */\n  async broadcastEvent(roomId, message) {\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/broadcast_event`,\n      message\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  async getStorageDocument(roomId, format = \"plain-lson\") {\n    const res = await this.get(url`/v2/rooms/${roomId}/storage`, { format });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Initializes a rooms Storage. The room must already exist and have an empty Storage.\n   * Calling this endpoint will disconnect all users from the room if there are any.\n   *\n   * @param roomId The id of the room to initialize the storage from.\n   * @param document The document to initialize the storage with.\n   * @returns The initialized storage document. It is of the same format as the one passed in.\n   */\n  async initializeStorageDocument(roomId, document) {\n    const res = await this.post(url`/v2/rooms/${roomId}/storage`, document);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Deletes all of the rooms Storage data and disconnect all users from the room if there are any. Note that this does not delete the Yjs document in the room if one exists.\n   * @param roomId The id of the room to delete the storage from.\n   */\n  async deleteStorageDocument(roomId) {\n    const res = await this.delete(url`/v2/rooms/${roomId}/storage`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Yjs\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a JSON representation of the rooms Yjs document.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.format (optional) If true, YText will return formatting.\n   * @param params.key (optional) If provided, returns only a single keys value, e.g. doc.get(key).toJSON().\n   * @param params.type (optional) Used with key to override the inferred type, i.e. \"ymap\" will return doc.get(key, Y.Map).\n   * @returns A JSON representation of the rooms Yjs document.\n   */\n  async getYjsDocument(roomId, params = {}) {\n    const { format, key, type } = params;\n    const path = url`v2/rooms/${roomId}/ydoc`;\n    const res = await this.get(path, {\n      formatting: format ? \"true\" : void 0,\n      key,\n      type\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Send a Yjs binary update to the rooms Yjs document. You can use this endpoint to initialize Yjs data for the room or to update the rooms Yjs document.\n   * @param roomId The id of the room to send the Yjs binary update to.\n   * @param update The Yjs update to send. Typically the result of calling `Yjs.encodeStateAsUpdate(doc)`. Read the [Yjs documentation](https://docs.yjs.dev/api/document-updates) to learn how to create a binary update.\n   * @param params.guid (optional) If provided, the binary update will be applied to the Yjs subdocument with the given guid. If not provided, the binary update will be applied to the root Yjs document.\n   */\n  async sendYjsBinaryUpdate(roomId, update, params = {}) {\n    const res = await this.putBinary(url`/v2/rooms/${roomId}/ydoc`, update, {\n      guid: params.guid\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns the rooms Yjs document encoded as a single binary update. This can be used by Y.applyUpdate(responseBody) to get a copy of the document in your backend.\n   * See [Yjs documentation](https://docs.yjs.dev/api/document-updates) for more information on working with updates.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.guid (optional) If provided, returns the binary update of the Yjs subdocument with the given guid. If not provided, returns the binary update of the root Yjs document.\n   * @returns The rooms Yjs document encoded as a single binary update.\n   */\n  async getYjsDocumentAsBinaryUpdate(roomId, params = {}) {\n    const res = await this.get(url`/v2/rooms/${roomId}/ydoc-binary`, {\n      guid: params.guid\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return res.arrayBuffer();\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Schema Validation\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Creates a new schema which can be referenced later to enforce a rooms Storage data structure.\n   * @param name The name used to reference the schema. Must be a non-empty string with less than 65 characters and only contain lowercase letters, numbers and dashes\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @returns The created schema.\n   */\n  async createSchema(name, body) {\n    const res = await this.post(url`/v2/schemas`, {\n      name,\n      body\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Returns a schema by its id.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @returns The schema with the given id.\n   */\n  async getSchema(schemaId) {\n    const res = await this.get(url`/v2/schemas/${schemaId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Updates the body for the schema. A schema can only be updated if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @returns The updated schema. The version of the schema will be incremented.\n   */\n  async updateSchema(schemaId, body) {\n    const res = await this.put(url`/v2/schemas/${schemaId}`, {\n      body\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Deletes a schema by its id. A schema can only be deleted if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   */\n  async deleteSchema(schemaId) {\n    const res = await this.delete(url`/v2/schemas/${schemaId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns the schema attached to a room.\n   * @param roomId The id of the room to get the schema from.\n   * @returns\n   */\n  async getSchemaByRoomId(roomId) {\n    const res = await this.get(url`/v2/rooms/${roomId}/schema`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Attaches a schema to a room, and instantly enables runtime schema validation for the room.\n   * If the current contents of the rooms Storage do not match the schema, attaching will fail and the error message will give details on why the schema failed to attach.\n   * @param roomId The id of the room to attach the schema to.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @returns The schema id as JSON.\n   */\n  async attachSchemaToRoom(roomId, schemaId) {\n    const res = await this.post(url`/v2/rooms/${roomId}/schema`, {\n      schema: schemaId\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Detaches a schema from a room, and disables runtime schema validation for the room.\n   * @param roomId The id of the room to detach the schema from.\n   */\n  async detachSchemaFromRoom(roomId) {\n    const res = await this.delete(url`/v2/rooms/${roomId}/schema`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Comments\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Gets all the threads in a room.\n   *\n   * @param params.roomId The room ID to get the threads from.\n   * @param params.query The query to filter threads by. It is based on our query language and can filter by metadata.\n   * @returns A list of threads.\n   */\n  async getThreads(params) {\n    const { roomId } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const res = await this.get(url`/v2/rooms/${roomId}/threads`, {\n      query\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const { data } = await res.json();\n    return {\n      data: data.map((thread) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(thread))\n    };\n  }\n  /**\n   * Gets a thread.\n   *\n   * @param params.roomId The room ID to get the thread from.\n   * @param params.threadId The thread ID.\n   * @returns A thread.\n   */\n  async getThread(params) {\n    const { roomId, threadId } = params;\n    const res = await this.get(url`/v2/rooms/${roomId}/threads/${threadId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Gets a thread's participants.\n   *\n   * Participants are users who have commented on the thread\n   * or users and groups that have been mentioned in a comment.\n   *\n   * @param params.roomId The room ID to get the thread participants from.\n   * @param params.threadId The thread ID to get the participants from.\n   * @returns An object containing an array of participant IDs.\n   */\n  async getThreadParticipants(params) {\n    const { roomId, threadId } = params;\n    const res = await this.get(\n      url`/v2/rooms/${roomId}/threads/${threadId}/participants`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Gets a thread's comment.\n   *\n   * @param params.roomId The room ID to get the comment from.\n   * @param params.threadId The thread ID to get the comment from.\n   * @param params.commentId The comment ID.\n   * @returns A comment.\n   */\n  async getComment(params) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.get(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Creates a comment.\n   *\n   * @param params.roomId The room ID to create the comment in.\n   * @param params.threadId The thread ID to create the comment in.\n   * @param params.data.userId The user ID of the user who is set to create the comment.\n   * @param params.data.createdAt (optional) The date the comment is set to be created.\n   * @param params.data.body The body of the comment.\n   * @returns The created comment.\n   */\n  async createComment(params) {\n    const { roomId, threadId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Edits a comment.\n   * @param params.roomId The room ID to edit the comment in.\n   * @param params.threadId The thread ID to edit the comment in.\n   * @param params.commentId The comment ID to edit.\n   * @param params.data.body The body of the comment.\n   * @param params.data.editedAt (optional) The date the comment was edited.\n   * @returns The edited comment.\n   */\n  async editComment(params) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      {\n        ...data,\n        editedAt: data.editedAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Deletes a comment. Deletes a comment. If there are no remaining comments in the thread, the thread is also deleted.\n   * @param params.roomId The room ID to delete the comment in.\n   * @param params.threadId The thread ID to delete the comment in.\n   * @param params.commentId The comment ID to delete.\n   */\n  async deleteComment(params) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.delete(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Creates a new thread. The thread will be created with the specified comment as its first comment.\n   * If the thread already exists, a `LiveblocksError` will be thrown with status code 409.\n   * @param params.roomId The room ID to create the thread in.\n   * @param params.thread.metadata (optional) The metadata for the thread. Supports upto a maximum of 10 entries. Value must be a string, boolean or number\n   * @param params.thread.comment.userId The user ID of the user who created the comment.\n   * @param params.thread.comment.createdAt (optional) The date the comment was created.\n   * @param params.thread.comment.body The body of the comment.\n   * @returns The created thread. The thread will be created with the specified comment as its first comment.\n   */\n  async createThread(params) {\n    const { roomId, data } = params;\n    const res = await this.post(url`/v2/rooms/${roomId}/threads`, {\n      ...data,\n      comment: {\n        ...data.comment,\n        createdAt: data.comment.createdAt?.toISOString()\n      }\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Deletes a thread and all of its comments.\n   * @param params.roomId The room ID to delete the thread in.\n   * @param params.threadId The thread ID to delete.\n   */\n  async deleteThread(params) {\n    const { roomId, threadId } = params;\n    const res = await this.delete(url`/v2/rooms/${roomId}/threads/${threadId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Mark a thread as resolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as resolved.\n   * @param params.data.userId The user ID of the user who marked the thread as resolved.\n   * @returns The thread marked as resolved.\n   */\n  async markThreadAsResolved(params) {\n    const { roomId, threadId } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/mark-as-resolved`,\n      {}\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Mark a thread as unresolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as unresolved.\n   * @param params.data.userId The user ID of the user who marked the thread as unresolved.\n   * @returns The thread marked as unresolved.\n   */\n  async markThreadAsUnresolved(params) {\n    const { roomId, threadId } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/mark-as-unresolved`,\n      {}\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Updates the metadata of the specified thread in a room.\n   * @param params.roomId The room ID to update the thread in.\n   * @param params.threadId The thread ID to update.\n   * @param params.data.metadata The metadata for the thread. Value must be a string, boolean or number\n   * @param params.data.userId The user ID of the user who updated the thread.\n   * @param params.data.updatedAt (optional) The date the thread is set to be updated.\n   * @returns The updated thread metadata.\n   */\n  async editThreadMetadata(params) {\n    const { roomId, threadId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/metadata`,\n      {\n        ...data,\n        updatedAt: data.updatedAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Adds a new comment reaction to a comment.\n   * @param params.roomId The room ID to add the comment reaction in.\n   * @param params.threadId The thread ID to add the comment reaction in.\n   * @param params.commentId The comment ID to add the reaction in.\n   * @param params.data.emoji The (emoji) reaction to add.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.createdAt (optional) The date the reaction is set to be created.\n   * @returns The created comment reaction.\n   */\n  async addCommentReaction(params) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}/add-reaction`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const reaction = await res.json();\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentUserReaction)(reaction);\n  }\n  /**\n   * Removes a reaction from a comment.\n   * @param params.roomId The room ID to remove the comment reaction from.\n   * @param params.threadId The thread ID to remove the comment reaction from.\n   * @param params.commentId The comment ID to remove the reaction from.\n   * @param params.data.emoji The (emoji) reaction to remove.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.removedAt (optional) The date the reaction is set to be removed.\n   */\n  async removeCommentReaction(params) {\n    const { roomId, threadId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${params.commentId}/remove-reaction`,\n      {\n        ...data,\n        removedAt: data.removedAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.inboxNotificationId The ID of the inbox notification to get.\n   */\n  async getInboxNotification(params) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.get(\n      url`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToInboxNotificationData)(\n      await res.json()\n    );\n  }\n  /**\n   * Gets the user's room notification settings.\n   * @param params.userId The user ID to get the room notifications from.\n   * @param params.roomId The room ID to get the room notification settings from.\n   */\n  async getRoomNotificationSettings(params) {\n    const { userId, roomId } = params;\n    const res = await this.get(\n      url`/v2/rooms/${roomId}/users/${userId}/notification-settings`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Updates the user's room notification settings.\n   * @param params.userId The user ID to update the room notification settings for.\n   * @param params.roomId The room ID to update the room notification settings for.\n   * @param params.data The new room notification settings for the user.\n   */\n  async updateRoomNotificationSettings(params) {\n    const { userId, roomId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/users/${userId}/notification-settings`,\n      data\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Delete the user's room notification settings.\n   * @param params.userId The user ID to delete the room notification settings from.\n   * @param params.roomId The room ID to delete the room notification settings from.\n   */\n  async deleteRoomNotificationSettings(params) {\n    const { userId, roomId } = params;\n    const res = await this.delete(\n      url`/v2/rooms/${roomId}/users/${userId}/notification-settings`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Update a room ID.\n   * @param params.roomId The current ID of the room.\n   * @param params.newRoomId The new room ID.\n   */\n  async updateRoomId(params) {\n    const { currentRoomId, newRoomId } = params;\n    const res = await this.post(\n      url`/v2/rooms/${currentRoomId}/update-room-id`,\n      {\n        newRoomId\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      lastConnectionAt: data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0\n    };\n  }\n  async triggerInboxNotification(params) {\n    const res = await this.post(url`/v2/inbox-notifications/trigger`, params);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Deletes an inbox notification for a user.\n   * @param params.userId The user ID for which to delete the inbox notification.\n   * @param params.inboxNotificationId The ID of the inbox notification to delete.\n   */\n  async deleteInboxNotification(params) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.delete(\n      url`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Deletes all inbox notifications for a user.\n   * @param params.userId The user ID for which to delete all the inbox notifications.\n   */\n  async deleteAllInboxNotifications(params) {\n    const { userId } = params;\n    const res = await this.delete(url`/v2/users/${userId}/inbox-notifications`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n};\nvar LiveblocksError = class extends Error {\n  constructor(status, message = \"\") {\n    super(message);\n    this.name = \"LiveblocksError\";\n    this.status = status;\n  }\n};\n\n// src/webhooks.ts\n\n\nvar _WebhookHandler = class _WebhookHandler {\n  constructor(secret) {\n    if (!secret) throw new Error(\"Secret is required\");\n    if (typeof secret !== \"string\") throw new Error(\"Secret must be a string\");\n    if (secret.startsWith(_WebhookHandler.secretPrefix) === false)\n      throw new Error(\"Invalid secret, must start with whsec_\");\n    const secretKey = secret.slice(_WebhookHandler.secretPrefix.length);\n    this.secretBuffer = Buffer.from(secretKey, \"base64\");\n  }\n  /**\n   * Verifies a webhook request and returns the event\n   */\n  verifyRequest(request) {\n    const { headers, rawBody } = request;\n    const { webhookId, timestamp, rawSignatures } = this.verifyHeaders(headers);\n    if (typeof rawBody !== \"string\") {\n      throw new Error(\n        `Invalid rawBody field, must be a string, got \"${typeof rawBody}\" instead. It is likely that you need to JSON.stringify the body before passing it.`\n      );\n    }\n    this.verifyTimestamp(timestamp);\n    const signature = this.sign(`${webhookId}.${timestamp}.${rawBody}`);\n    const expectedSignatures = rawSignatures.split(\" \").map((rawSignature) => {\n      const [, parsedSignature] = rawSignature.split(\",\");\n      return parsedSignature;\n    }).filter(isNotUndefined);\n    if (expectedSignatures.includes(signature) === false)\n      throw new Error(\n        `Invalid signature, expected one of ${expectedSignatures.join(\n          \", \"\n        )}, got ${signature}`\n      );\n    const event = JSON.parse(rawBody);\n    this.verifyWebhookEventType(event);\n    return event;\n  }\n  /**\n   * Verifies the headers and returns the webhookId, timestamp and rawSignatures\n   */\n  verifyHeaders(headers) {\n    const usingNativeHeaders = typeof Headers !== \"undefined\" && headers instanceof Headers;\n    const normalizedHeaders = usingNativeHeaders ? Object.fromEntries(headers) : headers;\n    const sanitizedHeaders = {};\n    Object.keys(normalizedHeaders).forEach((key) => {\n      sanitizedHeaders[key.toLowerCase()] = normalizedHeaders[key];\n    });\n    const webhookId = sanitizedHeaders[\"webhook-id\"];\n    if (typeof webhookId !== \"string\")\n      throw new Error(\"Invalid webhook-id header\");\n    const timestamp = sanitizedHeaders[\"webhook-timestamp\"];\n    if (typeof timestamp !== \"string\")\n      throw new Error(\"Invalid webhook-timestamp header\");\n    const rawSignatures = sanitizedHeaders[\"webhook-signature\"];\n    if (typeof rawSignatures !== \"string\")\n      throw new Error(\"Invalid webhook-signature header\");\n    return { webhookId, timestamp, rawSignatures };\n  }\n  /**\n   * Signs the content with the secret\n   * @param content\n   * @returns `string`\n   */\n  sign(content) {\n    const encoder = new TextEncoder();\n    const toSign = encoder.encode(content);\n    return _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__.encode(fast_sha256__WEBPACK_IMPORTED_MODULE_2__.hmac(this.secretBuffer, toSign));\n  }\n  /**\n   * Verifies that the timestamp is not too old or in the future\n   */\n  verifyTimestamp(timestampHeader) {\n    const now = Math.floor(Date.now() / 1e3);\n    const timestamp = parseInt(timestampHeader, 10);\n    if (isNaN(timestamp)) {\n      throw new Error(\"Invalid timestamp\");\n    }\n    if (timestamp < now - WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp too old\");\n    }\n    if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp in the future\");\n    }\n  }\n  /**\n   * Ensures that the event is a known event type\n   * or throws and prompts the user to upgrade to a higher version of @liveblocks/node\n   */\n  verifyWebhookEventType(event) {\n    if (event && event.type && [\n      \"storageUpdated\",\n      \"userEntered\",\n      \"userLeft\",\n      \"roomCreated\",\n      \"roomDeleted\",\n      \"commentCreated\",\n      \"commentEdited\",\n      \"commentDeleted\",\n      \"commentReactionAdded\",\n      \"commentReactionRemoved\",\n      \"threadMetadataUpdated\",\n      \"threadCreated\",\n      \"threadDeleted\",\n      \"ydocUpdated\",\n      \"notification\",\n      \"threadMarkedAsResolved\",\n      \"threadMarkedAsUnresolved\"\n    ].includes(event.type)) {\n      if (event.type === \"notification\") {\n        const notification = event;\n        if (notification.data.kind === \"thread\" || notification.data.kind === \"textMention\" || notification.data.kind.startsWith(\"$\")) {\n          return;\n        } else {\n          throw new Error(\n            `Unknown notification kind: ${notification.data.kind}`\n          );\n        }\n      }\n      return;\n    }\n    throw new Error(\n      \"Unknown event type, please upgrade to a higher version of @liveblocks/node\"\n    );\n  }\n};\n_WebhookHandler.secretPrefix = \"whsec_\";\nvar WebhookHandler = _WebhookHandler;\nvar WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;\nvar isNotUndefined = (value) => value !== void 0;\n\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9ub2RlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBTzBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDRXQUFvQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhCQUE4QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBDQUEwQyx1QkFBdUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUkwQjtBQUMxQiw2REFBVztBQU9UO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3Mvbm9kZS9kaXN0L2luZGV4Lm1qcz9iNDliIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgZGV0ZWN0RHVwZXMgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFBLR19OQU1FID0gXCJAbGl2ZWJsb2Nrcy9ub2RlXCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjIuMy4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9jbGllbnQudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRUb0NvbW1lbnREYXRhLFxuICBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uLFxuICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEsXG4gIGNvbnZlcnRUb1RocmVhZERhdGEsXG4gIG9iamVjdFRvUXVlcnlcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgREVGQVVMVF9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9hcGkubGl2ZWJsb2Nrcy5pb1wiO1xuZnVuY3Rpb24gZ2V0QmFzZVVybChiYXNlVXJsKSB7XG4gIGlmICh0eXBlb2YgYmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiBiYXNlVXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgcmV0dXJuIGJhc2VVcmw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQkFTRV9VUkw7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUG9seWZpbGwoKSB7XG4gIHJldHVybiB0eXBlb2YgZ2xvYmFsVGhpcy5mZXRjaCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMuZmV0Y2ggOiAoYXdhaXQgaW1wb3J0KFwibm9kZS1mZXRjaFwiKSkuZGVmYXVsdDtcbn1cbmZ1bmN0aW9uIGlzTm9uRW1wdHkodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gYXNzZXJ0Tm9uRW1wdHkodmFsdWUsIGZpZWxkKSB7XG4gIGlmICghaXNOb25FbXB0eSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgZmllbGQgXCIke2ZpZWxkfVwiLiBQbGVhc2UgcHJvdmlkZSBhIG5vbi1lbXB0eSBzdHJpbmcuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3Mtbm9kZSNhdXRob3JpemVgXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2VjcmV0S2V5KHZhbHVlLCBmaWVsZCkge1xuICBpZiAoIWlzTm9uRW1wdHkodmFsdWUpIHx8ICF2YWx1ZS5zdGFydHNXaXRoKFwic2tfXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIGZpZWxkIFwiJHtmaWVsZH1cIi4gU2VjcmV0IGtleXMgbXVzdCBzdGFydCB3aXRoIFwic2tfXCIuIFBsZWFzZSBwcm92aWRlIHRoZSBzZWNyZXQga2V5IGZyb20geW91ciBMaXZlYmxvY2tzIGRhc2hib2FyZCBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZGFzaGJvYXJkL2FwaWtleXMuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0YXR1c0NvZGUoc3RhdHVzQ29kZSkge1xuICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgIHJldHVybiAyMDA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzQ29kZSA+PSA1MDApIHtcbiAgICByZXR1cm4gNTAzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiA0MDM7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXJsam9pbihiYXNlVXJsLCBwYXRoLCBwYXJhbXMpIHtcbiAgY29uc3QgdXJsMiA9IG5ldyBVUkwocGF0aCwgYmFzZVVybCk7XG4gIGlmIChwYXJhbXMgIT09IHZvaWQgMCkge1xuICAgIHVybDIuc2VhcmNoID0gKHBhcmFtcyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IHBhcmFtcyA6IHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHVybDIudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHVybChzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIHN0cmluZ3MucmVkdWNlKFxuICAgIChyZXN1bHQsIHN0ciwgaSkgPT4gcmVzdWx0ICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpIC0gMV0gPz8gXCJcIikgKyBzdHJcbiAgKTtcbn1cblxuLy8gc3JjL1Nlc3Npb24udHNcbnZhciBBTExfUEVSTUlTU0lPTlMgPSBPYmplY3QuZnJlZXplKFtcbiAgXCJyb29tOndyaXRlXCIsXG4gIFwicm9vbTpyZWFkXCIsXG4gIFwicm9vbTpwcmVzZW5jZTp3cml0ZVwiLFxuICBcImNvbW1lbnRzOndyaXRlXCIsXG4gIFwiY29tbWVudHM6cmVhZFwiXG5dKTtcbmZ1bmN0aW9uIGlzUGVybWlzc2lvbih2YWx1ZSkge1xuICByZXR1cm4gQUxMX1BFUk1JU1NJT05TLmluY2x1ZGVzKHZhbHVlKTtcbn1cbnZhciBNQVhfUEVSTVNfUEVSX1NFVCA9IDEwO1xudmFyIFJFQURfQUNDRVNTID0gT2JqZWN0LmZyZWV6ZShbXG4gIFwicm9vbTpyZWFkXCIsXG4gIFwicm9vbTpwcmVzZW5jZTp3cml0ZVwiLFxuICBcImNvbW1lbnRzOnJlYWRcIlxuXSk7XG52YXIgRlVMTF9BQ0NFU1MgPSBPYmplY3QuZnJlZXplKFtcInJvb206d3JpdGVcIiwgXCJjb21tZW50czp3cml0ZVwiXSk7XG52YXIgcm9vbVBhdHRlcm5SZWdleCA9IC9eKFsqXXxbXipdezEsMTI4fVsqXT8pJC87XG52YXIgU2Vzc2lvbiA9IGNsYXNzIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3Rvcihwb3N0Rm4sIHVzZXJJZCwgdXNlckluZm8pIHtcbiAgICB0aGlzLkZVTExfQUNDRVNTID0gRlVMTF9BQ0NFU1M7XG4gICAgdGhpcy5SRUFEX0FDQ0VTUyA9IFJFQURfQUNDRVNTO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zZWFsZWQgPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGVybWlzc2lvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGFzc2VydE5vbkVtcHR5KHVzZXJJZCwgXCJ1c2VySWRcIik7XG4gICAgdGhpcy5fcG9zdEZuID0gcG9zdEZuO1xuICAgIHRoaXMuX3VzZXJJZCA9IHVzZXJJZDtcbiAgICB0aGlzLl91c2VySW5mbyA9IHVzZXJJbmZvO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0T3JDcmVhdGUocm9vbUlkKSB7XG4gICAgaWYgKHRoaXMuX3NlYWxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbiBubyBsb25nZXIgY2hhbmdlIHRoZXNlIHBlcm1pc3Npb25zLlwiKTtcbiAgICB9XG4gICAgbGV0IHBlcm1zID0gdGhpcy5fcGVybWlzc2lvbnMuZ2V0KHJvb21JZCk7XG4gICAgaWYgKHBlcm1zKSB7XG4gICAgICByZXR1cm4gcGVybXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9wZXJtaXNzaW9ucy5zaXplID49IE1BWF9QRVJNU19QRVJfU0VUKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIllvdSBjYW5ub3QgYWRkIHBlcm1pc3Npb25zIGZvciBtb3JlIHRoYW4gMTAgcm9vbXMgaW4gYSBzaW5nbGUgdG9rZW5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcGVybXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fcGVybWlzc2lvbnMuc2V0KHJvb21JZCwgcGVybXMpO1xuICAgICAgcmV0dXJuIHBlcm1zO1xuICAgIH1cbiAgfVxuICBhbGxvdyhyb29tSWRPclBhdHRlcm4sIG5ld1Blcm1zKSB7XG4gICAgaWYgKHR5cGVvZiByb29tSWRPclBhdHRlcm4gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb20gbmFtZSBvciBwYXR0ZXJuIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIGlmICghcm9vbVBhdHRlcm5SZWdleC50ZXN0KHJvb21JZE9yUGF0dGVybikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm9vbSBuYW1lIG9yIHBhdHRlcm5cIik7XG4gICAgfVxuICAgIGlmIChuZXdQZXJtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcm1pc3Npb24gbGlzdCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nUGVybXMgPSB0aGlzLmdldE9yQ3JlYXRlKHJvb21JZE9yUGF0dGVybik7XG4gICAgZm9yIChjb25zdCBwZXJtIG9mIG5ld1Blcm1zKSB7XG4gICAgICBpZiAoIWlzUGVybWlzc2lvbihwZXJtKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIHZhbGlkIHBlcm1pc3Npb246ICR7cGVybX1gKTtcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nUGVybXMuYWRkKHBlcm0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogQGludGVybmFsIC0gRm9yIHVuaXQgdGVzdHMgb25seSAqL1xuICBoYXNQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVybWlzc2lvbnMuc2l6ZSA+IDA7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAtIEZvciB1bml0IHRlc3RzIG9ubHkgKi9cbiAgc2VhbCgpIHtcbiAgICBpZiAodGhpcy5fc2VhbGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiWW91IGNhbm5vdCByZXVzZSBTZXNzaW9uIGluc3RhbmNlcy4gUGxlYXNlIGNyZWF0ZSBhIG5ldyBzZXNzaW9uIGV2ZXJ5IHRpbWUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuX3NlYWxlZCA9IHRydWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAtIEZvciB1bml0IHRlc3RzIG9ubHkgKi9cbiAgc2VyaWFsaXplUGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIEFycmF5LmZyb20odGhpcy5fcGVybWlzc2lvbnMuZW50cmllcygpKS5tYXAoKFtwYXQsIHBlcm1zXSkgPT4gW1xuICAgICAgICBwYXQsXG4gICAgICAgIEFycmF5LmZyb20ocGVybXMpXG4gICAgICBdKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBhdXRob3JpemUgdGhlIHNlc3Npb24gdG8gYWNjZXNzIExpdmVibG9ja3MuIE5vdGUgdGhhdCB0aGlzXG4gICAqIHdpbGwgcmV0dXJuIGEgTGl2ZWJsb2NrcyBcImFjY2VzcyB0b2tlblwiLiBBbnlvbmUgdGhhdCBvYnRhaW5zIHN1Y2ggYWNjZXNzXG4gICAqIHRva2VuIHdpbGwgaGF2ZSBhY2Nlc3MgdG8gdGhlIGFsbG93ZWQgcmVzb3VyY2VzLlxuICAgKi9cbiAgYXN5bmMgYXV0aG9yaXplKCkge1xuICAgIHRoaXMuc2VhbCgpO1xuICAgIGlmICghdGhpcy5oYXNQZXJtaXNzaW9ucygpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiQWNjZXNzIHRva2VucyB3aXRob3V0IGFueSBwZXJtaXNzaW9uIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBzb29uLCB5b3Ugc2hvdWxkIHVzZSB3aWxkY2FyZHMgd2hlbiB0aGUgY2xpZW50IHJlcXVlc3RzIGEgdG9rZW4gZm9yIHJlc291cmNlcyBvdXRzaWRlIGEgcm9vbS4gU2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLWNsaWVudC9hY2Nlc3MtdG9rZW5zLW5vdC1lbm91Z2gtcGVybWlzc2lvbnNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLl9wb3N0Rm4odXJsYC92Mi9hdXRob3JpemUtdXNlcmAsIHtcbiAgICAgICAgLy8gUmVxdWlyZWRcbiAgICAgICAgdXNlcklkOiB0aGlzLl91c2VySWQsXG4gICAgICAgIHBlcm1pc3Npb25zOiB0aGlzLnNlcmlhbGl6ZVBlcm1pc3Npb25zKCksXG4gICAgICAgIC8vIE9wdGlvbmFsIG1ldGFkYXRhXG4gICAgICAgIHVzZXJJbmZvOiB0aGlzLl91c2VySW5mb1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IG5vcm1hbGl6ZVN0YXR1c0NvZGUocmVzcC5zdGF0dXMpLFxuICAgICAgICBib2R5OiBhd2FpdCByZXNwLnRleHQoKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiA1MDMsXG4gICAgICAgIGJvZHk6ICdDYWxsIHRvIC92Mi9hdXRob3JpemUtdXNlciBmYWlsZWQuIFNlZSBcImVycm9yXCIgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgZXJyb3I6IGVyXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2NsaWVudC50c1xudmFyIExpdmVibG9ja3MgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBJbnRlcmFjdCB3aXRoIHRoZSBMaXZlYmxvY2tzIEFQSSBmcm9tIHlvdXIgTm9kZS5qcyBiYWNrZW5kLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNfID0gb3B0aW9ucztcbiAgICBjb25zdCBzZWNyZXQgPSBvcHRpb25zXy5zZWNyZXQ7XG4gICAgYXNzZXJ0U2VjcmV0S2V5KHNlY3JldCwgXCJzZWNyZXRcIik7XG4gICAgdGhpcy5fc2VjcmV0ID0gc2VjcmV0O1xuICAgIHRoaXMuX2Jhc2VVcmwgPSBuZXcgVVJMKGdldEJhc2VVcmwob3B0aW9ucy5iYXNlVXJsKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBwb3N0KHBhdGgsIGpzb24pIHtcbiAgICBjb25zdCB1cmwyID0gdXJsam9pbih0aGlzLl9iYXNlVXJsLCBwYXRoKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuX3NlY3JldH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoID0gYXdhaXQgZmV0Y2hQb2x5ZmlsbCgpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybDIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgcHV0KHBhdGgsIGpzb24pIHtcbiAgICBjb25zdCB1cmwyID0gdXJsam9pbih0aGlzLl9iYXNlVXJsLCBwYXRoKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuX3NlY3JldH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoID0gYXdhaXQgZmV0Y2hQb2x5ZmlsbCgpO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwyLCB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIHB1dEJpbmFyeShwYXRoLCBib2R5LCBwYXJhbXMpIHtcbiAgICBjb25zdCB1cmwyID0gdXJsam9pbih0aGlzLl9iYXNlVXJsLCBwYXRoLCBwYXJhbXMpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5fc2VjcmV0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGZldGNoUG9seWZpbGwoKTtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2godXJsMiwgeyBtZXRob2Q6IFwiUFVUXCIsIGhlYWRlcnMsIGJvZHkgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBkZWxldGUocGF0aCkge1xuICAgIGNvbnN0IHVybDIgPSB1cmxqb2luKHRoaXMuX2Jhc2VVcmwsIHBhdGgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5fc2VjcmV0fWBcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoID0gYXdhaXQgZmV0Y2hQb2x5ZmlsbCgpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybDIsIHsgbWV0aG9kOiBcIkRFTEVURVwiLCBoZWFkZXJzIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBnZXQocGF0aCwgcGFyYW1zKSB7XG4gICAgY29uc3QgdXJsMiA9IHVybGpvaW4odGhpcy5fYmFzZVVybCwgcGF0aCwgcGFyYW1zKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuX3NlY3JldH1gXG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGZldGNoUG9seWZpbGwoKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwyLCB7IG1ldGhvZDogXCJHRVRcIiwgaGVhZGVycyB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQXV0aGVudGljYXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogUHJlcGFyZXMgYSBuZXcgc2Vzc2lvbiB0byBhdXRob3JpemUgYSB1c2VyIHRvIGFjY2VzcyBMaXZlYmxvY2tzLlxuICAgKlxuICAgKiBJTVBPUlRBTlQ6XG4gICAqIEFsd2F5cyBtYWtlIHN1cmUgdGhhdCB5b3UgdHJ1c3QgdGhlIHVzZXIgbWFraW5nIHRoZSByZXF1ZXN0IHRvIHlvdXJcbiAgICogYmFja2VuZCBiZWZvcmUgY2FsbGluZyAucHJlcGFyZVNlc3Npb24oKSFcbiAgICpcbiAgICogQHBhcmFtIHVzZXJJZCBUZWxsIExpdmVibG9ja3MgdGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgdG8gYXV0aG9yaXplLiBNdXN0XG4gICAqIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSB1c2VyIGFjY291bnQgaW4geW91ciBzeXN0ZW0uIFRoZSB1bmlxdWVuZXNzIG9mIHRoaXNcbiAgICogdmFsdWUgd2lsbCBkZXRlcm1pbmUgaG93IG1hbnkgTUFVcyB3aWxsIGJlIGNvdW50ZWQvYmlsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy51c2VySW5mbyBDdXN0b20gbWV0YWRhdGEgdG8gYXR0YWNoIHRvIHRoaXMgdXNlci4gRGF0YSB5b3VcbiAgICogYWRkIGhlcmUgd2lsbCBiZSB2aXNpYmxlIHRvIGFsbCBvdGhlciBjbGllbnRzIGluIHRoZSByb29tLCB0aHJvdWdoIHRoZVxuICAgKiBgb3RoZXIuaW5mb2AgcHJvcGVydHkuXG4gICAqXG4gICAqL1xuICBwcmVwYXJlU2Vzc2lvbih1c2VySWQsIC4uLnJlc3QpIHtcbiAgICBjb25zdCBvcHRpb25zID0gcmVzdFswXTtcbiAgICByZXR1cm4gbmV3IFNlc3Npb24odGhpcy5wb3N0LmJpbmQodGhpcyksIHVzZXJJZCwgb3B0aW9ucz8udXNlckluZm8pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gYXV0aGVudGljYXRlIHRoZSB1c2VyIGFzIGFuIGFjdG9yIHlvdSB3YW50IHRvIGFsbG93IHRvIHVzZVxuICAgKiBMaXZlYmxvY2tzLlxuICAgKlxuICAgKiBZb3Ugc2hvdWxkIHVzZSB0aGlzIG1ldGhvZCBvbmx5IGlmIHlvdSB3YW50IHRvIG1hbmFnZSB5b3VyIHBlcm1pc3Npb25zXG4gICAqIHRocm91Z2ggdGhlIExpdmVibG9ja3MgUGVybWlzc2lvbnMgQVBJLiBUaGlzIG1ldGhvZCBpcyBtb3JlIGNvbXBsaWNhdGVkIHRvXG4gICAqIHNldCB1cCwgYnV0IGFsbG93cyBmb3IgZmluZXItZ3JhaW5lZCBzcGVjaWZpY2F0aW9uIG9mIHBlcm1pc3Npb25zLlxuICAgKlxuICAgKiBDYWxsaW5nIGAuaWRlbnRpZnlVc2VyKClgIG9ubHkgbGV0cyB5b3Ugc2VjdXJlbHkgaWRlbnRpZnkgYSB1c2VyIChhbmQgd2hhdFxuICAgKiBncm91cHMgdGhleSBiZWxvbmcgdG8pLiBXaGF0IHBlcm1pc3Npb25zIHRoaXMgdXNlciB3aWxsIGVuZCB1cCBoYXZpbmcgaXNcbiAgICogZGV0ZXJtaW5lZCBieSB3aGF0ZXZlciBwZXJtaXNzaW9ucyB5b3UgYXNzaWduIHRoZSB1c2VyL2dyb3VwIGluIHlvdXJcbiAgICogTGl2ZWJsb2NrcyBhY2NvdW50LCB0aHJvdWdoIHRoZSBQZXJtaXNzaW9ucyBBUEk6XG4gICAqIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3Jvb21zL3Blcm1pc3Npb25zXG4gICAqXG4gICAqIElNUE9SVEFOVDpcbiAgICogQWx3YXlzIHZlcmlmeSB0aGF0IHlvdSB0cnVzdCB0aGUgdXNlciBtYWtpbmcgdGhlIHJlcXVlc3QgYmVmb3JlIGNhbGxpbmdcbiAgICogLmlkZW50aWZ5VXNlcigpIVxuICAgKlxuICAgKiBAcGFyYW0gaWRlbnRpdHkgVGVsbCBMaXZlYmxvY2tzIHRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZS5cbiAgICogTXVzdCB1bmlxdWVseSBpZGVudGlmeSB0aGUgdXNlciBhY2NvdW50IGluIHlvdXIgc3lzdGVtLiBUaGUgdW5pcXVlbmVzcyBvZlxuICAgKiB0aGlzIHZhbHVlIHdpbGwgZGV0ZXJtaW5lIGhvdyBtYW55IE1BVXMgd2lsbCBiZSBjb3VudGVkL2JpbGxlZC5cbiAgICpcbiAgICogSWYgeW91IGFsc28gd2FudCB0byBhc3NpZ24gd2hpY2ggZ3JvdXBzIHRoaXMgdXNlciBiZWxvbmdzIHRvLCB1c2UgdGhlXG4gICAqIG9iamVjdCBmb3JtIGFuZCBzcGVjaWZ5IHRoZSBgZ3JvdXBJZHNgIHByb3BlcnR5LiBUaG9zZSBgZ3JvdXBJZHNgIHNob3VsZFxuICAgKiBtYXRjaCB0aGUgZ3JvdXBJZHMgeW91IGFzc2lnbmVkIHBlcm1pc3Npb25zIHRvIHZpYSB0aGUgTGl2ZWJsb2Nrc1xuICAgKiBQZXJtaXNzaW9ucyBBUEksIHNlZVxuICAgKiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9yb29tcy9wZXJtaXNzaW9ucyNwZXJtaXNzaW9ucy1sZXZlbHMtZ3JvdXBzLWFjY2Vzc2VzLWV4YW1wbGVcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMudXNlckluZm8gQ3VzdG9tIG1ldGFkYXRhIHRvIGF0dGFjaCB0byB0aGlzIHVzZXIuIERhdGEgeW91XG4gICAqIGFkZCBoZXJlIHdpbGwgYmUgdmlzaWJsZSB0byBhbGwgb3RoZXIgY2xpZW50cyBpbiB0aGUgcm9vbSwgdGhyb3VnaCB0aGVcbiAgICogYG90aGVyLmluZm9gIHByb3BlcnR5LlxuICAgKi9cbiAgLy8gVGhlc2UgZmllbGRzIGRlZmluZSB0aGUgc2VjdXJpdHkgaWRlbnRpdHkgb2YgdGhlIHVzZXIuIFdoYXRldmVyIHlvdSBwYXNzIGluIGhlcmUgd2lsbCBkZWZpbmUgd2hpY2hcbiAgYXN5bmMgaWRlbnRpZnlVc2VyKGlkZW50aXR5LCAuLi5yZXN0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc3RbMF07XG4gICAgY29uc3QgcGF0aCA9IHVybGAvdjIvaWRlbnRpZnktdXNlcmA7XG4gICAgY29uc3QgdXNlcklkID0gdHlwZW9mIGlkZW50aXR5ID09PSBcInN0cmluZ1wiID8gaWRlbnRpdHkgOiBpZGVudGl0eS51c2VySWQ7XG4gICAgY29uc3QgZ3JvdXBJZHMgPSB0eXBlb2YgaWRlbnRpdHkgPT09IFwic3RyaW5nXCIgPyB2b2lkIDAgOiBpZGVudGl0eS5ncm91cElkcztcbiAgICBhc3NlcnROb25FbXB0eSh1c2VySWQsIFwidXNlcklkXCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5wb3N0KHBhdGgsIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBncm91cElkcyxcbiAgICAgICAgLy8gT3B0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgdXNlckluZm86IG9wdGlvbnM/LnVzZXJJbmZvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogbm9ybWFsaXplU3RhdHVzQ29kZShyZXNwLnN0YXR1cyksXG4gICAgICAgIGJvZHk6IGF3YWl0IHJlc3AudGV4dCgpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IDUwMyxcbiAgICAgICAgYm9keTogYENhbGwgdG8gJHt1cmxqb2luKFxuICAgICAgICAgIHRoaXMuX2Jhc2VVcmwsXG4gICAgICAgICAgcGF0aFxuICAgICAgICApfSBmYWlsZWQuIFNlZSBcImVycm9yXCIgZm9yIG1vcmUgaW5mb3JtYXRpb24uYCxcbiAgICAgICAgZXJyb3I6IGVyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFJvb21cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgeW91ciByb29tcy4gVGhlIHJvb21zIGFyZSByZXR1cm5lZCBzb3J0ZWQgYnkgY3JlYXRpb24gZGF0ZSwgZnJvbSBuZXdlc3QgdG8gb2xkZXN0LiBZb3UgY2FuIGZpbHRlciByb29tcyBieSBtZXRhZGF0YSwgdXNlcnMgYWNjZXNzZXMgYW5kIGdyb3VwcyBhY2Nlc3Nlcy5cbiAgICogQHBhcmFtIHBhcmFtcy5saW1pdCAob3B0aW9uYWwpIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiByb29tcyB0byBiZSByZXR1cm5lZC4gVGhlIGxpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIGRlZmF1bHRzIHRvIDIwLlxuICAgKiBAcGFyYW0gcGFyYW1zLnN0YXJ0aW5nQWZ0ZXIgKG9wdGlvbmFsKSBBIGN1cnNvciB1c2VkIGZvciBwYWdpbmF0aW9uLiBZb3UgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvZiB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgKG9wdGlvbmFsKSBBIGZpbHRlciBvbiB1c2VycyBhY2Nlc3Nlcy5cbiAgICogQHBhcmFtIHBhcmFtcy5tZXRhZGF0YSAob3B0aW9uYWwpIEEgZmlsdGVyIG9uIG1ldGFkYXRhLiBNdWx0aXBsZSBtZXRhZGF0YSBrZXlzIGNhbiBiZSB1c2VkIHRvIGZpbHRlciByb29tcy5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cElkcyAob3B0aW9uYWwpIEEgZmlsdGVyIG9uIGdyb3VwcyBhY2Nlc3Nlcy4gTXVsdGlwbGUgZ3JvdXBzIGNhbiBiZSB1c2VkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnF1ZXJ5IChvcHRpb25hbCkgQSBxdWVyeSB0byBmaWx0ZXIgcm9vbXMgYnkuIEl0IGlzIGJhc2VkIG9uIG91ciBxdWVyeSBsYW5ndWFnZS4gWW91IGNhbiBmaWx0ZXIgYnkgbWV0YWRhdGEgYW5kIHJvb20gSUQuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiByb29tcy5cbiAgICovXG4gIGFzeW5jIGdldFJvb21zKHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgcGF0aCA9IHVybGAvdjIvcm9vbXNgO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcXVlcnkgPSBwYXJhbXMucXVlcnk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLnF1ZXJ5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBxdWVyeSA9IG9iamVjdFRvUXVlcnkocGFyYW1zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSB7XG4gICAgICBsaW1pdDogcGFyYW1zLmxpbWl0LFxuICAgICAgc3RhcnRpbmdBZnRlcjogcGFyYW1zLnN0YXJ0aW5nQWZ0ZXIsXG4gICAgICB1c2VySWQ6IHBhcmFtcy51c2VySWQsXG4gICAgICBncm91cElkczogcGFyYW1zLmdyb3VwSWRzID8gcGFyYW1zLmdyb3VwSWRzLmpvaW4oXCIsXCIpIDogdm9pZCAwLFxuICAgICAgLy8gXCJGbGF0dGVuXCIge21ldGFkYXRhOiB7Zm9vOiBcImJhclwifX0gdG8ge1wibWV0YWRhdGEuZm9vXCI6IFwiYmFyXCJ9XG4gICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcy5tZXRhZGF0YSA/PyB7fSkubWFwKChba2V5LCB2YWxdKSA9PiBbXG4gICAgICAgICAgYG1ldGFkYXRhLiR7a2V5fWAsXG4gICAgICAgICAgdmFsXG4gICAgICAgIF0pXG4gICAgICApLFxuICAgICAgcXVlcnlcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHBhdGgsIHF1ZXJ5UGFyYW1zKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCByb29tcyA9IGRhdGEuZGF0YS5tYXAoKHJvb20pID0+IHtcbiAgICAgIGNvbnN0IGxhc3RDb25uZWN0aW9uQXQgPSByb29tLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShyb29tLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUocm9vbS5jcmVhdGVkQXQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucm9vbSxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICBsYXN0Q29ubmVjdGlvbkF0XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgZGF0YTogcm9vbXNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHJvb20gd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtIHBhcmFtcy5kZWZhdWx0QWNjZXNzZXMgVGhlIGRlZmF1bHQgYWNjZXNzZXMgZm9yIHRoZSByb29tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmdyb3Vwc0FjY2Vzc2VzIChvcHRpb25hbCkgVGhlIGdyb3VwIGFjY2Vzc2VzIGZvciB0aGUgcm9vbS4gQ2FuIGNvbnRhaW4gYSBtYXhpbXVtIG9mIDEwMCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcnNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSB1c2VyIGFjY2Vzc2VzIGZvciB0aGUgcm9vbS4gQ2FuIGNvbnRhaW4gYSBtYXhpbXVtIG9mIDEwMCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMubWV0YWRhdGEgKG9wdGlvbmFsKSBUaGUgbWV0YWRhdGEgZm9yIHRoZSByb29tLiBTdXBwb3J0cyB1cHRvIGEgbWF4aW11bSBvZiA1MCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuIFZhbHVlIGxlbmd0aCBoYXMgYSBsaW1pdCBvZiAyNTYgY2hhcmFjdGVycy5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgcm9vbS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVJvb20ocm9vbUlkLCBwYXJhbXMpIHtcbiAgICBjb25zdCB7IGRlZmF1bHRBY2Nlc3NlcywgZ3JvdXBzQWNjZXNzZXMsIHVzZXJzQWNjZXNzZXMsIG1ldGFkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KHVybGAvdjIvcm9vbXNgLCB7XG4gICAgICBpZDogcm9vbUlkLFxuICAgICAgZGVmYXVsdEFjY2Vzc2VzLFxuICAgICAgZ3JvdXBzQWNjZXNzZXMsXG4gICAgICB1c2Vyc0FjY2Vzc2VzLFxuICAgICAgbWV0YWRhdGFcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBsYXN0Q29ubmVjdGlvbkF0ID0gZGF0YS5sYXN0Q29ubmVjdGlvbkF0ID8gbmV3IERhdGUoZGF0YS5sYXN0Q29ubmVjdGlvbkF0KSA6IHZvaWQgMDtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBsYXN0Q29ubmVjdGlvbkF0LFxuICAgICAgY3JlYXRlZEF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHJvb20gd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIHJldHVybi5cbiAgICogQHJldHVybnMgVGhlIHJvb20gd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqL1xuICBhc3luYyBnZXRSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHVybGAvdjIvcm9vbXMvJHtyb29tSWR9YCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgbGFzdENvbm5lY3Rpb25BdCA9IGRhdGEubGFzdENvbm5lY3Rpb25BdCA/IG5ldyBEYXRlKGRhdGEubGFzdENvbm5lY3Rpb25BdCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgbGFzdENvbm5lY3Rpb25BdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgc3BlY2lmaWMgcHJvcGVydGllcyBvZiBhIHJvb20uIEl04oCZcyBub3QgbmVjZXNzYXJ5IHRvIHByb3ZpZGUgdGhlIGVudGlyZSByb29t4oCZcyBpbmZvcm1hdGlvbi5cbiAgICogU2V0dGluZyBhIHByb3BlcnR5IHRvIGBudWxsYCBtZWFucyB0byBkZWxldGUgdGhpcyBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRlZmF1bHRBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBkZWZhdWx0IGFjY2Vzc2VzIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cHNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBncm91cCBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJzQWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgdXNlciBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgcm9vbS4gU3VwcG9ydHMgdXB0byBhIG1heGltdW0gb2YgNTAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLiBWYWx1ZSBsZW5ndGggaGFzIGEgbGltaXQgb2YgMjU2IGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIHJvb20uXG4gICAqL1xuICBhc3luYyB1cGRhdGVSb29tKHJvb21JZCwgcGFyYW1zKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0QWNjZXNzZXMsIGdyb3Vwc0FjY2Vzc2VzLCB1c2Vyc0FjY2Vzc2VzLCBtZXRhZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdCh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfWAsIHtcbiAgICAgIGRlZmF1bHRBY2Nlc3NlcyxcbiAgICAgIGdyb3Vwc0FjY2Vzc2VzLFxuICAgICAgdXNlcnNBY2Nlc3NlcyxcbiAgICAgIG1ldGFkYXRhXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgbGFzdENvbm5lY3Rpb25BdCA9IGRhdGEubGFzdENvbm5lY3Rpb25BdCA/IG5ldyBEYXRlKGRhdGEubGFzdENvbm5lY3Rpb25BdCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbGFzdENvbm5lY3Rpb25BdCxcbiAgICAgIGNyZWF0ZWRBdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSByb29tIHdpdGggdGhlIGdpdmVuIGlkLiBBIGRlbGV0ZWQgcm9vbSBpcyBubyBsb25nZXIgYWNjZXNzaWJsZSBmcm9tIHRoZSBBUEkgb3IgdGhlIGRhc2hib2FyZCBhbmQgaXQgY2Fubm90IGJlIHJlc3RvcmVkLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBkZWxldGUuXG4gICAqL1xuICBhc3luYyBkZWxldGVSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGVsZXRlKHVybGAvdjIvcm9vbXMvJHtyb29tSWR9YCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHVzZXJzIGN1cnJlbnRseSBwcmVzZW50IGluIHRoZSByZXF1ZXN0ZWQgcm9vbS4gRm9yIGJldHRlciBwZXJmb3JtYW5jZSwgd2UgcmVjb21tYW5kIHRvIGNhbGwgdGhpcyBlbmRwb2ludCBldmVyeSAxMCBzZWNvbmRzIG1heGltdW0uIER1cGxpY2F0ZXMgY2FuIGhhcHBlbiBpZiBhIHVzZXIgaXMgaW4gdGhlIHJlcXVlc3RlZCByb29tIHdpdGggbXVsdGlwbGUgYnJvd3NlciB0YWJzIG9wZW5lZC5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZ2V0IHRoZSB1c2VycyBmcm9tLlxuICAgKiBAcmV0dXJucyBBIGxpc3Qgb2YgdXNlcnMgY3VycmVudGx5IHByZXNlbnQgaW4gdGhlIHJlcXVlc3RlZCByb29tLlxuICAgKi9cbiAgYXN5bmMgZ2V0QWN0aXZlVXNlcnMocm9vbUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQodXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vYWN0aXZlX3VzZXJzYCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJvYWRjYXN0cyBhbiBldmVudCB0byBhIHJvb20gd2l0aG91dCBoYXZpbmcgdG8gY29ubmVjdCB0byBpdCB2aWEgdGhlIGNsaWVudCBmcm9tIEBsaXZlYmxvY2tzL2NsaWVudC4gVGhlIGNvbm5lY3Rpb25JZCBwYXNzZWQgdG8gZXZlbnQgbGlzdGVuZXJzIGlzIC0xIHdoZW4gdXNpbmcgdGhpcyBBUEkuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGJyb2FkY2FzdCB0aGUgZXZlbnQgdG8uXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJyb2FkY2FzdC4gSXQgY2FuIGJlIGFueSBKU09OIHNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAgICovXG4gIGFzeW5jIGJyb2FkY2FzdEV2ZW50KHJvb21JZCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L2Jyb2FkY2FzdF9ldmVudGAsXG4gICAgICBtZXNzYWdlXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlRG9jdW1lbnQocm9vbUlkLCBmb3JtYXQgPSBcInBsYWluLWxzb25cIikge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3N0b3JhZ2VgLCB7IGZvcm1hdCB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSByb29t4oCZcyBTdG9yYWdlLiBUaGUgcm9vbSBtdXN0IGFscmVhZHkgZXhpc3QgYW5kIGhhdmUgYW4gZW1wdHkgU3RvcmFnZS5cbiAgICogQ2FsbGluZyB0aGlzIGVuZHBvaW50IHdpbGwgZGlzY29ubmVjdCBhbGwgdXNlcnMgZnJvbSB0aGUgcm9vbSBpZiB0aGVyZSBhcmUgYW55LlxuICAgKlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBpbml0aWFsaXplIHRoZSBzdG9yYWdlIGZyb20uXG4gICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gaW5pdGlhbGl6ZSB0aGUgc3RvcmFnZSB3aXRoLlxuICAgKiBAcmV0dXJucyBUaGUgaW5pdGlhbGl6ZWQgc3RvcmFnZSBkb2N1bWVudC4gSXQgaXMgb2YgdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBvbmUgcGFzc2VkIGluLlxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZVN0b3JhZ2VEb2N1bWVudChyb29tSWQsIGRvY3VtZW50KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3N0b3JhZ2VgLCBkb2N1bWVudCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIG9mIHRoZSByb29t4oCZcyBTdG9yYWdlIGRhdGEgYW5kIGRpc2Nvbm5lY3QgYWxsIHVzZXJzIGZyb20gdGhlIHJvb20gaWYgdGhlcmUgYXJlIGFueS4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgZGVsZXRlIHRoZSBZanMgZG9jdW1lbnQgaW4gdGhlIHJvb20gaWYgb25lIGV4aXN0cy5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZGVsZXRlIHRoZSBzdG9yYWdlIGZyb20uXG4gICAqL1xuICBhc3luYyBkZWxldGVTdG9yYWdlRG9jdW1lbnQocm9vbUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kZWxldGUodXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vc3RvcmFnZWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogWWpzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByb29t4oCZcyBZanMgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGdldCB0aGUgWWpzIGRvY3VtZW50IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMuZm9ybWF0IChvcHRpb25hbCkgSWYgdHJ1ZSwgWVRleHQgd2lsbCByZXR1cm4gZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIHBhcmFtcy5rZXkgKG9wdGlvbmFsKSBJZiBwcm92aWRlZCwgcmV0dXJucyBvbmx5IGEgc2luZ2xlIGtleeKAmXMgdmFsdWUsIGUuZy4gZG9jLmdldChrZXkpLnRvSlNPTigpLlxuICAgKiBAcGFyYW0gcGFyYW1zLnR5cGUgKG9wdGlvbmFsKSBVc2VkIHdpdGgga2V5IHRvIG92ZXJyaWRlIHRoZSBpbmZlcnJlZCB0eXBlLCBpLmUuIFwieW1hcFwiIHdpbGwgcmV0dXJuIGRvYy5nZXQoa2V5LCBZLk1hcCkuXG4gICAqIEByZXR1cm5zIEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0WWpzRG9jdW1lbnQocm9vbUlkLCBwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IHsgZm9ybWF0LCBrZXksIHR5cGUgfSA9IHBhcmFtcztcbiAgICBjb25zdCBwYXRoID0gdXJsYHYyL3Jvb21zLyR7cm9vbUlkfS95ZG9jYDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldChwYXRoLCB7XG4gICAgICBmb3JtYXR0aW5nOiBmb3JtYXQgPyBcInRydWVcIiA6IHZvaWQgMCxcbiAgICAgIGtleSxcbiAgICAgIHR5cGVcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogU2VuZCBhIFlqcyBiaW5hcnkgdXBkYXRlIHRvIHRoZSByb29t4oCZcyBZanMgZG9jdW1lbnQuIFlvdSBjYW4gdXNlIHRoaXMgZW5kcG9pbnQgdG8gaW5pdGlhbGl6ZSBZanMgZGF0YSBmb3IgdGhlIHJvb20gb3IgdG8gdXBkYXRlIHRoZSByb29t4oCZcyBZanMgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIHNlbmQgdGhlIFlqcyBiaW5hcnkgdXBkYXRlIHRvLlxuICAgKiBAcGFyYW0gdXBkYXRlIFRoZSBZanMgdXBkYXRlIHRvIHNlbmQuIFR5cGljYWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYFlqcy5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYylgLiBSZWFkIHRoZSBbWWpzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy55anMuZGV2L2FwaS9kb2N1bWVudC11cGRhdGVzKSB0byBsZWFybiBob3cgdG8gY3JlYXRlIGEgYmluYXJ5IHVwZGF0ZS5cbiAgICogQHBhcmFtIHBhcmFtcy5ndWlkIChvcHRpb25hbCkgSWYgcHJvdmlkZWQsIHRoZSBiaW5hcnkgdXBkYXRlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgWWpzIHN1YmRvY3VtZW50IHdpdGggdGhlIGdpdmVuIGd1aWQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGJpbmFyeSB1cGRhdGUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSByb290IFlqcyBkb2N1bWVudC5cbiAgICovXG4gIGFzeW5jIHNlbmRZanNCaW5hcnlVcGRhdGUocm9vbUlkLCB1cGRhdGUsIHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wdXRCaW5hcnkodXJsYC92Mi9yb29tcy8ke3Jvb21JZH0veWRvY2AsIHVwZGF0ZSwge1xuICAgICAgZ3VpZDogcGFyYW1zLmd1aWRcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50IGVuY29kZWQgYXMgYSBzaW5nbGUgYmluYXJ5IHVwZGF0ZS4gVGhpcyBjYW4gYmUgdXNlZCBieSBZLmFwcGx5VXBkYXRlKHJlc3BvbnNlQm9keSkgdG8gZ2V0IGEgY29weSBvZiB0aGUgZG9jdW1lbnQgaW4geW91ciBiYWNrZW5kLlxuICAgKiBTZWUgW1lqcyBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MueWpzLmRldi9hcGkvZG9jdW1lbnQtdXBkYXRlcykgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd29ya2luZyB3aXRoIHVwZGF0ZXMuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGdldCB0aGUgWWpzIGRvY3VtZW50IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMuZ3VpZCAob3B0aW9uYWwpIElmIHByb3ZpZGVkLCByZXR1cm5zIHRoZSBiaW5hcnkgdXBkYXRlIG9mIHRoZSBZanMgc3ViZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gZ3VpZC4gSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIHRoZSBiaW5hcnkgdXBkYXRlIG9mIHRoZSByb290IFlqcyBkb2N1bWVudC5cbiAgICogQHJldHVybnMgVGhlIHJvb23igJlzIFlqcyBkb2N1bWVudCBlbmNvZGVkIGFzIGEgc2luZ2xlIGJpbmFyeSB1cGRhdGUuXG4gICAqL1xuICBhc3luYyBnZXRZanNEb2N1bWVudEFzQmluYXJ5VXBkYXRlKHJvb21JZCwgcGFyYW1zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS95ZG9jLWJpbmFyeWAsIHtcbiAgICAgIGd1aWQ6IHBhcmFtcy5ndWlkXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5hcnJheUJ1ZmZlcigpO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogU2NoZW1hIFZhbGlkYXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzY2hlbWEgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgbGF0ZXIgdG8gZW5mb3JjZSBhIHJvb23igJlzIFN0b3JhZ2UgZGF0YSBzdHJ1Y3R1cmUuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBzY2hlbWEuIE11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIHdpdGggbGVzcyB0aGFuIDY1IGNoYXJhY3RlcnMgYW5kIG9ubHkgY29udGFpbiBsb3dlcmNhc2UgbGV0dGVycywgbnVtYmVycyBhbmQgZGFzaGVzXG4gICAqIEBwYXJhbSBib2R5IFRoZSBleGFjdCBhbGxvd2VkIHNoYXBlIG9mIGRhdGEgaW4gdGhlIHJvb20uIEl0IGlzIGEgbXVsdGktbGluZSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgW0xpdmVibG9ja3Mgc2NoZW1hIHN5bnRheF0oaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvcGxhdGZvcm0vc2NoZW1hLXZhbGlkYXRpb24vc3ludGF4KS5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgc2NoZW1hLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2NoZW1hKG5hbWUsIGJvZHkpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QodXJsYC92Mi9zY2hlbWFzYCwge1xuICAgICAgbmFtZSxcbiAgICAgIGJvZHlcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgdXBkYXRlZEF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNjaGVtYSBieSBpdHMgaWQuXG4gICAqIEBwYXJhbSBzY2hlbWFJZCBJZCBvZiB0aGUgc2NoZW1hIC0gdGhpcyBpcyB0aGUgY29tYmluYXRpb24gb2YgdGhlIHNjaGVtYSBuYW1lIGFuZCB2ZXJzaW9uIG9mIHRoZSBzY2hlbWEgdG8gdXBkYXRlLiBGb3IgZXhhbXBsZSwgYG15LXNjaGVtYUAxYC5cbiAgICogQHJldHVybnMgVGhlIHNjaGVtYSB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICovXG4gIGFzeW5jIGdldFNjaGVtYShzY2hlbWFJZCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHVybGAvdjIvc2NoZW1hcy8ke3NjaGVtYUlkfWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBib2R5IGZvciB0aGUgc2NoZW1hLiBBIHNjaGVtYSBjYW4gb25seSBiZSB1cGRhdGVkIGlmIGl0IGlzIG5vdCB1c2VkIGJ5IGFueSByb29tLlxuICAgKiBAcGFyYW0gc2NoZW1hSWQgSWQgb2YgdGhlIHNjaGVtYSAtIHRoaXMgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBzY2hlbWEgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRvIHVwZGF0ZS4gRm9yIGV4YW1wbGUsIGBteS1zY2hlbWFAMWAuXG4gICAqIEBwYXJhbSBib2R5IFRoZSBleGFjdCBhbGxvd2VkIHNoYXBlIG9mIGRhdGEgaW4gdGhlIHJvb20uIEl0IGlzIGEgbXVsdGktbGluZSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgW0xpdmVibG9ja3Mgc2NoZW1hIHN5bnRheF0oaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvcGxhdGZvcm0vc2NoZW1hLXZhbGlkYXRpb24vc3ludGF4KS5cbiAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgc2NoZW1hLiBUaGUgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHdpbGwgYmUgaW5jcmVtZW50ZWQuXG4gICAqL1xuICBhc3luYyB1cGRhdGVTY2hlbWEoc2NoZW1hSWQsIGJvZHkpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnB1dCh1cmxgL3YyL3NjaGVtYXMvJHtzY2hlbWFJZH1gLCB7XG4gICAgICBib2R5XG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIHVwZGF0ZWRBdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBzY2hlbWEgYnkgaXRzIGlkLiBBIHNjaGVtYSBjYW4gb25seSBiZSBkZWxldGVkIGlmIGl0IGlzIG5vdCB1c2VkIGJ5IGFueSByb29tLlxuICAgKiBAcGFyYW0gc2NoZW1hSWQgSWQgb2YgdGhlIHNjaGVtYSAtIHRoaXMgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBzY2hlbWEgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRvIHVwZGF0ZS4gRm9yIGV4YW1wbGUsIGBteS1zY2hlbWFAMWAuXG4gICAqL1xuICBhc3luYyBkZWxldGVTY2hlbWEoc2NoZW1hSWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZSh1cmxgL3YyL3NjaGVtYXMvJHtzY2hlbWFJZH1gKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2NoZW1hIGF0dGFjaGVkIHRvIGEgcm9vbS5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZ2V0IHRoZSBzY2hlbWEgZnJvbS5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFNjaGVtYUJ5Um9vbUlkKHJvb21JZCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3NjaGVtYWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhIHNjaGVtYSB0byBhIHJvb20sIGFuZCBpbnN0YW50bHkgZW5hYmxlcyBydW50aW1lIHNjaGVtYSB2YWxpZGF0aW9uIGZvciB0aGUgcm9vbS5cbiAgICogSWYgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIHJvb23igJlzIFN0b3JhZ2UgZG8gbm90IG1hdGNoIHRoZSBzY2hlbWEsIGF0dGFjaGluZyB3aWxsIGZhaWwgYW5kIHRoZSBlcnJvciBtZXNzYWdlIHdpbGwgZ2l2ZSBkZXRhaWxzIG9uIHdoeSB0aGUgc2NoZW1hIGZhaWxlZCB0byBhdHRhY2guXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGF0dGFjaCB0aGUgc2NoZW1hIHRvLlxuICAgKiBAcGFyYW0gc2NoZW1hSWQgSWQgb2YgdGhlIHNjaGVtYSAtIHRoaXMgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBzY2hlbWEgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRvIHVwZGF0ZS4gRm9yIGV4YW1wbGUsIGBteS1zY2hlbWFAMWAuXG4gICAqIEByZXR1cm5zIFRoZSBzY2hlbWEgaWQgYXMgSlNPTi5cbiAgICovXG4gIGFzeW5jIGF0dGFjaFNjaGVtYVRvUm9vbShyb29tSWQsIHNjaGVtYUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3NjaGVtYWAsIHtcbiAgICAgIHNjaGVtYTogc2NoZW1hSWRcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRGV0YWNoZXMgYSBzY2hlbWEgZnJvbSBhIHJvb20sIGFuZCBkaXNhYmxlcyBydW50aW1lIHNjaGVtYSB2YWxpZGF0aW9uIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZGV0YWNoIHRoZSBzY2hlbWEgZnJvbS5cbiAgICovXG4gIGFzeW5jIGRldGFjaFNjaGVtYUZyb21Sb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGVsZXRlKHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3NjaGVtYWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29tbWVudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIHRocmVhZHMgaW4gYSByb29tLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIHRocmVhZHMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5xdWVyeSBUaGUgcXVlcnkgdG8gZmlsdGVyIHRocmVhZHMgYnkuIEl0IGlzIGJhc2VkIG9uIG91ciBxdWVyeSBsYW5ndWFnZSBhbmQgY2FuIGZpbHRlciBieSBtZXRhZGF0YS5cbiAgICogQHJldHVybnMgQSBsaXN0IG9mIHRocmVhZHMuXG4gICAqL1xuICBhc3luYyBnZXRUaHJlYWRzKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkIH0gPSBwYXJhbXM7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLnF1ZXJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBxdWVyeSA9IHBhcmFtcy5xdWVyeTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMucXVlcnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShwYXJhbXMucXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzYCwge1xuICAgICAgcXVlcnlcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGRhdGEubWFwKCh0aHJlYWQpID0+IGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgdGhyZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIHRocmVhZCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQuXG4gICAqIEByZXR1cm5zIEEgdGhyZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VGhyZWFkKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH1gKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIHRocmVhZCdzIHBhcnRpY2lwYW50cy5cbiAgICpcbiAgICogUGFydGljaXBhbnRzIGFyZSB1c2VycyB3aG8gaGF2ZSBjb21tZW50ZWQgb24gdGhlIHRocmVhZFxuICAgKiBvciB1c2VycyBhbmQgZ3JvdXBzIHRoYXQgaGF2ZSBiZWVuIG1lbnRpb25lZCBpbiBhIGNvbW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGdldCB0aGUgdGhyZWFkIHBhcnRpY2lwYW50cyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gZ2V0IHRoZSBwYXJ0aWNpcGFudHMgZnJvbS5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgcGFydGljaXBhbnQgSURzLlxuICAgKi9cbiAgYXN5bmMgZ2V0VGhyZWFkUGFydGljaXBhbnRzKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9wYXJ0aWNpcGFudHNgXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIHRocmVhZCdzIGNvbW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGdldCB0aGUgY29tbWVudCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gZ2V0IHRoZSBjb21tZW50IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMuY29tbWVudElkIFRoZSBjb21tZW50IElELlxuICAgKiBAcmV0dXJucyBBIGNvbW1lbnQuXG4gICAqL1xuICBhc3luYyBnZXRDb21tZW50KHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQoXG4gICAgICB1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWBcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGNyZWF0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGNyZWF0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gaXMgc2V0IHRvIGNyZWF0ZSB0aGUgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmNyZWF0ZWRBdCAob3B0aW9uYWwpIFRoZSBkYXRlIHRoZSBjb21tZW50IGlzIHNldCB0byBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuYm9keSBUaGUgYm9keSBvZiB0aGUgY29tbWVudC5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY29tbWVudC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUNvbW1lbnQocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50c2AsXG4gICAgICB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGNyZWF0ZWRBdDogZGF0YS5jcmVhdGVkQXQ/LnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogRWRpdHMgYSBjb21tZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBlZGl0IHRoZSBjb21tZW50IGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gZWRpdCB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gZWRpdC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmJvZHkgVGhlIGJvZHkgb2YgdGhlIGNvbW1lbnQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5lZGl0ZWRBdCAob3B0aW9uYWwpIFRoZSBkYXRlIHRoZSBjb21tZW50IHdhcyBlZGl0ZWQuXG4gICAqIEByZXR1cm5zIFRoZSBlZGl0ZWQgY29tbWVudC5cbiAgICovXG4gIGFzeW5jIGVkaXRDb21tZW50KHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH1gLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBlZGl0ZWRBdDogZGF0YS5lZGl0ZWRBdD8udG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGF3YWl0IHJlcy5qc29uKCkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgY29tbWVudC4gRGVsZXRlcyBhIGNvbW1lbnQuIElmIHRoZXJlIGFyZSBubyByZW1haW5pbmcgY29tbWVudHMgaW4gdGhlIHRocmVhZCwgdGhlIHRocmVhZCBpcyBhbHNvIGRlbGV0ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGRlbGV0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGRlbGV0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gZGVsZXRlLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlQ29tbWVudChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH1gXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0aHJlYWQuIFRoZSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBjb21tZW50IGFzIGl0cyBmaXJzdCBjb21tZW50LlxuICAgKiBJZiB0aGUgdGhyZWFkIGFscmVhZHkgZXhpc3RzLCBhIGBMaXZlYmxvY2tzRXJyb3JgIHdpbGwgYmUgdGhyb3duIHdpdGggc3RhdHVzIGNvZGUgNDA5LlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBjcmVhdGUgdGhlIHRocmVhZCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWQubWV0YWRhdGEgKG9wdGlvbmFsKSBUaGUgbWV0YWRhdGEgZm9yIHRoZSB0aHJlYWQuIFN1cHBvcnRzIHVwdG8gYSBtYXhpbXVtIG9mIDEwIGVudHJpZXMuIFZhbHVlIG11c3QgYmUgYSBzdHJpbmcsIGJvb2xlYW4gb3IgbnVtYmVyXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkLmNvbW1lbnQudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIHdobyBjcmVhdGVkIHRoZSBjb21tZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZC5jb21tZW50LmNyZWF0ZWRBdCAob3B0aW9uYWwpIFRoZSBkYXRlIHRoZSBjb21tZW50IHdhcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZC5jb21tZW50LmJvZHkgVGhlIGJvZHkgb2YgdGhlIGNvbW1lbnQuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHRocmVhZC4gVGhlIHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbW1lbnQgYXMgaXRzIGZpcnN0IGNvbW1lbnQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVUaHJlYWQocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIGRhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QodXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkc2AsIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjb21tZW50OiB7XG4gICAgICAgIC4uLmRhdGEuY29tbWVudCxcbiAgICAgICAgY3JlYXRlZEF0OiBkYXRhLmNvbW1lbnQuY3JlYXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSB0aHJlYWQgYW5kIGFsbCBvZiBpdHMgY29tbWVudHMuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGRlbGV0ZSB0aGUgdGhyZWFkIGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gZGVsZXRlLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlVGhyZWFkKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGVsZXRlKHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH1gKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTWFyayBhIHRocmVhZCBhcyByZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgb2YgdGhlIHRocmVhZC5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIG1hcmsgYXMgcmVzb2x2ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS51c2VySWQgVGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgd2hvIG1hcmtlZCB0aGUgdGhyZWFkIGFzIHJlc29sdmVkLlxuICAgKiBAcmV0dXJucyBUaGUgdGhyZWFkIG1hcmtlZCBhcyByZXNvbHZlZC5cbiAgICovXG4gIGFzeW5jIG1hcmtUaHJlYWRBc1Jlc29sdmVkKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vbWFyay1hcy1yZXNvbHZlZGAsXG4gICAgICB7fVxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmsgYSB0aHJlYWQgYXMgdW5yZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgb2YgdGhlIHRocmVhZC5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIG1hcmsgYXMgdW5yZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gbWFya2VkIHRoZSB0aHJlYWQgYXMgdW5yZXNvbHZlZC5cbiAgICogQHJldHVybnMgVGhlIHRocmVhZCBtYXJrZWQgYXMgdW5yZXNvbHZlZC5cbiAgICovXG4gIGFzeW5jIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9tYXJrLWFzLXVucmVzb2x2ZWRgLFxuICAgICAge31cbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9UaHJlYWREYXRhKGF3YWl0IHJlcy5qc29uKCkpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBtZXRhZGF0YSBvZiB0aGUgc3BlY2lmaWVkIHRocmVhZCBpbiBhIHJvb20uXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIHVwZGF0ZSB0aGUgdGhyZWFkIGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEubWV0YWRhdGEgVGhlIG1ldGFkYXRhIGZvciB0aGUgdGhyZWFkLiBWYWx1ZSBtdXN0IGJlIGEgc3RyaW5nLCBib29sZWFuIG9yIG51bWJlclxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIHdobyB1cGRhdGVkIHRoZSB0aHJlYWQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS51cGRhdGVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgdGhyZWFkIGlzIHNldCB0byBiZSB1cGRhdGVkLlxuICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCB0aHJlYWQgbWV0YWRhdGEuXG4gICAqL1xuICBhc3luYyBlZGl0VGhyZWFkTWV0YWRhdGEocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9tZXRhZGF0YWAsXG4gICAgICB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHVwZGF0ZWRBdDogZGF0YS51cGRhdGVkQXQ/LnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGNvbW1lbnQgcmVhY3Rpb24gdG8gYSBjb21tZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBhZGQgdGhlIGNvbW1lbnQgcmVhY3Rpb24gaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byBhZGQgdGhlIGNvbW1lbnQgcmVhY3Rpb24gaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMuY29tbWVudElkIFRoZSBjb21tZW50IElEIHRvIGFkZCB0aGUgcmVhY3Rpb24gaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5lbW9qaSBUaGUgKGVtb2ppKSByZWFjdGlvbiB0byBhZGQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS51c2VySWQgVGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWFjdGlvbi5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmNyZWF0ZWRBdCAob3B0aW9uYWwpIFRoZSBkYXRlIHRoZSByZWFjdGlvbiBpcyBzZXQgdG8gYmUgY3JlYXRlZC5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY29tbWVudCByZWFjdGlvbi5cbiAgICovXG4gIGFzeW5jIGFkZENvbW1lbnRSZWFjdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHMvJHtjb21tZW50SWR9L2FkZC1yZWFjdGlvbmAsXG4gICAgICB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGNyZWF0ZWRBdDogZGF0YS5jcmVhdGVkQXQ/LnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihyZWFjdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZWFjdGlvbiBmcm9tIGEgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gcmVtb3ZlIHRoZSBjb21tZW50IHJlYWN0aW9uIGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byByZW1vdmUgdGhlIGNvbW1lbnQgcmVhY3Rpb24gZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gcmVtb3ZlIHRoZSByZWFjdGlvbiBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuZW1vamkgVGhlIChlbW9qaSkgcmVhY3Rpb24gdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVhY3Rpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5yZW1vdmVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgcmVhY3Rpb24gaXMgc2V0IHRvIGJlIHJlbW92ZWQuXG4gICAqL1xuICBhc3luYyByZW1vdmVDb21tZW50UmVhY3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke3BhcmFtcy5jb21tZW50SWR9L3JlbW92ZS1yZWFjdGlvbmAsXG4gICAgICB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHJlbW92ZWRBdDogZGF0YS5yZW1vdmVkQXQ/LnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmJveCBub3RpZmljYXRpb25zIGZvciBhIHVzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIGdldCB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmluYm94Tm90aWZpY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBpbmJveCBub3RpZmljYXRpb24gdG8gZ2V0LlxuICAgKi9cbiAgYXN5bmMgZ2V0SW5ib3hOb3RpZmljYXRpb24ocGFyYW1zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIGluYm94Tm90aWZpY2F0aW9uSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldChcbiAgICAgIHVybGAvdjIvdXNlcnMvJHt1c2VySWR9L2luYm94LW5vdGlmaWNhdGlvbnMvJHtpbmJveE5vdGlmaWNhdGlvbklkfWBcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoXG4gICAgICBhd2FpdCByZXMuanNvbigpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlcidzIHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCB0byBnZXQgdGhlIHJvb20gbm90aWZpY2F0aW9ucyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzIGZyb20uXG4gICAqL1xuICBhc3luYyBnZXRSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MocGFyYW1zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIHJvb21JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdXNlcnMvJHt1c2VySWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2BcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyJ3Mgcm9vbSBub3RpZmljYXRpb24gc2V0dGluZ3MuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIHVwZGF0ZSB0aGUgcm9vbSBub3RpZmljYXRpb24gc2V0dGluZ3MgZm9yLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byB1cGRhdGUgdGhlIHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzIGZvci5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhIFRoZSBuZXcgcm9vbSBub3RpZmljYXRpb24gc2V0dGluZ3MgZm9yIHRoZSB1c2VyLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdXNlcklkLCByb29tSWQsIGRhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QoXG4gICAgICB1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS91c2Vycy8ke3VzZXJJZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGRhdGFcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gZGVsZXRlIHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBkZWxldGUgdGhlIHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzIGZyb20uXG4gICAqL1xuICBhc3luYyBkZWxldGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MocGFyYW1zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIHJvb21JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdXNlcnMvJHt1c2VySWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2BcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgYSByb29tIElELlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgY3VycmVudCBJRCBvZiB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHBhcmFtcy5uZXdSb29tSWQgVGhlIG5ldyByb29tIElELlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlUm9vbUlkKHBhcmFtcykge1xuICAgIGNvbnN0IHsgY3VycmVudFJvb21JZCwgbmV3Um9vbUlkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke2N1cnJlbnRSb29tSWR9L3VwZGF0ZS1yb29tLWlkYCxcbiAgICAgIHtcbiAgICAgICAgbmV3Um9vbUlkXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpLFxuICAgICAgbGFzdENvbm5lY3Rpb25BdDogZGF0YS5sYXN0Q29ubmVjdGlvbkF0ID8gbmV3IERhdGUoZGF0YS5sYXN0Q29ubmVjdGlvbkF0KSA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgYXN5bmMgdHJpZ2dlckluYm94Tm90aWZpY2F0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdCh1cmxgL3YyL2luYm94LW5vdGlmaWNhdGlvbnMvdHJpZ2dlcmAsIHBhcmFtcyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gaW5ib3ggbm90aWZpY2F0aW9uIGZvciBhIHVzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIGZvciB3aGljaCB0byBkZWxldGUgdGhlIGluYm94IG5vdGlmaWNhdGlvbi5cbiAgICogQHBhcmFtIHBhcmFtcy5pbmJveE5vdGlmaWNhdGlvbklkIFRoZSBJRCBvZiB0aGUgaW5ib3ggbm90aWZpY2F0aW9uIHRvIGRlbGV0ZS5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdXNlcklkLCBpbmJveE5vdGlmaWNhdGlvbklkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kZWxldGUoXG4gICAgICB1cmxgL3YyL3VzZXJzLyR7dXNlcklkfS9pbmJveC1ub3RpZmljYXRpb25zLyR7aW5ib3hOb3RpZmljYXRpb25JZH1gXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgaW5ib3ggbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCBmb3Igd2hpY2ggdG8gZGVsZXRlIGFsbCB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucy5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGVsZXRlKHVybGAvdjIvdXNlcnMvJHt1c2VySWR9L2luYm94LW5vdGlmaWNhdGlvbnNgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBMaXZlYmxvY2tzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBtZXNzYWdlID0gXCJcIikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiTGl2ZWJsb2Nrc0Vycm9yXCI7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cbn07XG5cbi8vIHNyYy93ZWJob29rcy50c1xuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gXCJAc3RhYmxlbGliL2Jhc2U2NFwiO1xuaW1wb3J0ICogYXMgc2hhMjU2IGZyb20gXCJmYXN0LXNoYTI1NlwiO1xudmFyIF9XZWJob29rSGFuZGxlciA9IGNsYXNzIF9XZWJob29rSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHNlY3JldCkge1xuICAgIGlmICghc2VjcmV0KSB0aHJvdyBuZXcgRXJyb3IoXCJTZWNyZXQgaXMgcmVxdWlyZWRcIik7XG4gICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcIlNlY3JldCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIGlmIChzZWNyZXQuc3RhcnRzV2l0aChfV2ViaG9va0hhbmRsZXIuc2VjcmV0UHJlZml4KSA9PT0gZmFsc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlY3JldCwgbXVzdCBzdGFydCB3aXRoIHdoc2VjX1wiKTtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSBzZWNyZXQuc2xpY2UoX1dlYmhvb2tIYW5kbGVyLnNlY3JldFByZWZpeC5sZW5ndGgpO1xuICAgIHRoaXMuc2VjcmV0QnVmZmVyID0gQnVmZmVyLmZyb20oc2VjcmV0S2V5LCBcImJhc2U2NFwiKTtcbiAgfVxuICAvKipcbiAgICogVmVyaWZpZXMgYSB3ZWJob29rIHJlcXVlc3QgYW5kIHJldHVybnMgdGhlIGV2ZW50XG4gICAqL1xuICB2ZXJpZnlSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBjb25zdCB7IGhlYWRlcnMsIHJhd0JvZHkgfSA9IHJlcXVlc3Q7XG4gICAgY29uc3QgeyB3ZWJob29rSWQsIHRpbWVzdGFtcCwgcmF3U2lnbmF0dXJlcyB9ID0gdGhpcy52ZXJpZnlIZWFkZXJzKGhlYWRlcnMpO1xuICAgIGlmICh0eXBlb2YgcmF3Qm9keSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCByYXdCb2R5IGZpZWxkLCBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgXCIke3R5cGVvZiByYXdCb2R5fVwiIGluc3RlYWQuIEl0IGlzIGxpa2VseSB0aGF0IHlvdSBuZWVkIHRvIEpTT04uc3RyaW5naWZ5IHRoZSBib2R5IGJlZm9yZSBwYXNzaW5nIGl0LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMudmVyaWZ5VGltZXN0YW1wKHRpbWVzdGFtcCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5zaWduKGAke3dlYmhvb2tJZH0uJHt0aW1lc3RhbXB9LiR7cmF3Qm9keX1gKTtcbiAgICBjb25zdCBleHBlY3RlZFNpZ25hdHVyZXMgPSByYXdTaWduYXR1cmVzLnNwbGl0KFwiIFwiKS5tYXAoKHJhd1NpZ25hdHVyZSkgPT4ge1xuICAgICAgY29uc3QgWywgcGFyc2VkU2lnbmF0dXJlXSA9IHJhd1NpZ25hdHVyZS5zcGxpdChcIixcIik7XG4gICAgICByZXR1cm4gcGFyc2VkU2lnbmF0dXJlO1xuICAgIH0pLmZpbHRlcihpc05vdFVuZGVmaW5lZCk7XG4gICAgaWYgKGV4cGVjdGVkU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpID09PSBmYWxzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgc2lnbmF0dXJlLCBleHBlY3RlZCBvbmUgb2YgJHtleHBlY3RlZFNpZ25hdHVyZXMuam9pbihcbiAgICAgICAgICBcIiwgXCJcbiAgICAgICAgKX0sIGdvdCAke3NpZ25hdHVyZX1gXG4gICAgICApO1xuICAgIGNvbnN0IGV2ZW50ID0gSlNPTi5wYXJzZShyYXdCb2R5KTtcbiAgICB0aGlzLnZlcmlmeVdlYmhvb2tFdmVudFR5cGUoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogVmVyaWZpZXMgdGhlIGhlYWRlcnMgYW5kIHJldHVybnMgdGhlIHdlYmhvb2tJZCwgdGltZXN0YW1wIGFuZCByYXdTaWduYXR1cmVzXG4gICAqL1xuICB2ZXJpZnlIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBjb25zdCB1c2luZ05hdGl2ZUhlYWRlcnMgPSB0eXBlb2YgSGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycztcbiAgICBjb25zdCBub3JtYWxpemVkSGVhZGVycyA9IHVzaW5nTmF0aXZlSGVhZGVycyA/IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzKSA6IGhlYWRlcnM7XG4gICAgY29uc3Qgc2FuaXRpemVkSGVhZGVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRIZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHNhbml0aXplZEhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gbm9ybWFsaXplZEhlYWRlcnNba2V5XTtcbiAgICB9KTtcbiAgICBjb25zdCB3ZWJob29rSWQgPSBzYW5pdGl6ZWRIZWFkZXJzW1wid2ViaG9vay1pZFwiXTtcbiAgICBpZiAodHlwZW9mIHdlYmhvb2tJZCAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2ViaG9vay1pZCBoZWFkZXJcIik7XG4gICAgY29uc3QgdGltZXN0YW1wID0gc2FuaXRpemVkSGVhZGVyc1tcIndlYmhvb2stdGltZXN0YW1wXCJdO1xuICAgIGlmICh0eXBlb2YgdGltZXN0YW1wICE9PSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3ZWJob29rLXRpbWVzdGFtcCBoZWFkZXJcIik7XG4gICAgY29uc3QgcmF3U2lnbmF0dXJlcyA9IHNhbml0aXplZEhlYWRlcnNbXCJ3ZWJob29rLXNpZ25hdHVyZVwiXTtcbiAgICBpZiAodHlwZW9mIHJhd1NpZ25hdHVyZXMgIT09IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdlYmhvb2stc2lnbmF0dXJlIGhlYWRlclwiKTtcbiAgICByZXR1cm4geyB3ZWJob29rSWQsIHRpbWVzdGFtcCwgcmF3U2lnbmF0dXJlcyB9O1xuICB9XG4gIC8qKlxuICAgKiBTaWducyB0aGUgY29udGVudCB3aXRoIHRoZSBzZWNyZXRcbiAgICogQHBhcmFtIGNvbnRlbnRcbiAgICogQHJldHVybnMgYHN0cmluZ2BcbiAgICovXG4gIHNpZ24oY29udGVudCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCB0b1NpZ24gPSBlbmNvZGVyLmVuY29kZShjb250ZW50KTtcbiAgICByZXR1cm4gYmFzZTY0LmVuY29kZShzaGEyNTYuaG1hYyh0aGlzLnNlY3JldEJ1ZmZlciwgdG9TaWduKSk7XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoYXQgdGhlIHRpbWVzdGFtcCBpcyBub3QgdG9vIG9sZCBvciBpbiB0aGUgZnV0dXJlXG4gICAqL1xuICB2ZXJpZnlUaW1lc3RhbXAodGltZXN0YW1wSGVhZGVyKSB7XG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZUludCh0aW1lc3RhbXBIZWFkZXIsIDEwKTtcbiAgICBpZiAoaXNOYU4odGltZXN0YW1wKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0aW1lc3RhbXBcIik7XG4gICAgfVxuICAgIGlmICh0aW1lc3RhbXAgPCBub3cgLSBXRUJIT09LX1RPTEVSQU5DRV9JTl9TRUNPTkRTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaW1lc3RhbXAgdG9vIG9sZFwiKTtcbiAgICB9XG4gICAgaWYgKHRpbWVzdGFtcCA+IG5vdyArIFdFQkhPT0tfVE9MRVJBTkNFX0lOX1NFQ09ORFMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVzdGFtcCBpbiB0aGUgZnV0dXJlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSBldmVudCBpcyBhIGtub3duIGV2ZW50IHR5cGVcbiAgICogb3IgdGhyb3dzIGFuZCBwcm9tcHRzIHRoZSB1c2VyIHRvIHVwZ3JhZGUgdG8gYSBoaWdoZXIgdmVyc2lvbiBvZiBAbGl2ZWJsb2Nrcy9ub2RlXG4gICAqL1xuICB2ZXJpZnlXZWJob29rRXZlbnRUeXBlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgJiYgW1xuICAgICAgXCJzdG9yYWdlVXBkYXRlZFwiLFxuICAgICAgXCJ1c2VyRW50ZXJlZFwiLFxuICAgICAgXCJ1c2VyTGVmdFwiLFxuICAgICAgXCJyb29tQ3JlYXRlZFwiLFxuICAgICAgXCJyb29tRGVsZXRlZFwiLFxuICAgICAgXCJjb21tZW50Q3JlYXRlZFwiLFxuICAgICAgXCJjb21tZW50RWRpdGVkXCIsXG4gICAgICBcImNvbW1lbnREZWxldGVkXCIsXG4gICAgICBcImNvbW1lbnRSZWFjdGlvbkFkZGVkXCIsXG4gICAgICBcImNvbW1lbnRSZWFjdGlvblJlbW92ZWRcIixcbiAgICAgIFwidGhyZWFkTWV0YWRhdGFVcGRhdGVkXCIsXG4gICAgICBcInRocmVhZENyZWF0ZWRcIixcbiAgICAgIFwidGhyZWFkRGVsZXRlZFwiLFxuICAgICAgXCJ5ZG9jVXBkYXRlZFwiLFxuICAgICAgXCJub3RpZmljYXRpb25cIixcbiAgICAgIFwidGhyZWFkTWFya2VkQXNSZXNvbHZlZFwiLFxuICAgICAgXCJ0aHJlYWRNYXJrZWRBc1VucmVzb2x2ZWRcIlxuICAgIF0uaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSBcIm5vdGlmaWNhdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IGV2ZW50O1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLmRhdGEua2luZCA9PT0gXCJ0aHJlYWRcIiB8fCBub3RpZmljYXRpb24uZGF0YS5raW5kID09PSBcInRleHRNZW50aW9uXCIgfHwgbm90aWZpY2F0aW9uLmRhdGEua2luZC5zdGFydHNXaXRoKFwiJFwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVW5rbm93biBub3RpZmljYXRpb24ga2luZDogJHtub3RpZmljYXRpb24uZGF0YS5raW5kfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVW5rbm93biBldmVudCB0eXBlLCBwbGVhc2UgdXBncmFkZSB0byBhIGhpZ2hlciB2ZXJzaW9uIG9mIEBsaXZlYmxvY2tzL25vZGVcIlxuICAgICk7XG4gIH1cbn07XG5fV2ViaG9va0hhbmRsZXIuc2VjcmV0UHJlZml4ID0gXCJ3aHNlY19cIjtcbnZhciBXZWJob29rSGFuZGxlciA9IF9XZWJob29rSGFuZGxlcjtcbnZhciBXRUJIT09LX1RPTEVSQU5DRV9JTl9TRUNPTkRTID0gNSAqIDYwO1xudmFyIGlzTm90VW5kZWZpbmVkID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gdm9pZCAwO1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7XG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHlcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBMaXZlYmxvY2tzLFxuICBMaXZlYmxvY2tzRXJyb3IsXG4gIFdlYmhvb2tIYW5kbGVyLFxuICBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHksXG4gIHN0cmluZ2lmeUNvbW1lbnRCb2R5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@liveblocks/node/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@liveblocks/node/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/node/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Liveblocks: () => (/* binding */ Liveblocks),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   WebhookHandler: () => (/* binding */ WebhookHandler),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.getMentionedIdsFromCommentBody),\n/* harmony export */   stringifyCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.stringifyCommentBody)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liveblocks/core */ \"(rsc)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stablelib/base64 */ \"(rsc)/./node_modules/@stablelib/base64/lib/base64.js\");\n/* harmony import */ var fast_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-sha256 */ \"(rsc)/./node_modules/fast-sha256/sha256.js\");\n// src/index.ts\n\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/node\";\nvar PKG_VERSION = \"2.3.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/client.ts\n\n\n// src/utils.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nasync function fetchPolyfill() {\n  return typeof globalThis.fetch !== \"undefined\" ? globalThis.fetch : (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/tr46\"), __webpack_require__.e(\"vendor-chunks/node-fetch\"), __webpack_require__.e(\"vendor-chunks/whatwg-url\"), __webpack_require__.e(\"vendor-chunks/webidl-conversions\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(rsc)/./node_modules/node-fetch/lib/index.mjs\"))).default;\n}\nfunction isNonEmpty(value) {\n  return typeof value === \"string\" && value.length > 0;\n}\nfunction assertNonEmpty(value, field) {\n  if (!isNonEmpty(value)) {\n    throw new Error(\n      `Invalid value for field \"${field}\". Please provide a non-empty string. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize`\n    );\n  }\n}\nfunction assertSecretKey(value, field) {\n  if (!isNonEmpty(value) || !value.startsWith(\"sk_\")) {\n    throw new Error(\n      `Invalid value for field \"${field}\". Secret keys must start with \"sk_\". Please provide the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`\n    );\n  }\n}\nfunction normalizeStatusCode(statusCode) {\n  if (statusCode >= 200 && statusCode < 300) {\n    return 200;\n  } else if (statusCode >= 500) {\n    return 503;\n  } else {\n    return 403;\n  }\n}\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values[i - 1] ?? \"\") + str\n  );\n}\n\n// src/Session.ts\nvar ALL_PERMISSIONS = Object.freeze([\n  \"room:write\",\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:write\",\n  \"comments:read\"\n]);\nfunction isPermission(value) {\n  return ALL_PERMISSIONS.includes(value);\n}\nvar MAX_PERMS_PER_SET = 10;\nvar READ_ACCESS = Object.freeze([\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:read\"\n]);\nvar FULL_ACCESS = Object.freeze([\"room:write\", \"comments:write\"]);\nvar roomPatternRegex = /^([*]|[^*]{1,128}[*]?)$/;\nvar Session = class {\n  /** @internal */\n  constructor(postFn, userId, userInfo) {\n    this.FULL_ACCESS = FULL_ACCESS;\n    this.READ_ACCESS = READ_ACCESS;\n    /** @internal */\n    this._sealed = false;\n    /** @internal */\n    this._permissions = /* @__PURE__ */ new Map();\n    assertNonEmpty(userId, \"userId\");\n    this._postFn = postFn;\n    this._userId = userId;\n    this._userInfo = userInfo;\n  }\n  /** @internal */\n  getOrCreate(roomId) {\n    if (this._sealed) {\n      throw new Error(\"You can no longer change these permissions.\");\n    }\n    let perms = this._permissions.get(roomId);\n    if (perms) {\n      return perms;\n    } else {\n      if (this._permissions.size >= MAX_PERMS_PER_SET) {\n        throw new Error(\n          \"You cannot add permissions for more than 10 rooms in a single token\"\n        );\n      }\n      perms = /* @__PURE__ */ new Set();\n      this._permissions.set(roomId, perms);\n      return perms;\n    }\n  }\n  allow(roomIdOrPattern, newPerms) {\n    if (typeof roomIdOrPattern !== \"string\") {\n      throw new Error(\"Room name or pattern must be a string\");\n    }\n    if (!roomPatternRegex.test(roomIdOrPattern)) {\n      throw new Error(\"Invalid room name or pattern\");\n    }\n    if (newPerms.length === 0) {\n      throw new Error(\"Permission list cannot be empty\");\n    }\n    const existingPerms = this.getOrCreate(roomIdOrPattern);\n    for (const perm of newPerms) {\n      if (!isPermission(perm)) {\n        throw new Error(`Not a valid permission: ${perm}`);\n      }\n      existingPerms.add(perm);\n    }\n    return this;\n  }\n  /** @internal - For unit tests only */\n  hasPermissions() {\n    return this._permissions.size > 0;\n  }\n  /** @internal - For unit tests only */\n  seal() {\n    if (this._sealed) {\n      throw new Error(\n        \"You cannot reuse Session instances. Please create a new session every time.\"\n      );\n    }\n    this._sealed = true;\n  }\n  /** @internal - For unit tests only */\n  serializePermissions() {\n    return Object.fromEntries(\n      Array.from(this._permissions.entries()).map(([pat, perms]) => [\n        pat,\n        Array.from(perms)\n      ])\n    );\n  }\n  /**\n   * Call this to authorize the session to access Liveblocks. Note that this\n   * will return a Liveblocks \"access token\". Anyone that obtains such access\n   * token will have access to the allowed resources.\n   */\n  async authorize() {\n    this.seal();\n    if (!this.hasPermissions()) {\n      console.warn(\n        \"Access tokens without any permission will not be supported soon, you should use wildcards when the client requests a token for resources outside a room. See https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n    try {\n      const resp = await this._postFn(url`/v2/authorize-user`, {\n        // Required\n        userId: this._userId,\n        permissions: this.serializePermissions(),\n        // Optional metadata\n        userInfo: this._userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: 'Call to /v2/authorize-user failed. See \"error\" for more information.',\n        error: er\n      };\n    }\n  }\n};\n\n// src/client.ts\nvar Liveblocks = class {\n  /**\n   * Interact with the Liveblocks API from your Node.js backend.\n   */\n  constructor(options) {\n    const options_ = options;\n    const secret = options_.secret;\n    assertSecretKey(secret, \"secret\");\n    this._secret = secret;\n    this._baseUrl = new URL(getBaseUrl(options.baseUrl));\n  }\n  /** @internal */\n  async post(path, json) {\n    const url2 = urljoin(this._baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url2, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(json)\n    });\n    return res;\n  }\n  /** @internal */\n  async put(path, json) {\n    const url2 = urljoin(this._baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url2, {\n      method: \"PUT\",\n      headers,\n      body: JSON.stringify(json)\n    });\n  }\n  /** @internal */\n  async putBinary(path, body, params) {\n    const url2 = urljoin(this._baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`,\n      \"Content-Type\": \"application/octet-stream\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url2, { method: \"PUT\", headers, body });\n  }\n  /** @internal */\n  async delete(path) {\n    const url2 = urljoin(this._baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url2, { method: \"DELETE\", headers });\n    return res;\n  }\n  /** @internal */\n  async get(path, params) {\n    const url2 = urljoin(this._baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this._secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url2, { method: \"GET\", headers });\n    return res;\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Authentication\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Prepares a new session to authorize a user to access Liveblocks.\n   *\n   * IMPORTANT:\n   * Always make sure that you trust the user making the request to your\n   * backend before calling .prepareSession()!\n   *\n   * @param userId Tell Liveblocks the user ID of the user to authorize. Must\n   * uniquely identify the user account in your system. The uniqueness of this\n   * value will determine how many MAUs will be counted/billed.\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   *\n   */\n  prepareSession(userId, ...rest) {\n    const options = rest[0];\n    return new Session(this.post.bind(this), userId, options?.userInfo);\n  }\n  /**\n   * Call this to authenticate the user as an actor you want to allow to use\n   * Liveblocks.\n   *\n   * You should use this method only if you want to manage your permissions\n   * through the Liveblocks Permissions API. This method is more complicated to\n   * set up, but allows for finer-grained specification of permissions.\n   *\n   * Calling `.identifyUser()` only lets you securely identify a user (and what\n   * groups they belong to). What permissions this user will end up having is\n   * determined by whatever permissions you assign the user/group in your\n   * Liveblocks account, through the Permissions API:\n   * https://liveblocks.io/docs/rooms/permissions\n   *\n   * IMPORTANT:\n   * Always verify that you trust the user making the request before calling\n   * .identifyUser()!\n   *\n   * @param identity Tell Liveblocks the user ID of the user to authenticate.\n   * Must uniquely identify the user account in your system. The uniqueness of\n   * this value will determine how many MAUs will be counted/billed.\n   *\n   * If you also want to assign which groups this user belongs to, use the\n   * object form and specify the `groupIds` property. Those `groupIds` should\n   * match the groupIds you assigned permissions to via the Liveblocks\n   * Permissions API, see\n   * https://liveblocks.io/docs/rooms/permissions#permissions-levels-groups-accesses-example\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   */\n  // These fields define the security identity of the user. Whatever you pass in here will define which\n  async identifyUser(identity, ...rest) {\n    const options = rest[0];\n    const path = url`/v2/identify-user`;\n    const userId = typeof identity === \"string\" ? identity : identity.userId;\n    const groupIds = typeof identity === \"string\" ? void 0 : identity.groupIds;\n    assertNonEmpty(userId, \"userId\");\n    try {\n      const resp = await this.post(path, {\n        userId,\n        groupIds,\n        // Optional metadata\n        userInfo: options?.userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: `Call to ${urljoin(\n          this._baseUrl,\n          path\n        )} failed. See \"error\" for more information.`,\n        error: er\n      };\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Room\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a list of your rooms. The rooms are returned sorted by creation date, from newest to oldest. You can filter rooms by metadata, users accesses and groups accesses.\n   * @param params.limit (optional) A limit on the number of rooms to be returned. The limit can range between 1 and 100, and defaults to 20.\n   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.\n   * @param params.userId (optional) A filter on users accesses.\n   * @param params.metadata (optional) A filter on metadata. Multiple metadata keys can be used to filter rooms.\n   * @param params.groupIds (optional) A filter on groups accesses. Multiple groups can be used.\n   * @param params.query (optional) A query to filter rooms by. It is based on our query language. You can filter by metadata and room ID.\n   * @returns A list of rooms.\n   */\n  async getRooms(params = {}) {\n    const path = url`/v2/rooms`;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const queryParams = {\n      limit: params.limit,\n      startingAfter: params.startingAfter,\n      userId: params.userId,\n      groupIds: params.groupIds ? params.groupIds.join(\",\") : void 0,\n      // \"Flatten\" {metadata: {foo: \"bar\"}} to {\"metadata.foo\": \"bar\"}\n      ...Object.fromEntries(\n        Object.entries(params.metadata ?? {}).map(([key, val]) => [\n          `metadata.${key}`,\n          val\n        ])\n      ),\n      query\n    };\n    const res = await this.get(path, queryParams);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const rooms = data.data.map((room) => {\n      const lastConnectionAt = room.lastConnectionAt ? new Date(room.lastConnectionAt) : void 0;\n      const createdAt = new Date(room.createdAt);\n      return {\n        ...room,\n        createdAt,\n        lastConnectionAt\n      };\n    });\n    return {\n      ...data,\n      data: rooms\n    };\n  }\n  /**\n   * Creates a new room with the given id.\n   * @param roomId The id of the room to create.\n   * @param params.defaultAccesses The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @returns The created room.\n   */\n  async createRoom(roomId, params) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.post(url`/v2/rooms`, {\n      id: roomId,\n      defaultAccesses,\n      groupsAccesses,\n      usersAccesses,\n      metadata\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Returns a room with the given id.\n   * @param roomId The id of the room to return.\n   * @returns The room with the given id.\n   */\n  async getRoom(roomId) {\n    const res = await this.get(url`/v2/rooms/${roomId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      createdAt,\n      lastConnectionAt\n    };\n  }\n  /**\n   * Updates specific properties of a room. Its not necessary to provide the entire rooms information.\n   * Setting a property to `null` means to delete this property.\n   * @param roomId The id of the room to update.\n   * @param params.defaultAccesses (optional) The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @returns The updated room.\n   */\n  async updateRoom(roomId, params) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.post(url`/v2/rooms/${roomId}`, {\n      defaultAccesses,\n      groupsAccesses,\n      usersAccesses,\n      metadata\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Deletes a room with the given id. A deleted room is no longer accessible from the API or the dashboard and it cannot be restored.\n   * @param roomId The id of the room to delete.\n   */\n  async deleteRoom(roomId) {\n    const res = await this.delete(url`/v2/rooms/${roomId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns a list of users currently present in the requested room. For better performance, we recommand to call this endpoint every 10 seconds maximum. Duplicates can happen if a user is in the requested room with multiple browser tabs opened.\n   * @param roomId The id of the room to get the users from.\n   * @returns A list of users currently present in the requested room.\n   */\n  async getActiveUsers(roomId) {\n    const res = await this.get(url`/v2/rooms/${roomId}/active_users`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Boadcasts an event to a room without having to connect to it via the client from @liveblocks/client. The connectionId passed to event listeners is -1 when using this API.\n   * @param roomId The id of the room to broadcast the event to.\n   * @param message The message to broadcast. It can be any JSON serializable value.\n   */\n  async broadcastEvent(roomId, message) {\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/broadcast_event`,\n      message\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  async getStorageDocument(roomId, format = \"plain-lson\") {\n    const res = await this.get(url`/v2/rooms/${roomId}/storage`, { format });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Initializes a rooms Storage. The room must already exist and have an empty Storage.\n   * Calling this endpoint will disconnect all users from the room if there are any.\n   *\n   * @param roomId The id of the room to initialize the storage from.\n   * @param document The document to initialize the storage with.\n   * @returns The initialized storage document. It is of the same format as the one passed in.\n   */\n  async initializeStorageDocument(roomId, document) {\n    const res = await this.post(url`/v2/rooms/${roomId}/storage`, document);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Deletes all of the rooms Storage data and disconnect all users from the room if there are any. Note that this does not delete the Yjs document in the room if one exists.\n   * @param roomId The id of the room to delete the storage from.\n   */\n  async deleteStorageDocument(roomId) {\n    const res = await this.delete(url`/v2/rooms/${roomId}/storage`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Yjs\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a JSON representation of the rooms Yjs document.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.format (optional) If true, YText will return formatting.\n   * @param params.key (optional) If provided, returns only a single keys value, e.g. doc.get(key).toJSON().\n   * @param params.type (optional) Used with key to override the inferred type, i.e. \"ymap\" will return doc.get(key, Y.Map).\n   * @returns A JSON representation of the rooms Yjs document.\n   */\n  async getYjsDocument(roomId, params = {}) {\n    const { format, key, type } = params;\n    const path = url`v2/rooms/${roomId}/ydoc`;\n    const res = await this.get(path, {\n      formatting: format ? \"true\" : void 0,\n      key,\n      type\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Send a Yjs binary update to the rooms Yjs document. You can use this endpoint to initialize Yjs data for the room or to update the rooms Yjs document.\n   * @param roomId The id of the room to send the Yjs binary update to.\n   * @param update The Yjs update to send. Typically the result of calling `Yjs.encodeStateAsUpdate(doc)`. Read the [Yjs documentation](https://docs.yjs.dev/api/document-updates) to learn how to create a binary update.\n   * @param params.guid (optional) If provided, the binary update will be applied to the Yjs subdocument with the given guid. If not provided, the binary update will be applied to the root Yjs document.\n   */\n  async sendYjsBinaryUpdate(roomId, update, params = {}) {\n    const res = await this.putBinary(url`/v2/rooms/${roomId}/ydoc`, update, {\n      guid: params.guid\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns the rooms Yjs document encoded as a single binary update. This can be used by Y.applyUpdate(responseBody) to get a copy of the document in your backend.\n   * See [Yjs documentation](https://docs.yjs.dev/api/document-updates) for more information on working with updates.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.guid (optional) If provided, returns the binary update of the Yjs subdocument with the given guid. If not provided, returns the binary update of the root Yjs document.\n   * @returns The rooms Yjs document encoded as a single binary update.\n   */\n  async getYjsDocumentAsBinaryUpdate(roomId, params = {}) {\n    const res = await this.get(url`/v2/rooms/${roomId}/ydoc-binary`, {\n      guid: params.guid\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return res.arrayBuffer();\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Schema Validation\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Creates a new schema which can be referenced later to enforce a rooms Storage data structure.\n   * @param name The name used to reference the schema. Must be a non-empty string with less than 65 characters and only contain lowercase letters, numbers and dashes\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @returns The created schema.\n   */\n  async createSchema(name, body) {\n    const res = await this.post(url`/v2/schemas`, {\n      name,\n      body\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Returns a schema by its id.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @returns The schema with the given id.\n   */\n  async getSchema(schemaId) {\n    const res = await this.get(url`/v2/schemas/${schemaId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Updates the body for the schema. A schema can only be updated if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @returns The updated schema. The version of the schema will be incremented.\n   */\n  async updateSchema(schemaId, body) {\n    const res = await this.put(url`/v2/schemas/${schemaId}`, {\n      body\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Deletes a schema by its id. A schema can only be deleted if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   */\n  async deleteSchema(schemaId) {\n    const res = await this.delete(url`/v2/schemas/${schemaId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns the schema attached to a room.\n   * @param roomId The id of the room to get the schema from.\n   * @returns\n   */\n  async getSchemaByRoomId(roomId) {\n    const res = await this.get(url`/v2/rooms/${roomId}/schema`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Attaches a schema to a room, and instantly enables runtime schema validation for the room.\n   * If the current contents of the rooms Storage do not match the schema, attaching will fail and the error message will give details on why the schema failed to attach.\n   * @param roomId The id of the room to attach the schema to.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @returns The schema id as JSON.\n   */\n  async attachSchemaToRoom(roomId, schemaId) {\n    const res = await this.post(url`/v2/rooms/${roomId}/schema`, {\n      schema: schemaId\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Detaches a schema from a room, and disables runtime schema validation for the room.\n   * @param roomId The id of the room to detach the schema from.\n   */\n  async detachSchemaFromRoom(roomId) {\n    const res = await this.delete(url`/v2/rooms/${roomId}/schema`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Comments\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Gets all the threads in a room.\n   *\n   * @param params.roomId The room ID to get the threads from.\n   * @param params.query The query to filter threads by. It is based on our query language and can filter by metadata.\n   * @returns A list of threads.\n   */\n  async getThreads(params) {\n    const { roomId } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const res = await this.get(url`/v2/rooms/${roomId}/threads`, {\n      query\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const { data } = await res.json();\n    return {\n      data: data.map((thread) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(thread))\n    };\n  }\n  /**\n   * Gets a thread.\n   *\n   * @param params.roomId The room ID to get the thread from.\n   * @param params.threadId The thread ID.\n   * @returns A thread.\n   */\n  async getThread(params) {\n    const { roomId, threadId } = params;\n    const res = await this.get(url`/v2/rooms/${roomId}/threads/${threadId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Gets a thread's participants.\n   *\n   * Participants are users who have commented on the thread\n   * or users and groups that have been mentioned in a comment.\n   *\n   * @param params.roomId The room ID to get the thread participants from.\n   * @param params.threadId The thread ID to get the participants from.\n   * @returns An object containing an array of participant IDs.\n   */\n  async getThreadParticipants(params) {\n    const { roomId, threadId } = params;\n    const res = await this.get(\n      url`/v2/rooms/${roomId}/threads/${threadId}/participants`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Gets a thread's comment.\n   *\n   * @param params.roomId The room ID to get the comment from.\n   * @param params.threadId The thread ID to get the comment from.\n   * @param params.commentId The comment ID.\n   * @returns A comment.\n   */\n  async getComment(params) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.get(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Creates a comment.\n   *\n   * @param params.roomId The room ID to create the comment in.\n   * @param params.threadId The thread ID to create the comment in.\n   * @param params.data.userId The user ID of the user who is set to create the comment.\n   * @param params.data.createdAt (optional) The date the comment is set to be created.\n   * @param params.data.body The body of the comment.\n   * @returns The created comment.\n   */\n  async createComment(params) {\n    const { roomId, threadId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Edits a comment.\n   * @param params.roomId The room ID to edit the comment in.\n   * @param params.threadId The thread ID to edit the comment in.\n   * @param params.commentId The comment ID to edit.\n   * @param params.data.body The body of the comment.\n   * @param params.data.editedAt (optional) The date the comment was edited.\n   * @returns The edited comment.\n   */\n  async editComment(params) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      {\n        ...data,\n        editedAt: data.editedAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Deletes a comment. Deletes a comment. If there are no remaining comments in the thread, the thread is also deleted.\n   * @param params.roomId The room ID to delete the comment in.\n   * @param params.threadId The thread ID to delete the comment in.\n   * @param params.commentId The comment ID to delete.\n   */\n  async deleteComment(params) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.delete(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Creates a new thread. The thread will be created with the specified comment as its first comment.\n   * If the thread already exists, a `LiveblocksError` will be thrown with status code 409.\n   * @param params.roomId The room ID to create the thread in.\n   * @param params.thread.metadata (optional) The metadata for the thread. Supports upto a maximum of 10 entries. Value must be a string, boolean or number\n   * @param params.thread.comment.userId The user ID of the user who created the comment.\n   * @param params.thread.comment.createdAt (optional) The date the comment was created.\n   * @param params.thread.comment.body The body of the comment.\n   * @returns The created thread. The thread will be created with the specified comment as its first comment.\n   */\n  async createThread(params) {\n    const { roomId, data } = params;\n    const res = await this.post(url`/v2/rooms/${roomId}/threads`, {\n      ...data,\n      comment: {\n        ...data.comment,\n        createdAt: data.comment.createdAt?.toISOString()\n      }\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Deletes a thread and all of its comments.\n   * @param params.roomId The room ID to delete the thread in.\n   * @param params.threadId The thread ID to delete.\n   */\n  async deleteThread(params) {\n    const { roomId, threadId } = params;\n    const res = await this.delete(url`/v2/rooms/${roomId}/threads/${threadId}`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Mark a thread as resolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as resolved.\n   * @param params.data.userId The user ID of the user who marked the thread as resolved.\n   * @returns The thread marked as resolved.\n   */\n  async markThreadAsResolved(params) {\n    const { roomId, threadId } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/mark-as-resolved`,\n      {}\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Mark a thread as unresolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as unresolved.\n   * @param params.data.userId The user ID of the user who marked the thread as unresolved.\n   * @returns The thread marked as unresolved.\n   */\n  async markThreadAsUnresolved(params) {\n    const { roomId, threadId } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/mark-as-unresolved`,\n      {}\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Updates the metadata of the specified thread in a room.\n   * @param params.roomId The room ID to update the thread in.\n   * @param params.threadId The thread ID to update.\n   * @param params.data.metadata The metadata for the thread. Value must be a string, boolean or number\n   * @param params.data.userId The user ID of the user who updated the thread.\n   * @param params.data.updatedAt (optional) The date the thread is set to be updated.\n   * @returns The updated thread metadata.\n   */\n  async editThreadMetadata(params) {\n    const { roomId, threadId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/metadata`,\n      {\n        ...data,\n        updatedAt: data.updatedAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Adds a new comment reaction to a comment.\n   * @param params.roomId The room ID to add the comment reaction in.\n   * @param params.threadId The thread ID to add the comment reaction in.\n   * @param params.commentId The comment ID to add the reaction in.\n   * @param params.data.emoji The (emoji) reaction to add.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.createdAt (optional) The date the reaction is set to be created.\n   * @returns The created comment reaction.\n   */\n  async addCommentReaction(params) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}/add-reaction`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const reaction = await res.json();\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentUserReaction)(reaction);\n  }\n  /**\n   * Removes a reaction from a comment.\n   * @param params.roomId The room ID to remove the comment reaction from.\n   * @param params.threadId The thread ID to remove the comment reaction from.\n   * @param params.commentId The comment ID to remove the reaction from.\n   * @param params.data.emoji The (emoji) reaction to remove.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.removedAt (optional) The date the reaction is set to be removed.\n   */\n  async removeCommentReaction(params) {\n    const { roomId, threadId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/threads/${threadId}/comments/${params.commentId}/remove-reaction`,\n      {\n        ...data,\n        removedAt: data.removedAt?.toISOString()\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.inboxNotificationId The ID of the inbox notification to get.\n   */\n  async getInboxNotification(params) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.get(\n      url`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToInboxNotificationData)(\n      await res.json()\n    );\n  }\n  /**\n   * Gets the user's room notification settings.\n   * @param params.userId The user ID to get the room notifications from.\n   * @param params.roomId The room ID to get the room notification settings from.\n   */\n  async getRoomNotificationSettings(params) {\n    const { userId, roomId } = params;\n    const res = await this.get(\n      url`/v2/rooms/${roomId}/users/${userId}/notification-settings`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Updates the user's room notification settings.\n   * @param params.userId The user ID to update the room notification settings for.\n   * @param params.roomId The room ID to update the room notification settings for.\n   * @param params.data The new room notification settings for the user.\n   */\n  async updateRoomNotificationSettings(params) {\n    const { userId, roomId, data } = params;\n    const res = await this.post(\n      url`/v2/rooms/${roomId}/users/${userId}/notification-settings`,\n      data\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    return await res.json();\n  }\n  /**\n   * Delete the user's room notification settings.\n   * @param params.userId The user ID to delete the room notification settings from.\n   * @param params.roomId The room ID to delete the room notification settings from.\n   */\n  async deleteRoomNotificationSettings(params) {\n    const { userId, roomId } = params;\n    const res = await this.delete(\n      url`/v2/rooms/${roomId}/users/${userId}/notification-settings`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Update a room ID.\n   * @param params.roomId The current ID of the room.\n   * @param params.newRoomId The new room ID.\n   */\n  async updateRoomId(params) {\n    const { currentRoomId, newRoomId } = params;\n    const res = await this.post(\n      url`/v2/rooms/${currentRoomId}/update-room-id`,\n      {\n        newRoomId\n      }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n    const data = await res.json();\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      lastConnectionAt: data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0\n    };\n  }\n  async triggerInboxNotification(params) {\n    const res = await this.post(url`/v2/inbox-notifications/trigger`, params);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Deletes an inbox notification for a user.\n   * @param params.userId The user ID for which to delete the inbox notification.\n   * @param params.inboxNotificationId The ID of the inbox notification to delete.\n   */\n  async deleteInboxNotification(params) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.delete(\n      url`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n  /**\n   * Deletes all inbox notifications for a user.\n   * @param params.userId The user ID for which to delete all the inbox notifications.\n   */\n  async deleteAllInboxNotifications(params) {\n    const { userId } = params;\n    const res = await this.delete(url`/v2/users/${userId}/inbox-notifications`);\n    if (!res.ok) {\n      const text = await res.text();\n      throw new LiveblocksError(res.status, text);\n    }\n  }\n};\nvar LiveblocksError = class extends Error {\n  constructor(status, message = \"\") {\n    super(message);\n    this.name = \"LiveblocksError\";\n    this.status = status;\n  }\n};\n\n// src/webhooks.ts\n\n\nvar _WebhookHandler = class _WebhookHandler {\n  constructor(secret) {\n    if (!secret) throw new Error(\"Secret is required\");\n    if (typeof secret !== \"string\") throw new Error(\"Secret must be a string\");\n    if (secret.startsWith(_WebhookHandler.secretPrefix) === false)\n      throw new Error(\"Invalid secret, must start with whsec_\");\n    const secretKey = secret.slice(_WebhookHandler.secretPrefix.length);\n    this.secretBuffer = Buffer.from(secretKey, \"base64\");\n  }\n  /**\n   * Verifies a webhook request and returns the event\n   */\n  verifyRequest(request) {\n    const { headers, rawBody } = request;\n    const { webhookId, timestamp, rawSignatures } = this.verifyHeaders(headers);\n    if (typeof rawBody !== \"string\") {\n      throw new Error(\n        `Invalid rawBody field, must be a string, got \"${typeof rawBody}\" instead. It is likely that you need to JSON.stringify the body before passing it.`\n      );\n    }\n    this.verifyTimestamp(timestamp);\n    const signature = this.sign(`${webhookId}.${timestamp}.${rawBody}`);\n    const expectedSignatures = rawSignatures.split(\" \").map((rawSignature) => {\n      const [, parsedSignature] = rawSignature.split(\",\");\n      return parsedSignature;\n    }).filter(isNotUndefined);\n    if (expectedSignatures.includes(signature) === false)\n      throw new Error(\n        `Invalid signature, expected one of ${expectedSignatures.join(\n          \", \"\n        )}, got ${signature}`\n      );\n    const event = JSON.parse(rawBody);\n    this.verifyWebhookEventType(event);\n    return event;\n  }\n  /**\n   * Verifies the headers and returns the webhookId, timestamp and rawSignatures\n   */\n  verifyHeaders(headers) {\n    const usingNativeHeaders = typeof Headers !== \"undefined\" && headers instanceof Headers;\n    const normalizedHeaders = usingNativeHeaders ? Object.fromEntries(headers) : headers;\n    const sanitizedHeaders = {};\n    Object.keys(normalizedHeaders).forEach((key) => {\n      sanitizedHeaders[key.toLowerCase()] = normalizedHeaders[key];\n    });\n    const webhookId = sanitizedHeaders[\"webhook-id\"];\n    if (typeof webhookId !== \"string\")\n      throw new Error(\"Invalid webhook-id header\");\n    const timestamp = sanitizedHeaders[\"webhook-timestamp\"];\n    if (typeof timestamp !== \"string\")\n      throw new Error(\"Invalid webhook-timestamp header\");\n    const rawSignatures = sanitizedHeaders[\"webhook-signature\"];\n    if (typeof rawSignatures !== \"string\")\n      throw new Error(\"Invalid webhook-signature header\");\n    return { webhookId, timestamp, rawSignatures };\n  }\n  /**\n   * Signs the content with the secret\n   * @param content\n   * @returns `string`\n   */\n  sign(content) {\n    const encoder = new TextEncoder();\n    const toSign = encoder.encode(content);\n    return _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__.encode(fast_sha256__WEBPACK_IMPORTED_MODULE_2__.hmac(this.secretBuffer, toSign));\n  }\n  /**\n   * Verifies that the timestamp is not too old or in the future\n   */\n  verifyTimestamp(timestampHeader) {\n    const now = Math.floor(Date.now() / 1e3);\n    const timestamp = parseInt(timestampHeader, 10);\n    if (isNaN(timestamp)) {\n      throw new Error(\"Invalid timestamp\");\n    }\n    if (timestamp < now - WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp too old\");\n    }\n    if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp in the future\");\n    }\n  }\n  /**\n   * Ensures that the event is a known event type\n   * or throws and prompts the user to upgrade to a higher version of @liveblocks/node\n   */\n  verifyWebhookEventType(event) {\n    if (event && event.type && [\n      \"storageUpdated\",\n      \"userEntered\",\n      \"userLeft\",\n      \"roomCreated\",\n      \"roomDeleted\",\n      \"commentCreated\",\n      \"commentEdited\",\n      \"commentDeleted\",\n      \"commentReactionAdded\",\n      \"commentReactionRemoved\",\n      \"threadMetadataUpdated\",\n      \"threadCreated\",\n      \"threadDeleted\",\n      \"ydocUpdated\",\n      \"notification\",\n      \"threadMarkedAsResolved\",\n      \"threadMarkedAsUnresolved\"\n    ].includes(event.type)) {\n      if (event.type === \"notification\") {\n        const notification = event;\n        if (notification.data.kind === \"thread\" || notification.data.kind === \"textMention\" || notification.data.kind.startsWith(\"$\")) {\n          return;\n        } else {\n          throw new Error(\n            `Unknown notification kind: ${notification.data.kind}`\n          );\n        }\n      }\n      return;\n    }\n    throw new Error(\n      \"Unknown event type, please upgrade to a higher version of @liveblocks/node\"\n    );\n  }\n};\n_WebhookHandler.secretPrefix = \"whsec_\";\nvar WebhookHandler = _WebhookHandler;\nvar WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;\nvar isNotUndefined = (value) => value !== void 0;\n\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3Mvbm9kZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQytDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQU8wQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxpV0FBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwQ0FBMEMsdUJBQXVCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJMEI7QUFDMUIsNkRBQVc7QUFPVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL25vZGUvZGlzdC9pbmRleC5tanM/ZGJmZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGRldGVjdER1cGVzIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBQS0dfTkFNRSA9IFwiQGxpdmVibG9ja3Mvbm9kZVwiO1xudmFyIFBLR19WRVJTSU9OID0gXCIyLjMuMFwiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvY2xpZW50LnRzXG5pbXBvcnQge1xuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBvYmplY3RUb1F1ZXJ5XG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy91dGlscy50c1xudmFyIERFRkFVTFRfQkFTRV9VUkwgPSBcImh0dHBzOi8vYXBpLmxpdmVibG9ja3MuaW9cIjtcbmZ1bmN0aW9uIGdldEJhc2VVcmwoYmFzZVVybCkge1xuICBpZiAodHlwZW9mIGJhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgYmFzZVVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBiYXNlVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERUZBVUxUX0JBU0VfVVJMO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFBvbHlmaWxsKCkge1xuICByZXR1cm4gdHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzLmZldGNoIDogKGF3YWl0IGltcG9ydChcIm5vZGUtZmV0Y2hcIikpLmRlZmF1bHQ7XG59XG5mdW5jdGlvbiBpc05vbkVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIGFzc2VydE5vbkVtcHR5KHZhbHVlLCBmaWVsZCkge1xuICBpZiAoIWlzTm9uRW1wdHkodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIGZpZWxkIFwiJHtmaWVsZH1cIi4gUGxlYXNlIHByb3ZpZGUgYSBub24tZW1wdHkgc3RyaW5nLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLW5vZGUjYXV0aG9yaXplYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFNlY3JldEtleSh2YWx1ZSwgZmllbGQpIHtcbiAgaWYgKCFpc05vbkVtcHR5KHZhbHVlKSB8fCAhdmFsdWUuc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBmaWVsZCBcIiR7ZmllbGR9XCIuIFNlY3JldCBrZXlzIG11c3Qgc3RhcnQgd2l0aCBcInNrX1wiLiBQbGVhc2UgcHJvdmlkZSB0aGUgc2VjcmV0IGtleSBmcm9tIHlvdXIgTGl2ZWJsb2NrcyBkYXNoYm9hcmQgYXQgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2Rhc2hib2FyZC9hcGlrZXlzLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdGF0dXNDb2RlKHN0YXR1c0NvZGUpIHtcbiAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICByZXR1cm4gMjAwO1xuICB9IGVsc2UgaWYgKHN0YXR1c0NvZGUgPj0gNTAwKSB7XG4gICAgcmV0dXJuIDUwMztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gNDAzO1xuICB9XG59XG5mdW5jdGlvbiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVybGpvaW4oYmFzZVVybCwgcGF0aCwgcGFyYW1zKSB7XG4gIGNvbnN0IHVybDIgPSBuZXcgVVJMKHBhdGgsIGJhc2VVcmwpO1xuICBpZiAocGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICB1cmwyLnNlYXJjaCA9IChwYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBwYXJhbXMgOiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB1cmwyLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB1cmwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBzdHJpbmdzLnJlZHVjZShcbiAgICAocmVzdWx0LCBzdHIsIGkpID0+IHJlc3VsdCArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaSAtIDFdID8/IFwiXCIpICsgc3RyXG4gICk7XG59XG5cbi8vIHNyYy9TZXNzaW9uLnRzXG52YXIgQUxMX1BFUk1JU1NJT05TID0gT2JqZWN0LmZyZWV6ZShbXG4gIFwicm9vbTp3cml0ZVwiLFxuICBcInJvb206cmVhZFwiLFxuICBcInJvb206cHJlc2VuY2U6d3JpdGVcIixcbiAgXCJjb21tZW50czp3cml0ZVwiLFxuICBcImNvbW1lbnRzOnJlYWRcIlxuXSk7XG5mdW5jdGlvbiBpc1Blcm1pc3Npb24odmFsdWUpIHtcbiAgcmV0dXJuIEFMTF9QRVJNSVNTSU9OUy5pbmNsdWRlcyh2YWx1ZSk7XG59XG52YXIgTUFYX1BFUk1TX1BFUl9TRVQgPSAxMDtcbnZhciBSRUFEX0FDQ0VTUyA9IE9iamVjdC5mcmVlemUoW1xuICBcInJvb206cmVhZFwiLFxuICBcInJvb206cHJlc2VuY2U6d3JpdGVcIixcbiAgXCJjb21tZW50czpyZWFkXCJcbl0pO1xudmFyIEZVTExfQUNDRVNTID0gT2JqZWN0LmZyZWV6ZShbXCJyb29tOndyaXRlXCIsIFwiY29tbWVudHM6d3JpdGVcIl0pO1xudmFyIHJvb21QYXR0ZXJuUmVnZXggPSAvXihbKl18W14qXXsxLDEyOH1bKl0/KSQvO1xudmFyIFNlc3Npb24gPSBjbGFzcyB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IocG9zdEZuLCB1c2VySWQsIHVzZXJJbmZvKSB7XG4gICAgdGhpcy5GVUxMX0FDQ0VTUyA9IEZVTExfQUNDRVNTO1xuICAgIHRoaXMuUkVBRF9BQ0NFU1MgPSBSRUFEX0FDQ0VTUztcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc2VhbGVkID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3Blcm1pc3Npb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBhc3NlcnROb25FbXB0eSh1c2VySWQsIFwidXNlcklkXCIpO1xuICAgIHRoaXMuX3Bvc3RGbiA9IHBvc3RGbjtcbiAgICB0aGlzLl91c2VySWQgPSB1c2VySWQ7XG4gICAgdGhpcy5fdXNlckluZm8gPSB1c2VySW5mbztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldE9yQ3JlYXRlKHJvb21JZCkge1xuICAgIGlmICh0aGlzLl9zZWFsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4gbm8gbG9uZ2VyIGNoYW5nZSB0aGVzZSBwZXJtaXNzaW9ucy5cIik7XG4gICAgfVxuICAgIGxldCBwZXJtcyA9IHRoaXMuX3Blcm1pc3Npb25zLmdldChyb29tSWQpO1xuICAgIGlmIChwZXJtcykge1xuICAgICAgcmV0dXJuIHBlcm1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fcGVybWlzc2lvbnMuc2l6ZSA+PSBNQVhfUEVSTVNfUEVSX1NFVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJZb3UgY2Fubm90IGFkZCBwZXJtaXNzaW9ucyBmb3IgbW9yZSB0aGFuIDEwIHJvb21zIGluIGEgc2luZ2xlIHRva2VuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHBlcm1zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuX3Blcm1pc3Npb25zLnNldChyb29tSWQsIHBlcm1zKTtcbiAgICAgIHJldHVybiBwZXJtcztcbiAgICB9XG4gIH1cbiAgYWxsb3cocm9vbUlkT3JQYXR0ZXJuLCBuZXdQZXJtcykge1xuICAgIGlmICh0eXBlb2Ygcm9vbUlkT3JQYXR0ZXJuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tIG5hbWUgb3IgcGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAoIXJvb21QYXR0ZXJuUmVnZXgudGVzdChyb29tSWRPclBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvb20gbmFtZSBvciBwYXR0ZXJuXCIpO1xuICAgIH1cbiAgICBpZiAobmV3UGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJtaXNzaW9uIGxpc3QgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1Blcm1zID0gdGhpcy5nZXRPckNyZWF0ZShyb29tSWRPclBhdHRlcm4pO1xuICAgIGZvciAoY29uc3QgcGVybSBvZiBuZXdQZXJtcykge1xuICAgICAgaWYgKCFpc1Blcm1pc3Npb24ocGVybSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSB2YWxpZCBwZXJtaXNzaW9uOiAke3Blcm19YCk7XG4gICAgICB9XG4gICAgICBleGlzdGluZ1Blcm1zLmFkZChwZXJtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAtIEZvciB1bml0IHRlc3RzIG9ubHkgKi9cbiAgaGFzUGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Blcm1pc3Npb25zLnNpemUgPiAwO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgLSBGb3IgdW5pdCB0ZXN0cyBvbmx5ICovXG4gIHNlYWwoKSB7XG4gICAgaWYgKHRoaXMuX3NlYWxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIllvdSBjYW5ub3QgcmV1c2UgU2Vzc2lvbiBpbnN0YW5jZXMuIFBsZWFzZSBjcmVhdGUgYSBuZXcgc2Vzc2lvbiBldmVyeSB0aW1lLlwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9zZWFsZWQgPSB0cnVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgLSBGb3IgdW5pdCB0ZXN0cyBvbmx5ICovXG4gIHNlcmlhbGl6ZVBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBBcnJheS5mcm9tKHRoaXMuX3Blcm1pc3Npb25zLmVudHJpZXMoKSkubWFwKChbcGF0LCBwZXJtc10pID0+IFtcbiAgICAgICAgcGF0LFxuICAgICAgICBBcnJheS5mcm9tKHBlcm1zKVxuICAgICAgXSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gYXV0aG9yaXplIHRoZSBzZXNzaW9uIHRvIGFjY2VzcyBMaXZlYmxvY2tzLiBOb3RlIHRoYXQgdGhpc1xuICAgKiB3aWxsIHJldHVybiBhIExpdmVibG9ja3MgXCJhY2Nlc3MgdG9rZW5cIi4gQW55b25lIHRoYXQgb2J0YWlucyBzdWNoIGFjY2Vzc1xuICAgKiB0b2tlbiB3aWxsIGhhdmUgYWNjZXNzIHRvIHRoZSBhbGxvd2VkIHJlc291cmNlcy5cbiAgICovXG4gIGFzeW5jIGF1dGhvcml6ZSgpIHtcbiAgICB0aGlzLnNlYWwoKTtcbiAgICBpZiAoIXRoaXMuaGFzUGVybWlzc2lvbnMoKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIkFjY2VzcyB0b2tlbnMgd2l0aG91dCBhbnkgcGVybWlzc2lvbiB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgc29vbiwgeW91IHNob3VsZCB1c2Ugd2lsZGNhcmRzIHdoZW4gdGhlIGNsaWVudCByZXF1ZXN0cyBhIHRva2VuIGZvciByZXNvdXJjZXMgb3V0c2lkZSBhIHJvb20uIFNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1jbGllbnQvYWNjZXNzLXRva2Vucy1ub3QtZW5vdWdoLXBlcm1pc3Npb25zXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5fcG9zdEZuKHVybGAvdjIvYXV0aG9yaXplLXVzZXJgLCB7XG4gICAgICAgIC8vIFJlcXVpcmVkXG4gICAgICAgIHVzZXJJZDogdGhpcy5fdXNlcklkLFxuICAgICAgICBwZXJtaXNzaW9uczogdGhpcy5zZXJpYWxpemVQZXJtaXNzaW9ucygpLFxuICAgICAgICAvLyBPcHRpb25hbCBtZXRhZGF0YVxuICAgICAgICB1c2VySW5mbzogdGhpcy5fdXNlckluZm9cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBub3JtYWxpemVTdGF0dXNDb2RlKHJlc3Auc3RhdHVzKSxcbiAgICAgICAgYm9keTogYXdhaXQgcmVzcC50ZXh0KClcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogNTAzLFxuICAgICAgICBib2R5OiAnQ2FsbCB0byAvdjIvYXV0aG9yaXplLXVzZXIgZmFpbGVkLiBTZWUgXCJlcnJvclwiIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgIGVycm9yOiBlclxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jbGllbnQudHNcbnZhciBMaXZlYmxvY2tzID0gY2xhc3Mge1xuICAvKipcbiAgICogSW50ZXJhY3Qgd2l0aCB0aGUgTGl2ZWJsb2NrcyBBUEkgZnJvbSB5b3VyIE5vZGUuanMgYmFja2VuZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zXyA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VjcmV0ID0gb3B0aW9uc18uc2VjcmV0O1xuICAgIGFzc2VydFNlY3JldEtleShzZWNyZXQsIFwic2VjcmV0XCIpO1xuICAgIHRoaXMuX3NlY3JldCA9IHNlY3JldDtcbiAgICB0aGlzLl9iYXNlVXJsID0gbmV3IFVSTChnZXRCYXNlVXJsKG9wdGlvbnMuYmFzZVVybCkpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgcG9zdChwYXRoLCBqc29uKSB7XG4gICAgY29uc3QgdXJsMiA9IHVybGpvaW4odGhpcy5fYmFzZVVybCwgcGF0aCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLl9zZWNyZXR9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGZldGNoUG9seWZpbGwoKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwyLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIHB1dChwYXRoLCBqc29uKSB7XG4gICAgY29uc3QgdXJsMiA9IHVybGpvaW4odGhpcy5fYmFzZVVybCwgcGF0aCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLl9zZWNyZXR9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGZldGNoUG9seWZpbGwoKTtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2godXJsMiwge1xuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBwdXRCaW5hcnkocGF0aCwgYm9keSwgcGFyYW1zKSB7XG4gICAgY29uc3QgdXJsMiA9IHVybGpvaW4odGhpcy5fYmFzZVVybCwgcGF0aCwgcGFyYW1zKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuX3NlY3JldH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhd2FpdCBmZXRjaFBvbHlmaWxsKCk7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybDIsIHsgbWV0aG9kOiBcIlBVVFwiLCBoZWFkZXJzLCBib2R5IH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgZGVsZXRlKHBhdGgpIHtcbiAgICBjb25zdCB1cmwyID0gdXJsam9pbih0aGlzLl9iYXNlVXJsLCBwYXRoKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuX3NlY3JldH1gXG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGZldGNoUG9seWZpbGwoKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwyLCB7IG1ldGhvZDogXCJERUxFVEVcIiwgaGVhZGVycyB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgZ2V0KHBhdGgsIHBhcmFtcykge1xuICAgIGNvbnN0IHVybDIgPSB1cmxqb2luKHRoaXMuX2Jhc2VVcmwsIHBhdGgsIHBhcmFtcyk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLl9zZWNyZXR9YFxuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhd2FpdCBmZXRjaFBvbHlmaWxsKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsMiwgeyBtZXRob2Q6IFwiR0VUXCIsIGhlYWRlcnMgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEF1dGhlbnRpY2F0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLyoqXG4gICAqIFByZXBhcmVzIGEgbmV3IHNlc3Npb24gdG8gYXV0aG9yaXplIGEgdXNlciB0byBhY2Nlc3MgTGl2ZWJsb2Nrcy5cbiAgICpcbiAgICogSU1QT1JUQU5UOlxuICAgKiBBbHdheXMgbWFrZSBzdXJlIHRoYXQgeW91IHRydXN0IHRoZSB1c2VyIG1ha2luZyB0aGUgcmVxdWVzdCB0byB5b3VyXG4gICAqIGJhY2tlbmQgYmVmb3JlIGNhbGxpbmcgLnByZXBhcmVTZXNzaW9uKCkhXG4gICAqXG4gICAqIEBwYXJhbSB1c2VySWQgVGVsbCBMaXZlYmxvY2tzIHRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIHRvIGF1dGhvcml6ZS4gTXVzdFxuICAgKiB1bmlxdWVseSBpZGVudGlmeSB0aGUgdXNlciBhY2NvdW50IGluIHlvdXIgc3lzdGVtLiBUaGUgdW5pcXVlbmVzcyBvZiB0aGlzXG4gICAqIHZhbHVlIHdpbGwgZGV0ZXJtaW5lIGhvdyBtYW55IE1BVXMgd2lsbCBiZSBjb3VudGVkL2JpbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMudXNlckluZm8gQ3VzdG9tIG1ldGFkYXRhIHRvIGF0dGFjaCB0byB0aGlzIHVzZXIuIERhdGEgeW91XG4gICAqIGFkZCBoZXJlIHdpbGwgYmUgdmlzaWJsZSB0byBhbGwgb3RoZXIgY2xpZW50cyBpbiB0aGUgcm9vbSwgdGhyb3VnaCB0aGVcbiAgICogYG90aGVyLmluZm9gIHByb3BlcnR5LlxuICAgKlxuICAgKi9cbiAgcHJlcGFyZVNlc3Npb24odXNlcklkLCAuLi5yZXN0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc3RbMF07XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uKHRoaXMucG9zdC5iaW5kKHRoaXMpLCB1c2VySWQsIG9wdGlvbnM/LnVzZXJJbmZvKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIGF1dGhlbnRpY2F0ZSB0aGUgdXNlciBhcyBhbiBhY3RvciB5b3Ugd2FudCB0byBhbGxvdyB0byB1c2VcbiAgICogTGl2ZWJsb2Nrcy5cbiAgICpcbiAgICogWW91IHNob3VsZCB1c2UgdGhpcyBtZXRob2Qgb25seSBpZiB5b3Ugd2FudCB0byBtYW5hZ2UgeW91ciBwZXJtaXNzaW9uc1xuICAgKiB0aHJvdWdoIHRoZSBMaXZlYmxvY2tzIFBlcm1pc3Npb25zIEFQSS4gVGhpcyBtZXRob2QgaXMgbW9yZSBjb21wbGljYXRlZCB0b1xuICAgKiBzZXQgdXAsIGJ1dCBhbGxvd3MgZm9yIGZpbmVyLWdyYWluZWQgc3BlY2lmaWNhdGlvbiBvZiBwZXJtaXNzaW9ucy5cbiAgICpcbiAgICogQ2FsbGluZyBgLmlkZW50aWZ5VXNlcigpYCBvbmx5IGxldHMgeW91IHNlY3VyZWx5IGlkZW50aWZ5IGEgdXNlciAoYW5kIHdoYXRcbiAgICogZ3JvdXBzIHRoZXkgYmVsb25nIHRvKS4gV2hhdCBwZXJtaXNzaW9ucyB0aGlzIHVzZXIgd2lsbCBlbmQgdXAgaGF2aW5nIGlzXG4gICAqIGRldGVybWluZWQgYnkgd2hhdGV2ZXIgcGVybWlzc2lvbnMgeW91IGFzc2lnbiB0aGUgdXNlci9ncm91cCBpbiB5b3VyXG4gICAqIExpdmVibG9ja3MgYWNjb3VudCwgdGhyb3VnaCB0aGUgUGVybWlzc2lvbnMgQVBJOlxuICAgKiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9yb29tcy9wZXJtaXNzaW9uc1xuICAgKlxuICAgKiBJTVBPUlRBTlQ6XG4gICAqIEFsd2F5cyB2ZXJpZnkgdGhhdCB5b3UgdHJ1c3QgdGhlIHVzZXIgbWFraW5nIHRoZSByZXF1ZXN0IGJlZm9yZSBjYWxsaW5nXG4gICAqIC5pZGVudGlmeVVzZXIoKSFcbiAgICpcbiAgICogQHBhcmFtIGlkZW50aXR5IFRlbGwgTGl2ZWJsb2NrcyB0aGUgdXNlciBJRCBvZiB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUuXG4gICAqIE11c3QgdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHVzZXIgYWNjb3VudCBpbiB5b3VyIHN5c3RlbS4gVGhlIHVuaXF1ZW5lc3Mgb2ZcbiAgICogdGhpcyB2YWx1ZSB3aWxsIGRldGVybWluZSBob3cgbWFueSBNQVVzIHdpbGwgYmUgY291bnRlZC9iaWxsZWQuXG4gICAqXG4gICAqIElmIHlvdSBhbHNvIHdhbnQgdG8gYXNzaWduIHdoaWNoIGdyb3VwcyB0aGlzIHVzZXIgYmVsb25ncyB0bywgdXNlIHRoZVxuICAgKiBvYmplY3QgZm9ybSBhbmQgc3BlY2lmeSB0aGUgYGdyb3VwSWRzYCBwcm9wZXJ0eS4gVGhvc2UgYGdyb3VwSWRzYCBzaG91bGRcbiAgICogbWF0Y2ggdGhlIGdyb3VwSWRzIHlvdSBhc3NpZ25lZCBwZXJtaXNzaW9ucyB0byB2aWEgdGhlIExpdmVibG9ja3NcbiAgICogUGVybWlzc2lvbnMgQVBJLCBzZWVcbiAgICogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3Mvcm9vbXMvcGVybWlzc2lvbnMjcGVybWlzc2lvbnMtbGV2ZWxzLWdyb3Vwcy1hY2Nlc3Nlcy1leGFtcGxlXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnVzZXJJbmZvIEN1c3RvbSBtZXRhZGF0YSB0byBhdHRhY2ggdG8gdGhpcyB1c2VyLiBEYXRhIHlvdVxuICAgKiBhZGQgaGVyZSB3aWxsIGJlIHZpc2libGUgdG8gYWxsIG90aGVyIGNsaWVudHMgaW4gdGhlIHJvb20sIHRocm91Z2ggdGhlXG4gICAqIGBvdGhlci5pbmZvYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIFRoZXNlIGZpZWxkcyBkZWZpbmUgdGhlIHNlY3VyaXR5IGlkZW50aXR5IG9mIHRoZSB1c2VyLiBXaGF0ZXZlciB5b3UgcGFzcyBpbiBoZXJlIHdpbGwgZGVmaW5lIHdoaWNoXG4gIGFzeW5jIGlkZW50aWZ5VXNlcihpZGVudGl0eSwgLi4ucmVzdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXN0WzBdO1xuICAgIGNvbnN0IHBhdGggPSB1cmxgL3YyL2lkZW50aWZ5LXVzZXJgO1xuICAgIGNvbnN0IHVzZXJJZCA9IHR5cGVvZiBpZGVudGl0eSA9PT0gXCJzdHJpbmdcIiA/IGlkZW50aXR5IDogaWRlbnRpdHkudXNlcklkO1xuICAgIGNvbnN0IGdyb3VwSWRzID0gdHlwZW9mIGlkZW50aXR5ID09PSBcInN0cmluZ1wiID8gdm9pZCAwIDogaWRlbnRpdHkuZ3JvdXBJZHM7XG4gICAgYXNzZXJ0Tm9uRW1wdHkodXNlcklkLCBcInVzZXJJZFwiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMucG9zdChwYXRoLCB7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgZ3JvdXBJZHMsXG4gICAgICAgIC8vIE9wdGlvbmFsIG1ldGFkYXRhXG4gICAgICAgIHVzZXJJbmZvOiBvcHRpb25zPy51c2VySW5mb1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IG5vcm1hbGl6ZVN0YXR1c0NvZGUocmVzcC5zdGF0dXMpLFxuICAgICAgICBib2R5OiBhd2FpdCByZXNwLnRleHQoKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiA1MDMsXG4gICAgICAgIGJvZHk6IGBDYWxsIHRvICR7dXJsam9pbihcbiAgICAgICAgICB0aGlzLl9iYXNlVXJsLFxuICAgICAgICAgIHBhdGhcbiAgICAgICAgKX0gZmFpbGVkLiBTZWUgXCJlcnJvclwiIGZvciBtb3JlIGluZm9ybWF0aW9uLmAsXG4gICAgICAgIGVycm9yOiBlclxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBSb29tXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHlvdXIgcm9vbXMuIFRoZSByb29tcyBhcmUgcmV0dXJuZWQgc29ydGVkIGJ5IGNyZWF0aW9uIGRhdGUsIGZyb20gbmV3ZXN0IHRvIG9sZGVzdC4gWW91IGNhbiBmaWx0ZXIgcm9vbXMgYnkgbWV0YWRhdGEsIHVzZXJzIGFjY2Vzc2VzIGFuZCBncm91cHMgYWNjZXNzZXMuXG4gICAqIEBwYXJhbSBwYXJhbXMubGltaXQgKG9wdGlvbmFsKSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygcm9vbXMgdG8gYmUgcmV0dXJuZWQuIFRoZSBsaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCBkZWZhdWx0cyB0byAyMC5cbiAgICogQHBhcmFtIHBhcmFtcy5zdGFydGluZ0FmdGVyIChvcHRpb25hbCkgQSBjdXJzb3IgdXNlZCBmb3IgcGFnaW5hdGlvbi4gWW91IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgcmVzcG9uc2Ugb2YgdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIChvcHRpb25hbCkgQSBmaWx0ZXIgb24gdXNlcnMgYWNjZXNzZXMuXG4gICAqIEBwYXJhbSBwYXJhbXMubWV0YWRhdGEgKG9wdGlvbmFsKSBBIGZpbHRlciBvbiBtZXRhZGF0YS4gTXVsdGlwbGUgbWV0YWRhdGEga2V5cyBjYW4gYmUgdXNlZCB0byBmaWx0ZXIgcm9vbXMuXG4gICAqIEBwYXJhbSBwYXJhbXMuZ3JvdXBJZHMgKG9wdGlvbmFsKSBBIGZpbHRlciBvbiBncm91cHMgYWNjZXNzZXMuIE11bHRpcGxlIGdyb3VwcyBjYW4gYmUgdXNlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5xdWVyeSAob3B0aW9uYWwpIEEgcXVlcnkgdG8gZmlsdGVyIHJvb21zIGJ5LiBJdCBpcyBiYXNlZCBvbiBvdXIgcXVlcnkgbGFuZ3VhZ2UuIFlvdSBjYW4gZmlsdGVyIGJ5IG1ldGFkYXRhIGFuZCByb29tIElELlxuICAgKiBAcmV0dXJucyBBIGxpc3Qgb2Ygcm9vbXMuXG4gICAqL1xuICBhc3luYyBnZXRSb29tcyhwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGggPSB1cmxgL3YyL3Jvb21zYDtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KHBhcmFtcy5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgbGltaXQ6IHBhcmFtcy5saW1pdCxcbiAgICAgIHN0YXJ0aW5nQWZ0ZXI6IHBhcmFtcy5zdGFydGluZ0FmdGVyLFxuICAgICAgdXNlcklkOiBwYXJhbXMudXNlcklkLFxuICAgICAgZ3JvdXBJZHM6IHBhcmFtcy5ncm91cElkcyA/IHBhcmFtcy5ncm91cElkcy5qb2luKFwiLFwiKSA6IHZvaWQgMCxcbiAgICAgIC8vIFwiRmxhdHRlblwiIHttZXRhZGF0YToge2ZvbzogXCJiYXJcIn19IHRvIHtcIm1ldGFkYXRhLmZvb1wiOiBcImJhclwifVxuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMubWV0YWRhdGEgPz8ge30pLm1hcCgoW2tleSwgdmFsXSkgPT4gW1xuICAgICAgICAgIGBtZXRhZGF0YS4ke2tleX1gLFxuICAgICAgICAgIHZhbFxuICAgICAgICBdKVxuICAgICAgKSxcbiAgICAgIHF1ZXJ5XG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldChwYXRoLCBxdWVyeVBhcmFtcyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3Qgcm9vbXMgPSBkYXRhLmRhdGEubWFwKChyb29tKSA9PiB7XG4gICAgICBjb25zdCBsYXN0Q29ubmVjdGlvbkF0ID0gcm9vbS5sYXN0Q29ubmVjdGlvbkF0ID8gbmV3IERhdGUocm9vbS5sYXN0Q29ubmVjdGlvbkF0KSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKHJvb20uY3JlYXRlZEF0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJvb20sXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgbGFzdENvbm5lY3Rpb25BdFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGRhdGE6IHJvb21zXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyByb29tIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGVmYXVsdEFjY2Vzc2VzIFRoZSBkZWZhdWx0IGFjY2Vzc2VzIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cHNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBncm91cCBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJzQWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgdXNlciBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgcm9vbS4gU3VwcG9ydHMgdXB0byBhIG1heGltdW0gb2YgNTAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLiBWYWx1ZSBsZW5ndGggaGFzIGEgbGltaXQgb2YgMjU2IGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHJvb20uXG4gICAqL1xuICBhc3luYyBjcmVhdGVSb29tKHJvb21JZCwgcGFyYW1zKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0QWNjZXNzZXMsIGdyb3Vwc0FjY2Vzc2VzLCB1c2Vyc0FjY2Vzc2VzLCBtZXRhZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdCh1cmxgL3YyL3Jvb21zYCwge1xuICAgICAgaWQ6IHJvb21JZCxcbiAgICAgIGRlZmF1bHRBY2Nlc3NlcyxcbiAgICAgIGdyb3Vwc0FjY2Vzc2VzLFxuICAgICAgdXNlcnNBY2Nlc3NlcyxcbiAgICAgIG1ldGFkYXRhXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgbGFzdENvbm5lY3Rpb25BdCA9IGRhdGEubGFzdENvbm5lY3Rpb25BdCA/IG5ldyBEYXRlKGRhdGEubGFzdENvbm5lY3Rpb25BdCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbGFzdENvbm5lY3Rpb25BdCxcbiAgICAgIGNyZWF0ZWRBdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSByb29tIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSByb29tIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Um9vbShyb29tSWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGxhc3RDb25uZWN0aW9uQXQgPSBkYXRhLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShkYXRhLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGxhc3RDb25uZWN0aW9uQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHNwZWNpZmljIHByb3BlcnRpZXMgb2YgYSByb29tLiBJdOKAmXMgbm90IG5lY2Vzc2FyeSB0byBwcm92aWRlIHRoZSBlbnRpcmUgcm9vbeKAmXMgaW5mb3JtYXRpb24uXG4gICAqIFNldHRpbmcgYSBwcm9wZXJ0eSB0byBgbnVsbGAgbWVhbnMgdG8gZGVsZXRlIHRoaXMgcHJvcGVydHkuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHBhcmFtcy5kZWZhdWx0QWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgZGVmYXVsdCBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uXG4gICAqIEBwYXJhbSBwYXJhbXMuZ3JvdXBzQWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgZ3JvdXAgYWNjZXNzZXMgZm9yIHRoZSByb29tLiBDYW4gY29udGFpbiBhIG1heGltdW0gb2YgMTAwIGVudHJpZXMuIEtleSBsZW5ndGggaGFzIGEgbGltaXQgb2YgNDAgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2Vyc0FjY2Vzc2VzIChvcHRpb25hbCkgVGhlIHVzZXIgYWNjZXNzZXMgZm9yIHRoZSByb29tLiBDYW4gY29udGFpbiBhIG1heGltdW0gb2YgMTAwIGVudHJpZXMuIEtleSBsZW5ndGggaGFzIGEgbGltaXQgb2YgNDAgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIHBhcmFtcy5tZXRhZGF0YSAob3B0aW9uYWwpIFRoZSBtZXRhZGF0YSBmb3IgdGhlIHJvb20uIFN1cHBvcnRzIHVwdG8gYSBtYXhpbXVtIG9mIDUwIGVudHJpZXMuIEtleSBsZW5ndGggaGFzIGEgbGltaXQgb2YgNDAgY2hhcmFjdGVycy4gVmFsdWUgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDI1NiBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCByb29tLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlUm9vbShyb29tSWQsIHBhcmFtcykge1xuICAgIGNvbnN0IHsgZGVmYXVsdEFjY2Vzc2VzLCBncm91cHNBY2Nlc3NlcywgdXNlcnNBY2Nlc3NlcywgbWV0YWRhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QodXJsYC92Mi9yb29tcy8ke3Jvb21JZH1gLCB7XG4gICAgICBkZWZhdWx0QWNjZXNzZXMsXG4gICAgICBncm91cHNBY2Nlc3NlcyxcbiAgICAgIHVzZXJzQWNjZXNzZXMsXG4gICAgICBtZXRhZGF0YVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGxhc3RDb25uZWN0aW9uQXQgPSBkYXRhLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShkYXRhLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGxhc3RDb25uZWN0aW9uQXQsXG4gICAgICBjcmVhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgcm9vbSB3aXRoIHRoZSBnaXZlbiBpZC4gQSBkZWxldGVkIHJvb20gaXMgbm8gbG9uZ2VyIGFjY2Vzc2libGUgZnJvbSB0aGUgQVBJIG9yIHRoZSBkYXNoYm9hcmQgYW5kIGl0IGNhbm5vdCBiZSByZXN0b3JlZC5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZGVsZXRlLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlUm9vbShyb29tSWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZSh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfWApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB1c2VycyBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgcmVxdWVzdGVkIHJvb20uIEZvciBiZXR0ZXIgcGVyZm9ybWFuY2UsIHdlIHJlY29tbWFuZCB0byBjYWxsIHRoaXMgZW5kcG9pbnQgZXZlcnkgMTAgc2Vjb25kcyBtYXhpbXVtLiBEdXBsaWNhdGVzIGNhbiBoYXBwZW4gaWYgYSB1c2VyIGlzIGluIHRoZSByZXF1ZXN0ZWQgcm9vbSB3aXRoIG11bHRpcGxlIGJyb3dzZXIgdGFicyBvcGVuZWQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGdldCB0aGUgdXNlcnMgZnJvbS5cbiAgICogQHJldHVybnMgQSBsaXN0IG9mIHVzZXJzIGN1cnJlbnRseSBwcmVzZW50IGluIHRoZSByZXF1ZXN0ZWQgcm9vbS5cbiAgICovXG4gIGFzeW5jIGdldEFjdGl2ZVVzZXJzKHJvb21JZCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L2FjdGl2ZV91c2Vyc2ApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBCb2FkY2FzdHMgYW4gZXZlbnQgdG8gYSByb29tIHdpdGhvdXQgaGF2aW5nIHRvIGNvbm5lY3QgdG8gaXQgdmlhIHRoZSBjbGllbnQgZnJvbSBAbGl2ZWJsb2Nrcy9jbGllbnQuIFRoZSBjb25uZWN0aW9uSWQgcGFzc2VkIHRvIGV2ZW50IGxpc3RlbmVycyBpcyAtMSB3aGVuIHVzaW5nIHRoaXMgQVBJLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBicm9hZGNhc3QgdGhlIGV2ZW50IHRvLlxuICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBicm9hZGNhc3QuIEl0IGNhbiBiZSBhbnkgSlNPTiBzZXJpYWxpemFibGUgdmFsdWUuXG4gICAqL1xuICBhc3luYyBicm9hZGNhc3RFdmVudChyb29tSWQsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QoXG4gICAgICB1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS9icm9hZGNhc3RfZXZlbnRgLFxuICAgICAgbWVzc2FnZVxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmFnZURvY3VtZW50KHJvb21JZCwgZm9ybWF0ID0gXCJwbGFpbi1sc29uXCIpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS9zdG9yYWdlYCwgeyBmb3JtYXQgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgcm9vbeKAmXMgU3RvcmFnZS4gVGhlIHJvb20gbXVzdCBhbHJlYWR5IGV4aXN0IGFuZCBoYXZlIGFuIGVtcHR5IFN0b3JhZ2UuXG4gICAqIENhbGxpbmcgdGhpcyBlbmRwb2ludCB3aWxsIGRpc2Nvbm5lY3QgYWxsIHVzZXJzIGZyb20gdGhlIHJvb20gaWYgdGhlcmUgYXJlIGFueS5cbiAgICpcbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gaW5pdGlhbGl6ZSB0aGUgc3RvcmFnZSBmcm9tLlxuICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGluaXRpYWxpemUgdGhlIHN0b3JhZ2Ugd2l0aC5cbiAgICogQHJldHVybnMgVGhlIGluaXRpYWxpemVkIHN0b3JhZ2UgZG9jdW1lbnQuIEl0IGlzIG9mIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgb25lIHBhc3NlZCBpbi5cbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemVTdG9yYWdlRG9jdW1lbnQocm9vbUlkLCBkb2N1bWVudCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdCh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS9zdG9yYWdlYCwgZG9jdW1lbnQpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBvZiB0aGUgcm9vbeKAmXMgU3RvcmFnZSBkYXRhIGFuZCBkaXNjb25uZWN0IGFsbCB1c2VycyBmcm9tIHRoZSByb29tIGlmIHRoZXJlIGFyZSBhbnkuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGRlbGV0ZSB0aGUgWWpzIGRvY3VtZW50IGluIHRoZSByb29tIGlmIG9uZSBleGlzdHMuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGRlbGV0ZSB0aGUgc3RvcmFnZSBmcm9tLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlU3RvcmFnZURvY3VtZW50KHJvb21JZCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGVsZXRlKHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3N0b3JhZ2VgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFlqc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50LlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBnZXQgdGhlIFlqcyBkb2N1bWVudCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmZvcm1hdCAob3B0aW9uYWwpIElmIHRydWUsIFlUZXh0IHdpbGwgcmV0dXJuIGZvcm1hdHRpbmcuXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5IChvcHRpb25hbCkgSWYgcHJvdmlkZWQsIHJldHVybnMgb25seSBhIHNpbmdsZSBrZXnigJlzIHZhbHVlLCBlLmcuIGRvYy5nZXQoa2V5KS50b0pTT04oKS5cbiAgICogQHBhcmFtIHBhcmFtcy50eXBlIChvcHRpb25hbCkgVXNlZCB3aXRoIGtleSB0byBvdmVycmlkZSB0aGUgaW5mZXJyZWQgdHlwZSwgaS5lLiBcInltYXBcIiB3aWxsIHJldHVybiBkb2MuZ2V0KGtleSwgWS5NYXApLlxuICAgKiBAcmV0dXJucyBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJvb23igJlzIFlqcyBkb2N1bWVudC5cbiAgICovXG4gIGFzeW5jIGdldFlqc0RvY3VtZW50KHJvb21JZCwgcGFyYW1zID0ge30pIHtcbiAgICBjb25zdCB7IGZvcm1hdCwga2V5LCB0eXBlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcGF0aCA9IHVybGB2Mi9yb29tcy8ke3Jvb21JZH0veWRvY2A7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQocGF0aCwge1xuICAgICAgZm9ybWF0dGluZzogZm9ybWF0ID8gXCJ0cnVlXCIgOiB2b2lkIDAsXG4gICAgICBrZXksXG4gICAgICB0eXBlXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBZanMgYmluYXJ5IHVwZGF0ZSB0byB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50LiBZb3UgY2FuIHVzZSB0aGlzIGVuZHBvaW50IHRvIGluaXRpYWxpemUgWWpzIGRhdGEgZm9yIHRoZSByb29tIG9yIHRvIHVwZGF0ZSB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50LlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBzZW5kIHRoZSBZanMgYmluYXJ5IHVwZGF0ZSB0by5cbiAgICogQHBhcmFtIHVwZGF0ZSBUaGUgWWpzIHVwZGF0ZSB0byBzZW5kLiBUeXBpY2FsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBZanMuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MpYC4gUmVhZCB0aGUgW1lqcyBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MueWpzLmRldi9hcGkvZG9jdW1lbnQtdXBkYXRlcykgdG8gbGVhcm4gaG93IHRvIGNyZWF0ZSBhIGJpbmFyeSB1cGRhdGUuXG4gICAqIEBwYXJhbSBwYXJhbXMuZ3VpZCAob3B0aW9uYWwpIElmIHByb3ZpZGVkLCB0aGUgYmluYXJ5IHVwZGF0ZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIFlqcyBzdWJkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBndWlkLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBiaW5hcnkgdXBkYXRlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcm9vdCBZanMgZG9jdW1lbnQuXG4gICAqL1xuICBhc3luYyBzZW5kWWpzQmluYXJ5VXBkYXRlKHJvb21JZCwgdXBkYXRlLCBwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucHV0QmluYXJ5KHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3lkb2NgLCB1cGRhdGUsIHtcbiAgICAgIGd1aWQ6IHBhcmFtcy5ndWlkXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb23igJlzIFlqcyBkb2N1bWVudCBlbmNvZGVkIGFzIGEgc2luZ2xlIGJpbmFyeSB1cGRhdGUuIFRoaXMgY2FuIGJlIHVzZWQgYnkgWS5hcHBseVVwZGF0ZShyZXNwb25zZUJvZHkpIHRvIGdldCBhIGNvcHkgb2YgdGhlIGRvY3VtZW50IGluIHlvdXIgYmFja2VuZC5cbiAgICogU2VlIFtZanMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLnlqcy5kZXYvYXBpL2RvY3VtZW50LXVwZGF0ZXMpIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdvcmtpbmcgd2l0aCB1cGRhdGVzLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBnZXQgdGhlIFlqcyBkb2N1bWVudCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmd1aWQgKG9wdGlvbmFsKSBJZiBwcm92aWRlZCwgcmV0dXJucyB0aGUgYmluYXJ5IHVwZGF0ZSBvZiB0aGUgWWpzIHN1YmRvY3VtZW50IHdpdGggdGhlIGdpdmVuIGd1aWQuIElmIG5vdCBwcm92aWRlZCwgcmV0dXJucyB0aGUgYmluYXJ5IHVwZGF0ZSBvZiB0aGUgcm9vdCBZanMgZG9jdW1lbnQuXG4gICAqIEByZXR1cm5zIFRoZSByb29t4oCZcyBZanMgZG9jdW1lbnQgZW5jb2RlZCBhcyBhIHNpbmdsZSBiaW5hcnkgdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgZ2V0WWpzRG9jdW1lbnRBc0JpbmFyeVVwZGF0ZShyb29tSWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQodXJsYC92Mi9yb29tcy8ke3Jvb21JZH0veWRvYy1iaW5hcnlgLCB7XG4gICAgICBndWlkOiBwYXJhbXMuZ3VpZFxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXMuYXJyYXlCdWZmZXIoKTtcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFNjaGVtYSBWYWxpZGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc2NoZW1hIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGxhdGVyIHRvIGVuZm9yY2UgYSByb29t4oCZcyBTdG9yYWdlIGRhdGEgc3RydWN0dXJlLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgc2NoZW1hLiBNdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyB3aXRoIGxlc3MgdGhhbiA2NSBjaGFyYWN0ZXJzIGFuZCBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGxldHRlcnMsIG51bWJlcnMgYW5kIGRhc2hlc1xuICAgKiBAcGFyYW0gYm9keSBUaGUgZXhhY3QgYWxsb3dlZCBzaGFwZSBvZiBkYXRhIGluIHRoZSByb29tLiBJdCBpcyBhIG11bHRpLWxpbmUgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIFtMaXZlYmxvY2tzIHNjaGVtYSBzeW50YXhdKGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3NjaGVtYS12YWxpZGF0aW9uL3N5bnRheCkuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHNjaGVtYS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNjaGVtYShuYW1lLCBib2R5KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KHVybGAvdjIvc2NoZW1hc2AsIHtcbiAgICAgIG5hbWUsXG4gICAgICBib2R5XG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIHVwZGF0ZWRBdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzY2hlbWEgYnkgaXRzIGlkLlxuICAgKiBAcGFyYW0gc2NoZW1hSWQgSWQgb2YgdGhlIHNjaGVtYSAtIHRoaXMgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBzY2hlbWEgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRvIHVwZGF0ZS4gRm9yIGV4YW1wbGUsIGBteS1zY2hlbWFAMWAuXG4gICAqIEByZXR1cm5zIFRoZSBzY2hlbWEgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqL1xuICBhc3luYyBnZXRTY2hlbWEoc2NoZW1hSWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmxgL3YyL3NjaGVtYXMvJHtzY2hlbWFJZH1gKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgdXBkYXRlZEF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYm9keSBmb3IgdGhlIHNjaGVtYS4gQSBzY2hlbWEgY2FuIG9ubHkgYmUgdXBkYXRlZCBpZiBpdCBpcyBub3QgdXNlZCBieSBhbnkgcm9vbS5cbiAgICogQHBhcmFtIHNjaGVtYUlkIElkIG9mIHRoZSBzY2hlbWEgLSB0aGlzIGlzIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgc2NoZW1hIG5hbWUgYW5kIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB0byB1cGRhdGUuIEZvciBleGFtcGxlLCBgbXktc2NoZW1hQDFgLlxuICAgKiBAcGFyYW0gYm9keSBUaGUgZXhhY3QgYWxsb3dlZCBzaGFwZSBvZiBkYXRhIGluIHRoZSByb29tLiBJdCBpcyBhIG11bHRpLWxpbmUgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIFtMaXZlYmxvY2tzIHNjaGVtYSBzeW50YXhdKGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3NjaGVtYS12YWxpZGF0aW9uL3N5bnRheCkuXG4gICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIHNjaGVtYS4gVGhlIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB3aWxsIGJlIGluY3JlbWVudGVkLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlU2NoZW1hKHNjaGVtYUlkLCBib2R5KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wdXQodXJsYC92Mi9zY2hlbWFzLyR7c2NoZW1hSWR9YCwge1xuICAgICAgYm9keVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgc2NoZW1hIGJ5IGl0cyBpZC4gQSBzY2hlbWEgY2FuIG9ubHkgYmUgZGVsZXRlZCBpZiBpdCBpcyBub3QgdXNlZCBieSBhbnkgcm9vbS5cbiAgICogQHBhcmFtIHNjaGVtYUlkIElkIG9mIHRoZSBzY2hlbWEgLSB0aGlzIGlzIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgc2NoZW1hIG5hbWUgYW5kIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB0byB1cGRhdGUuIEZvciBleGFtcGxlLCBgbXktc2NoZW1hQDFgLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlU2NoZW1hKHNjaGVtYUlkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kZWxldGUodXJsYC92Mi9zY2hlbWFzLyR7c2NoZW1hSWR9YCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjaGVtYSBhdHRhY2hlZCB0byBhIHJvb20uXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGdldCB0aGUgc2NoZW1hIGZyb20uXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRTY2hlbWFCeVJvb21JZChyb29tSWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS9zY2hlbWFgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgdXBkYXRlZEF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgYSBzY2hlbWEgdG8gYSByb29tLCBhbmQgaW5zdGFudGx5IGVuYWJsZXMgcnVudGltZSBzY2hlbWEgdmFsaWRhdGlvbiBmb3IgdGhlIHJvb20uXG4gICAqIElmIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSByb29t4oCZcyBTdG9yYWdlIGRvIG5vdCBtYXRjaCB0aGUgc2NoZW1hLCBhdHRhY2hpbmcgd2lsbCBmYWlsIGFuZCB0aGUgZXJyb3IgbWVzc2FnZSB3aWxsIGdpdmUgZGV0YWlscyBvbiB3aHkgdGhlIHNjaGVtYSBmYWlsZWQgdG8gYXR0YWNoLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBhdHRhY2ggdGhlIHNjaGVtYSB0by5cbiAgICogQHBhcmFtIHNjaGVtYUlkIElkIG9mIHRoZSBzY2hlbWEgLSB0aGlzIGlzIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgc2NoZW1hIG5hbWUgYW5kIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB0byB1cGRhdGUuIEZvciBleGFtcGxlLCBgbXktc2NoZW1hQDFgLlxuICAgKiBAcmV0dXJucyBUaGUgc2NoZW1hIGlkIGFzIEpTT04uXG4gICAqL1xuICBhc3luYyBhdHRhY2hTY2hlbWFUb1Jvb20ocm9vbUlkLCBzY2hlbWFJZCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdCh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS9zY2hlbWFgLCB7XG4gICAgICBzY2hlbWE6IHNjaGVtYUlkXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgc2NoZW1hIGZyb20gYSByb29tLCBhbmQgZGlzYWJsZXMgcnVudGltZSBzY2hlbWEgdmFsaWRhdGlvbiBmb3IgdGhlIHJvb20uXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGRldGFjaCB0aGUgc2NoZW1hIGZyb20uXG4gICAqL1xuICBhc3luYyBkZXRhY2hTY2hlbWFGcm9tUm9vbShyb29tSWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZSh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS9zY2hlbWFgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbW1lbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLyoqXG4gICAqIEdldHMgYWxsIHRoZSB0aHJlYWRzIGluIGEgcm9vbS5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZ2V0IHRoZSB0aHJlYWRzIGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMucXVlcnkgVGhlIHF1ZXJ5IHRvIGZpbHRlciB0aHJlYWRzIGJ5LiBJdCBpcyBiYXNlZCBvbiBvdXIgcXVlcnkgbGFuZ3VhZ2UgYW5kIGNhbiBmaWx0ZXIgYnkgbWV0YWRhdGEuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiB0aHJlYWRzLlxuICAgKi9cbiAgYXN5bmMgZ2V0VGhyZWFkcyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCB9ID0gcGFyYW1zO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcXVlcnkgPSBwYXJhbXMucXVlcnk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLnF1ZXJ5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBxdWVyeSA9IG9iamVjdFRvUXVlcnkocGFyYW1zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQodXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkc2AsIHtcbiAgICAgIHF1ZXJ5XG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBkYXRhLm1hcCgodGhyZWFkKSA9PiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCkpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIHRocmVhZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZ2V0IHRoZSB0aHJlYWQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElELlxuICAgKiBAcmV0dXJucyBBIHRocmVhZC5cbiAgICovXG4gIGFzeW5jIGdldFRocmVhZChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldCh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9YCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSB0aHJlYWQncyBwYXJ0aWNpcGFudHMuXG4gICAqXG4gICAqIFBhcnRpY2lwYW50cyBhcmUgdXNlcnMgd2hvIGhhdmUgY29tbWVudGVkIG9uIHRoZSB0aHJlYWRcbiAgICogb3IgdXNlcnMgYW5kIGdyb3VwcyB0aGF0IGhhdmUgYmVlbiBtZW50aW9uZWQgaW4gYSBjb21tZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIHRocmVhZCBwYXJ0aWNpcGFudHMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGdldCB0aGUgcGFydGljaXBhbnRzIGZyb20uXG4gICAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIHBhcnRpY2lwYW50IElEcy5cbiAgICovXG4gIGFzeW5jIGdldFRocmVhZFBhcnRpY2lwYW50cyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vcGFydGljaXBhbnRzYFxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSB0aHJlYWQncyBjb21tZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIGNvbW1lbnQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGdldCB0aGUgY29tbWVudCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmNvbW1lbnRJZCBUaGUgY29tbWVudCBJRC5cbiAgICogQHJldHVybnMgQSBjb21tZW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29tbWVudChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH1gXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21tZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBjcmVhdGUgdGhlIGNvbW1lbnQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byBjcmVhdGUgdGhlIGNvbW1lbnQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS51c2VySWQgVGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgd2hvIGlzIHNldCB0byBjcmVhdGUgdGhlIGNvbW1lbnQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5jcmVhdGVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgY29tbWVudCBpcyBzZXQgdG8gYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmJvZHkgVGhlIGJvZHkgb2YgdGhlIGNvbW1lbnQuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGNvbW1lbnQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVDb21tZW50KHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHNgLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY3JlYXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRzIGEgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZWRpdCB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGVkaXQgdGhlIGNvbW1lbnQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMuY29tbWVudElkIFRoZSBjb21tZW50IElEIHRvIGVkaXQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5ib2R5IFRoZSBib2R5IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuZWRpdGVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgY29tbWVudCB3YXMgZWRpdGVkLlxuICAgKiBAcmV0dXJucyBUaGUgZWRpdGVkIGNvbW1lbnQuXG4gICAqL1xuICBhc3luYyBlZGl0Q29tbWVudChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHMvJHtjb21tZW50SWR9YCxcbiAgICAgIHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgZWRpdGVkQXQ6IGRhdGEuZWRpdGVkQXQ/LnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGNvbW1lbnQuIERlbGV0ZXMgYSBjb21tZW50LiBJZiB0aGVyZSBhcmUgbm8gcmVtYWluaW5nIGNvbW1lbnRzIGluIHRoZSB0aHJlYWQsIHRoZSB0aHJlYWQgaXMgYWxzbyBkZWxldGVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBkZWxldGUgdGhlIGNvbW1lbnQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byBkZWxldGUgdGhlIGNvbW1lbnQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMuY29tbWVudElkIFRoZSBjb21tZW50IElEIHRvIGRlbGV0ZS5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUNvbW1lbnQocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZShcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHMvJHtjb21tZW50SWR9YFxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdGhyZWFkLiBUaGUgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgY29tbWVudCBhcyBpdHMgZmlyc3QgY29tbWVudC5cbiAgICogSWYgdGhlIHRocmVhZCBhbHJlYWR5IGV4aXN0cywgYSBgTGl2ZWJsb2Nrc0Vycm9yYCB3aWxsIGJlIHRocm93biB3aXRoIHN0YXR1cyBjb2RlIDQwOS5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gY3JlYXRlIHRoZSB0aHJlYWQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgdGhyZWFkLiBTdXBwb3J0cyB1cHRvIGEgbWF4aW11bSBvZiAxMCBlbnRyaWVzLiBWYWx1ZSBtdXN0IGJlIGEgc3RyaW5nLCBib29sZWFuIG9yIG51bWJlclxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZC5jb21tZW50LnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGUgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWQuY29tbWVudC5jcmVhdGVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgY29tbWVudCB3YXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWQuY29tbWVudC5ib2R5IFRoZSBib2R5IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB0aHJlYWQuIFRoZSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBjb21tZW50IGFzIGl0cyBmaXJzdCBjb21tZW50LlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVGhyZWFkKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHNgLCB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY29tbWVudDoge1xuICAgICAgICAuLi5kYXRhLmNvbW1lbnQsXG4gICAgICAgIGNyZWF0ZWRBdDogZGF0YS5jb21tZW50LmNyZWF0ZWRBdD8udG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9UaHJlYWREYXRhKGF3YWl0IHJlcy5qc29uKCkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgdGhyZWFkIGFuZCBhbGwgb2YgaXRzIGNvbW1lbnRzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBkZWxldGUgdGhlIHRocmVhZCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGRlbGV0ZS5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVRocmVhZChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZSh1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9YCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1hcmsgYSB0aHJlYWQgYXMgcmVzb2x2ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIG9mIHRoZSB0aHJlYWQuXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byBtYXJrIGFzIHJlc29sdmVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIHdobyBtYXJrZWQgdGhlIHRocmVhZCBhcyByZXNvbHZlZC5cbiAgICogQHJldHVybnMgVGhlIHRocmVhZCBtYXJrZWQgYXMgcmVzb2x2ZWQuXG4gICAqL1xuICBhc3luYyBtYXJrVGhyZWFkQXNSZXNvbHZlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QoXG4gICAgICB1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L21hcmstYXMtcmVzb2x2ZWRgLFxuICAgICAge31cbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9UaHJlYWREYXRhKGF3YWl0IHJlcy5qc29uKCkpO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrIGEgdGhyZWFkIGFzIHVucmVzb2x2ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIG9mIHRoZSB0aHJlYWQuXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byBtYXJrIGFzIHVucmVzb2x2ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS51c2VySWQgVGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgd2hvIG1hcmtlZCB0aGUgdGhyZWFkIGFzIHVucmVzb2x2ZWQuXG4gICAqIEByZXR1cm5zIFRoZSB0aHJlYWQgbWFya2VkIGFzIHVucmVzb2x2ZWQuXG4gICAqL1xuICBhc3luYyBtYXJrVGhyZWFkQXNVbnJlc29sdmVkKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vbWFyay1hcy11bnJlc29sdmVkYCxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgb2YgdGhlIHNwZWNpZmllZCB0aHJlYWQgaW4gYSByb29tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byB1cGRhdGUgdGhlIHRocmVhZCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLm1ldGFkYXRhIFRoZSBtZXRhZGF0YSBmb3IgdGhlIHRocmVhZC4gVmFsdWUgbXVzdCBiZSBhIHN0cmluZywgYm9vbGVhbiBvciBudW1iZXJcbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gdXBkYXRlZCB0aGUgdGhyZWFkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXBkYXRlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIHRocmVhZCBpcyBzZXQgdG8gYmUgdXBkYXRlZC5cbiAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgdGhyZWFkIG1ldGFkYXRhLlxuICAgKi9cbiAgYXN5bmMgZWRpdFRocmVhZE1ldGFkYXRhKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vbWV0YWRhdGFgLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICB1cGRhdGVkQXQ6IGRhdGEudXBkYXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBjb21tZW50IHJlYWN0aW9uIHRvIGEgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gYWRkIHRoZSBjb21tZW50IHJlYWN0aW9uIGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gYWRkIHRoZSBjb21tZW50IHJlYWN0aW9uIGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLmNvbW1lbnRJZCBUaGUgY29tbWVudCBJRCB0byBhZGQgdGhlIHJlYWN0aW9uIGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuZW1vamkgVGhlIChlbW9qaSkgcmVhY3Rpb24gdG8gYWRkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVhY3Rpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5jcmVhdGVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgcmVhY3Rpb24gaXMgc2V0IHRvIGJlIGNyZWF0ZWQuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGNvbW1lbnQgcmVhY3Rpb24uXG4gICAqL1xuICBhc3luYyBhZGRDb21tZW50UmVhY3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGRhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QoXG4gICAgICB1cmxgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfS9hZGQtcmVhY3Rpb25gLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY3JlYXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICBjb25zdCByZWFjdGlvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24ocmVhY3Rpb24pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgcmVhY3Rpb24gZnJvbSBhIGNvbW1lbnQuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIHJlbW92ZSB0aGUgY29tbWVudCByZWFjdGlvbiBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gcmVtb3ZlIHRoZSBjb21tZW50IHJlYWN0aW9uIGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMuY29tbWVudElkIFRoZSBjb21tZW50IElEIHRvIHJlbW92ZSB0aGUgcmVhY3Rpb24gZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmVtb2ppIFRoZSAoZW1vamkpIHJlYWN0aW9uIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciBhc3NvY2lhdGVkIHdpdGggdGhlIHJlYWN0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEucmVtb3ZlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIHJlYWN0aW9uIGlzIHNldCB0byBiZSByZW1vdmVkLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ29tbWVudFJlYWN0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHMvJHtwYXJhbXMuY29tbWVudElkfS9yZW1vdmUtcmVhY3Rpb25gLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICByZW1vdmVkQXQ6IGRhdGEucmVtb3ZlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCB0byBnZXQgdGhlIGluYm94IG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5pbmJveE5vdGlmaWNhdGlvbklkIFRoZSBJRCBvZiB0aGUgaW5ib3ggbm90aWZpY2F0aW9uIHRvIGdldC5cbiAgICovXG4gIGFzeW5jIGdldEluYm94Tm90aWZpY2F0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdXNlcklkLCBpbmJveE5vdGlmaWNhdGlvbklkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQoXG4gICAgICB1cmxgL3YyL3VzZXJzLyR7dXNlcklkfS9pbmJveC1ub3RpZmljYXRpb25zLyR7aW5ib3hOb3RpZmljYXRpb25JZH1gXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKFxuICAgICAgYXdhaXQgcmVzLmpzb24oKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gZ2V0IHRoZSByb29tIG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZ2V0IHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmcm9tLlxuICAgKi9cbiAgYXN5bmMgZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdXNlcklkLCByb29tSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3VzZXJzLyR7dXNlcklkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdXNlcidzIHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCB0byB1cGRhdGUgdGhlIHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzIGZvci5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gdXBkYXRlIHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YSBUaGUgbmV3IHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzIGZvciB0aGUgdXNlci5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCwgcm9vbUlkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wb3N0KFxuICAgICAgdXJsYC92Mi9yb29tcy8ke3Jvb21JZH0vdXNlcnMvJHt1c2VySWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBkYXRhXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIHRoZSB1c2VyJ3Mgcm9vbSBub3RpZmljYXRpb24gc2V0dGluZ3MuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIGRlbGV0ZSB0aGUgcm9vbSBub3RpZmljYXRpb24gc2V0dGluZ3MgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZGVsZXRlIHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmcm9tLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdXNlcklkLCByb29tSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZShcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtyb29tSWR9L3VzZXJzLyR7dXNlcklkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgTGl2ZWJsb2Nrc0Vycm9yKHJlcy5zdGF0dXMsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGEgcm9vbSBJRC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIGN1cnJlbnQgSUQgb2YgdGhlIHJvb20uXG4gICAqIEBwYXJhbSBwYXJhbXMubmV3Um9vbUlkIFRoZSBuZXcgcm9vbSBJRC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVJvb21JZChwYXJhbXMpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRSb29tSWQsIG5ld1Jvb21JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucG9zdChcbiAgICAgIHVybGAvdjIvcm9vbXMvJHtjdXJyZW50Um9vbUlkfS91cGRhdGUtcm9vbS1pZGAsXG4gICAgICB7XG4gICAgICAgIG5ld1Jvb21JZFxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KSxcbiAgICAgIGxhc3RDb25uZWN0aW9uQXQ6IGRhdGEubGFzdENvbm5lY3Rpb25BdCA/IG5ldyBEYXRlKGRhdGEubGFzdENvbm5lY3Rpb25BdCkgOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGFzeW5jIHRyaWdnZXJJbmJveE5vdGlmaWNhdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnBvc3QodXJsYC92Mi9pbmJveC1ub3RpZmljYXRpb25zL3RyaWdnZXJgLCBwYXJhbXMpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBMaXZlYmxvY2tzRXJyb3IocmVzLnN0YXR1cywgdGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGluYm94IG5vdGlmaWNhdGlvbiBmb3IgYSB1c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCBmb3Igd2hpY2ggdG8gZGVsZXRlIHRoZSBpbmJveCBub3RpZmljYXRpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMuaW5ib3hOb3RpZmljYXRpb25JZCBUaGUgSUQgb2YgdGhlIGluYm94IG5vdGlmaWNhdGlvbiB0byBkZWxldGUuXG4gICAqL1xuICBhc3luYyBkZWxldGVJbmJveE5vdGlmaWNhdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCwgaW5ib3hOb3RpZmljYXRpb25JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGVsZXRlKFxuICAgICAgdXJsYC92Mi91c2Vycy8ke3VzZXJJZH0vaW5ib3gtbm90aWZpY2F0aW9ucy8ke2luYm94Tm90aWZpY2F0aW9uSWR9YFxuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGluYm94IG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlci5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgZm9yIHdoaWNoIHRvIGRlbGV0ZSBhbGwgdGhlIGluYm94IG5vdGlmaWNhdGlvbnMuXG4gICAqL1xuICBhc3luYyBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMocGFyYW1zKSB7XG4gICAgY29uc3QgeyB1c2VySWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRlbGV0ZSh1cmxgL3YyL3VzZXJzLyR7dXNlcklkfS9pbmJveC1ub3RpZmljYXRpb25zYCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IExpdmVibG9ja3NFcnJvcihyZXMuc3RhdHVzLCB0ZXh0KTtcbiAgICB9XG4gIH1cbn07XG52YXIgTGl2ZWJsb2Nrc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgbWVzc2FnZSA9IFwiXCIpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkxpdmVibG9ja3NFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICB9XG59O1xuXG4vLyBzcmMvd2ViaG9va3MudHNcbmltcG9ydCAqIGFzIGJhc2U2NCBmcm9tIFwiQHN0YWJsZWxpYi9iYXNlNjRcIjtcbmltcG9ydCAqIGFzIHNoYTI1NiBmcm9tIFwiZmFzdC1zaGEyNTZcIjtcbnZhciBfV2ViaG9va0hhbmRsZXIgPSBjbGFzcyBfV2ViaG9va0hhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihzZWNyZXQpIHtcbiAgICBpZiAoIXNlY3JldCkgdGhyb3cgbmV3IEVycm9yKFwiU2VjcmV0IGlzIHJlcXVpcmVkXCIpO1xuICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoXCJTZWNyZXQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICBpZiAoc2VjcmV0LnN0YXJ0c1dpdGgoX1dlYmhvb2tIYW5kbGVyLnNlY3JldFByZWZpeCkgPT09IGZhbHNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWNyZXQsIG11c3Qgc3RhcnQgd2l0aCB3aHNlY19cIik7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gc2VjcmV0LnNsaWNlKF9XZWJob29rSGFuZGxlci5zZWNyZXRQcmVmaXgubGVuZ3RoKTtcbiAgICB0aGlzLnNlY3JldEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNlY3JldEtleSwgXCJiYXNlNjRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGEgd2ViaG9vayByZXF1ZXN0IGFuZCByZXR1cm5zIHRoZSBldmVudFxuICAgKi9cbiAgdmVyaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgeyBoZWFkZXJzLCByYXdCb2R5IH0gPSByZXF1ZXN0O1xuICAgIGNvbnN0IHsgd2ViaG9va0lkLCB0aW1lc3RhbXAsIHJhd1NpZ25hdHVyZXMgfSA9IHRoaXMudmVyaWZ5SGVhZGVycyhoZWFkZXJzKTtcbiAgICBpZiAodHlwZW9mIHJhd0JvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgcmF3Qm9keSBmaWVsZCwgbXVzdCBiZSBhIHN0cmluZywgZ290IFwiJHt0eXBlb2YgcmF3Qm9keX1cIiBpbnN0ZWFkLiBJdCBpcyBsaWtlbHkgdGhhdCB5b3UgbmVlZCB0byBKU09OLnN0cmluZ2lmeSB0aGUgYm9keSBiZWZvcmUgcGFzc2luZyBpdC5gXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnZlcmlmeVRpbWVzdGFtcCh0aW1lc3RhbXApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuc2lnbihgJHt3ZWJob29rSWR9LiR7dGltZXN0YW1wfS4ke3Jhd0JvZHl9YCk7XG4gICAgY29uc3QgZXhwZWN0ZWRTaWduYXR1cmVzID0gcmF3U2lnbmF0dXJlcy5zcGxpdChcIiBcIikubWFwKChyYXdTaWduYXR1cmUpID0+IHtcbiAgICAgIGNvbnN0IFssIHBhcnNlZFNpZ25hdHVyZV0gPSByYXdTaWduYXR1cmUuc3BsaXQoXCIsXCIpO1xuICAgICAgcmV0dXJuIHBhcnNlZFNpZ25hdHVyZTtcbiAgICB9KS5maWx0ZXIoaXNOb3RVbmRlZmluZWQpO1xuICAgIGlmIChleHBlY3RlZFNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSA9PT0gZmFsc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHNpZ25hdHVyZSwgZXhwZWN0ZWQgb25lIG9mICR7ZXhwZWN0ZWRTaWduYXR1cmVzLmpvaW4oXG4gICAgICAgICAgXCIsIFwiXG4gICAgICAgICl9LCBnb3QgJHtzaWduYXR1cmV9YFxuICAgICAgKTtcbiAgICBjb25zdCBldmVudCA9IEpTT04ucGFyc2UocmF3Qm9keSk7XG4gICAgdGhpcy52ZXJpZnlXZWJob29rRXZlbnRUeXBlKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoZSBoZWFkZXJzIGFuZCByZXR1cm5zIHRoZSB3ZWJob29rSWQsIHRpbWVzdGFtcCBhbmQgcmF3U2lnbmF0dXJlc1xuICAgKi9cbiAgdmVyaWZ5SGVhZGVycyhoZWFkZXJzKSB7XG4gICAgY29uc3QgdXNpbmdOYXRpdmVIZWFkZXJzID0gdHlwZW9mIEhlYWRlcnMgIT09IFwidW5kZWZpbmVkXCIgJiYgaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnM7XG4gICAgY29uc3Qgbm9ybWFsaXplZEhlYWRlcnMgPSB1c2luZ05hdGl2ZUhlYWRlcnMgPyBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycykgOiBoZWFkZXJzO1xuICAgIGNvbnN0IHNhbml0aXplZEhlYWRlcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhub3JtYWxpemVkSGVhZGVycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBzYW5pdGl6ZWRIZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IG5vcm1hbGl6ZWRIZWFkZXJzW2tleV07XG4gICAgfSk7XG4gICAgY29uc3Qgd2ViaG9va0lkID0gc2FuaXRpemVkSGVhZGVyc1tcIndlYmhvb2staWRcIl07XG4gICAgaWYgKHR5cGVvZiB3ZWJob29rSWQgIT09IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdlYmhvb2staWQgaGVhZGVyXCIpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHNhbml0aXplZEhlYWRlcnNbXCJ3ZWJob29rLXRpbWVzdGFtcFwiXTtcbiAgICBpZiAodHlwZW9mIHRpbWVzdGFtcCAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2ViaG9vay10aW1lc3RhbXAgaGVhZGVyXCIpO1xuICAgIGNvbnN0IHJhd1NpZ25hdHVyZXMgPSBzYW5pdGl6ZWRIZWFkZXJzW1wid2ViaG9vay1zaWduYXR1cmVcIl07XG4gICAgaWYgKHR5cGVvZiByYXdTaWduYXR1cmVzICE9PSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3ZWJob29rLXNpZ25hdHVyZSBoZWFkZXJcIik7XG4gICAgcmV0dXJuIHsgd2ViaG9va0lkLCB0aW1lc3RhbXAsIHJhd1NpZ25hdHVyZXMgfTtcbiAgfVxuICAvKipcbiAgICogU2lnbnMgdGhlIGNvbnRlbnQgd2l0aCB0aGUgc2VjcmV0XG4gICAqIEBwYXJhbSBjb250ZW50XG4gICAqIEByZXR1cm5zIGBzdHJpbmdgXG4gICAqL1xuICBzaWduKGNvbnRlbnQpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgdG9TaWduID0gZW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoc2hhMjU2LmhtYWModGhpcy5zZWNyZXRCdWZmZXIsIHRvU2lnbikpO1xuICB9XG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGF0IHRoZSB0aW1lc3RhbXAgaXMgbm90IHRvbyBvbGQgb3IgaW4gdGhlIGZ1dHVyZVxuICAgKi9cbiAgdmVyaWZ5VGltZXN0YW1wKHRpbWVzdGFtcEhlYWRlcikge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VJbnQodGltZXN0YW1wSGVhZGVyLCAxMCk7XG4gICAgaWYgKGlzTmFOKHRpbWVzdGFtcCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGltZXN0YW1wXCIpO1xuICAgIH1cbiAgICBpZiAodGltZXN0YW1wIDwgbm93IC0gV0VCSE9PS19UT0xFUkFOQ0VfSU5fU0VDT05EUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGltZXN0YW1wIHRvbyBvbGRcIik7XG4gICAgfVxuICAgIGlmICh0aW1lc3RhbXAgPiBub3cgKyBXRUJIT09LX1RPTEVSQU5DRV9JTl9TRUNPTkRTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaW1lc3RhbXAgaW4gdGhlIGZ1dHVyZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgZXZlbnQgaXMgYSBrbm93biBldmVudCB0eXBlXG4gICAqIG9yIHRocm93cyBhbmQgcHJvbXB0cyB0aGUgdXNlciB0byB1cGdyYWRlIHRvIGEgaGlnaGVyIHZlcnNpb24gb2YgQGxpdmVibG9ja3Mvbm9kZVxuICAgKi9cbiAgdmVyaWZ5V2ViaG9va0V2ZW50VHlwZShldmVudCkge1xuICAgIGlmIChldmVudCAmJiBldmVudC50eXBlICYmIFtcbiAgICAgIFwic3RvcmFnZVVwZGF0ZWRcIixcbiAgICAgIFwidXNlckVudGVyZWRcIixcbiAgICAgIFwidXNlckxlZnRcIixcbiAgICAgIFwicm9vbUNyZWF0ZWRcIixcbiAgICAgIFwicm9vbURlbGV0ZWRcIixcbiAgICAgIFwiY29tbWVudENyZWF0ZWRcIixcbiAgICAgIFwiY29tbWVudEVkaXRlZFwiLFxuICAgICAgXCJjb21tZW50RGVsZXRlZFwiLFxuICAgICAgXCJjb21tZW50UmVhY3Rpb25BZGRlZFwiLFxuICAgICAgXCJjb21tZW50UmVhY3Rpb25SZW1vdmVkXCIsXG4gICAgICBcInRocmVhZE1ldGFkYXRhVXBkYXRlZFwiLFxuICAgICAgXCJ0aHJlYWRDcmVhdGVkXCIsXG4gICAgICBcInRocmVhZERlbGV0ZWRcIixcbiAgICAgIFwieWRvY1VwZGF0ZWRcIixcbiAgICAgIFwibm90aWZpY2F0aW9uXCIsXG4gICAgICBcInRocmVhZE1hcmtlZEFzUmVzb2x2ZWRcIixcbiAgICAgIFwidGhyZWFkTWFya2VkQXNVbnJlc29sdmVkXCJcbiAgICBdLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJub3RpZmljYXRpb25cIikge1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBldmVudDtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi5kYXRhLmtpbmQgPT09IFwidGhyZWFkXCIgfHwgbm90aWZpY2F0aW9uLmRhdGEua2luZCA9PT0gXCJ0ZXh0TWVudGlvblwiIHx8IG5vdGlmaWNhdGlvbi5kYXRhLmtpbmQuc3RhcnRzV2l0aChcIiRcIikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVua25vd24gbm90aWZpY2F0aW9uIGtpbmQ6ICR7bm90aWZpY2F0aW9uLmRhdGEua2luZH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVua25vd24gZXZlbnQgdHlwZSwgcGxlYXNlIHVwZ3JhZGUgdG8gYSBoaWdoZXIgdmVyc2lvbiBvZiBAbGl2ZWJsb2Nrcy9ub2RlXCJcbiAgICApO1xuICB9XG59O1xuX1dlYmhvb2tIYW5kbGVyLnNlY3JldFByZWZpeCA9IFwid2hzZWNfXCI7XG52YXIgV2ViaG9va0hhbmRsZXIgPSBfV2ViaG9va0hhbmRsZXI7XG52YXIgV0VCSE9PS19UT0xFUkFOQ0VfSU5fU0VDT05EUyA9IDUgKiA2MDtcbnZhciBpc05vdFVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT09IHZvaWQgMDtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQge1xuICBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHksXG4gIHN0cmluZ2lmeUNvbW1lbnRCb2R5XG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgTGl2ZWJsb2NrcyxcbiAgTGl2ZWJsb2Nrc0Vycm9yLFxuICBXZWJob29rSGFuZGxlcixcbiAgZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5LFxuICBzdHJpbmdpZnlDb21tZW50Qm9keVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@liveblocks/node/dist/index.mjs\n");

/***/ })

};
;